#! /usr/bin/env python3

import os
import re
from _afwdev.common import msg, nfc

def get_generated_by(generated_by):
    return \
    "/*  ----------------------------- N O T E -------------------------------------\n" + \
    " *\n"                                                                              + \
    ' * This file is generated by "' + generated_by + '".\n'                           + \
    " *\n"                                                                              + \
    " * Do not change this file directly or the changes will be lost the next time\n"  + \
    " * this file is regenerated.\n"                                                   + \
    " *\n"                                                                              + \
    " * -------------------------------------------------------------------------*/\n" + \
    "\n"


def write_generated_by(fd, generated_by):
    fd.write(get_generated_by(generated_by))


def get_copyright(title):
    #t = title
    #if (len(t) < 73):
    #    t += ' '*(73 - len(t))
    return \
    "// See the 'COPYING' file in the project root for licensing information.\n" + \
    "/*\n" + \
    " * " + title + "\n" + \
    " *\n" + \
    " * Copyright (c) 2010-2023 Clemson University\n" + \
    " *\n" + \
    " */\n"
 

def write_copyright(fd, title):
    fd.write(get_copyright(title))


def get_doxygen_file_section(filename, brief, more=False):
    m = more
    if (m == False): m=""
    return \
    "\n/**\n" + \
    " * @file " + filename + "\n" + \
    " * @brief " + brief + "\n" + \
    m + \
    " */\n"


def write_doxygen_file_section(fd, filename, brief, more=False):
    fd.write(get_doxygen_file_section(filename, brief, more))


def get_c_prologue(fd, generated_by, title):
    return get_copyright(title) + '\n' + get_generated_by(generated_by) + '\n'


def write_c_prologue(fd, generated_by, title):
    fd.write(get_c_prologue(fd, generated_by, title))


def get_h_prologue(generated_by, title, filename):
    guard = ('__' + filename + '__').upper().replace('.', '_')
    return \
    get_copyright(title) + \
    "\n" + \
    get_generated_by(generated_by) + \
    "\n" + \
    "#ifndef " + guard + "\n" + \
    "#define " + guard + "\n\n"


def write_h_prologue(fd, generated_by, title, filename):
    fd.write(get_h_prologue(generated_by, title, filename))


def get_h_epilogue(filename):
    guard = ('__' + filename + '__').upper().replace('.', '_')
    return "\n\n#endif /* " + guard + " */\n"


def write_h_epilogue(fd, filename):
    fd.write(get_h_epilogue(filename))

def write_wrapped(fd, max, prefix, s, continue_indent='', last_char='', trim=False):

    # The s passed to this function is often the text from properties like
    # "description" that contains "plain/text".
    #
    # Doxygen considers strings enclosed in angle brackets to be links. This
    # attempts put grave symbols around series of characters that contain angle
    # bracket enclosed substrings. This may need to be adjusted over time but
    # worked correctly when originally added.
    # 
    # Enclose strings that contain substrings enclosed with angle brackets in
    # grave symbols. If previously enclosed in single quotes, just enclose in
    # grave symbols. Don't put graves around the open/close parentheses.
    pattern = r"[^ (]*<[^ ]*>[^\n.) ]*"
    replacement = r"`\g<0>`"
    s = re.sub(pattern, replacement, s)
    s = re.sub("`'", "`", s)
    s = re.sub("'`", "`", s)

    end_of_line = -1
    s_len = len(s)
    use_len = max - len(prefix) - len(last_char) - 1
    indent = ''
    while True:
        beginning_of_line = end_of_line + 1
        if beginning_of_line >= s_len: break

        end_of_line = beginning_of_line
        while end_of_line < beginning_of_line + use_len and end_of_line < s_len and s[end_of_line] != '\n':
            end_of_line += 1

        if end_of_line >= s_len:
            end_of_line = s_len - 1
        elif s[end_of_line] != '\n':
            original_end_of_line = end_of_line
            while True:
                if s[end_of_line] == ' ': break
                end_of_line -= 1
                if end_of_line <= beginning_of_line:
                    end_of_line = original_end_of_line
                    break

        if s[end_of_line] == '\n' or s[end_of_line] == ' ':
            line = s[beginning_of_line:end_of_line]
        else:
            line = s[beginning_of_line:end_of_line+1]
        if trim:
            line = line.strip()
        w = prefix + indent + line
        fd.write(w)
        if last_char is not None and last_char != '':
            if len(w) < max - 1:
                fd.write(' ' * (max - len(w) - 1))
            fd.write(last_char)

        fd.write('\n')
        indent = continue_indent
        use_len = max - len(prefix) - len(continue_indent) - 1

def make_quoted(s):
    r = '"'
    for c in s:
        x = ord(c)
        if x < 32:
            if x == 0x07:
                r += '\\a'
            elif x == 0x08:
                r += '\\beginning_of_line'
            elif x == 0x0c:
                r += '\\f'
            elif x == 0x0a:
                r += '\\n'
            elif x == 0x0d:
                r += '\\r'
            elif x == 0x09:
                r += '\\t'
            elif x == 0x0b:
                r += '\\v'
            else:
                r += '\\' + hex(x)

        elif c == '\\':
            r += '\\\\'
        elif c == '"':
            r += '\\"'
        else:
            r += c

    r += '"'
    return r


def replace_directory_files_copyright(srcdir_path, ignore_files=[], recursive=False):
    for src_file in sorted(os.listdir(srcdir_path)):
        if os.path.isdir(srcdir_path + src_file):
            if recursive and  src_file not in ignore_files:
                replace_directory_files_copyright(srcdir_path + src_file + '/', ignore_files, recursive)
        elif src_file.endswith('.c') or src_file.endswith('.h') or src_file.endswith('.js'):
            if src_file not in ignore_files:
                replace_file_copyright(srcdir_path, src_file)

def replace_file_copyright(srcdir_path, src_file) :
    file_path = srcdir_path + src_file
    directives = []
    old_copyright = []
    remaining_lines = []
    title = ''
    state = 'ignore_empty'
    has_copyright = False
    linenumber = 0;
    with nfc.open(file_path, mode='r') as fd:
        while True:
    
            # Read a line. The line might have invalid utf-8, so use try.
            linenumber += 1
            try:
                line = fd.readline()
            except:
                msg.error('Error reading ' + file_path + ' line number ' + str(linenumber))
                return

            if not line:
                break

            #  Ignore initial empty lines
            if state == 'ignore_empty':
                if line.strip() == '':
                    continue
                state = 'directives'

            #  Keep directives that are before license/copyright like #ifdef/#define
            if state == 'directives':
                if line.startswith('#'):
                    directives.append(line)
                    continue
                elif line.strip() == '':
                    continue
                state = 'license'

            #  There can be a license line that starts with // and contains
            #  SPDX-License-Identifier. Also accept a placeholder that starts
            #  with '//>>>'
            if state == 'license':
                state = 'copyright'
                if line.startswith('//'):
                    if line.startswith('//>>>') or 'SPDX-License-Identifier' in line:
                        old_copyright.append(line)
                        continue

            #
            #  There are all kinds of comments that might hold copyright. There can
            #  one or more block or line comments. Because of this, a guess is made
            #  as to when the old copyright ends. An empty line is always considered
            #  the end of the copyright. A line that does not begin with '/*', '*',
            #  or '//' is also considered to be the end of the copyright since there
            #  are examples in AFW source that do not have an empty line following
            #  the copyright.
            # 
            #  This function does not parse block comment begin and end, so a blank
            #  line in the middle of a block comment will mistakenly be recognized
            #  as the end of the copyright. It is expected that there will at least 
            #  an asterisk instead of a totally empty line.
            #
            #  The first line that contains text is used as the title for the
            #  copyright.
            #
            #  At least one line must have a case insensitive 'copyright' for this
            #  source to be considered to have a copyright section that needs
            #  replacing.
            #
            if state == 'copyright':
                if 'copyright' in line.lower():
                    has_copyright = True
                stripped = line.strip()
                if stripped == '':
                    state = 'remaining'
                elif not stripped.startswith('/*') and not stripped.startswith('*') and not stripped.startswith('//'):
                    state = 'remaining'
                else:
                    old_copyright.append(line)
                    if title == '':
                        if stripped.startswith('/*'):
                            title = stripped[2:]
                        elif stripped.startswith('*'):
                            title = stripped[1:]
                        else:
                            continue
                        title = title.strip()
                        if title.endswith('*/'):
                            title = title[:-2]
                        title = title.strip()
                    continue

            # If there is not a copyright section, stop reading.
            if not has_copyright:
                break

            # All lines after the copyright are kept.
            remaining_lines.append(line)

    # If there is a copyright section: write license, replacement copyright,
    # derivities, and remaining lines.
    if has_copyright:
        msg.info('Updating copyright in ' + src_file)
        with nfc.open(file_path, mode='w') as fd:
            try:
                write_copyright(fd, title)

                if len(directives) > 0:
                    fd.write('\n')
                    fd.writelines(directives)
                    fd.write('\n')

                fd.writelines(remaining_lines)
            except:
                msg.error('Error updating copyright in ' + src_file)





    # # Replace copyrights in srcdir plus some without generate/ dir if srcdir is 'afw'
    # # NOTE: Change replace_copyright to True if copyrights need to be replaced.
    # # NOTE: Make sure c.replace_directory_files_copyright() does what you want.  These is a
    # # NOTE: good chance it will not.
    # replace_copyright = False
    # if replace_copyright:
    #     c.replace_directory_files_copyright(options['srcsubdir_path'], recursive=True)
    #     if options['srcdir'] == 'afw':
    #         c.replace_directory_files_copyright(options['src_dir_path'] + 'afw_command/', recursive=True)
    #         c.replace_directory_files_copyright(options['src_dir_path'] + 'afw_xacml_pdp/', recursive=True)
    #         c.replace_directory_files_copyright(options['src_dir_path'] + 'afw_xacml_tester/', recursive=True)
