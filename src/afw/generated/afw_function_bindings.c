// See the 'COPYING' file in the project root for licensing information.
/*
 * Adaptive Framework Core Adaptive Function Bindings 
 *
 * Copyright (c) 2010-2023 Clemson University
 *
 */

/*  ----------------------------- N O T E -------------------------------------
 *
 * This file is generated by "afwdev generate afw".
 *
 * Do not change this file directly or the changes will be lost the next time
 * this file is regenerated.
 *
 * -------------------------------------------------------------------------*/



/**
 * @file afw_function_bindings.c
 * @brief Adaptive Framework core adaptive function bindings.
 */

#include "afw.h"
#include "afw_internal.h"
#include "afw_function_bindings.h"
#include "afw_runtime_object_maps.h"
#include "afw_strings.h"


/* ---------- adaptor_objectCallback_signature ---------- */

static const afw_utf8_t
impl_object_path__adaptor_objectCallback_signature =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/adaptor_objectCallback_signature");

static const afw_runtime_object_indirect_t
impl_object__adaptor_objectCallback_signature = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_adaptor_objectCallback_signature,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__adaptor_objectCallback_signature
        }
    },
    (void *)&afw_function_definition_adaptor_objectCallback_signature
};

static const afw_value_function_parameter_t
impl_adaptor_objectCallback_signature_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("true if objectCallback should not be called again"),
    AFW_UTF8_LITERAL("Return true if this callback should not be called again for any reason such a limit exceeded or the desired object being found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_adaptor_objectCallback_signature_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("The object from adaptor"),
    AFW_UTF8_LITERAL("This is the object from adaptor or undefined if there are no more objects to return."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_adaptor_objectCallback_signature_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_any_direct,
    AFW_UTF8_LITERAL("any"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("userData"),
    AFW_UTF8_LITERAL("User data"),
    AFW_UTF8_LITERAL("This is the value of the userData parameter when objectCallback was called."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_adaptor_objectCallback_signature_parameters[] = {
    &impl_adaptor_objectCallback_signature_parameter_1,
    &impl_adaptor_objectCallback_signature_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_adaptor_objectCallback_signature = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__adaptor_objectCallback_signature,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("adaptor_objectCallback_signature"),
    AFW_UTF8_LITERAL("adaptor_objectCallback_signature"),
    AFW_UTF8_LITERAL("adaptor_objectCallback_signature"),
    AFW_UTF8_LITERAL("adaptorObjectCallbackSignature"),
    AFW_UTF8_LITERAL("afwAdaptorObjectCallbackSignature"),
    AFW_UTF8_LITERAL("Signature used for adaptor objectCallback"),
    AFW_UTF8_LITERAL("This is the function signature for the objectCallback parameter in adaptor functions. Calling this directly will throw a \"Do not call directly\" error."),
    AFW_UTF8_LITERAL("(object: object, userData?: any): boolean"),
    AFW_UTF8_LITERAL("/* Signature used for adaptor objectCallback */\nfunction adaptor_objectCallback_signature (\n    object: object /* The object from adaptor */,\n    userData?: any /* User data */\n): boolean; /* true if objectCallback should not be called again */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_adaptor_objectCallback_signature,
    NULL,
    1,
    2,
    &impl_adaptor_objectCallback_signature_parameters[0],
    2,
    &impl_adaptor_objectCallback_signature_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    true
};

/* ---------- add_object ---------- */

static const afw_utf8_t
impl_object_path__add_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_object");

static const afw_runtime_object_indirect_t
impl_object__add_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_object
        }
    },
    (void *)&afw_function_definition_add_object
};

static const afw_value_function_parameter_t
impl_add_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry. Property \"objectId\" is the objectId assigned by the adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptive object type of object being added."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object to add."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional preferred objectId of object to add. The adaptor may ignore this."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_add_object\n\nwhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_object_parameters[] = {
    &impl_add_object_parameter_1,
    &impl_add_object_parameter_2,
    &impl_add_object_parameter_3,
    &impl_add_object_parameter_4,
    &impl_add_object_parameter_5,
    &impl_add_object_parameter_6,
    NULL
};

static const afw_utf8_t
impl_add_object_sideEffects[] = {
    AFW_UTF8_LITERAL("Object created"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_object,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("add_object"),
    AFW_UTF8_LITERAL("add_object"),
    AFW_UTF8_LITERAL("add_object"),
    AFW_UTF8_LITERAL("addObject"),
    AFW_UTF8_LITERAL("afwAddObject"),
    AFW_UTF8_LITERAL("Add adaptive object"),
    AFW_UTF8_LITERAL("Add an adaptive object to an adaptor, specified by the adaptorId, with a specified objectType. You may supply an optional objectId, if the underlying adaptorId allows it."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, object: object, objectId?: string, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Add adaptive object */\nfunction add_object (\n    adaptorId: string,\n    objectType: string,\n    object: object,\n    objectId?: string,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_add_object,
    NULL,
    3,
    6,
    &impl_add_object_parameters[0],
    6,
    &impl_add_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_add_object_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- add_object_with_uri ---------- */

static const afw_utf8_t
impl_object_path__add_object_with_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_object_with_uri");

static const afw_runtime_object_indirect_t
impl_object__add_object_with_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_object_with_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_object_with_uri
        }
    },
    (void *)&afw_function_definition_add_object_with_uri
};

static const afw_value_function_parameter_t
impl_add_object_with_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry. Property \"objectId\" is the objectId assigned by the adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_with_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of object to add. If a URI begins with a single slash ('/'), it is the local object path. In the case of a local path, an optional preferred objectId of object can be including in URI which the adaptor may ignore."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_with_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object to add."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_with_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_object_with_uri_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_add_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_object_with_uri_parameters[] = {
    &impl_add_object_with_uri_parameter_1,
    &impl_add_object_with_uri_parameter_2,
    &impl_add_object_with_uri_parameter_3,
    &impl_add_object_with_uri_parameter_4,
    NULL
};

static const afw_utf8_t
impl_add_object_with_uri_sideEffects[] = {
    AFW_UTF8_LITERAL("Object created"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_object_with_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_object_with_uri,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("add_object_with_uri"),
    AFW_UTF8_LITERAL("add_object_with_uri"),
    AFW_UTF8_LITERAL("add_object_with_uri"),
    AFW_UTF8_LITERAL("addObjectWithUri"),
    AFW_UTF8_LITERAL("afwAddObjectWithUri"),
    AFW_UTF8_LITERAL("Add adaptive object with URI"),
    AFW_UTF8_LITERAL("Add an adaptive object with a given URI."),
    AFW_UTF8_LITERAL("(uri: anyURI, object: object, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Add adaptive object with URI */\nfunction add_object_with_uri (\n    uri: anyURI,\n    object: object,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_add_object_with_uri,
    NULL,
    2,
    4,
    &impl_add_object_with_uri_parameters[0],
    4,
    &impl_add_object_with_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_add_object_with_uri_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- convert_AdaptiveQueryCriteria_to_query_string ---------- */

static const afw_utf8_t
impl_object_path__convert_AdaptiveQueryCriteria_to_query_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/convert_AdaptiveQueryCriteria_to_query_string");

static const afw_runtime_object_indirect_t
impl_object__convert_AdaptiveQueryCriteria_to_query_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_convert_AdaptiveQueryCriteria_to_query_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__convert_AdaptiveQueryCriteria_to_query_string
        }
    },
    (void *)&afw_function_definition_convert_AdaptiveQueryCriteria_to_query_string
};

static const afw_value_function_parameter_t
impl_convert_AdaptiveQueryCriteria_to_query_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Query string representation of the query criteria."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveQueryCriteria_"),
    AFW_UTF8_LITERAL("queryCriteria"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An object type _AdaptiveQueryCriteria_ object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptorId of adaptor containing the objectType for validating and mapping this query. If not specified, no validation or mapping will occur."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the objectType used in conjunction with the adaptorId parameter. This parameter is only allowed and is required if the adaptorId parameter is specified."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("style"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The style of the query string produced. All of the styles are appropriately url encoded.\n\n0 - \"name=op=value\" where \"=op=\" will be \"==\", \"!=\", \"=ge=\", etc. with conjunctions \"&\" (and) and \"|\" (or). Parentheses are placed around each group of like conjunctions except for outer \"&\". (default)\n\n1 - the same as 1 with \"=gte=\" instead of \"=ge=\", \"=lte=\" instead of \"=le=\", \"=eq=\" instead of \"=\", and \"=ne=\" instead of '!='.\n\n2 - similar to 1 with ';' for '&' and ',' for '|'.\n\n3 - comparisons \"op(name,value)\" where \"op\" will be \"eq\", \"ne\", \"ge\", ..., plus conjunctions \"and(list)\" and \"or(list)\" where \"list\" is a comma separated list of any comparison or conjunction."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_convert_AdaptiveQueryCriteria_to_query_string_parameters[] = {
    &impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_1,
    &impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_2,
    &impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_3,
    &impl_convert_AdaptiveQueryCriteria_to_query_string_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_convert_AdaptiveQueryCriteria_to_query_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__convert_AdaptiveQueryCriteria_to_query_string,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("convert_AdaptiveQueryCriteria_to_query_string"),
    AFW_UTF8_LITERAL("convert_AdaptiveQueryCriteria_to_query_string"),
    AFW_UTF8_LITERAL("convert_AdaptiveQueryCriteria_to_query_string"),
    AFW_UTF8_LITERAL("convertAdaptiveQueryCriteriaToQueryString"),
    AFW_UTF8_LITERAL("afwConvertAdaptiveQueryCriteriaToQueryString"),
    AFW_UTF8_LITERAL("Convert _AdaptiveQueryCriteria_ to RQL"),
    AFW_UTF8_LITERAL("This function converts an _AdaptiveQueryCriteria_ object to a query string."),
    AFW_UTF8_LITERAL("(queryCriteria: (object _AdaptiveQueryCriteria_), adaptorId?: string, objectType?: string, style?: integer): string"),
    AFW_UTF8_LITERAL("/* Convert _AdaptiveQueryCriteria_ to RQL */\nfunction convert_AdaptiveQueryCriteria_to_query_string (\n    queryCriteria: (object _AdaptiveQueryCriteria_),\n    adaptorId?: string,\n    objectType?: string,\n    style?: integer\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert_AdaptiveQueryCriteria_to_query_string,
    NULL,
    1,
    4,
    &impl_convert_AdaptiveQueryCriteria_to_query_string_parameters[0],
    4,
    &impl_convert_AdaptiveQueryCriteria_to_query_string_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- convert_query_string_to_AdaptiveQueryCriteria ---------- */

static const afw_utf8_t
impl_object_path__convert_query_string_to_AdaptiveQueryCriteria =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/convert_query_string_to_AdaptiveQueryCriteria");

static const afw_runtime_object_indirect_t
impl_object__convert_query_string_to_AdaptiveQueryCriteria = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_convert_query_string_to_AdaptiveQueryCriteria,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__convert_query_string_to_AdaptiveQueryCriteria
        }
    },
    (void *)&afw_function_definition_convert_query_string_to_AdaptiveQueryCriteria
};

static const afw_value_function_parameter_t
impl_convert_query_string_to_AdaptiveQueryCriteria_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveQueryCriteria_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An object type _AdaptiveQueryCriteria_ object representing query string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_query_string_to_AdaptiveQueryCriteria_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("queryString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The query string to convert."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_query_string_to_AdaptiveQueryCriteria_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptorId of adaptor containing the objectType for validating and mapping this query. If not specified, no validation or mapping will occur."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_query_string_to_AdaptiveQueryCriteria_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the objectType used in conjunction with the adaptorId parameter. This parameter is only allowed and is required if the adaptorId parameter is specified."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_convert_query_string_to_AdaptiveQueryCriteria_parameters[] = {
    &impl_convert_query_string_to_AdaptiveQueryCriteria_parameter_1,
    &impl_convert_query_string_to_AdaptiveQueryCriteria_parameter_2,
    &impl_convert_query_string_to_AdaptiveQueryCriteria_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_convert_query_string_to_AdaptiveQueryCriteria = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__convert_query_string_to_AdaptiveQueryCriteria,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("convert_query_string_to_AdaptiveQueryCriteria"),
    AFW_UTF8_LITERAL("convert_query_string_to_AdaptiveQueryCriteria"),
    AFW_UTF8_LITERAL("convert_query_string_to_AdaptiveQueryCriteria"),
    AFW_UTF8_LITERAL("convertQueryStringToAdaptiveQueryCriteria"),
    AFW_UTF8_LITERAL("afwConvertQueryStringToAdaptiveQueryCriteria"),
    AFW_UTF8_LITERAL("Convert query string to _AdaptiveQueryCriteria_"),
    AFW_UTF8_LITERAL("This function converts a query string to an _AdaptiveQueryCriteria_ object."),
    AFW_UTF8_LITERAL("(queryString: string, adaptorId?: string, objectType?: string): (object _AdaptiveQueryCriteria_)"),
    AFW_UTF8_LITERAL("/* Convert query string to _AdaptiveQueryCriteria_ */\nfunction convert_query_string_to_AdaptiveQueryCriteria (\n    queryString: string,\n    adaptorId?: string,\n    objectType?: string\n): (object _AdaptiveQueryCriteria_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert_query_string_to_AdaptiveQueryCriteria,
    NULL,
    1,
    3,
    &impl_convert_query_string_to_AdaptiveQueryCriteria_parameters[0],
    3,
    &impl_convert_query_string_to_AdaptiveQueryCriteria_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- delete_object ---------- */

static const afw_utf8_t
impl_object_path__delete_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/delete_object");

static const afw_runtime_object_indirect_t
impl_object__delete_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_delete_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__delete_object
        }
    },
    (void *)&afw_function_definition_delete_object
};

static const afw_value_function_parameter_t
impl_delete_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor containing object to delete."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptive object type of object to delete."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of object to delete."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_delete_object\n\nwhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_delete_object_parameters[] = {
    &impl_delete_object_parameter_1,
    &impl_delete_object_parameter_2,
    &impl_delete_object_parameter_3,
    &impl_delete_object_parameter_4,
    &impl_delete_object_parameter_5,
    NULL
};

static const afw_utf8_t
impl_delete_object_sideEffects[] = {
    AFW_UTF8_LITERAL("Object deleted"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_delete_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__delete_object,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("delete_object"),
    AFW_UTF8_LITERAL("delete_object"),
    AFW_UTF8_LITERAL("delete_object"),
    AFW_UTF8_LITERAL("deleteObject"),
    AFW_UTF8_LITERAL("afwDeleteObject"),
    AFW_UTF8_LITERAL("Delete adaptive object"),
    AFW_UTF8_LITERAL("Delete an adaptive object."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Delete adaptive object */\nfunction delete_object (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_delete_object,
    NULL,
    3,
    5,
    &impl_delete_object_parameters[0],
    5,
    &impl_delete_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_delete_object_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- delete_object_with_uri ---------- */

static const afw_utf8_t
impl_object_path__delete_object_with_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/delete_object_with_uri");

static const afw_runtime_object_indirect_t
impl_object__delete_object_with_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_delete_object_with_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__delete_object_with_uri
        }
    },
    (void *)&afw_function_definition_delete_object_with_uri
};

static const afw_value_function_parameter_t
impl_delete_object_with_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_with_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of object to delete. If a URI begins with a single slash ('/'), it is the local object path."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_with_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_delete_object_with_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_delete_object\n\nwhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_delete_object_with_uri_parameters[] = {
    &impl_delete_object_with_uri_parameter_1,
    &impl_delete_object_with_uri_parameter_2,
    &impl_delete_object_with_uri_parameter_3,
    NULL
};

static const afw_utf8_t
impl_delete_object_with_uri_sideEffects[] = {
    AFW_UTF8_LITERAL("Object deleted"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_delete_object_with_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__delete_object_with_uri,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("delete_object_with_uri"),
    AFW_UTF8_LITERAL("delete_object_with_uri"),
    AFW_UTF8_LITERAL("delete_object_with_uri"),
    AFW_UTF8_LITERAL("deleteObjectWithUri"),
    AFW_UTF8_LITERAL("afwDeleteObjectWithUri"),
    AFW_UTF8_LITERAL("Delete adaptive object with URI"),
    AFW_UTF8_LITERAL("Delete an adaptive object with a given URI."),
    AFW_UTF8_LITERAL("(uri: anyURI, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Delete adaptive object with URI */\nfunction delete_object_with_uri (\n    uri: anyURI,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_delete_object_with_uri,
    NULL,
    1,
    3,
    &impl_delete_object_with_uri_parameters[0],
    3,
    &impl_delete_object_with_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_delete_object_with_uri_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- get_object ---------- */

static const afw_utf8_t
impl_object_path__get_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/get_object");

static const afw_runtime_object_indirect_t
impl_object__get_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_get_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__get_object
        }
    },
    (void *)&afw_function_definition_get_object
};

static const afw_value_function_parameter_t
impl_get_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object retrieved or NULL if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor containing object to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptive object type of object to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of object to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_get_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_get_object_parameters[] = {
    &impl_get_object_parameter_1,
    &impl_get_object_parameter_2,
    &impl_get_object_parameter_3,
    &impl_get_object_parameter_4,
    &impl_get_object_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_get_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__get_object,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("get_object"),
    AFW_UTF8_LITERAL("get_object"),
    AFW_UTF8_LITERAL("get_object"),
    AFW_UTF8_LITERAL("getObject"),
    AFW_UTF8_LITERAL("afwGetObject"),
    AFW_UTF8_LITERAL("Get adaptive object"),
    AFW_UTF8_LITERAL("Get an adaptive object from the adaptor, specified by adaptorId, objectType and objectId. Optional view options and adaptor-specific options may be supplied to influence how the object is returned."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): object"),
    AFW_UTF8_LITERAL("/* Get adaptive object */\nfunction get_object (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    options?: (object _AdaptiveObjectOptions_),\n    adaptorTypeSpecific?: object\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_get_object,
    NULL,
    3,
    5,
    &impl_get_object_parameters[0],
    5,
    &impl_get_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- get_object_with_uri ---------- */

static const afw_utf8_t
impl_object_path__get_object_with_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/get_object_with_uri");

static const afw_runtime_object_indirect_t
impl_object__get_object_with_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_get_object_with_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__get_object_with_uri
        }
    },
    (void *)&afw_function_definition_get_object_with_uri
};

static const afw_value_function_parameter_t
impl_get_object_with_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object retrieved or NULL if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_with_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of object to retrieve. If a URI begins with a single slash ('/'), it is the local object path."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_with_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_get_object_with_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_get_object\n\nwhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_get_object_with_uri_parameters[] = {
    &impl_get_object_with_uri_parameter_1,
    &impl_get_object_with_uri_parameter_2,
    &impl_get_object_with_uri_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_get_object_with_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__get_object_with_uri,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("get_object_with_uri"),
    AFW_UTF8_LITERAL("get_object_with_uri"),
    AFW_UTF8_LITERAL("get_object_with_uri"),
    AFW_UTF8_LITERAL("getObjectWithUri"),
    AFW_UTF8_LITERAL("afwGetObjectWithUri"),
    AFW_UTF8_LITERAL("Get adaptive object with URI"),
    AFW_UTF8_LITERAL("Get an object with a given URI."),
    AFW_UTF8_LITERAL("(uri: anyURI, options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): object"),
    AFW_UTF8_LITERAL("/* Get adaptive object with URI */\nfunction get_object_with_uri (\n    uri: anyURI,\n    options?: (object _AdaptiveObjectOptions_),\n    adaptorTypeSpecific?: object\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_get_object_with_uri,
    NULL,
    1,
    3,
    &impl_get_object_with_uri_parameters[0],
    3,
    &impl_get_object_with_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- modify_object ---------- */

static const afw_utf8_t
impl_object_path__modify_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/modify_object");

static const afw_runtime_object_indirect_t
impl_object__modify_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_modify_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__modify_object
        }
    },
    (void *)&afw_function_definition_modify_object
};

static const afw_value_function_parameter_t
impl_modify_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor containing object to modify."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptive object type of object to modify."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of object to modify."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("entries"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("List of modifications. Entries are of the form:\n\n    [\n        \"add_value\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]\n\n    [\n        \"remove_property\",\n        \"property name\" or [\"property name\", ... ]\n    ]\n\n    [\n        \"remove_value\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]\n\n    [\n        \"set_property\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_modify_object_parameters[] = {
    &impl_modify_object_parameter_1,
    &impl_modify_object_parameter_2,
    &impl_modify_object_parameter_3,
    &impl_modify_object_parameter_4,
    &impl_modify_object_parameter_5,
    &impl_modify_object_parameter_6,
    NULL
};

static const afw_utf8_t
impl_modify_object_sideEffects[] = {
    AFW_UTF8_LITERAL("Object modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_modify_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__modify_object,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("modify_object"),
    AFW_UTF8_LITERAL("modify_object"),
    AFW_UTF8_LITERAL("modify_object"),
    AFW_UTF8_LITERAL("modifyObject"),
    AFW_UTF8_LITERAL("afwModifyObject"),
    AFW_UTF8_LITERAL("Modify adaptive object"),
    AFW_UTF8_LITERAL("Modify an adaptive object."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, entries: list, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Modify adaptive object */\nfunction modify_object (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    entries: list,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_modify_object,
    NULL,
    4,
    6,
    &impl_modify_object_parameters[0],
    6,
    &impl_modify_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_modify_object_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- modify_object_with_uri ---------- */

static const afw_utf8_t
impl_object_path__modify_object_with_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/modify_object_with_uri");

static const afw_runtime_object_indirect_t
impl_object__modify_object_with_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_modify_object_with_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__modify_object_with_uri
        }
    },
    (void *)&afw_function_definition_modify_object_with_uri
};

static const afw_value_function_parameter_t
impl_modify_object_with_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_with_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of object to modify. If a URI begins with a single slash ('/'), it is the local object path."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_with_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("entries"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("List of asserts and modifications. Entries are of the form:\n\n    [\n        \"add_value\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]\n\n    [\n        \"remove_property\",\n        \"property name\" or [\"property name\", ... ]\n    ]\n\n    [\n        \"remove_value\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]\n\n    [\n        \"set_property\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_with_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_modify_object_with_uri_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_modify_object_with_uri_parameters[] = {
    &impl_modify_object_with_uri_parameter_1,
    &impl_modify_object_with_uri_parameter_2,
    &impl_modify_object_with_uri_parameter_3,
    &impl_modify_object_with_uri_parameter_4,
    NULL
};

static const afw_utf8_t
impl_modify_object_with_uri_sideEffects[] = {
    AFW_UTF8_LITERAL("Object modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_modify_object_with_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__modify_object_with_uri,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("modify_object_with_uri"),
    AFW_UTF8_LITERAL("modify_object_with_uri"),
    AFW_UTF8_LITERAL("modify_object_with_uri"),
    AFW_UTF8_LITERAL("modifyObjectWithUri"),
    AFW_UTF8_LITERAL("afwModifyObjectWithUri"),
    AFW_UTF8_LITERAL("Modify adaptive object with URI"),
    AFW_UTF8_LITERAL("Modify an adaptive object with a given URI."),
    AFW_UTF8_LITERAL("(uri: anyURI, entries: list, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Modify adaptive object with URI */\nfunction modify_object_with_uri (\n    uri: anyURI,\n    entries: list,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_modify_object_with_uri,
    NULL,
    2,
    4,
    &impl_modify_object_with_uri_parameters[0],
    4,
    &impl_modify_object_with_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_modify_object_with_uri_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- reconcile_object ---------- */

static const afw_utf8_t
impl_object_path__reconcile_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/reconcile_object");

static const afw_runtime_object_indirect_t
impl_object__reconcile_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_reconcile_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__reconcile_object
        }
    },
    (void *)&afw_function_definition_reconcile_object
};

static const afw_value_function_parameter_t
impl_reconcile_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_reconcile_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An object that has been retrieved with object options reconcilable, and whose properties have been modified. A modify_object request will be produced reflecting the difference between the original object and this unmodified object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_reconcile_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("checkOnly"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Produce the modify_object request but don't execute it. The returned journal enter will contain the modify_object request."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_reconcile_object_parameters[] = {
    &impl_reconcile_object_parameter_1,
    &impl_reconcile_object_parameter_2,
    NULL
};

static const afw_utf8_t
impl_reconcile_object_sideEffects[] = {
    AFW_UTF8_LITERAL("Object modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_reconcile_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__reconcile_object,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("reconcile_object"),
    AFW_UTF8_LITERAL("reconcile_object"),
    AFW_UTF8_LITERAL("reconcile_object"),
    AFW_UTF8_LITERAL("reconcileObject"),
    AFW_UTF8_LITERAL("afwReconcileObject"),
    AFW_UTF8_LITERAL("Reconcile adaptive object"),
    AFW_UTF8_LITERAL("Reconcile an adaptive object."),
    AFW_UTF8_LITERAL("(object: object, checkOnly?: boolean): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Reconcile adaptive object */\nfunction reconcile_object (\n    object: object,\n    checkOnly?: boolean\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_reconcile_object,
    NULL,
    1,
    2,
    &impl_reconcile_object_parameters[0],
    2,
    &impl_reconcile_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_reconcile_object_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- replace_object ---------- */

static const afw_utf8_t
impl_object_path__replace_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/replace_object");

static const afw_runtime_object_indirect_t
impl_object__replace_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_replace_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__replace_object
        }
    },
    (void *)&afw_function_definition_replace_object
};

static const afw_value_function_parameter_t
impl_replace_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor containing object to replace."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptive object type of object to replace."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of object to replace."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Replacement object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_replace_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_replace_object_parameters[] = {
    &impl_replace_object_parameter_1,
    &impl_replace_object_parameter_2,
    &impl_replace_object_parameter_3,
    &impl_replace_object_parameter_4,
    &impl_replace_object_parameter_5,
    &impl_replace_object_parameter_6,
    NULL
};

static const afw_utf8_t
impl_replace_object_sideEffects[] = {
    AFW_UTF8_LITERAL("Object modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__replace_object,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("replace_object"),
    AFW_UTF8_LITERAL("replace_object"),
    AFW_UTF8_LITERAL("replace_object"),
    AFW_UTF8_LITERAL("replaceObject"),
    AFW_UTF8_LITERAL("afwReplaceObject"),
    AFW_UTF8_LITERAL("Replace adaptive object"),
    AFW_UTF8_LITERAL("Replace an adaptive object."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, object: object, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Replace adaptive object */\nfunction replace_object (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    object: object,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_replace_object,
    NULL,
    4,
    6,
    &impl_replace_object_parameters[0],
    6,
    &impl_replace_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_replace_object_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- replace_object_with_uri ---------- */

static const afw_utf8_t
impl_object_path__replace_object_with_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/replace_object_with_uri");

static const afw_runtime_object_indirect_t
impl_object__replace_object_with_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_replace_object_with_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__replace_object_with_uri
        }
    },
    (void *)&afw_function_definition_replace_object_with_uri
};

static const afw_value_function_parameter_t
impl_replace_object_with_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_with_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of object to replace. If a URI begins with a single slash ('/'), it is the local object path."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_with_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Replacement object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_with_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_object_with_uri_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_replace_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_replace_object_with_uri_parameters[] = {
    &impl_replace_object_with_uri_parameter_1,
    &impl_replace_object_with_uri_parameter_2,
    &impl_replace_object_with_uri_parameter_3,
    &impl_replace_object_with_uri_parameter_4,
    NULL
};

static const afw_utf8_t
impl_replace_object_with_uri_sideEffects[] = {
    AFW_UTF8_LITERAL("Object modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_object_with_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__replace_object_with_uri,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("replace_object_with_uri"),
    AFW_UTF8_LITERAL("replace_object_with_uri"),
    AFW_UTF8_LITERAL("replace_object_with_uri"),
    AFW_UTF8_LITERAL("replaceObjectWithUri"),
    AFW_UTF8_LITERAL("afwReplaceObjectWithUri"),
    AFW_UTF8_LITERAL("Replace adaptive object with URI"),
    AFW_UTF8_LITERAL("Replace an adaptive object with a given URI."),
    AFW_UTF8_LITERAL("(uri: anyURI, object: object, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Replace adaptive object with URI */\nfunction replace_object_with_uri (\n    uri: anyURI,\n    object: object,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_replace_object_with_uri,
    NULL,
    2,
    4,
    &impl_replace_object_with_uri_parameters[0],
    4,
    &impl_replace_object_with_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_replace_object_with_uri_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects
        }
    },
    (void *)&afw_function_definition_retrieve_objects
};

static const afw_value_function_parameter_t
impl_retrieve_objects_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Objects retrieved or undefined"),
    AFW_UTF8_LITERAL("This is the list of objects retrieved."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL("Id of adaptor"),
    AFW_UTF8_LITERAL("Id of adaptor containing objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL("Id of object type"),
    AFW_UTF8_LITERAL("Id of adaptive object type of objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveQueryCriteria_"),
    AFW_UTF8_LITERAL("queryCriteria"),
    AFW_UTF8_LITERAL("Query criteria"),
    AFW_UTF8_LITERAL("This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_parameters[] = {
    &impl_retrieve_objects_parameter_1,
    &impl_retrieve_objects_parameter_2,
    &impl_retrieve_objects_parameter_3,
    &impl_retrieve_objects_parameter_4,
    &impl_retrieve_objects_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects"),
    AFW_UTF8_LITERAL("retrieve_objects"),
    AFW_UTF8_LITERAL("retrieve_objects"),
    AFW_UTF8_LITERAL("retrieveObjects"),
    AFW_UTF8_LITERAL("afwRetrieveObjects"),
    AFW_UTF8_LITERAL("Retrieve adaptive objects"),
    AFW_UTF8_LITERAL("This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, queryCriteria?: (object _AdaptiveQueryCriteria_), options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): list"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive objects */\nfunction retrieve_objects (\n    adaptorId: string                                /* Id of adaptor */,\n    objectType: string                               /* Id of object type */,\n    queryCriteria?: (object _AdaptiveQueryCriteria_) /* Query criteria */,\n    options?: (object _AdaptiveObjectOptions_)       /* Object options */,\n    adaptorTypeSpecific?: object                     /* Adaptor specific */\n): list; /* Objects retrieved or undefined */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects,
    NULL,
    2,
    5,
    &impl_retrieve_objects_parameters[0],
    5,
    &impl_retrieve_objects_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects_to_callback ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects_to_callback =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects_to_callback");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects_to_callback = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects_to_callback,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects_to_callback
        }
    },
    (void *)&afw_function_definition_retrieve_objects_to_callback
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(object: object, userData: any): boolean"),
    AFW_UTF8_LITERAL("objectCallback"),
    AFW_UTF8_LITERAL("Object Callback"),
    AFW_UTF8_LITERAL("If this is specified, this function is called once for each object retrieved instead of adding the object to the return list. Parameter object will be an object retrieved or undefined if there are no more objects. This function should return true if it wants to abort the retrieve request."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("userData"),
    AFW_UTF8_LITERAL("User data"),
    AFW_UTF8_LITERAL("This value is passed to the objectCallback function in the userData parameter."),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL("Id of adaptor"),
    AFW_UTF8_LITERAL("Id of adaptor containing objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL("Id of object type"),
    AFW_UTF8_LITERAL("Id of adaptive object type of objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveQueryCriteria_"),
    AFW_UTF8_LITERAL("queryCriteria"),
    AFW_UTF8_LITERAL("Query criteria"),
    AFW_UTF8_LITERAL("This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_callback_parameter_7 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects_to_callback\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_to_callback_parameters[] = {
    &impl_retrieve_objects_to_callback_parameter_1,
    &impl_retrieve_objects_to_callback_parameter_2,
    &impl_retrieve_objects_to_callback_parameter_3,
    &impl_retrieve_objects_to_callback_parameter_4,
    &impl_retrieve_objects_to_callback_parameter_5,
    &impl_retrieve_objects_to_callback_parameter_6,
    &impl_retrieve_objects_to_callback_parameter_7,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_to_callback = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects_to_callback,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects_to_callback"),
    AFW_UTF8_LITERAL("retrieve_objects_to_callback"),
    AFW_UTF8_LITERAL("retrieve_objects_to_callback"),
    AFW_UTF8_LITERAL("retrieveObjectsToCallback"),
    AFW_UTF8_LITERAL("afwRetrieveObjectsToCallback"),
    AFW_UTF8_LITERAL("Retrieve adaptive objects"),
    AFW_UTF8_LITERAL("This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.\n\nEach object is passed to the callback as it's retrieved.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(objectCallback: (function (object: object, userData: any): boolean), userData: any, adaptorId: string, objectType: string, queryCriteria?: (object _AdaptiveQueryCriteria_), options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): null"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive objects */\nfunction retrieve_objects_to_callback (\n    objectCallback: (function (object: object, userData: any): boolean) /* Object Callback */,\n    userData: any                                                       /* User data */,\n    adaptorId: string                                                   /* Id of adaptor */,\n    objectType: string                                                  /* Id of object type */,\n    queryCriteria?: (object _AdaptiveQueryCriteria_)                    /* Query criteria */,\n    options?: (object _AdaptiveObjectOptions_)                          /* Object options */,\n    adaptorTypeSpecific?: object                                        /* Adaptor specific */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects_to_callback,
    NULL,
    4,
    7,
    &impl_retrieve_objects_to_callback_parameters[0],
    7,
    &impl_retrieve_objects_to_callback_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects_to_response ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects_to_response =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects_to_response");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects_to_response = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects_to_response,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects_to_response
        }
    },
    (void *)&afw_function_definition_retrieve_objects_to_response
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_response_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_response_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL("Id of adaptor"),
    AFW_UTF8_LITERAL("Id of adaptor containing objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_response_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL("Id of object type"),
    AFW_UTF8_LITERAL("Id of adaptive object type of objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_response_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveQueryCriteria_"),
    AFW_UTF8_LITERAL("queryCriteria"),
    AFW_UTF8_LITERAL("Query criteria"),
    AFW_UTF8_LITERAL("This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_response_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_response_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_to_response_parameters[] = {
    &impl_retrieve_objects_to_response_parameter_1,
    &impl_retrieve_objects_to_response_parameter_2,
    &impl_retrieve_objects_to_response_parameter_3,
    &impl_retrieve_objects_to_response_parameter_4,
    &impl_retrieve_objects_to_response_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_to_response = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects_to_response,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects_to_response"),
    AFW_UTF8_LITERAL("retrieve_objects_to_response"),
    AFW_UTF8_LITERAL("retrieve_objects_to_response"),
    AFW_UTF8_LITERAL("retrieveObjectsToResponse"),
    AFW_UTF8_LITERAL("afwRetrieveObjectsToResponse"),
    AFW_UTF8_LITERAL("Retrieve adaptive objects to a response"),
    AFW_UTF8_LITERAL("This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.\n\nThis function is only allowed when called during a request with content type \"application/x-afw\". An \"_AdaptiveResponse_\" object is written to the request's response as each object is retrieved. This \"_AdaptiveResponse_\" object has a \"result\" property containing the retrieved object and a \"intermediate\" property set to true.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, queryCriteria?: (object _AdaptiveQueryCriteria_), options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): null"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive objects to a response */\nfunction retrieve_objects_to_response (\n    adaptorId: string                                /* Id of adaptor */,\n    objectType: string                               /* Id of object type */,\n    queryCriteria?: (object _AdaptiveQueryCriteria_) /* Query criteria */,\n    options?: (object _AdaptiveObjectOptions_)       /* Object options */,\n    adaptorTypeSpecific?: object                     /* Adaptor specific */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects_to_response,
    NULL,
    2,
    5,
    &impl_retrieve_objects_to_response_parameters[0],
    5,
    &impl_retrieve_objects_to_response_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects_to_stream ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects_to_stream =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects_to_stream");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects_to_stream = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects_to_stream,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects_to_stream
        }
    },
    (void *)&afw_function_definition_retrieve_objects_to_stream
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_stream_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_stream_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("Stream number objects will be written to as they are retrieved."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_stream_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL("Id of adaptor"),
    AFW_UTF8_LITERAL("Id of adaptor containing objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_stream_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL("Id of object type"),
    AFW_UTF8_LITERAL("Id of adaptive object type of objects to retrieve."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_stream_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveQueryCriteria_"),
    AFW_UTF8_LITERAL("queryCriteria"),
    AFW_UTF8_LITERAL("Query criteria"),
    AFW_UTF8_LITERAL("This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_stream_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_to_stream_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_to_stream_parameters[] = {
    &impl_retrieve_objects_to_stream_parameter_1,
    &impl_retrieve_objects_to_stream_parameter_2,
    &impl_retrieve_objects_to_stream_parameter_3,
    &impl_retrieve_objects_to_stream_parameter_4,
    &impl_retrieve_objects_to_stream_parameter_5,
    &impl_retrieve_objects_to_stream_parameter_6,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_to_stream = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects_to_stream,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects_to_stream"),
    AFW_UTF8_LITERAL("retrieve_objects_to_stream"),
    AFW_UTF8_LITERAL("retrieve_objects_to_stream"),
    AFW_UTF8_LITERAL("retrieveObjectsToStream"),
    AFW_UTF8_LITERAL("afwRetrieveObjectsToStream"),
    AFW_UTF8_LITERAL("Retrieve adaptive objects to a stream"),
    AFW_UTF8_LITERAL("This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.\n\nEach object is written to the \"streamId\" stream as it's retrieved.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(streamNumber: integer, adaptorId: string, objectType: string, queryCriteria?: (object _AdaptiveQueryCriteria_), options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): null"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive objects to a stream */\nfunction retrieve_objects_to_stream (\n    streamNumber: integer                            /* Stream number */,\n    adaptorId: string                                /* Id of adaptor */,\n    objectType: string                               /* Id of object type */,\n    queryCriteria?: (object _AdaptiveQueryCriteria_) /* Query criteria */,\n    options?: (object _AdaptiveObjectOptions_)       /* Object options */,\n    adaptorTypeSpecific?: object                     /* Adaptor specific */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects_to_stream,
    NULL,
    3,
    6,
    &impl_retrieve_objects_to_stream_parameters[0],
    6,
    &impl_retrieve_objects_to_stream_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects_with_uri ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects_with_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects_with_uri");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects_with_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects_with_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects_with_uri
        }
    },
    (void *)&afw_function_definition_retrieve_objects_with_uri
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Objects retrieved or undefined"),
    AFW_UTF8_LITERAL("This is the list of objects retrieved."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_with_uri_parameters[] = {
    &impl_retrieve_objects_with_uri_parameter_1,
    &impl_retrieve_objects_with_uri_parameter_2,
    &impl_retrieve_objects_with_uri_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects_with_uri,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri"),
    AFW_UTF8_LITERAL("retrieveObjectsWithUri"),
    AFW_UTF8_LITERAL("afwRetrieveObjectsWithUri"),
    AFW_UTF8_LITERAL("Retrieve adaptive object with URI"),
    AFW_UTF8_LITERAL("Retrieve adaptive objects with a given URI.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(uri: anyURI, options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): list"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive object with URI */\nfunction retrieve_objects_with_uri (\n    uri: anyURI,\n    options?: (object _AdaptiveObjectOptions_) /* Object options */,\n    adaptorTypeSpecific?: object               /* Adaptor specific */\n): list; /* Objects retrieved or undefined */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects_with_uri,
    NULL,
    1,
    3,
    &impl_retrieve_objects_with_uri_parameters[0],
    3,
    &impl_retrieve_objects_with_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects_with_uri_to_callback ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects_with_uri_to_callback =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects_with_uri_to_callback");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects_with_uri_to_callback = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects_with_uri_to_callback,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects_with_uri_to_callback
        }
    },
    (void *)&afw_function_definition_retrieve_objects_with_uri_to_callback
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_callback_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_callback_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(object: object, userData: any): boolean"),
    AFW_UTF8_LITERAL("objectCallback"),
    AFW_UTF8_LITERAL("Object Callback"),
    AFW_UTF8_LITERAL("If this is specified, this function is called once for each object retrieved instead of adding the object to the return list. Parameter object will be an object retrieved or undefined if there are no more objects. This function should return true if it wants to abort the retrieve request."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_callback_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_any_direct,
    AFW_UTF8_LITERAL("any"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("userData"),
    AFW_UTF8_LITERAL("User data"),
    AFW_UTF8_LITERAL("This is the value passed to the objectCallback function in the userData parameter."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_callback_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_callback_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_callback_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_with_uri_to_callback_parameters[] = {
    &impl_retrieve_objects_with_uri_to_callback_parameter_1,
    &impl_retrieve_objects_with_uri_to_callback_parameter_2,
    &impl_retrieve_objects_with_uri_to_callback_parameter_3,
    &impl_retrieve_objects_with_uri_to_callback_parameter_4,
    &impl_retrieve_objects_with_uri_to_callback_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri_to_callback = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects_with_uri_to_callback,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_callback"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_callback"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_callback"),
    AFW_UTF8_LITERAL("retrieveObjectsWithUriToCallback"),
    AFW_UTF8_LITERAL("afwRetrieveObjectsWithUriToCallback"),
    AFW_UTF8_LITERAL("Retrieve adaptive object with URI"),
    AFW_UTF8_LITERAL("Retrieve adaptive objects with a given URI.\n\nEach object is passed to the callback as it's retrieved.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(objectCallback: (function (object: object, userData: any): boolean), userData: any, uri: anyURI, options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): null"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive object with URI */\nfunction retrieve_objects_with_uri_to_callback (\n    objectCallback: (function (object: object, userData: any): boolean) /* Object Callback */,\n    userData: any                                                       /* User data */,\n    uri: anyURI,\n    options?: (object _AdaptiveObjectOptions_)                          /* Object options */,\n    adaptorTypeSpecific?: object                                        /* Adaptor specific */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects_with_uri_to_callback,
    NULL,
    3,
    5,
    &impl_retrieve_objects_with_uri_to_callback_parameters[0],
    5,
    &impl_retrieve_objects_with_uri_to_callback_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects_with_uri_to_response ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects_with_uri_to_response =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects_with_uri_to_response");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects_with_uri_to_response = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects_with_uri_to_response,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects_with_uri_to_response
        }
    },
    (void *)&afw_function_definition_retrieve_objects_with_uri_to_response
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_response_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_response_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_response_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_response_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_with_uri_to_response_parameters[] = {
    &impl_retrieve_objects_with_uri_to_response_parameter_1,
    &impl_retrieve_objects_with_uri_to_response_parameter_2,
    &impl_retrieve_objects_with_uri_to_response_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri_to_response = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects_with_uri_to_response,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_response"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_response"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_response"),
    AFW_UTF8_LITERAL("retrieveObjectsWithUriToResponse"),
    AFW_UTF8_LITERAL("afwRetrieveObjectsWithUriToResponse"),
    AFW_UTF8_LITERAL("Retrieve adaptive object with URI to response"),
    AFW_UTF8_LITERAL("This function retrieves adaptive objects with a given URI.\n\nThis function is only allowed when called during a request with content type \"application/x-afw\". An \"_AdaptiveResponse_\" object is written to the request's response as each object is retrieved. This \"_AdaptiveResponse_\" object has a \"result\" property containing the retrieved object and a \"partial\" property set to true.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(uri: anyURI, options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): null"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive object with URI to response */\nfunction retrieve_objects_with_uri_to_response (\n    uri: anyURI,\n    options?: (object _AdaptiveObjectOptions_) /* Object options */,\n    adaptorTypeSpecific?: object               /* Adaptor specific */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects_with_uri_to_response,
    NULL,
    1,
    3,
    &impl_retrieve_objects_with_uri_to_response_parameters[0],
    3,
    &impl_retrieve_objects_with_uri_to_response_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- retrieve_objects_with_uri_to_stream ---------- */

static const afw_utf8_t
impl_object_path__retrieve_objects_with_uri_to_stream =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/retrieve_objects_with_uri_to_stream");

static const afw_runtime_object_indirect_t
impl_object__retrieve_objects_with_uri_to_stream = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_retrieve_objects_with_uri_to_stream,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__retrieve_objects_with_uri_to_stream
        }
    },
    (void *)&afw_function_definition_retrieve_objects_with_uri_to_stream
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_stream_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_stream_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("Stream number objects will be written to as they are retrieved."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_stream_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_stream_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL("Object options"),
    AFW_UTF8_LITERAL("Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_retrieve_objects_with_uri_to_stream_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL("Adaptor specific"),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_retrieve_objects_with_uri_to_stream_parameters[] = {
    &impl_retrieve_objects_with_uri_to_stream_parameter_1,
    &impl_retrieve_objects_with_uri_to_stream_parameter_2,
    &impl_retrieve_objects_with_uri_to_stream_parameter_3,
    &impl_retrieve_objects_with_uri_to_stream_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri_to_stream = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__retrieve_objects_with_uri_to_stream,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_stream"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_stream"),
    AFW_UTF8_LITERAL("retrieve_objects_with_uri_to_stream"),
    AFW_UTF8_LITERAL("retrieveObjectsWithUriToStream"),
    AFW_UTF8_LITERAL("afwRetrieveObjectsWithUriToStream"),
    AFW_UTF8_LITERAL("Retrieve adaptive object with URI to stream"),
    AFW_UTF8_LITERAL("This function retrieves adaptive objects with a given URI.\n\nEach object is written to the \"streamId\" stream as it's retrieved.\n\nThe optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.\n\nOptions, specific to the adaptorId, can be optionally supplied."),
    AFW_UTF8_LITERAL("(streamNumber: integer, uri: anyURI, options?: (object _AdaptiveObjectOptions_), adaptorTypeSpecific?: object): null"),
    AFW_UTF8_LITERAL("/* Retrieve adaptive object with URI to stream */\nfunction retrieve_objects_with_uri_to_stream (\n    streamNumber: integer                      /* Stream number */,\n    uri: anyURI,\n    options?: (object _AdaptiveObjectOptions_) /* Object options */,\n    adaptorTypeSpecific?: object               /* Adaptor specific */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_retrieve_objects_with_uri_to_stream,
    NULL,
    2,
    4,
    &impl_retrieve_objects_with_uri_to_stream_parameters[0],
    4,
    &impl_retrieve_objects_with_uri_to_stream_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- update_object ---------- */

static const afw_utf8_t
impl_object_path__update_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/update_object");

static const afw_runtime_object_indirect_t
impl_object__update_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_update_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__update_object
        }
    },
    (void *)&afw_function_definition_update_object
};

static const afw_value_function_parameter_t
impl_update_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor containing object to update."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptive object type of object to update."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of object to update."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object containing properties to replace in existing object. You can use object_modify instead to update properties of embedded objects and lists, as well as to modify individual values of the object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_update_object_parameters[] = {
    &impl_update_object_parameter_1,
    &impl_update_object_parameter_2,
    &impl_update_object_parameter_3,
    &impl_update_object_parameter_4,
    &impl_update_object_parameter_5,
    &impl_update_object_parameter_6,
    NULL
};

static const afw_utf8_t
impl_update_object_sideEffects[] = {
    AFW_UTF8_LITERAL("Object updated"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_update_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__update_object,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("update_object"),
    AFW_UTF8_LITERAL("update_object"),
    AFW_UTF8_LITERAL("update_object"),
    AFW_UTF8_LITERAL("updateObject"),
    AFW_UTF8_LITERAL("afwUpdateObject"),
    AFW_UTF8_LITERAL("Update adaptive object"),
    AFW_UTF8_LITERAL("Update an adaptive object."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, object: object, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Update adaptive object */\nfunction update_object (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    object: object,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_update_object,
    NULL,
    4,
    6,
    &impl_update_object_parameters[0],
    6,
    &impl_update_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_update_object_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- update_object_with_uri ---------- */

static const afw_utf8_t
impl_object_path__update_object_with_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/update_object_with_uri");

static const afw_runtime_object_indirect_t
impl_object__update_object_with_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_update_object_with_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__update_object_with_uri
        }
    },
    (void *)&afw_function_definition_update_object_with_uri
};

static const afw_value_function_parameter_t
impl_update_object_with_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveJournalEntry_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Resulting journal entry."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_with_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI of object to update. If a URI begins with a single slash ('/'), it is the local object path."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_with_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object containing properties to replace in existing object. You can use object_modify instead to update properties of embedded objects and lists, as well as to modify individual values of the object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_with_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_update_object_with_uri_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorTypeSpecific"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:\n\n_AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object\n\nWhere ${adaptorType} is the adaptor type id."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_update_object_with_uri_parameters[] = {
    &impl_update_object_with_uri_parameter_1,
    &impl_update_object_with_uri_parameter_2,
    &impl_update_object_with_uri_parameter_3,
    &impl_update_object_with_uri_parameter_4,
    NULL
};

static const afw_utf8_t
impl_update_object_with_uri_sideEffects[] = {
    AFW_UTF8_LITERAL("Object updated"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_update_object_with_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__update_object_with_uri,
    AFW_UTF8_LITERAL("adaptor"),
    AFW_UTF8_LITERAL("update_object_with_uri"),
    AFW_UTF8_LITERAL("update_object_with_uri"),
    AFW_UTF8_LITERAL("update_object_with_uri"),
    AFW_UTF8_LITERAL("updateObjectWithUri"),
    AFW_UTF8_LITERAL("afwUpdateObjectWithUri"),
    AFW_UTF8_LITERAL("Update adaptive object with URI"),
    AFW_UTF8_LITERAL("Update an adaptive object with a given URI."),
    AFW_UTF8_LITERAL("(uri: anyURI, object: object, journal?: object, adaptorTypeSpecific?: object): (object _AdaptiveJournalEntry_)"),
    AFW_UTF8_LITERAL("/* Update adaptive object with URI */\nfunction update_object_with_uri (\n    uri: anyURI,\n    object: object,\n    journal?: object,\n    adaptorTypeSpecific?: object\n): (object _AdaptiveJournalEntry_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_update_object_with_uri,
    NULL,
    2,
    4,
    &impl_update_object_with_uri_parameters[0],
    4,
    &impl_update_object_with_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_update_object_with_uri_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- extension_load ---------- */

static const afw_utf8_t
impl_object_path__extension_load =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/extension_load");

static const afw_runtime_object_indirect_t
impl_object__extension_load = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_extension_load,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__extension_load
        }
    },
    (void *)&afw_function_definition_extension_load
};

static const afw_value_function_parameter_t
impl_extension_load_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If false the extension was already loaded. If true, the extension was successfully loaded which might have caused side effects such as environment registry changes. An error is thrown if there is a problem."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_extension_load_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("extension_id"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the object id of a /afw/_AdaptiveManifest_/ object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_extension_load_parameters[] = {
    &impl_extension_load_parameter_1,
    NULL
};

static const afw_utf8_t
impl_extension_load_sideEffects[] = {
    AFW_UTF8_LITERAL("The loading of the extension may add environment registry entries as well as make other changes."),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_extension_load = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__extension_load,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("extension_load"),
    AFW_UTF8_LITERAL("extension_load"),
    AFW_UTF8_LITERAL("extension_load"),
    AFW_UTF8_LITERAL("extensionLoad"),
    AFW_UTF8_LITERAL("afwExtensionLoad"),
    AFW_UTF8_LITERAL("Load extension by id"),
    AFW_UTF8_LITERAL("Load an extension by its extension id if it is not already loaded. Loading an AFW package's manifest extension will register the manifest of all extensions in the package."),
    AFW_UTF8_LITERAL("(extension_id: string): boolean"),
    AFW_UTF8_LITERAL("/* Load extension by id */\nfunction extension_load (\n    extension_id: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_extension_load,
    NULL,
    1,
    1,
    &impl_extension_load_parameters[0],
    1,
    &impl_extension_load_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_extension_load_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- extension_load_by_module_path ---------- */

static const afw_utf8_t
impl_object_path__extension_load_by_module_path =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/extension_load_by_module_path");

static const afw_runtime_object_indirect_t
impl_object__extension_load_by_module_path = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_extension_load_by_module_path,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__extension_load_by_module_path
        }
    },
    (void *)&afw_function_definition_extension_load_by_module_path
};

static const afw_value_function_parameter_t
impl_extension_load_by_module_path_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The extension id of the extension loaded."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_extension_load_by_module_path_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("module_path"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the path to the dso containing the extension. If the extension is installed in the normal place, the library name without a file extension (.so) will suffice."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_extension_load_by_module_path_parameters[] = {
    &impl_extension_load_by_module_path_parameter_1,
    NULL
};

static const afw_utf8_t
impl_extension_load_by_module_path_sideEffects[] = {
    AFW_UTF8_LITERAL("The loading of the extension may add environment registry entries as well as make other changes."),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_extension_load_by_module_path = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__extension_load_by_module_path,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("extension_load_by_module_path"),
    AFW_UTF8_LITERAL("extension_load_by_module_path"),
    AFW_UTF8_LITERAL("extension_load_by_module_path"),
    AFW_UTF8_LITERAL("extensionLoadByModulePath"),
    AFW_UTF8_LITERAL("afwExtensionLoadByModulePath"),
    AFW_UTF8_LITERAL("Load extension by module path"),
    AFW_UTF8_LITERAL("Load an extension by its module path. Loading an AFW package's manifest extension will register the manifest of all extensions in the package."),
    AFW_UTF8_LITERAL("(module_path: string): string"),
    AFW_UTF8_LITERAL("/* Load extension by module path */\nfunction extension_load_by_module_path (\n    module_path: string\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_extension_load_by_module_path,
    NULL,
    1,
    1,
    &impl_extension_load_by_module_path_parameters[0],
    1,
    &impl_extension_load_by_module_path_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_extension_load_by_module_path_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- flag_get_active ---------- */

static const afw_utf8_t
impl_object_path__flag_get_active =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/flag_get_active");

static const afw_runtime_object_indirect_t
impl_object__flag_get_active = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_flag_get_active,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__flag_get_active
        }
    },
    (void *)&afw_function_definition_flag_get_active
};

static const afw_value_function_parameter_t
impl_flag_get_active_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of the flagId of flags that are set in the current execution context (xctx)."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_flag_get_active_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_get_active = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__flag_get_active,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("flag_get_active"),
    AFW_UTF8_LITERAL("flag_get_active"),
    AFW_UTF8_LITERAL("flag_get_active"),
    AFW_UTF8_LITERAL("flagGetActive"),
    AFW_UTF8_LITERAL("afwFlagGetActive"),
    AFW_UTF8_LITERAL("Get a list of active flags"),
    AFW_UTF8_LITERAL("Get a list of of the flagId of flags that are set in the current execution context (xctx)."),
    AFW_UTF8_LITERAL("(): (list string)"),
    AFW_UTF8_LITERAL("/* Get a list of active flags */\nfunction flag_get_active (\n\n): (list string);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_flag_get_active,
    NULL,
    0,
    0,
    &impl_flag_get_active_parameters[0],
    0,
    &impl_flag_get_active_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- flag_get_active_defaults ---------- */

static const afw_utf8_t
impl_object_path__flag_get_active_defaults =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/flag_get_active_defaults");

static const afw_runtime_object_indirect_t
impl_object__flag_get_active_defaults = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_flag_get_active_defaults,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__flag_get_active_defaults
        }
    },
    (void *)&afw_function_definition_flag_get_active_defaults
};

static const afw_value_function_parameter_t
impl_flag_get_active_defaults_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of the flagId of flags that are set by default when a new execution context (xctx) is created."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_flag_get_active_defaults_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_get_active_defaults = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__flag_get_active_defaults,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("flag_get_active_defaults"),
    AFW_UTF8_LITERAL("flag_get_active_defaults"),
    AFW_UTF8_LITERAL("flag_get_active_defaults"),
    AFW_UTF8_LITERAL("flagGetActiveDefaults"),
    AFW_UTF8_LITERAL("afwFlagGetActiveDefaults"),
    AFW_UTF8_LITERAL("Get a list of default active flags"),
    AFW_UTF8_LITERAL("Get a list of the flagId of flags that are set by default when a new execution context (xctx) is created."),
    AFW_UTF8_LITERAL("(): (list string)"),
    AFW_UTF8_LITERAL("/* Get a list of default active flags */\nfunction flag_get_active_defaults (\n\n): (list string);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_flag_get_active_defaults,
    NULL,
    0,
    0,
    &impl_flag_get_active_defaults_parameters[0],
    0,
    &impl_flag_get_active_defaults_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- flag_get_defaults ---------- */

static const afw_utf8_t
impl_object_path__flag_get_defaults =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/flag_get_defaults");

static const afw_runtime_object_indirect_t
impl_object__flag_get_defaults = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_flag_get_defaults,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__flag_get_defaults
        }
    },
    (void *)&afw_function_definition_flag_get_defaults
};

static const afw_value_function_parameter_t
impl_flag_get_defaults_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of the flagId of flags used to determine the default active flags."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_flag_get_defaults_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_get_defaults = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__flag_get_defaults,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("flag_get_defaults"),
    AFW_UTF8_LITERAL("flag_get_defaults"),
    AFW_UTF8_LITERAL("flag_get_defaults"),
    AFW_UTF8_LITERAL("flagGetDefaults"),
    AFW_UTF8_LITERAL("afwFlagGetDefaults"),
    AFW_UTF8_LITERAL("Get the list of flags used to determine the default active flags"),
    AFW_UTF8_LITERAL("Get the list of the flagId of flags that are used to determine the default active flags when an execution context (xctx) is created. This list can contain the flagId of flags that have not yet been registered. Each of these flags and the flags they include are set as the active default flags."),
    AFW_UTF8_LITERAL("(): (list string)"),
    AFW_UTF8_LITERAL("/* Get the list of flags used to determine the default active flags */\nfunction flag_get_defaults (\n\n): (list string);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_flag_get_defaults,
    NULL,
    0,
    0,
    &impl_flag_get_defaults_parameters[0],
    0,
    &impl_flag_get_defaults_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- flag_modify_defaults ---------- */

static const afw_utf8_t
impl_object_path__flag_modify_defaults =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/flag_modify_defaults");

static const afw_runtime_object_indirect_t
impl_object__flag_modify_defaults = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_flag_modify_defaults,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__flag_modify_defaults
        }
    },
    (void *)&afw_function_definition_flag_modify_defaults
};

static const afw_value_function_parameter_t
impl_flag_modify_defaults_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_flag_modify_defaults_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("flagId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The flagId of flags to be added or removed."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_flag_modify_defaults_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Specify true to add and false to remove flags. If not specified, flags are added."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_flag_modify_defaults_parameters[] = {
    &impl_flag_modify_defaults_parameter_1,
    &impl_flag_modify_defaults_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_modify_defaults = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__flag_modify_defaults,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("flag_modify_defaults"),
    AFW_UTF8_LITERAL("flag_modify_defaults"),
    AFW_UTF8_LITERAL("flag_modify_defaults"),
    AFW_UTF8_LITERAL("flagModifyDefaults"),
    AFW_UTF8_LITERAL("afwFlagModifyDefaults"),
    AFW_UTF8_LITERAL("Add or remove flags used to determine the default active flags"),
    AFW_UTF8_LITERAL("Add or remove flags from the list of the flagId of flags that are used to determine the default active flags when an execution context (xctx) is created. This list can contain the flagId of flags that have not yet been registered. These flags and the flags they include are set as the active default flags.\n\nThis change only lasts for the life of the current adaptive environment (e.g. until the adaptive server or afw command ends). If you want the change to persist, change the defaultFlags property in the application config."),
    AFW_UTF8_LITERAL("(flagId: (list string), add?: boolean): null"),
    AFW_UTF8_LITERAL("/* Add or remove flags used to determine the default active flags */\nfunction flag_modify_defaults (\n    flagId: (list string),\n    add?: boolean\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_flag_modify_defaults,
    NULL,
    1,
    2,
    &impl_flag_modify_defaults_parameters[0],
    2,
    &impl_flag_modify_defaults_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- flag_replace_defaults ---------- */

static const afw_utf8_t
impl_object_path__flag_replace_defaults =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/flag_replace_defaults");

static const afw_runtime_object_indirect_t
impl_object__flag_replace_defaults = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_flag_replace_defaults,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__flag_replace_defaults
        }
    },
    (void *)&afw_function_definition_flag_replace_defaults
};

static const afw_value_function_parameter_t
impl_flag_replace_defaults_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_flag_replace_defaults_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("flagId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The list of the flagId of flags used to determine the default active flags."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_flag_replace_defaults_parameters[] = {
    &impl_flag_replace_defaults_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_replace_defaults = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__flag_replace_defaults,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("flag_replace_defaults"),
    AFW_UTF8_LITERAL("flag_replace_defaults"),
    AFW_UTF8_LITERAL("flag_replace_defaults"),
    AFW_UTF8_LITERAL("flagReplaceDefaults"),
    AFW_UTF8_LITERAL("afwFlagReplaceDefaults"),
    AFW_UTF8_LITERAL("Replace the list of flags used to determine the default active flags"),
    AFW_UTF8_LITERAL("Completely replace the list of the flagId of flags that are used to determine the default active flags when an execution context (xctx) is created. This list can contain the flagId of flags that have not yet been registered. These flags and the flags they include are set as the active default flags.\n\nThis change only lasts for the life of the current adaptive environment (e.g. until the adaptive server or afw command ends). If you want the change to persist, change the defaultFlags property in the application config."),
    AFW_UTF8_LITERAL("(flagId: (list string)): null"),
    AFW_UTF8_LITERAL("/* Replace the list of flags used to determine the default active flags */\nfunction flag_replace_defaults (\n    flagId: (list string)\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_flag_replace_defaults,
    NULL,
    1,
    1,
    &impl_flag_replace_defaults_parameters[0],
    1,
    &impl_flag_replace_defaults_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- flag_set ---------- */

static const afw_utf8_t
impl_object_path__flag_set =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/flag_set");

static const afw_runtime_object_indirect_t
impl_object__flag_set = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_flag_set,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__flag_set
        }
    },
    (void *)&afw_function_definition_flag_set
};

static const afw_value_function_parameter_t
impl_flag_set_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_flag_set_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("flagId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("List of flagId of flags to set or unset."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_flag_set_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("setTo"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Specify true to set and false to unset. If not specified, flags are set."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_flag_set_parameters[] = {
    &impl_flag_set_parameter_1,
    &impl_flag_set_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_set = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__flag_set,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("flag_set"),
    AFW_UTF8_LITERAL("flag_set"),
    AFW_UTF8_LITERAL("flag_set"),
    AFW_UTF8_LITERAL("flagSet"),
    AFW_UTF8_LITERAL("afwFlagSet"),
    AFW_UTF8_LITERAL("Set or unset active xctx flags"),
    AFW_UTF8_LITERAL("Set or unset one or more active xctx (request) flags."),
    AFW_UTF8_LITERAL("(flagId: (list string), setTo?: boolean): null"),
    AFW_UTF8_LITERAL("/* Set or unset active xctx flags */\nfunction flag_set (\n    flagId: (list string),\n    setTo?: boolean\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_flag_set,
    NULL,
    1,
    2,
    &impl_flag_set_parameters[0],
    2,
    &impl_flag_set_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- registry_key_check ---------- */

static const afw_utf8_t
impl_object_path__registry_key_check =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/registry_key_check");

static const afw_runtime_object_indirect_t
impl_object__registry_key_check = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_registry_key_check,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__registry_key_check
        }
    },
    (void *)&afw_function_definition_registry_key_check
};

static const afw_value_function_parameter_t
impl_registry_key_check_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If false the extension was already loaded. If true, the extension was successfully loaded which might have caused side effects such as environment registry changes. An error is thrown if there is a problem."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_registry_key_check_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("registryType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the registry type, which is the object id of a /afw/_AdaptiveEnvironmentRegistryType_/ object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_registry_key_check_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("key"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a key to check for existence in the specified registryType."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_registry_key_check_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("loadExtension"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Specifying true for this optional parameter will cause the associated extension to be loaded if needed."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_registry_key_check_parameters[] = {
    &impl_registry_key_check_parameter_1,
    &impl_registry_key_check_parameter_2,
    &impl_registry_key_check_parameter_3,
    NULL
};

static const afw_utf8_t
impl_registry_key_check_sideEffects[] = {
    AFW_UTF8_LITERAL("The loading of the extension may add environment registry entries as well as make other changes."),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_registry_key_check = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__registry_key_check,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("registry_key_check"),
    AFW_UTF8_LITERAL("registry_key_check"),
    AFW_UTF8_LITERAL("registry_key_check"),
    AFW_UTF8_LITERAL("registryKeyCheck"),
    AFW_UTF8_LITERAL("afwRegistryKeyCheck"),
    AFW_UTF8_LITERAL("Check to see if a registry key exists"),
    AFW_UTF8_LITERAL("This will check to see if a registry key exists for a specified registry type and optionally load it's associated extension if needed."),
    AFW_UTF8_LITERAL("(registryType: string, key: string, loadExtension?: boolean): boolean"),
    AFW_UTF8_LITERAL("/* Check to see if a registry key exists */\nfunction registry_key_check (\n    registryType: string,\n    key: string,\n    loadExtension?: boolean\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_registry_key_check,
    NULL,
    2,
    3,
    &impl_registry_key_check_parameters[0],
    3,
    &impl_registry_key_check_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_registry_key_check_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- service_get ---------- */

static const afw_utf8_t
impl_object_path__service_get =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/service_get");

static const afw_runtime_object_indirect_t
impl_object__service_get = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_service_get,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__service_get
        }
    },
    (void *)&afw_function_definition_service_get
};

static const afw_value_function_parameter_t
impl_service_get_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveService_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("_AdaptiveService_ object for the service which will contain the current status of the service. If there is an error, the status property value will be \"error\" and \"statusMessage\" contain an error message."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_service_get_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("serviceId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The serviceId of the service."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_service_get_parameters[] = {
    &impl_service_get_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_get = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__service_get,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("service_get"),
    AFW_UTF8_LITERAL("service_get"),
    AFW_UTF8_LITERAL("service_get"),
    AFW_UTF8_LITERAL("serviceGet"),
    AFW_UTF8_LITERAL("afwServiceGet"),
    AFW_UTF8_LITERAL("Get service object"),
    AFW_UTF8_LITERAL("Get a service object."),
    AFW_UTF8_LITERAL("(serviceId: string): (object _AdaptiveService_)"),
    AFW_UTF8_LITERAL("/* Get service object */\nfunction service_get (\n    serviceId: string\n): (object _AdaptiveService_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_service_get,
    NULL,
    1,
    1,
    &impl_service_get_parameters[0],
    1,
    &impl_service_get_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- service_restart ---------- */

static const afw_utf8_t
impl_object_path__service_restart =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/service_restart");

static const afw_runtime_object_indirect_t
impl_object__service_restart = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_service_restart,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__service_restart
        }
    },
    (void *)&afw_function_definition_service_restart
};

static const afw_value_function_parameter_t
impl_service_restart_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveService_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("_AdaptiveService_ object for the service which will contain the current status of the service. If there is an error, the status property value will be \"error\" and \"statusMessage\" contain an error message."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_service_restart_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("serviceId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The serviceId of the service to restart."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_service_restart_parameters[] = {
    &impl_service_restart_parameter_1,
    NULL
};

static const afw_utf8_t
impl_service_restart_sideEffects[] = {
    AFW_UTF8_LITERAL("Service restarted"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_restart = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__service_restart,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("service_restart"),
    AFW_UTF8_LITERAL("service_restart"),
    AFW_UTF8_LITERAL("service_restart"),
    AFW_UTF8_LITERAL("serviceRestart"),
    AFW_UTF8_LITERAL("afwServiceRestart"),
    AFW_UTF8_LITERAL("Restart service"),
    AFW_UTF8_LITERAL("Restart a service."),
    AFW_UTF8_LITERAL("(serviceId: string): (object _AdaptiveService_)"),
    AFW_UTF8_LITERAL("/* Restart service */\nfunction service_restart (\n    serviceId: string\n): (object _AdaptiveService_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_service_restart,
    NULL,
    1,
    1,
    &impl_service_restart_parameters[0],
    1,
    &impl_service_restart_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_service_restart_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- service_start ---------- */

static const afw_utf8_t
impl_object_path__service_start =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/service_start");

static const afw_runtime_object_indirect_t
impl_object__service_start = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_service_start,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__service_start
        }
    },
    (void *)&afw_function_definition_service_start
};

static const afw_value_function_parameter_t
impl_service_start_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveService_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("_AdaptiveService_ object for the service which will contain the current status of the service. If there is an error, the status property value will be \"error\" and \"statusMessage\" contain an error message."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_service_start_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("serviceId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The serviceId of the service to start"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_service_start_parameters[] = {
    &impl_service_start_parameter_1,
    NULL
};

static const afw_utf8_t
impl_service_start_sideEffects[] = {
    AFW_UTF8_LITERAL("Service started"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_start = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__service_start,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("service_start"),
    AFW_UTF8_LITERAL("service_start"),
    AFW_UTF8_LITERAL("service_start"),
    AFW_UTF8_LITERAL("serviceStart"),
    AFW_UTF8_LITERAL("afwServiceStart"),
    AFW_UTF8_LITERAL("Start service"),
    AFW_UTF8_LITERAL("Start a service."),
    AFW_UTF8_LITERAL("(serviceId: string): (object _AdaptiveService_)"),
    AFW_UTF8_LITERAL("/* Start service */\nfunction service_start (\n    serviceId: string\n): (object _AdaptiveService_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_service_start,
    NULL,
    1,
    1,
    &impl_service_start_parameters[0],
    1,
    &impl_service_start_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_service_start_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- service_stop ---------- */

static const afw_utf8_t
impl_object_path__service_stop =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/service_stop");

static const afw_runtime_object_indirect_t
impl_object__service_stop = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_service_stop,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__service_stop
        }
    },
    (void *)&afw_function_definition_service_stop
};

static const afw_value_function_parameter_t
impl_service_stop_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveService_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("_AdaptiveService_ object for the service which will contain the current status of the service. If there is an error, the status property value will be \"error\" and \"statusMessage\" contain an error message."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_service_stop_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("serviceId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The serviceId of the service to stop."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_service_stop_parameters[] = {
    &impl_service_stop_parameter_1,
    NULL
};

static const afw_utf8_t
impl_service_stop_sideEffects[] = {
    AFW_UTF8_LITERAL("Service stopped"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_stop = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__service_stop,
    AFW_UTF8_LITERAL("administrative"),
    AFW_UTF8_LITERAL("service_stop"),
    AFW_UTF8_LITERAL("service_stop"),
    AFW_UTF8_LITERAL("service_stop"),
    AFW_UTF8_LITERAL("serviceStop"),
    AFW_UTF8_LITERAL("afwServiceStop"),
    AFW_UTF8_LITERAL("Stop service"),
    AFW_UTF8_LITERAL("Stop a service."),
    AFW_UTF8_LITERAL("(serviceId: string): (object _AdaptiveService_)"),
    AFW_UTF8_LITERAL("/* Stop service */\nfunction service_stop (\n    serviceId: string\n): (object _AdaptiveService_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_service_stop,
    NULL,
    1,
    1,
    &impl_service_stop_parameters[0],
    1,
    &impl_service_stop_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_service_stop_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- anyURI ---------- */

static const afw_utf8_t
impl_object_path__anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/anyURI");

static const afw_runtime_object_indirect_t
impl_object__anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__anyURI
        }
    },
    (void *)&afw_function_definition_anyURI
};

static const afw_value_function_parameter_t
impl_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_anyURI_parameters[] = {
    &impl_anyURI_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_anyURI_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("afwAnyURI"),
    AFW_UTF8_LITERAL("Convert to data type anyURI"),
    AFW_UTF8_LITERAL("Converts value to data type anyURI returning anyURI result."),
    AFW_UTF8_LITERAL("(value: any): anyURI"),
    AFW_UTF8_LITERAL("/* Convert to data type anyURI */\nfunction anyURI (\n    value: any\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_anyURI_parameters[0],
    1,
    &impl_anyURI_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_anyURI_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_anyURI");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_anyURI
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_anyURI
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_anyURI_parameters[] = {
    &impl_at_least_one_member_of_anyURI_parameter_1,
    &impl_at_least_one_member_of_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("at_least_one_member_of<anyURI>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_anyURI"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfAnyURI"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfAnyURI"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in anyURI list1 is in anyURI list2."),
    AFW_UTF8_LITERAL("(list1: (list anyURI), list2: (list anyURI)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<anyURI> (\n    list1: (list anyURI),\n    list2: (list anyURI)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_anyURI_parameters[0],
    2,
    &impl_at_least_one_member_of_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__bag_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_anyURI");

static const afw_runtime_object_indirect_t
impl_object__bag_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_anyURI
        }
    },
    (void *)&afw_function_definition_bag_anyURI
};

static const afw_value_function_parameter_t
impl_bag_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_anyURI_parameters[] = {
    &impl_bag_anyURI_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("bag<anyURI>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_anyURI"),
    AFW_UTF8_LITERAL("bagAnyURI"),
    AFW_UTF8_LITERAL("afwBagAnyURI"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of anyURI values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list anyURI))): (list anyURI)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<anyURI> (\n    ...values: (list of (list anyURI))\n): (list anyURI);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_anyURI_parameters[0],
    1,
    &impl_bag_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_anyURI");

static const afw_runtime_object_indirect_t
impl_object__bag_size_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_anyURI
        }
    },
    (void *)&afw_function_definition_bag_size_anyURI
};

static const afw_value_function_parameter_t
impl_bag_size_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_anyURI_parameters[] = {
    &impl_bag_size_anyURI_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("bag_size<anyURI>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_anyURI"),
    AFW_UTF8_LITERAL("bagSizeAnyURI"),
    AFW_UTF8_LITERAL("afwBagSizeAnyURI"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list anyURI)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<anyURI> (\n    value: (list anyURI)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_anyURI_parameters[0],
    1,
    &impl_bag_size_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ends_with<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__ends_with_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ends_with_anyURI");

static const afw_runtime_object_indirect_t
impl_object__ends_with_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ends_with_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ends_with_anyURI
        }
    },
    (void *)&afw_function_definition_ends_with_anyURI
};

static const afw_value_function_parameter_t
impl_ends_with_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ends_with_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ends_with_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ends_with_anyURI_parameters[] = {
    &impl_ends_with_anyURI_parameter_1,
    &impl_ends_with_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ends_with_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ends_with_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("ends_with<anyURI>"),
    AFW_UTF8_LITERAL("ends_with"),
    AFW_UTF8_LITERAL("ends_with_anyURI"),
    AFW_UTF8_LITERAL("endsWithAnyURI"),
    AFW_UTF8_LITERAL("afwEndsWithAnyURI"),
    AFW_UTF8_LITERAL("Checks whether value ends with a string"),
    AFW_UTF8_LITERAL("Checks whether anyURI value ends with a anyURI and return the boolean result."),
    AFW_UTF8_LITERAL("(value: anyURI, subString: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value ends with a string */\nfunction ends_with<anyURI> (\n    value: anyURI,\n    subString: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_ends_with,
    NULL,
    2,
    2,
    &impl_ends_with_anyURI_parameters[0],
    2,
    &impl_ends_with_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_ends_with,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__eq_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_anyURI");

static const afw_runtime_object_indirect_t
impl_object__eq_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_anyURI
        }
    },
    (void *)&afw_function_definition_eq_anyURI
};

static const afw_value_function_parameter_t
impl_eq_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_anyURI_parameters[] = {
    &impl_eq_anyURI_parameter_1,
    &impl_eq_anyURI_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_anyURI_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("eq<anyURI>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_anyURI"),
    AFW_UTF8_LITERAL("eqAnyURI"),
    AFW_UTF8_LITERAL("afwEqAnyURI"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if anyURI arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<anyURI> (\n    arg1: anyURI,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_anyURI_parameters[0],
    2,
    &impl_eq_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    &impl_eq_anyURI_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__eqx_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_anyURI");

static const afw_runtime_object_indirect_t
impl_object__eqx_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_anyURI
        }
    },
    (void *)&afw_function_definition_eqx_anyURI
};

static const afw_value_function_parameter_t
impl_eqx_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_anyURI_parameters[] = {
    &impl_eqx_anyURI_parameter_1,
    &impl_eqx_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("eqx<anyURI>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_anyURI"),
    AFW_UTF8_LITERAL("eqxAnyURI"),
    AFW_UTF8_LITERAL("afwEqxAnyURI"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for anyURI arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<anyURI> (\n    arg1: anyURI,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_anyURI_parameters[0],
    2,
    &impl_eqx_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__ge_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_anyURI");

static const afw_runtime_object_indirect_t
impl_object__ge_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_anyURI
        }
    },
    (void *)&afw_function_definition_ge_anyURI
};

static const afw_value_function_parameter_t
impl_ge_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_anyURI_parameters[] = {
    &impl_ge_anyURI_parameter_1,
    &impl_ge_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("ge<anyURI>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_anyURI"),
    AFW_UTF8_LITERAL("geAnyURI"),
    AFW_UTF8_LITERAL("afwGeAnyURI"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for anyURI arg1 is greater than or equal to anyURI arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: anyURI): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<anyURI> (\n    arg1: anyURI,\n    arg2: anyURI\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_anyURI_parameters[0],
    2,
    &impl_ge_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__gt_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_anyURI");

static const afw_runtime_object_indirect_t
impl_object__gt_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_anyURI
        }
    },
    (void *)&afw_function_definition_gt_anyURI
};

static const afw_value_function_parameter_t
impl_gt_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_anyURI_parameters[] = {
    &impl_gt_anyURI_parameter_1,
    &impl_gt_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("gt<anyURI>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_anyURI"),
    AFW_UTF8_LITERAL("gtAnyURI"),
    AFW_UTF8_LITERAL("afwGtAnyURI"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for anyURI arg1 is greater than anyURI arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: anyURI): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<anyURI> (\n    arg1: anyURI,\n    arg2: anyURI\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_anyURI_parameters[0],
    2,
    &impl_gt_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- includes<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__includes_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/includes_anyURI");

static const afw_runtime_object_indirect_t
impl_object__includes_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_includes_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__includes_anyURI
        }
    },
    (void *)&afw_function_definition_includes_anyURI
};

static const afw_value_function_parameter_t
impl_includes_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Indicates if the substring is found"),
    AFW_UTF8_LITERAL("Indicates if the substring is contained in the search string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("searchString"),
    AFW_UTF8_LITERAL("The anyURI to search"),
    AFW_UTF8_LITERAL("The anyURI to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL("Substring to find"),
    AFW_UTF8_LITERAL("Substring to find."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_anyURI_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("position"),
    AFW_UTF8_LITERAL("Zero-based position in the search string to start search"),
    AFW_UTF8_LITERAL("Zero-based position in the search string to start search."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_includes_anyURI_parameters[] = {
    &impl_includes_anyURI_parameter_1,
    &impl_includes_anyURI_parameter_2,
    &impl_includes_anyURI_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__includes_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("includes<anyURI>"),
    AFW_UTF8_LITERAL("includes"),
    AFW_UTF8_LITERAL("includes_anyURI"),
    AFW_UTF8_LITERAL("includesAnyURI"),
    AFW_UTF8_LITERAL("afwIncludesAnyURI"),
    AFW_UTF8_LITERAL("Checks whether the anyURI value includes a string"),
    AFW_UTF8_LITERAL("Checks whether the anyURI value includes a string and return the boolean result."),
    AFW_UTF8_LITERAL("(searchString: anyURI, subString: string, position?: integer): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether the anyURI value includes a string */\nfunction includes<anyURI> (\n    searchString: anyURI /* The anyURI to search */,\n    subString: string    /* Substring to find */,\n    position?: integer   /* Zero-based position in the search string to start search */\n): boolean; /* Indicates if the substring is found */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_includes,
    NULL,
    2,
    3,
    &impl_includes_anyURI_parameters[0],
    3,
    &impl_includes_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_includes,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- index_of<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__index_of_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/index_of_anyURI");

static const afw_runtime_object_indirect_t
impl_object__index_of_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_index_of_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__index_of_anyURI
        }
    },
    (void *)&afw_function_definition_index_of_anyURI
};

static const afw_value_function_parameter_t
impl_index_of_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The anyURI value to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Substring to search for."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_anyURI_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional start index for search if different than start of string."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_index_of_anyURI_parameters[] = {
    &impl_index_of_anyURI_parameter_1,
    &impl_index_of_anyURI_parameter_2,
    &impl_index_of_anyURI_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_of_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__index_of_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("index_of<anyURI>"),
    AFW_UTF8_LITERAL("index_of"),
    AFW_UTF8_LITERAL("index_of_anyURI"),
    AFW_UTF8_LITERAL("indexOfAnyURI"),
    AFW_UTF8_LITERAL("afwIndexOfAnyURI"),
    AFW_UTF8_LITERAL("Returns index of first occurrence"),
    AFW_UTF8_LITERAL("Returns the zero-based index into anyURI value of subString. If subString is not found, -1 is returned."),
    AFW_UTF8_LITERAL("(value: anyURI, subString: string, startIndex?: integer): integer"),
    AFW_UTF8_LITERAL("/* Returns index of first occurrence */\nfunction index_of<anyURI> (\n    value: anyURI,\n    subString: string,\n    startIndex?: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_index_of,
    NULL,
    2,
    3,
    &impl_index_of_anyURI_parameters[0],
    3,
    &impl_index_of_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_index_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__intersection_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_anyURI");

static const afw_runtime_object_indirect_t
impl_object__intersection_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_anyURI
        }
    },
    (void *)&afw_function_definition_intersection_anyURI
};

static const afw_value_function_parameter_t
impl_intersection_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_anyURI_parameters[] = {
    &impl_intersection_anyURI_parameter_1,
    &impl_intersection_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("intersection<anyURI>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_anyURI"),
    AFW_UTF8_LITERAL("intersectionAnyURI"),
    AFW_UTF8_LITERAL("afwIntersectionAnyURI"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of anyURI with the values that are common to both list of anyURI list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list anyURI), list2: (list anyURI)): (list anyURI)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<anyURI> (\n    list1: (list anyURI),\n    list2: (list anyURI)\n): (list anyURI);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_anyURI_parameters[0],
    2,
    &impl_intersection_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__is_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_anyURI");

static const afw_runtime_object_indirect_t
impl_object__is_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_anyURI
        }
    },
    (void *)&afw_function_definition_is_anyURI
};

static const afw_value_function_parameter_t
impl_is_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_anyURI_parameters[] = {
    &impl_is_anyURI_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("is<anyURI>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_anyURI"),
    AFW_UTF8_LITERAL("isAnyURI"),
    AFW_UTF8_LITERAL("afwIsAnyURI"),
    AFW_UTF8_LITERAL("Checks whether value is dataType anyURI"),
    AFW_UTF8_LITERAL("Checks whether value is dataType anyURI and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType anyURI */\nfunction is<anyURI> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_anyURI_parameters[0],
    1,
    &impl_is_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__is_in_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_anyURI");

static const afw_runtime_object_indirect_t
impl_object__is_in_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_anyURI
        }
    },
    (void *)&afw_function_definition_is_in_anyURI
};

static const afw_value_function_parameter_t
impl_is_in_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_anyURI_parameters[] = {
    &impl_is_in_anyURI_parameter_1,
    &impl_is_in_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("is_in<anyURI>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_anyURI"),
    AFW_UTF8_LITERAL("isInAnyURI"),
    AFW_UTF8_LITERAL("afwIsInAnyURI"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether anyURI value is in list of anyURI list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: anyURI, list: (list anyURI)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<anyURI> (\n    value: anyURI,\n    list: (list anyURI)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_anyURI_parameters[0],
    2,
    &impl_is_in_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- last_index_of<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__last_index_of_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/last_index_of_anyURI");

static const afw_runtime_object_indirect_t
impl_object__last_index_of_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_last_index_of_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__last_index_of_anyURI
        }
    },
    (void *)&afw_function_definition_last_index_of_anyURI
};

static const afw_value_function_parameter_t
impl_last_index_of_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The anyURI value to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Substring to search for."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_anyURI_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional start index for search if different than start of string."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_last_index_of_anyURI_parameters[] = {
    &impl_last_index_of_anyURI_parameter_1,
    &impl_last_index_of_anyURI_parameter_2,
    &impl_last_index_of_anyURI_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_last_index_of_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__last_index_of_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("last_index_of<anyURI>"),
    AFW_UTF8_LITERAL("last_index_of"),
    AFW_UTF8_LITERAL("last_index_of_anyURI"),
    AFW_UTF8_LITERAL("lastIndexOfAnyURI"),
    AFW_UTF8_LITERAL("afwLastIndexOfAnyURI"),
    AFW_UTF8_LITERAL("Returns index of last occurrence"),
    AFW_UTF8_LITERAL("Returns the zero-based index into anyURI value of the last occurrence of a subString. If subString is not found, -1 is returned."),
    AFW_UTF8_LITERAL("(value: anyURI, subString: string, startIndex?: integer): integer"),
    AFW_UTF8_LITERAL("/* Returns index of last occurrence */\nfunction last_index_of<anyURI> (\n    value: anyURI,\n    subString: string,\n    startIndex?: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_last_index_of,
    NULL,
    2,
    3,
    &impl_last_index_of_anyURI_parameters[0],
    3,
    &impl_last_index_of_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_last_index_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__le_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_anyURI");

static const afw_runtime_object_indirect_t
impl_object__le_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_anyURI
        }
    },
    (void *)&afw_function_definition_le_anyURI
};

static const afw_value_function_parameter_t
impl_le_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_anyURI_parameters[] = {
    &impl_le_anyURI_parameter_1,
    &impl_le_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("le<anyURI>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_anyURI"),
    AFW_UTF8_LITERAL("leAnyURI"),
    AFW_UTF8_LITERAL("afwLeAnyURI"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for anyURI arg1 is less than or equal to anyURI arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<anyURI> (\n    arg1: anyURI,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_anyURI_parameters[0],
    2,
    &impl_le_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- length<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__length_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/length_anyURI");

static const afw_runtime_object_indirect_t
impl_object__length_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_length_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__length_anyURI
        }
    },
    (void *)&afw_function_definition_length_anyURI
};

static const afw_value_function_parameter_t
impl_length_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_length_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Returns the number of entries in a list or code points in others."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_length_anyURI_parameters[] = {
    &impl_length_anyURI_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__length_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("length<anyURI>"),
    AFW_UTF8_LITERAL("length"),
    AFW_UTF8_LITERAL("length_anyURI"),
    AFW_UTF8_LITERAL("lengthAnyURI"),
    AFW_UTF8_LITERAL("afwLengthAnyURI"),
    AFW_UTF8_LITERAL("Returns number of codepoints or entries in value"),
    AFW_UTF8_LITERAL("This is a polymorphic function where anyURI can be any of the supported data types. Return the integer number of entries in datatype list or codepoints in others."),
    AFW_UTF8_LITERAL("(value: anyURI): integer"),
    AFW_UTF8_LITERAL("/* Returns number of codepoints or entries in value */\nfunction length<anyURI> (\n    value: anyURI\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_length,
    NULL,
    1,
    1,
    &impl_length_anyURI_parameters[0],
    1,
    &impl_length_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_length,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__lt_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_anyURI");

static const afw_runtime_object_indirect_t
impl_object__lt_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_anyURI
        }
    },
    (void *)&afw_function_definition_lt_anyURI
};

static const afw_value_function_parameter_t
impl_lt_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_anyURI_parameters[] = {
    &impl_lt_anyURI_parameter_1,
    &impl_lt_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("lt<anyURI>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_anyURI"),
    AFW_UTF8_LITERAL("ltAnyURI"),
    AFW_UTF8_LITERAL("afwLtAnyURI"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for anyURI arg1 is less that anyURI arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: anyURI): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<anyURI> (\n    arg1: anyURI,\n    arg2: anyURI\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_anyURI_parameters[0],
    2,
    &impl_lt_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__ne_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_anyURI");

static const afw_runtime_object_indirect_t
impl_object__ne_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_anyURI
        }
    },
    (void *)&afw_function_definition_ne_anyURI
};

static const afw_value_function_parameter_t
impl_ne_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_anyURI_parameters[] = {
    &impl_ne_anyURI_parameter_1,
    &impl_ne_anyURI_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_anyURI_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("ne<anyURI>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_anyURI"),
    AFW_UTF8_LITERAL("neAnyURI"),
    AFW_UTF8_LITERAL("afwNeAnyURI"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if anyURI arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<anyURI> (\n    arg1: anyURI,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_anyURI_parameters[0],
    2,
    &impl_ne_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    &impl_ne_anyURI_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__nex_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_anyURI");

static const afw_runtime_object_indirect_t
impl_object__nex_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_anyURI
        }
    },
    (void *)&afw_function_definition_nex_anyURI
};

static const afw_value_function_parameter_t
impl_nex_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_anyURI_parameters[] = {
    &impl_nex_anyURI_parameter_1,
    &impl_nex_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("nex<anyURI>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_anyURI"),
    AFW_UTF8_LITERAL("nexAnyURI"),
    AFW_UTF8_LITERAL("afwNexAnyURI"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for anyURI arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: anyURI, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<anyURI> (\n    arg1: anyURI,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_anyURI_parameters[0],
    2,
    &impl_nex_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_anyURI");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_anyURI
        }
    },
    (void *)&afw_function_definition_one_and_only_anyURI
};

static const afw_value_function_parameter_t
impl_one_and_only_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_anyURI_parameters[] = {
    &impl_one_and_only_anyURI_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_anyURI_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("one_and_only<anyURI>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_anyURI"),
    AFW_UTF8_LITERAL("oneAndOnlyAnyURI"),
    AFW_UTF8_LITERAL("afwOneAndOnlyAnyURI"),
    AFW_UTF8_LITERAL("Converts a one value list to a anyURI value"),
    AFW_UTF8_LITERAL("This converts a list of anyURI values that contains one value to a single anyURI value."),
    AFW_UTF8_LITERAL("(list: (list list)): anyURI"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a anyURI value */\nfunction one_and_only<anyURI> (\n    list: (list list)\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_anyURI_parameters[0],
    1,
    &impl_one_and_only_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    &impl_one_and_only_anyURI_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_index_of<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__regexp_index_of_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_index_of_anyURI");

static const afw_runtime_object_indirect_t
impl_object__regexp_index_of_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_index_of_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_index_of_anyURI
        }
    },
    (void *)&afw_function_definition_regexp_index_of_anyURI
};

static const afw_value_function_parameter_t
impl_regexp_index_of_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_index_of_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The anyURI value to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_index_of_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A regular expression to use for search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_index_of_anyURI_parameters[] = {
    &impl_regexp_index_of_anyURI_parameter_1,
    &impl_regexp_index_of_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_index_of_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_index_of_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("regexp_index_of<anyURI>"),
    AFW_UTF8_LITERAL("regexp_index_of"),
    AFW_UTF8_LITERAL("regexp_index_of_anyURI"),
    AFW_UTF8_LITERAL("regexpIndexOfAnyURI"),
    AFW_UTF8_LITERAL("afwRegexpIndexOfAnyURI"),
    AFW_UTF8_LITERAL("Returns index of first match of regular expression"),
    AFW_UTF8_LITERAL("Search anyURI value for a regular expression and return index. If not found, -1 is returned."),
    AFW_UTF8_LITERAL("(value: anyURI, regexp: string): integer"),
    AFW_UTF8_LITERAL("/* Returns index of first match of regular expression */\nfunction regexp_index_of<anyURI> (\n    value: anyURI,\n    regexp: string\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_index_of,
    NULL,
    2,
    2,
    &impl_regexp_index_of_anyURI_parameters[0],
    2,
    &impl_regexp_index_of_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_index_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_match<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__regexp_match_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_match_anyURI");

static const afw_runtime_object_indirect_t
impl_object__regexp_match_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_match_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_match_anyURI
        }
    },
    (void *)&afw_function_definition_regexp_match_anyURI
};

static const afw_value_function_parameter_t
impl_regexp_match_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_match_anyURI_parameters[] = {
    &impl_regexp_match_anyURI_parameter_1,
    &impl_regexp_match_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_match_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("regexp_match<anyURI>"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match_anyURI"),
    AFW_UTF8_LITERAL("regexpMatchAnyURI"),
    AFW_UTF8_LITERAL("afwRegexpMatchAnyURI"),
    AFW_UTF8_LITERAL("Search for a match using a regular expression"),
    AFW_UTF8_LITERAL("Checks whether anyURI value matches the regular expression regexp and return the boolean result."),
    AFW_UTF8_LITERAL("(value: anyURI, regexp: string): boolean"),
    AFW_UTF8_LITERAL("/* Search for a match using a regular expression */\nfunction regexp_match<anyURI> (\n    value: anyURI,\n    regexp: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_match,
    NULL,
    2,
    2,
    &impl_regexp_match_anyURI_parameters[0],
    2,
    &impl_regexp_match_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_replace<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__regexp_replace_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_replace_anyURI");

static const afw_runtime_object_indirect_t
impl_object__regexp_replace_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_replace_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_replace_anyURI
        }
    },
    (void *)&afw_function_definition_regexp_replace_anyURI
};

static const afw_value_function_parameter_t
impl_regexp_replace_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A anyURI value with the matched string(s) replaced."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The original anyURI value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A regular expression to use for search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_anyURI_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("replacement"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The replacement string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_anyURI_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_replace_anyURI_parameters[] = {
    &impl_regexp_replace_anyURI_parameter_1,
    &impl_regexp_replace_anyURI_parameter_2,
    &impl_regexp_replace_anyURI_parameter_3,
    &impl_regexp_replace_anyURI_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_replace_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_replace_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("regexp_replace<anyURI>"),
    AFW_UTF8_LITERAL("regexp_replace"),
    AFW_UTF8_LITERAL("regexp_replace_anyURI"),
    AFW_UTF8_LITERAL("regexpReplaceAnyURI"),
    AFW_UTF8_LITERAL("afwRegexpReplaceAnyURI"),
    AFW_UTF8_LITERAL("Replace strings matching a regular expression"),
    AFW_UTF8_LITERAL("Replace matched values for a regular expression in a anyURI value."),
    AFW_UTF8_LITERAL("(value: anyURI, regexp: string, replacement: string, limit?: integer): anyURI"),
    AFW_UTF8_LITERAL("/* Replace strings matching a regular expression */\nfunction regexp_replace<anyURI> (\n    value: anyURI,\n    regexp: string,\n    replacement: string,\n    limit?: integer\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_replace,
    NULL,
    3,
    4,
    &impl_regexp_replace_anyURI_parameters[0],
    4,
    &impl_regexp_replace_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_replace,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- repeat<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__repeat_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/repeat_anyURI");

static const afw_runtime_object_indirect_t
impl_object__repeat_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_repeat_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__repeat_anyURI
        }
    },
    (void *)&afw_function_definition_repeat_anyURI
};

static const afw_value_function_parameter_t
impl_repeat_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The repeated anyURI value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_repeat_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The anyURI value to repeat."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_repeat_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("times"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The number of times to repeat the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_repeat_anyURI_parameters[] = {
    &impl_repeat_anyURI_parameter_1,
    &impl_repeat_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_repeat_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__repeat_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("repeat<anyURI>"),
    AFW_UTF8_LITERAL("repeat"),
    AFW_UTF8_LITERAL("repeat_anyURI"),
    AFW_UTF8_LITERAL("repeatAnyURI"),
    AFW_UTF8_LITERAL("afwRepeatAnyURI"),
    AFW_UTF8_LITERAL("Returns a repeated value"),
    AFW_UTF8_LITERAL("Repeat a anyURI value a specified number of times."),
    AFW_UTF8_LITERAL("(value: anyURI, times: integer): anyURI"),
    AFW_UTF8_LITERAL("/* Returns a repeated value */\nfunction repeat<anyURI> (\n    value: anyURI,\n    times: integer\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_repeat,
    NULL,
    2,
    2,
    &impl_repeat_anyURI_parameters[0],
    2,
    &impl_repeat_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_repeat,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- replace<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__replace_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/replace_anyURI");

static const afw_runtime_object_indirect_t
impl_object__replace_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_replace_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__replace_anyURI
        }
    },
    (void *)&afw_function_definition_replace_anyURI
};

static const afw_value_function_parameter_t
impl_replace_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A anyURI value with the matched string(s) replaced."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The original anyURI value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string to replace."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_anyURI_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("replacement"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The replacement string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_anyURI_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_replace_anyURI_parameters[] = {
    &impl_replace_anyURI_parameter_1,
    &impl_replace_anyURI_parameter_2,
    &impl_replace_anyURI_parameter_3,
    &impl_replace_anyURI_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__replace_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("replace<anyURI>"),
    AFW_UTF8_LITERAL("replace"),
    AFW_UTF8_LITERAL("replace_anyURI"),
    AFW_UTF8_LITERAL("replaceAnyURI"),
    AFW_UTF8_LITERAL("afwReplaceAnyURI"),
    AFW_UTF8_LITERAL("Replace strings"),
    AFW_UTF8_LITERAL("Replace string(s) in a anyURI value."),
    AFW_UTF8_LITERAL("(value: anyURI, match: string, replacement: string, limit?: integer): anyURI"),
    AFW_UTF8_LITERAL("/* Replace strings */\nfunction replace<anyURI> (\n    value: anyURI,\n    match: string,\n    replacement: string,\n    limit?: integer\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_replace,
    NULL,
    3,
    4,
    &impl_replace_anyURI_parameters[0],
    4,
    &impl_replace_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_replace,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_anyURI");

static const afw_runtime_object_indirect_t
impl_object__set_equals_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_anyURI
        }
    },
    (void *)&afw_function_definition_set_equals_anyURI
};

static const afw_value_function_parameter_t
impl_set_equals_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_anyURI_parameters[] = {
    &impl_set_equals_anyURI_parameter_1,
    &impl_set_equals_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("set_equals<anyURI>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_anyURI"),
    AFW_UTF8_LITERAL("setEqualsAnyURI"),
    AFW_UTF8_LITERAL("afwSetEqualsAnyURI"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if anyURI list1 and anyURI list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list anyURI), list2: (list anyURI)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<anyURI> (\n    list1: (list anyURI),\n    list2: (list anyURI)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_anyURI_parameters[0],
    2,
    &impl_set_equals_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- split<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__split_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/split_anyURI");

static const afw_runtime_object_indirect_t
impl_object__split_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_split_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__split_anyURI
        }
    },
    (void *)&afw_function_definition_split_anyURI
};

static const afw_value_function_parameter_t
impl_split_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An list of strings."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The anyURI value to split."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("separator"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The separator to use. If this is an empty string or separator is not specified, the value is split between characters."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_anyURI_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum number of splits. Any remaining part of value is ignored."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_split_anyURI_parameters[] = {
    &impl_split_anyURI_parameter_1,
    &impl_split_anyURI_parameter_2,
    &impl_split_anyURI_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_split_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__split_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("split<anyURI>"),
    AFW_UTF8_LITERAL("split"),
    AFW_UTF8_LITERAL("split_anyURI"),
    AFW_UTF8_LITERAL("splitAnyURI"),
    AFW_UTF8_LITERAL("afwSplitAnyURI"),
    AFW_UTF8_LITERAL("Split at a separator"),
    AFW_UTF8_LITERAL("Split anyURI value into an list of strings using a separator."),
    AFW_UTF8_LITERAL("(value: anyURI, separator?: string, limit?: integer): list"),
    AFW_UTF8_LITERAL("/* Split at a separator */\nfunction split<anyURI> (\n    value: anyURI,\n    separator?: string,\n    limit?: integer\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_split,
    NULL,
    1,
    3,
    &impl_split_anyURI_parameters[0],
    3,
    &impl_split_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_split,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- starts_with<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__starts_with_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/starts_with_anyURI");

static const afw_runtime_object_indirect_t
impl_object__starts_with_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_starts_with_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__starts_with_anyURI
        }
    },
    (void *)&afw_function_definition_starts_with_anyURI
};

static const afw_value_function_parameter_t
impl_starts_with_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_starts_with_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_starts_with_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_starts_with_anyURI_parameters[] = {
    &impl_starts_with_anyURI_parameter_1,
    &impl_starts_with_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_starts_with_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__starts_with_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("starts_with<anyURI>"),
    AFW_UTF8_LITERAL("starts_with"),
    AFW_UTF8_LITERAL("starts_with_anyURI"),
    AFW_UTF8_LITERAL("startsWithAnyURI"),
    AFW_UTF8_LITERAL("afwStartsWithAnyURI"),
    AFW_UTF8_LITERAL("Checks whether value starts with a string"),
    AFW_UTF8_LITERAL("Checks whether anyURI value starts with a subString and return the boolean result."),
    AFW_UTF8_LITERAL("(value: anyURI, subString: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value starts with a string */\nfunction starts_with<anyURI> (\n    value: anyURI,\n    subString: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_starts_with,
    NULL,
    2,
    2,
    &impl_starts_with_anyURI_parameters[0],
    2,
    &impl_starts_with_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_starts_with,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__subset_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_anyURI");

static const afw_runtime_object_indirect_t
impl_object__subset_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_anyURI
        }
    },
    (void *)&afw_function_definition_subset_anyURI
};

static const afw_value_function_parameter_t
impl_subset_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_anyURI_parameters[] = {
    &impl_subset_anyURI_parameter_1,
    &impl_subset_anyURI_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("subset<anyURI>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_anyURI"),
    AFW_UTF8_LITERAL("subsetAnyURI"),
    AFW_UTF8_LITERAL("afwSubsetAnyURI"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in anyURI list1 are all in anyURI list2."),
    AFW_UTF8_LITERAL("(list1: (list anyURI), list2: (list anyURI)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<anyURI> (\n    list1: (list anyURI),\n    list2: (list anyURI)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_anyURI_parameters[0],
    2,
    &impl_subset_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- substring<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__substring_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/substring_anyURI");

static const afw_runtime_object_indirect_t
impl_object__substring_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_substring_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__substring_anyURI
        }
    },
    (void *)&afw_function_definition_substring_anyURI
};

static const afw_value_function_parameter_t
impl_substring_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_substring_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_substring_anyURI_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_substring_anyURI_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("endIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_substring_anyURI_parameters[] = {
    &impl_substring_anyURI_parameter_1,
    &impl_substring_anyURI_parameter_2,
    &impl_substring_anyURI_parameter_3,
    NULL
};

static const afw_utf8_z_t *
impl_substring_anyURI_errorsThrown[] = {
    "error", "arg_error",
    "reason", "startIndex or endIndex is out of range",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_substring_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__substring_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("substring<anyURI>"),
    AFW_UTF8_LITERAL("substring"),
    AFW_UTF8_LITERAL("substring_anyURI"),
    AFW_UTF8_LITERAL("substringAnyURI"),
    AFW_UTF8_LITERAL("afwSubstringAnyURI"),
    AFW_UTF8_LITERAL("Extract a substring"),
    AFW_UTF8_LITERAL("Returns the anyURI substring of value beginning at zero-based position integer startIndex and ending at the position before integer endIndex. Specify -1 or omitting endIndex to return up to end of anyURI."),
    AFW_UTF8_LITERAL("(string: anyURI, startIndex: integer, endIndex?: integer): anyURI"),
    AFW_UTF8_LITERAL("/* Extract a substring */\nfunction substring<anyURI> (\n    string: anyURI,\n    startIndex: integer,\n    endIndex?: integer\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_substring,
    NULL,
    2,
    3,
    &impl_substring_anyURI_parameters[0],
    3,
    &impl_substring_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    &impl_substring_anyURI_errorsThrown[0],
    NULL,
    afw_data_type_method_number_substring,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__to_string_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_anyURI");

static const afw_runtime_object_indirect_t
impl_object__to_string_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_anyURI
        }
    },
    (void *)&afw_function_definition_to_string_anyURI
};

static const afw_value_function_parameter_t
impl_to_string_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A anyURI value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_anyURI_parameters[] = {
    &impl_to_string_anyURI_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("to_string<anyURI>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_anyURI"),
    AFW_UTF8_LITERAL("toStringAnyURI"),
    AFW_UTF8_LITERAL("afwToStringAnyURI"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts anyURI value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: anyURI): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<anyURI> (\n    value: anyURI\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_anyURI_parameters[0],
    1,
    &impl_to_string_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__union_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_anyURI");

static const afw_runtime_object_indirect_t
impl_object__union_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_anyURI
        }
    },
    (void *)&afw_function_definition_union_anyURI
};

static const afw_value_function_parameter_t
impl_union_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_anyURI_parameters[] = {
    &impl_union_anyURI_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("union<anyURI>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_anyURI"),
    AFW_UTF8_LITERAL("unionAnyURI"),
    AFW_UTF8_LITERAL("afwUnionAnyURI"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of anyURI contains all of the unique values in two or more list of anyURI values."),
    AFW_UTF8_LITERAL("(lists_1: (list anyURI), lists_2: (list anyURI), ...lists_rest: (list of (list anyURI))): (list anyURI)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<anyURI> (\n    lists_1: (list anyURI),\n    lists_2: (list anyURI),\n    ...lists_rest: (list of (list anyURI))\n): (list anyURI);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_anyURI_parameters[0],
    1,
    &impl_union_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- url_encode<anyURI> ---------- */

static const afw_utf8_t
impl_object_path__url_encode_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/url_encode_anyURI");

static const afw_runtime_object_indirect_t
impl_object__url_encode_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_url_encode_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__url_encode_anyURI
        }
    },
    (void *)&afw_function_definition_url_encode_anyURI
};

static const afw_value_function_parameter_t
impl_url_encode_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI encoded string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_url_encode_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("unencoded"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URL encode a single value. See the url_encode method for the data type of more details."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_url_encode_anyURI_parameters[] = {
    &impl_url_encode_anyURI_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_encode_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__url_encode_anyURI,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("url_encode<anyURI>"),
    AFW_UTF8_LITERAL("url_encode"),
    AFW_UTF8_LITERAL("url_encode_anyURI"),
    AFW_UTF8_LITERAL("urlEncodeAnyURI"),
    AFW_UTF8_LITERAL("afwUrlEncodeAnyURI"),
    AFW_UTF8_LITERAL("URI encode"),
    AFW_UTF8_LITERAL("URL encode a value or bag of values."),
    AFW_UTF8_LITERAL("(unencoded: anyURI): string"),
    AFW_UTF8_LITERAL("/* URI encode */\nfunction url_encode<anyURI> (\n    unencoded: anyURI\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_url_encode,
    NULL,
    1,
    1,
    &impl_url_encode_anyURI_parameters[0],
    1,
    &impl_url_encode_anyURI_returns,
    NULL,
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    NULL,
    NULL,
    afw_data_type_method_number_url_encode,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_base64Binary
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_base64Binary
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_base64Binary_parameters[] = {
    &impl_at_least_one_member_of_base64Binary_parameter_1,
    &impl_at_least_one_member_of_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("at_least_one_member_of<base64Binary>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_base64Binary"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfBase64Binary"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfBase64Binary"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in base64Binary list1 is in base64Binary list2."),
    AFW_UTF8_LITERAL("(list1: (list base64Binary), list2: (list base64Binary)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<base64Binary> (\n    list1: (list base64Binary),\n    list2: (list base64Binary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_base64Binary_parameters[0],
    2,
    &impl_at_least_one_member_of_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__bag_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__bag_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_base64Binary
        }
    },
    (void *)&afw_function_definition_bag_base64Binary
};

static const afw_value_function_parameter_t
impl_bag_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_base64Binary_parameters[] = {
    &impl_bag_base64Binary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("bag<base64Binary>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_base64Binary"),
    AFW_UTF8_LITERAL("bagBase64Binary"),
    AFW_UTF8_LITERAL("afwBagBase64Binary"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of base64Binary values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list base64Binary))): (list base64Binary)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<base64Binary> (\n    ...values: (list of (list base64Binary))\n): (list base64Binary);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_base64Binary_parameters[0],
    1,
    &impl_bag_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__bag_size_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_base64Binary
        }
    },
    (void *)&afw_function_definition_bag_size_base64Binary
};

static const afw_value_function_parameter_t
impl_bag_size_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_base64Binary_parameters[] = {
    &impl_bag_size_base64Binary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("bag_size<base64Binary>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_base64Binary"),
    AFW_UTF8_LITERAL("bagSizeBase64Binary"),
    AFW_UTF8_LITERAL("afwBagSizeBase64Binary"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list base64Binary)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<base64Binary> (\n    value: (list base64Binary)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_base64Binary_parameters[0],
    1,
    &impl_bag_size_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- base64Binary ---------- */

static const afw_utf8_t
impl_object_path__base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/base64Binary");

static const afw_runtime_object_indirect_t
impl_object__base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__base64Binary
        }
    },
    (void *)&afw_function_definition_base64Binary
};

static const afw_value_function_parameter_t
impl_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_base64Binary_parameters[] = {
    &impl_base64Binary_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_base64Binary_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("afwBase64Binary"),
    AFW_UTF8_LITERAL("Convert to data type base64Binary"),
    AFW_UTF8_LITERAL("Converts value to data type base64Binary returning base64Binary result."),
    AFW_UTF8_LITERAL("(value: any): base64Binary"),
    AFW_UTF8_LITERAL("/* Convert to data type base64Binary */\nfunction base64Binary (\n    value: any\n): base64Binary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_base64Binary_parameters[0],
    1,
    &impl_base64Binary_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_base64Binary_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- decode_to_string<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__decode_to_string_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/decode_to_string_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__decode_to_string_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_decode_to_string_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__decode_to_string_base64Binary
        }
    },
    (void *)&afw_function_definition_decode_to_string_base64Binary
};

static const afw_value_function_parameter_t
impl_decode_to_string_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The decoded string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_decode_to_string_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The base64Binary value to decode."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_decode_to_string_base64Binary_parameters[] = {
    &impl_decode_to_string_base64Binary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decode_to_string_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__decode_to_string_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("decode_to_string<base64Binary>"),
    AFW_UTF8_LITERAL("decode_to_string"),
    AFW_UTF8_LITERAL("decode_to_string_base64Binary"),
    AFW_UTF8_LITERAL("decodeToStringBase64Binary"),
    AFW_UTF8_LITERAL("afwDecodeToStringBase64Binary"),
    AFW_UTF8_LITERAL("Decode base64Binary to string"),
    AFW_UTF8_LITERAL("Decode base64Binary value to string. An error is thrown if decoded value is not valid UTF-8."),
    AFW_UTF8_LITERAL("(value: base64Binary): string"),
    AFW_UTF8_LITERAL("/* Decode base64Binary to string */\nfunction decode_to_string<base64Binary> (\n    value: base64Binary\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_decode_to_string_base64Binary,
    NULL,
    1,
    1,
    &impl_decode_to_string_base64Binary_parameters[0],
    1,
    &impl_decode_to_string_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_decode_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__eq_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__eq_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_base64Binary
        }
    },
    (void *)&afw_function_definition_eq_base64Binary
};

static const afw_value_function_parameter_t
impl_eq_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_base64Binary_parameters[] = {
    &impl_eq_base64Binary_parameter_1,
    &impl_eq_base64Binary_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_base64Binary_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("eq<base64Binary>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_base64Binary"),
    AFW_UTF8_LITERAL("eqBase64Binary"),
    AFW_UTF8_LITERAL("afwEqBase64Binary"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if base64Binary arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<base64Binary> (\n    arg1: base64Binary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_base64Binary_parameters[0],
    2,
    &impl_eq_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    &impl_eq_base64Binary_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__eqx_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__eqx_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_base64Binary
        }
    },
    (void *)&afw_function_definition_eqx_base64Binary
};

static const afw_value_function_parameter_t
impl_eqx_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_base64Binary_parameters[] = {
    &impl_eqx_base64Binary_parameter_1,
    &impl_eqx_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("eqx<base64Binary>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_base64Binary"),
    AFW_UTF8_LITERAL("eqxBase64Binary"),
    AFW_UTF8_LITERAL("afwEqxBase64Binary"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for base64Binary arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<base64Binary> (\n    arg1: base64Binary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_base64Binary_parameters[0],
    2,
    &impl_eqx_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__ge_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__ge_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_base64Binary
        }
    },
    (void *)&afw_function_definition_ge_base64Binary
};

static const afw_value_function_parameter_t
impl_ge_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_base64Binary_parameters[] = {
    &impl_ge_base64Binary_parameter_1,
    &impl_ge_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("ge<base64Binary>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_base64Binary"),
    AFW_UTF8_LITERAL("geBase64Binary"),
    AFW_UTF8_LITERAL("afwGeBase64Binary"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for base64Binary arg1 is greater than or equal to base64Binary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: base64Binary): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<base64Binary> (\n    arg1: base64Binary,\n    arg2: base64Binary\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_base64Binary_parameters[0],
    2,
    &impl_ge_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__gt_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__gt_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_base64Binary
        }
    },
    (void *)&afw_function_definition_gt_base64Binary
};

static const afw_value_function_parameter_t
impl_gt_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_base64Binary_parameters[] = {
    &impl_gt_base64Binary_parameter_1,
    &impl_gt_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("gt<base64Binary>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_base64Binary"),
    AFW_UTF8_LITERAL("gtBase64Binary"),
    AFW_UTF8_LITERAL("afwGtBase64Binary"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for base64Binary arg1 is greater than base64Binary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: base64Binary): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<base64Binary> (\n    arg1: base64Binary,\n    arg2: base64Binary\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_base64Binary_parameters[0],
    2,
    &impl_gt_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__intersection_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__intersection_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_base64Binary
        }
    },
    (void *)&afw_function_definition_intersection_base64Binary
};

static const afw_value_function_parameter_t
impl_intersection_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_base64Binary_parameters[] = {
    &impl_intersection_base64Binary_parameter_1,
    &impl_intersection_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("intersection<base64Binary>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_base64Binary"),
    AFW_UTF8_LITERAL("intersectionBase64Binary"),
    AFW_UTF8_LITERAL("afwIntersectionBase64Binary"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of base64Binary with the values that are common to both list of base64Binary list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list base64Binary), list2: (list base64Binary)): (list base64Binary)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<base64Binary> (\n    list1: (list base64Binary),\n    list2: (list base64Binary)\n): (list base64Binary);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_base64Binary_parameters[0],
    2,
    &impl_intersection_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__is_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__is_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_base64Binary
        }
    },
    (void *)&afw_function_definition_is_base64Binary
};

static const afw_value_function_parameter_t
impl_is_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_base64Binary_parameters[] = {
    &impl_is_base64Binary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("is<base64Binary>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_base64Binary"),
    AFW_UTF8_LITERAL("isBase64Binary"),
    AFW_UTF8_LITERAL("afwIsBase64Binary"),
    AFW_UTF8_LITERAL("Checks whether value is dataType base64Binary"),
    AFW_UTF8_LITERAL("Checks whether value is dataType base64Binary and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType base64Binary */\nfunction is<base64Binary> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_base64Binary_parameters[0],
    1,
    &impl_is_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__is_in_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__is_in_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_base64Binary
        }
    },
    (void *)&afw_function_definition_is_in_base64Binary
};

static const afw_value_function_parameter_t
impl_is_in_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_base64Binary_parameters[] = {
    &impl_is_in_base64Binary_parameter_1,
    &impl_is_in_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("is_in<base64Binary>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_base64Binary"),
    AFW_UTF8_LITERAL("isInBase64Binary"),
    AFW_UTF8_LITERAL("afwIsInBase64Binary"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether base64Binary value is in list of base64Binary list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: base64Binary, list: (list base64Binary)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<base64Binary> (\n    value: base64Binary,\n    list: (list base64Binary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_base64Binary_parameters[0],
    2,
    &impl_is_in_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__le_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__le_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_base64Binary
        }
    },
    (void *)&afw_function_definition_le_base64Binary
};

static const afw_value_function_parameter_t
impl_le_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_base64Binary_parameters[] = {
    &impl_le_base64Binary_parameter_1,
    &impl_le_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("le<base64Binary>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_base64Binary"),
    AFW_UTF8_LITERAL("leBase64Binary"),
    AFW_UTF8_LITERAL("afwLeBase64Binary"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for base64Binary arg1 is less than or equal to base64Binary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<base64Binary> (\n    arg1: base64Binary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_base64Binary_parameters[0],
    2,
    &impl_le_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__lt_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__lt_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_base64Binary
        }
    },
    (void *)&afw_function_definition_lt_base64Binary
};

static const afw_value_function_parameter_t
impl_lt_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_base64Binary_parameters[] = {
    &impl_lt_base64Binary_parameter_1,
    &impl_lt_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("lt<base64Binary>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_base64Binary"),
    AFW_UTF8_LITERAL("ltBase64Binary"),
    AFW_UTF8_LITERAL("afwLtBase64Binary"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for base64Binary arg1 is less that base64Binary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: base64Binary): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<base64Binary> (\n    arg1: base64Binary,\n    arg2: base64Binary\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_base64Binary_parameters[0],
    2,
    &impl_lt_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__ne_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__ne_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_base64Binary
        }
    },
    (void *)&afw_function_definition_ne_base64Binary
};

static const afw_value_function_parameter_t
impl_ne_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_base64Binary_parameters[] = {
    &impl_ne_base64Binary_parameter_1,
    &impl_ne_base64Binary_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_base64Binary_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("ne<base64Binary>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_base64Binary"),
    AFW_UTF8_LITERAL("neBase64Binary"),
    AFW_UTF8_LITERAL("afwNeBase64Binary"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if base64Binary arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<base64Binary> (\n    arg1: base64Binary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_base64Binary_parameters[0],
    2,
    &impl_ne_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    &impl_ne_base64Binary_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__nex_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__nex_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_base64Binary
        }
    },
    (void *)&afw_function_definition_nex_base64Binary
};

static const afw_value_function_parameter_t
impl_nex_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_base64Binary_parameters[] = {
    &impl_nex_base64Binary_parameter_1,
    &impl_nex_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("nex<base64Binary>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_base64Binary"),
    AFW_UTF8_LITERAL("nexBase64Binary"),
    AFW_UTF8_LITERAL("afwNexBase64Binary"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for base64Binary arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: base64Binary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<base64Binary> (\n    arg1: base64Binary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_base64Binary_parameters[0],
    2,
    &impl_nex_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_base64Binary
        }
    },
    (void *)&afw_function_definition_one_and_only_base64Binary
};

static const afw_value_function_parameter_t
impl_one_and_only_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_base64Binary_parameters[] = {
    &impl_one_and_only_base64Binary_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_base64Binary_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("one_and_only<base64Binary>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_base64Binary"),
    AFW_UTF8_LITERAL("oneAndOnlyBase64Binary"),
    AFW_UTF8_LITERAL("afwOneAndOnlyBase64Binary"),
    AFW_UTF8_LITERAL("Converts a one value list to a base64Binary value"),
    AFW_UTF8_LITERAL("This converts a list of base64Binary values that contains one value to a single base64Binary value."),
    AFW_UTF8_LITERAL("(list: (list list)): base64Binary"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a base64Binary value */\nfunction one_and_only<base64Binary> (\n    list: (list list)\n): base64Binary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_base64Binary_parameters[0],
    1,
    &impl_one_and_only_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    &impl_one_and_only_base64Binary_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__set_equals_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_base64Binary
        }
    },
    (void *)&afw_function_definition_set_equals_base64Binary
};

static const afw_value_function_parameter_t
impl_set_equals_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_base64Binary_parameters[] = {
    &impl_set_equals_base64Binary_parameter_1,
    &impl_set_equals_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("set_equals<base64Binary>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_base64Binary"),
    AFW_UTF8_LITERAL("setEqualsBase64Binary"),
    AFW_UTF8_LITERAL("afwSetEqualsBase64Binary"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if base64Binary list1 and base64Binary list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list base64Binary), list2: (list base64Binary)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<base64Binary> (\n    list1: (list base64Binary),\n    list2: (list base64Binary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_base64Binary_parameters[0],
    2,
    &impl_set_equals_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__subset_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__subset_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_base64Binary
        }
    },
    (void *)&afw_function_definition_subset_base64Binary
};

static const afw_value_function_parameter_t
impl_subset_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_base64Binary_parameters[] = {
    &impl_subset_base64Binary_parameter_1,
    &impl_subset_base64Binary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("subset<base64Binary>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_base64Binary"),
    AFW_UTF8_LITERAL("subsetBase64Binary"),
    AFW_UTF8_LITERAL("afwSubsetBase64Binary"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in base64Binary list1 are all in base64Binary list2."),
    AFW_UTF8_LITERAL("(list1: (list base64Binary), list2: (list base64Binary)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<base64Binary> (\n    list1: (list base64Binary),\n    list2: (list base64Binary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_base64Binary_parameters[0],
    2,
    &impl_subset_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__to_string_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__to_string_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_base64Binary
        }
    },
    (void *)&afw_function_definition_to_string_base64Binary
};

static const afw_value_function_parameter_t
impl_to_string_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A base64Binary value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_base64Binary_parameters[] = {
    &impl_to_string_base64Binary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("to_string<base64Binary>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_base64Binary"),
    AFW_UTF8_LITERAL("toStringBase64Binary"),
    AFW_UTF8_LITERAL("afwToStringBase64Binary"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts base64Binary value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: base64Binary): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<base64Binary> (\n    value: base64Binary\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_base64Binary_parameters[0],
    1,
    &impl_to_string_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<base64Binary> ---------- */

static const afw_utf8_t
impl_object_path__union_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__union_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_base64Binary
        }
    },
    (void *)&afw_function_definition_union_base64Binary
};

static const afw_value_function_parameter_t
impl_union_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_base64Binary_parameters[] = {
    &impl_union_base64Binary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_base64Binary,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("union<base64Binary>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_base64Binary"),
    AFW_UTF8_LITERAL("unionBase64Binary"),
    AFW_UTF8_LITERAL("afwUnionBase64Binary"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of base64Binary contains all of the unique values in two or more list of base64Binary values."),
    AFW_UTF8_LITERAL("(lists_1: (list base64Binary), lists_2: (list base64Binary), ...lists_rest: (list of (list base64Binary))): (list base64Binary)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<base64Binary> (\n    lists_1: (list base64Binary),\n    lists_2: (list base64Binary),\n    ...lists_rest: (list of (list base64Binary))\n): (list base64Binary);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_base64Binary_parameters[0],
    1,
    &impl_union_base64Binary_returns,
    NULL,
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<boolean> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_boolean");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_boolean
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_boolean
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_boolean_parameters[] = {
    &impl_at_least_one_member_of_boolean_parameter_1,
    &impl_at_least_one_member_of_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("at_least_one_member_of<boolean>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_boolean"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfBoolean"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfBoolean"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in boolean list1 is in boolean list2."),
    AFW_UTF8_LITERAL("(list1: (list boolean), list2: (list boolean)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<boolean> (\n    list1: (list boolean),\n    list2: (list boolean)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_boolean_parameters[0],
    2,
    &impl_at_least_one_member_of_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<boolean> ---------- */

static const afw_utf8_t
impl_object_path__bag_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_boolean");

static const afw_runtime_object_indirect_t
impl_object__bag_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_boolean
        }
    },
    (void *)&afw_function_definition_bag_boolean
};

static const afw_value_function_parameter_t
impl_bag_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_boolean_parameters[] = {
    &impl_bag_boolean_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("bag<boolean>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_boolean"),
    AFW_UTF8_LITERAL("bagBoolean"),
    AFW_UTF8_LITERAL("afwBagBoolean"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of boolean values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list boolean))): (list boolean)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<boolean> (\n    ...values: (list of (list boolean))\n): (list boolean);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_boolean_parameters[0],
    1,
    &impl_bag_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<boolean> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_boolean");

static const afw_runtime_object_indirect_t
impl_object__bag_size_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_boolean
        }
    },
    (void *)&afw_function_definition_bag_size_boolean
};

static const afw_value_function_parameter_t
impl_bag_size_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_boolean_parameters[] = {
    &impl_bag_size_boolean_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("bag_size<boolean>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_boolean"),
    AFW_UTF8_LITERAL("bagSizeBoolean"),
    AFW_UTF8_LITERAL("afwBagSizeBoolean"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list boolean)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<boolean> (\n    value: (list boolean)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_boolean_parameters[0],
    1,
    &impl_bag_size_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- boolean ---------- */

static const afw_utf8_t
impl_object_path__boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/boolean");

static const afw_runtime_object_indirect_t
impl_object__boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__boolean
        }
    },
    (void *)&afw_function_definition_boolean
};

static const afw_value_function_parameter_t
impl_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_boolean_parameters[] = {
    &impl_boolean_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_boolean_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("afwBoolean"),
    AFW_UTF8_LITERAL("Convert to data type boolean"),
    AFW_UTF8_LITERAL("Converts value to data type boolean returning boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Convert to data type boolean */\nfunction boolean (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_boolean_parameters[0],
    1,
    &impl_boolean_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_boolean_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<boolean> ---------- */

static const afw_utf8_t
impl_object_path__eq_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_boolean");

static const afw_runtime_object_indirect_t
impl_object__eq_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_boolean
        }
    },
    (void *)&afw_function_definition_eq_boolean
};

static const afw_value_function_parameter_t
impl_eq_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_boolean_parameters[] = {
    &impl_eq_boolean_parameter_1,
    &impl_eq_boolean_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_boolean_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("eq<boolean>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_boolean"),
    AFW_UTF8_LITERAL("eqBoolean"),
    AFW_UTF8_LITERAL("afwEqBoolean"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if boolean arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<boolean> (\n    arg1: boolean,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_boolean_parameters[0],
    2,
    &impl_eq_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    &impl_eq_boolean_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<boolean> ---------- */

static const afw_utf8_t
impl_object_path__eqx_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_boolean");

static const afw_runtime_object_indirect_t
impl_object__eqx_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_boolean
        }
    },
    (void *)&afw_function_definition_eqx_boolean
};

static const afw_value_function_parameter_t
impl_eqx_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_boolean_parameters[] = {
    &impl_eqx_boolean_parameter_1,
    &impl_eqx_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("eqx<boolean>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_boolean"),
    AFW_UTF8_LITERAL("eqxBoolean"),
    AFW_UTF8_LITERAL("afwEqxBoolean"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for boolean arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<boolean> (\n    arg1: boolean,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_boolean_parameters[0],
    2,
    &impl_eqx_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<boolean> ---------- */

static const afw_utf8_t
impl_object_path__ge_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_boolean");

static const afw_runtime_object_indirect_t
impl_object__ge_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_boolean
        }
    },
    (void *)&afw_function_definition_ge_boolean
};

static const afw_value_function_parameter_t
impl_ge_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_boolean_parameters[] = {
    &impl_ge_boolean_parameter_1,
    &impl_ge_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("ge<boolean>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_boolean"),
    AFW_UTF8_LITERAL("geBoolean"),
    AFW_UTF8_LITERAL("afwGeBoolean"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for boolean arg1 is greater than or equal to boolean arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: boolean): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<boolean> (\n    arg1: boolean,\n    arg2: boolean\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_boolean_parameters[0],
    2,
    &impl_ge_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<boolean> ---------- */

static const afw_utf8_t
impl_object_path__gt_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_boolean");

static const afw_runtime_object_indirect_t
impl_object__gt_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_boolean
        }
    },
    (void *)&afw_function_definition_gt_boolean
};

static const afw_value_function_parameter_t
impl_gt_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_boolean_parameters[] = {
    &impl_gt_boolean_parameter_1,
    &impl_gt_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("gt<boolean>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_boolean"),
    AFW_UTF8_LITERAL("gtBoolean"),
    AFW_UTF8_LITERAL("afwGtBoolean"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for boolean arg1 is greater than boolean arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: boolean): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<boolean> (\n    arg1: boolean,\n    arg2: boolean\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_boolean_parameters[0],
    2,
    &impl_gt_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<boolean> ---------- */

static const afw_utf8_t
impl_object_path__intersection_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_boolean");

static const afw_runtime_object_indirect_t
impl_object__intersection_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_boolean
        }
    },
    (void *)&afw_function_definition_intersection_boolean
};

static const afw_value_function_parameter_t
impl_intersection_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_boolean_parameters[] = {
    &impl_intersection_boolean_parameter_1,
    &impl_intersection_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("intersection<boolean>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_boolean"),
    AFW_UTF8_LITERAL("intersectionBoolean"),
    AFW_UTF8_LITERAL("afwIntersectionBoolean"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of boolean with the values that are common to both list of boolean list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list boolean), list2: (list boolean)): (list boolean)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<boolean> (\n    list1: (list boolean),\n    list2: (list boolean)\n): (list boolean);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_boolean_parameters[0],
    2,
    &impl_intersection_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<boolean> ---------- */

static const afw_utf8_t
impl_object_path__is_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_boolean");

static const afw_runtime_object_indirect_t
impl_object__is_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_boolean
        }
    },
    (void *)&afw_function_definition_is_boolean
};

static const afw_value_function_parameter_t
impl_is_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_boolean_parameters[] = {
    &impl_is_boolean_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("is<boolean>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_boolean"),
    AFW_UTF8_LITERAL("isBoolean"),
    AFW_UTF8_LITERAL("afwIsBoolean"),
    AFW_UTF8_LITERAL("Checks whether value is dataType boolean"),
    AFW_UTF8_LITERAL("Checks whether value is dataType boolean and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType boolean */\nfunction is<boolean> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_boolean_parameters[0],
    1,
    &impl_is_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<boolean> ---------- */

static const afw_utf8_t
impl_object_path__is_in_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_boolean");

static const afw_runtime_object_indirect_t
impl_object__is_in_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_boolean
        }
    },
    (void *)&afw_function_definition_is_in_boolean
};

static const afw_value_function_parameter_t
impl_is_in_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_boolean_parameters[] = {
    &impl_is_in_boolean_parameter_1,
    &impl_is_in_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("is_in<boolean>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_boolean"),
    AFW_UTF8_LITERAL("isInBoolean"),
    AFW_UTF8_LITERAL("afwIsInBoolean"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether boolean value is in list of boolean list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: boolean, list: (list boolean)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<boolean> (\n    value: boolean,\n    list: (list boolean)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_boolean_parameters[0],
    2,
    &impl_is_in_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<boolean> ---------- */

static const afw_utf8_t
impl_object_path__le_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_boolean");

static const afw_runtime_object_indirect_t
impl_object__le_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_boolean
        }
    },
    (void *)&afw_function_definition_le_boolean
};

static const afw_value_function_parameter_t
impl_le_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_boolean_parameters[] = {
    &impl_le_boolean_parameter_1,
    &impl_le_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("le<boolean>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_boolean"),
    AFW_UTF8_LITERAL("leBoolean"),
    AFW_UTF8_LITERAL("afwLeBoolean"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for boolean arg1 is less than or equal to boolean arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<boolean> (\n    arg1: boolean,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_boolean_parameters[0],
    2,
    &impl_le_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<boolean> ---------- */

static const afw_utf8_t
impl_object_path__lt_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_boolean");

static const afw_runtime_object_indirect_t
impl_object__lt_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_boolean
        }
    },
    (void *)&afw_function_definition_lt_boolean
};

static const afw_value_function_parameter_t
impl_lt_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_boolean_parameters[] = {
    &impl_lt_boolean_parameter_1,
    &impl_lt_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("lt<boolean>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_boolean"),
    AFW_UTF8_LITERAL("ltBoolean"),
    AFW_UTF8_LITERAL("afwLtBoolean"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for boolean arg1 is less that boolean arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: boolean): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<boolean> (\n    arg1: boolean,\n    arg2: boolean\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_boolean_parameters[0],
    2,
    &impl_lt_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<boolean> ---------- */

static const afw_utf8_t
impl_object_path__ne_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_boolean");

static const afw_runtime_object_indirect_t
impl_object__ne_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_boolean
        }
    },
    (void *)&afw_function_definition_ne_boolean
};

static const afw_value_function_parameter_t
impl_ne_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_boolean_parameters[] = {
    &impl_ne_boolean_parameter_1,
    &impl_ne_boolean_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_boolean_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("ne<boolean>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_boolean"),
    AFW_UTF8_LITERAL("neBoolean"),
    AFW_UTF8_LITERAL("afwNeBoolean"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if boolean arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<boolean> (\n    arg1: boolean,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_boolean_parameters[0],
    2,
    &impl_ne_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    &impl_ne_boolean_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<boolean> ---------- */

static const afw_utf8_t
impl_object_path__nex_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_boolean");

static const afw_runtime_object_indirect_t
impl_object__nex_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_boolean
        }
    },
    (void *)&afw_function_definition_nex_boolean
};

static const afw_value_function_parameter_t
impl_nex_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_boolean_parameters[] = {
    &impl_nex_boolean_parameter_1,
    &impl_nex_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("nex<boolean>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_boolean"),
    AFW_UTF8_LITERAL("nexBoolean"),
    AFW_UTF8_LITERAL("afwNexBoolean"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for boolean arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: boolean, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<boolean> (\n    arg1: boolean,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_boolean_parameters[0],
    2,
    &impl_nex_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<boolean> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_boolean");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_boolean
        }
    },
    (void *)&afw_function_definition_one_and_only_boolean
};

static const afw_value_function_parameter_t
impl_one_and_only_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_boolean_parameters[] = {
    &impl_one_and_only_boolean_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_boolean_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("one_and_only<boolean>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_boolean"),
    AFW_UTF8_LITERAL("oneAndOnlyBoolean"),
    AFW_UTF8_LITERAL("afwOneAndOnlyBoolean"),
    AFW_UTF8_LITERAL("Converts a one value list to a boolean value"),
    AFW_UTF8_LITERAL("This converts a list of boolean values that contains one value to a single boolean value."),
    AFW_UTF8_LITERAL("(list: (list list)): boolean"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a boolean value */\nfunction one_and_only<boolean> (\n    list: (list list)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_boolean_parameters[0],
    1,
    &impl_one_and_only_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    &impl_one_and_only_boolean_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<boolean> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_boolean");

static const afw_runtime_object_indirect_t
impl_object__set_equals_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_boolean
        }
    },
    (void *)&afw_function_definition_set_equals_boolean
};

static const afw_value_function_parameter_t
impl_set_equals_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_boolean_parameters[] = {
    &impl_set_equals_boolean_parameter_1,
    &impl_set_equals_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("set_equals<boolean>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_boolean"),
    AFW_UTF8_LITERAL("setEqualsBoolean"),
    AFW_UTF8_LITERAL("afwSetEqualsBoolean"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if boolean list1 and boolean list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list boolean), list2: (list boolean)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<boolean> (\n    list1: (list boolean),\n    list2: (list boolean)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_boolean_parameters[0],
    2,
    &impl_set_equals_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<boolean> ---------- */

static const afw_utf8_t
impl_object_path__subset_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_boolean");

static const afw_runtime_object_indirect_t
impl_object__subset_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_boolean
        }
    },
    (void *)&afw_function_definition_subset_boolean
};

static const afw_value_function_parameter_t
impl_subset_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_boolean_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_boolean_parameters[] = {
    &impl_subset_boolean_parameter_1,
    &impl_subset_boolean_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("subset<boolean>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_boolean"),
    AFW_UTF8_LITERAL("subsetBoolean"),
    AFW_UTF8_LITERAL("afwSubsetBoolean"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in boolean list1 are all in boolean list2."),
    AFW_UTF8_LITERAL("(list1: (list boolean), list2: (list boolean)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<boolean> (\n    list1: (list boolean),\n    list2: (list boolean)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_boolean_parameters[0],
    2,
    &impl_subset_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<boolean> ---------- */

static const afw_utf8_t
impl_object_path__to_string_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_boolean");

static const afw_runtime_object_indirect_t
impl_object__to_string_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_boolean
        }
    },
    (void *)&afw_function_definition_to_string_boolean
};

static const afw_value_function_parameter_t
impl_to_string_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A boolean value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_boolean_parameters[] = {
    &impl_to_string_boolean_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("to_string<boolean>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_boolean"),
    AFW_UTF8_LITERAL("toStringBoolean"),
    AFW_UTF8_LITERAL("afwToStringBoolean"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts boolean value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: boolean): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<boolean> (\n    value: boolean\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_boolean_parameters[0],
    1,
    &impl_to_string_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<boolean> ---------- */

static const afw_utf8_t
impl_object_path__union_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_boolean");

static const afw_runtime_object_indirect_t
impl_object__union_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_boolean
        }
    },
    (void *)&afw_function_definition_union_boolean
};

static const afw_value_function_parameter_t
impl_union_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_boolean_parameters[] = {
    &impl_union_boolean_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_boolean,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("union<boolean>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_boolean"),
    AFW_UTF8_LITERAL("unionBoolean"),
    AFW_UTF8_LITERAL("afwUnionBoolean"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of boolean contains all of the unique values in two or more list of boolean values."),
    AFW_UTF8_LITERAL("(lists_1: (list boolean), lists_2: (list boolean), ...lists_rest: (list of (list boolean))): (list boolean)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<boolean> (\n    lists_1: (list boolean),\n    lists_2: (list boolean),\n    ...lists_rest: (list of (list boolean))\n): (list boolean);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_boolean_parameters[0],
    1,
    &impl_union_boolean_returns,
    NULL,
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- assert ---------- */

static const afw_utf8_t
impl_object_path__assert =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/assert");

static const afw_runtime_object_indirect_t
impl_object__assert = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_assert,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__assert
        }
    },
    (void *)&afw_function_definition_assert
};

static const afw_value_function_parameter_t
impl_assert_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_assert_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("assertion"),
    AFW_UTF8_LITERAL("Assertion"),
    AFW_UTF8_LITERAL("This is the assertion to make. If not true, an assertion_failed error is thrown."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_assert_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("reason"),
    AFW_UTF8_LITERAL("Reason"),
    AFW_UTF8_LITERAL("This is an optional reason to include in the assertion_failed message."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_assert_parameters[] = {
    &impl_assert_parameter_1,
    &impl_assert_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_assert = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__assert,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("assert"),
    AFW_UTF8_LITERAL("assert"),
    AFW_UTF8_LITERAL("assert"),
    AFW_UTF8_LITERAL("assert"),
    AFW_UTF8_LITERAL("afwAssert"),
    AFW_UTF8_LITERAL("Assert a value"),
    AFW_UTF8_LITERAL("Assert that a value is true. If not, an assertion_failed error is thrown."),
    AFW_UTF8_LITERAL("(assertion: boolean, reason?: string): null"),
    AFW_UTF8_LITERAL("/* Assert a value */\nfunction assert (\n    assertion: boolean /* Assertion */,\n    reason?: string    /* Reason */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_assert,
    NULL,
    1,
    2,
    &impl_assert_parameters[0],
    2,
    &impl_assert_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- compile_expression_tuple ---------- */

static const afw_utf8_t
impl_object_path__compile_expression_tuple =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_expression_tuple");

static const afw_runtime_object_indirect_t
impl_object__compile_expression_tuple = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_expression_tuple,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_expression_tuple
        }
    },
    (void *)&afw_function_definition_compile_expression_tuple
};

static const afw_value_function_parameter_t
impl_compile_expression_tuple_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An unevaluated expression tuple value ready for use by function evaluate() or a string containing the compiler listing."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_expression_tuple_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expression_tuple"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expression tuple to compile."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_expression_tuple_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression tuple value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_expression_tuple_parameters[] = {
    &impl_compile_expression_tuple_parameter_1,
    &impl_compile_expression_tuple_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_expression_tuple = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_expression_tuple,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("compile_expression_tuple"),
    AFW_UTF8_LITERAL("compile_expression_tuple"),
    AFW_UTF8_LITERAL("compile_expression_tuple"),
    AFW_UTF8_LITERAL("compileExpressionTuple"),
    AFW_UTF8_LITERAL("afwCompileExpressionTuple"),
    AFW_UTF8_LITERAL("Compile expression tuple value"),
    AFW_UTF8_LITERAL("Compile a string containing adaptive expression tuple syntax and return either an unevaluated expression tuple adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(expression_tuple: list, listing?: any): any"),
    AFW_UTF8_LITERAL("/* Compile expression tuple value */\nfunction compile_expression_tuple (\n    expression_tuple: list,\n    listing?: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_expression_tuple,
    NULL,
    1,
    2,
    &impl_compile_expression_tuple_parameters[0],
    2,
    &impl_compile_expression_tuple_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compile_json ---------- */

static const afw_utf8_t
impl_object_path__compile_json =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_json");

static const afw_runtime_object_indirect_t
impl_object__compile_json = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_json,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_json
        }
    },
    (void *)&afw_function_definition_compile_json
};

static const afw_value_function_parameter_t
impl_compile_json_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An unevaluated JSON value ready for use by function evaluate() or a string containing the compiler listing."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_json_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("json"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("JSON string to compile."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_json_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated JSON value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_json_parameters[] = {
    &impl_compile_json_parameter_1,
    &impl_compile_json_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_json = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_json,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("compile_json"),
    AFW_UTF8_LITERAL("compile_json"),
    AFW_UTF8_LITERAL("compile_json"),
    AFW_UTF8_LITERAL("compileJson"),
    AFW_UTF8_LITERAL("afwCompileJson"),
    AFW_UTF8_LITERAL("Compile JSON"),
    AFW_UTF8_LITERAL("Compile a string containing adaptive JSON syntax and return either an unevaluated JSON adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(json: string, listing?: any): any"),
    AFW_UTF8_LITERAL("/* Compile JSON */\nfunction compile_json (\n    json: string,\n    listing?: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_json,
    NULL,
    1,
    2,
    &impl_compile_json_parameters[0],
    2,
    &impl_compile_json_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compile_relaxed_json ---------- */

static const afw_utf8_t
impl_object_path__compile_relaxed_json =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_relaxed_json");

static const afw_runtime_object_indirect_t
impl_object__compile_relaxed_json = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_relaxed_json,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_relaxed_json
        }
    },
    (void *)&afw_function_definition_compile_relaxed_json
};

static const afw_value_function_parameter_t
impl_compile_relaxed_json_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An unevaluated relaxed JSON value ready for use by function evaluate() or a string containing the compiler listing."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_relaxed_json_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("json"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Adaptive relaxed JSON syntax string to compile."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_relaxed_json_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated relaxed JSON value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_relaxed_json_parameters[] = {
    &impl_compile_relaxed_json_parameter_1,
    &impl_compile_relaxed_json_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_relaxed_json = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_relaxed_json,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("compile_relaxed_json"),
    AFW_UTF8_LITERAL("compile_relaxed_json"),
    AFW_UTF8_LITERAL("compile_relaxed_json"),
    AFW_UTF8_LITERAL("compileRelaxedJson"),
    AFW_UTF8_LITERAL("afwCompileRelaxedJson"),
    AFW_UTF8_LITERAL("Compile relaxed JSON"),
    AFW_UTF8_LITERAL("Compile an adaptive relaxed JSON syntax string and return an adaptive value."),
    AFW_UTF8_LITERAL("(json: string, listing?: any): any"),
    AFW_UTF8_LITERAL("/* Compile relaxed JSON */\nfunction compile_relaxed_json (\n    json: string,\n    listing?: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_relaxed_json,
    NULL,
    1,
    2,
    &impl_compile_relaxed_json_parameters[0],
    2,
    &impl_compile_relaxed_json_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- convert_syntax_hybrid_to_expression ---------- */

static const afw_utf8_t
impl_object_path__convert_syntax_hybrid_to_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/convert_syntax_hybrid_to_expression");

static const afw_runtime_object_indirect_t
impl_object__convert_syntax_hybrid_to_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_convert_syntax_hybrid_to_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__convert_syntax_hybrid_to_expression
        }
    },
    (void *)&afw_function_definition_convert_syntax_hybrid_to_expression
};

static const afw_value_function_parameter_t
impl_convert_syntax_hybrid_to_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The converted value in adaptive expression syntax."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_syntax_hybrid_to_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The hybrid to convert."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_convert_syntax_hybrid_to_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("whitespace"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Add whitespace for readability if present and not 0. This parameter can be an integer between 0 and 10 or a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_convert_syntax_hybrid_to_expression_parameters[] = {
    &impl_convert_syntax_hybrid_to_expression_parameter_1,
    &impl_convert_syntax_hybrid_to_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_convert_syntax_hybrid_to_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__convert_syntax_hybrid_to_expression,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("convert_syntax_hybrid_to_expression"),
    AFW_UTF8_LITERAL("convert_syntax_hybrid_to_expression"),
    AFW_UTF8_LITERAL("convert_syntax_hybrid_to_expression"),
    AFW_UTF8_LITERAL("convertSyntaxHybridToExpression"),
    AFW_UTF8_LITERAL("afwConvertSyntaxHybridToExpression"),
    AFW_UTF8_LITERAL("Convert a hybrid to a expression."),
    AFW_UTF8_LITERAL("Convert a string containing adaptive hybrid syntax, which can be an adaptive template or adaptive expression tuple, to adaptive expression syntax."),
    AFW_UTF8_LITERAL("(hybrid: string, whitespace?: any): expression"),
    AFW_UTF8_LITERAL("/* Convert a hybrid to a expression. */\nfunction convert_syntax_hybrid_to_expression (\n    hybrid: string,\n    whitespace?: any\n): expression;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert_syntax_hybrid_to_expression,
    NULL,
    1,
    2,
    &impl_convert_syntax_hybrid_to_expression_parameters[0],
    2,
    &impl_convert_syntax_hybrid_to_expression_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- decompile ---------- */

static const afw_utf8_t
impl_object_path__decompile =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/decompile");

static const afw_runtime_object_indirect_t
impl_object__decompile = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_decompile,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__decompile
        }
    },
    (void *)&afw_function_definition_decompile
};

static const afw_value_function_parameter_t
impl_decompile_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Decompiled value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_decompile_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to decompile."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_decompile_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("whitespace"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Add whitespace for readability if present and not 0. This parameter can be an integer between 0 and 10 or a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_decompile_parameters[] = {
    &impl_decompile_parameter_1,
    &impl_decompile_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decompile = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__decompile,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("decompile"),
    AFW_UTF8_LITERAL("decompile"),
    AFW_UTF8_LITERAL("decompile"),
    AFW_UTF8_LITERAL("decompile"),
    AFW_UTF8_LITERAL("afwDecompile"),
    AFW_UTF8_LITERAL("Decompile value"),
    AFW_UTF8_LITERAL("Decompile an adaptive value to string."),
    AFW_UTF8_LITERAL("(value: any, whitespace?: any): string"),
    AFW_UTF8_LITERAL("/* Decompile value */\nfunction decompile (\n    value: any,\n    whitespace?: any\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_decompile,
    NULL,
    1,
    2,
    &impl_decompile_parameters[0],
    2,
    &impl_decompile_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- evaluate_expression_tuple ---------- */

static const afw_utf8_t
impl_object_path__evaluate_expression_tuple =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_expression_tuple");

static const afw_runtime_object_indirect_t
impl_object__evaluate_expression_tuple = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_expression_tuple,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_expression_tuple
        }
    },
    (void *)&afw_function_definition_evaluate_expression_tuple
};

static const afw_value_function_parameter_t
impl_evaluate_expression_tuple_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Evaluated adaptive expression tuple."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_expression_tuple_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expression_tuple"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expression tuple to compile and evaluate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_expression_tuple_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_expression_tuple_parameters[] = {
    &impl_evaluate_expression_tuple_parameter_1,
    &impl_evaluate_expression_tuple_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_expression_tuple = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_expression_tuple,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("evaluate_expression_tuple"),
    AFW_UTF8_LITERAL("evaluate_expression_tuple"),
    AFW_UTF8_LITERAL("evaluate_expression_tuple"),
    AFW_UTF8_LITERAL("evaluateExpressionTuple"),
    AFW_UTF8_LITERAL("afwEvaluateExpressionTuple"),
    AFW_UTF8_LITERAL("Evaluate expression tuple"),
    AFW_UTF8_LITERAL("Compile a string containing adaptive expression tuple syntax and then evaluate the result."),
    AFW_UTF8_LITERAL("(expression_tuple: string, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): any"),
    AFW_UTF8_LITERAL("/* Evaluate expression tuple */\nfunction evaluate_expression_tuple (\n    expression_tuple: string,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_expression_tuple,
    NULL,
    1,
    2,
    &impl_evaluate_expression_tuple_parameters[0],
    2,
    &impl_evaluate_expression_tuple_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- evaluate_value ---------- */

static const afw_utf8_t
impl_object_path__evaluate_value =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_value");

static const afw_runtime_object_indirect_t
impl_object__evaluate_value = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_value,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_value
        }
    },
    (void *)&afw_function_definition_evaluate_value
};

static const afw_value_function_parameter_t
impl_evaluate_value_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Evaluated adaptive value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_value_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_value_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_value_parameters[] = {
    &impl_evaluate_value_parameter_1,
    &impl_evaluate_value_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_value = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_value,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("evaluate_value"),
    AFW_UTF8_LITERAL("evaluate_value"),
    AFW_UTF8_LITERAL("evaluate_value"),
    AFW_UTF8_LITERAL("evaluateValue"),
    AFW_UTF8_LITERAL("afwEvaluateValue"),
    AFW_UTF8_LITERAL("Evaluate value"),
    AFW_UTF8_LITERAL("Evaluate an adaptive value."),
    AFW_UTF8_LITERAL("(value: any, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): any"),
    AFW_UTF8_LITERAL("/* Evaluate value */\nfunction evaluate_value (\n    value: any,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_value,
    NULL,
    1,
    2,
    &impl_evaluate_value_parameters[0],
    2,
    &impl_evaluate_value_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- evaluate_with_retry ---------- */

static const afw_utf8_t
impl_object_path__evaluate_with_retry =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_with_retry");

static const afw_runtime_object_indirect_t
impl_object__evaluate_with_retry = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_with_retry,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_with_retry
        }
    },
    (void *)&afw_function_definition_evaluate_with_retry
};

static const afw_value_function_parameter_t
impl_evaluate_with_retry_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Evaluated value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_with_retry_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to evaluated"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_with_retry_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Maximum number to retry if an exception occurs."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_with_retry_parameters[] = {
    &impl_evaluate_with_retry_parameter_1,
    &impl_evaluate_with_retry_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_with_retry = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_with_retry,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("evaluate_with_retry"),
    AFW_UTF8_LITERAL("evaluate_with_retry"),
    AFW_UTF8_LITERAL("evaluate_with_retry"),
    AFW_UTF8_LITERAL("evaluateWithRetry"),
    AFW_UTF8_LITERAL("afwEvaluateWithRetry"),
    AFW_UTF8_LITERAL("Evaluate value with retry"),
    AFW_UTF8_LITERAL("Evaluate a value and retry up to a limit if an exception occurs."),
    AFW_UTF8_LITERAL("(value: any, limit: integer): any"),
    AFW_UTF8_LITERAL("/* Evaluate value with retry */\nfunction evaluate_with_retry (\n    value: any,\n    limit: integer\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_with_retry,
    NULL,
    2,
    2,
    &impl_evaluate_with_retry_parameters[0],
    2,
    &impl_evaluate_with_retry_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- qualifier ---------- */

static const afw_utf8_t
impl_object_path__qualifier =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/qualifier");

static const afw_runtime_object_indirect_t
impl_object__qualifier = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_qualifier,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__qualifier
        }
    },
    (void *)&afw_function_definition_qualifier
};

static const afw_value_function_parameter_t
impl_qualifier_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Variables for the specified qualifier"),
    AFW_UTF8_LITERAL("Each property is the name of a variable with the value influenced by the forTesting property."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_qualifier_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("qualifier"),
    AFW_UTF8_LITERAL("Qualifier"),
    AFW_UTF8_LITERAL("This is the qualifier whose variables are to be accessed as properties of the returned object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_qualifier_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("forTesting"),
    AFW_UTF8_LITERAL("For testing if true"),
    AFW_UTF8_LITERAL("If specified and true, the object returned will be suitable to pass as the additionalUntrustedQualifiedVariables parameter of evaluate*() functions. This is intended for testing purposes and should not be used in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_qualifier_parameters[] = {
    &impl_qualifier_parameter_1,
    &impl_qualifier_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_qualifier = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__qualifier,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("qualifier"),
    AFW_UTF8_LITERAL("qualifier"),
    AFW_UTF8_LITERAL("qualifier"),
    AFW_UTF8_LITERAL("qualifier"),
    AFW_UTF8_LITERAL("afwQualifier"),
    AFW_UTF8_LITERAL("Access variables of a qualifier as an object"),
    AFW_UTF8_LITERAL("This function allows the active variables for a qualifier to be accessed as the properties of an object."),
    AFW_UTF8_LITERAL("(qualifier: string, forTesting?: boolean): object"),
    AFW_UTF8_LITERAL("/* Access variables of a qualifier as an object */\nfunction qualifier (\n    qualifier: string    /* Qualifier */,\n    forTesting?: boolean /* For testing if true */\n): object; /* Variables for the specified qualifier */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_qualifier,
    NULL,
    1,
    2,
    &impl_qualifier_parameters[0],
    2,
    &impl_qualifier_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- qualifiers ---------- */

static const afw_utf8_t
impl_object_path__qualifiers =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/qualifiers");

static const afw_runtime_object_indirect_t
impl_object__qualifiers = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_qualifiers,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__qualifiers
        }
    },
    (void *)&afw_function_definition_qualifiers
};

static const afw_value_function_parameter_t
impl_qualifiers_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("All qualifiers and their variables"),
    AFW_UTF8_LITERAL("Each property is the name of a qualifier with a value that is an object whose properties are the variables of that qualifier. The value of the variable properties is influenced by the forTesting property."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_qualifiers_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("forTesting"),
    AFW_UTF8_LITERAL("For testing if true"),
    AFW_UTF8_LITERAL("If specified and true, the object returned will be suitable to pass as the additionalUntrustedQualifiedVariables parameter of evaluate*() functions. This is intended for testing purposes and should not be used in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_qualifiers_parameters[] = {
    &impl_qualifiers_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_qualifiers = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__qualifiers,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("qualifiers"),
    AFW_UTF8_LITERAL("qualifiers"),
    AFW_UTF8_LITERAL("qualifiers"),
    AFW_UTF8_LITERAL("qualifiers"),
    AFW_UTF8_LITERAL("afwQualifiers"),
    AFW_UTF8_LITERAL("Access qualifiers as an object"),
    AFW_UTF8_LITERAL("This function allows the active qualifiers to be accessed as properties of an object. The value of each of these properties is an object whose properties are the variables for the corresponding qualifier."),
    AFW_UTF8_LITERAL("(forTesting?: boolean): object"),
    AFW_UTF8_LITERAL("/* Access qualifiers as an object */\nfunction qualifiers (\n    forTesting?: boolean /* For testing if true */\n): object; /* All qualifiers and their variables */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_qualifiers,
    NULL,
    0,
    1,
    &impl_qualifiers_parameters[0],
    1,
    &impl_qualifiers_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- safe_evaluate ---------- */

static const afw_utf8_t
impl_object_path__safe_evaluate =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/safe_evaluate");

static const afw_runtime_object_indirect_t
impl_object__safe_evaluate = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_safe_evaluate,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__safe_evaluate
        }
    },
    (void *)&afw_function_definition_safe_evaluate
};

static const afw_value_function_parameter_t
impl_safe_evaluate_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Evaluated adaptive value or error value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_safe_evaluate_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to evaluated"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_safe_evaluate_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("error"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to evaluate and return if exception occurs. If an error occurs evaluating this value, the exception will continue."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_safe_evaluate_parameters[] = {
    &impl_safe_evaluate_parameter_1,
    &impl_safe_evaluate_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_safe_evaluate = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__safe_evaluate,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("safe_evaluate"),
    AFW_UTF8_LITERAL("safe_evaluate"),
    AFW_UTF8_LITERAL("safe_evaluate"),
    AFW_UTF8_LITERAL("safeEvaluate"),
    AFW_UTF8_LITERAL("afwSafeEvaluate"),
    AFW_UTF8_LITERAL("Safe evaluate"),
    AFW_UTF8_LITERAL("Return the evaluated adaptive value. If an exception occurs, return evaluated error instead."),
    AFW_UTF8_LITERAL("(value: any, error: any): any"),
    AFW_UTF8_LITERAL("/* Safe evaluate */\nfunction safe_evaluate (\n    value: any,\n    error: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_safe_evaluate,
    NULL,
    2,
    2,
    &impl_safe_evaluate_parameters[0],
    2,
    &impl_safe_evaluate_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- stringify ---------- */

static const afw_utf8_t
impl_object_path__stringify =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/stringify");

static const afw_runtime_object_indirect_t
impl_object__stringify = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_stringify,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__stringify
        }
    },
    (void *)&afw_function_definition_stringify
};

static const afw_value_function_parameter_t
impl_stringify_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Evaluated and decompiled value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_stringify_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to stringify."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_stringify_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("replacer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional replacer function."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_stringify_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("whitespace"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Add whitespace for readability if present and not 0. This parameter can be an integer between 0 and 10 or a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_stringify_parameters[] = {
    &impl_stringify_parameter_1,
    &impl_stringify_parameter_2,
    &impl_stringify_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_stringify = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__stringify,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("stringify"),
    AFW_UTF8_LITERAL("stringify"),
    AFW_UTF8_LITERAL("stringify"),
    AFW_UTF8_LITERAL("stringify"),
    AFW_UTF8_LITERAL("afwStringify"),
    AFW_UTF8_LITERAL("Evaluate and decompile a value"),
    AFW_UTF8_LITERAL("Evaluate and decompile an adaptive value to string. For most values this has the effect of producing a string containing json."),
    AFW_UTF8_LITERAL("(value: any, replacer?: any, whitespace?: any): string"),
    AFW_UTF8_LITERAL("/* Evaluate and decompile a value */\nfunction stringify (\n    value: any,\n    replacer?: any,\n    whitespace?: any\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_stringify,
    NULL,
    1,
    3,
    &impl_stringify_parameters[0],
    3,
    &impl_stringify_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- test_expression ---------- */

static const afw_utf8_t
impl_object_path__test_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/test_expression");

static const afw_runtime_object_indirect_t
impl_object__test_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_test_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__test_expression
        }
    },
    (void *)&afw_function_definition_test_expression
};

static const afw_value_function_parameter_t
impl_test_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Test results."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("id"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("description"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Description of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expression to compile and evaluate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expected"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expected result."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_test_expression_parameters[] = {
    &impl_test_expression_parameter_1,
    &impl_test_expression_parameter_2,
    &impl_test_expression_parameter_3,
    &impl_test_expression_parameter_4,
    &impl_test_expression_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__test_expression,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("test_expression"),
    AFW_UTF8_LITERAL("test_expression"),
    AFW_UTF8_LITERAL("test_expression"),
    AFW_UTF8_LITERAL("testExpression"),
    AFW_UTF8_LITERAL("afwTestExpression"),
    AFW_UTF8_LITERAL("Test expression"),
    AFW_UTF8_LITERAL("Compile and evaluate an adaptive expression and compare the results to an expected value. Return object with the test's results."),
    AFW_UTF8_LITERAL("(id: string, description: string, expression: string, expected: any, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): object"),
    AFW_UTF8_LITERAL("/* Test expression */\nfunction test_expression (\n    id: string,\n    description: string,\n    expression: string,\n    expected: any,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_test_expression,
    NULL,
    4,
    5,
    &impl_test_expression_parameters[0],
    5,
    &impl_test_expression_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- test_expression_tuple ---------- */

static const afw_utf8_t
impl_object_path__test_expression_tuple =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/test_expression_tuple");

static const afw_runtime_object_indirect_t
impl_object__test_expression_tuple = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_test_expression_tuple,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__test_expression_tuple
        }
    },
    (void *)&afw_function_definition_test_expression_tuple
};

static const afw_value_function_parameter_t
impl_test_expression_tuple_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Test results."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_tuple_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("id"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_tuple_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("description"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Description of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_tuple_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expression tuple to compile and evaluate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_tuple_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expected"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expected result."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_expression_tuple_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_test_expression_tuple_parameters[] = {
    &impl_test_expression_tuple_parameter_1,
    &impl_test_expression_tuple_parameter_2,
    &impl_test_expression_tuple_parameter_3,
    &impl_test_expression_tuple_parameter_4,
    &impl_test_expression_tuple_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_expression_tuple = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__test_expression_tuple,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("test_expression_tuple"),
    AFW_UTF8_LITERAL("test_expression_tuple"),
    AFW_UTF8_LITERAL("test_expression_tuple"),
    AFW_UTF8_LITERAL("testExpressionTuple"),
    AFW_UTF8_LITERAL("afwTestExpressionTuple"),
    AFW_UTF8_LITERAL("Test expression tuple"),
    AFW_UTF8_LITERAL("Compile and evaluate an adaptive expression tuple and compare the results to an expected value. Return object with the test's results."),
    AFW_UTF8_LITERAL("(id: string, description: string, expression: string, expected: any, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): object"),
    AFW_UTF8_LITERAL("/* Test expression tuple */\nfunction test_expression_tuple (\n    id: string,\n    description: string,\n    expression: string,\n    expected: any,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_test_expression_tuple,
    NULL,
    4,
    5,
    &impl_test_expression_tuple_parameters[0],
    5,
    &impl_test_expression_tuple_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- test_hybrid ---------- */

static const afw_utf8_t
impl_object_path__test_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/test_hybrid");

static const afw_runtime_object_indirect_t
impl_object__test_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_test_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__test_hybrid
        }
    },
    (void *)&afw_function_definition_test_hybrid
};

static const afw_value_function_parameter_t
impl_test_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Test results."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("id"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("description"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Description of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_hybrid_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Hybrid to compile and evaluate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_hybrid_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expected"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expected evaluated result."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_hybrid_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_test_hybrid_parameters[] = {
    &impl_test_hybrid_parameter_1,
    &impl_test_hybrid_parameter_2,
    &impl_test_hybrid_parameter_3,
    &impl_test_hybrid_parameter_4,
    &impl_test_hybrid_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__test_hybrid,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("test_hybrid"),
    AFW_UTF8_LITERAL("test_hybrid"),
    AFW_UTF8_LITERAL("test_hybrid"),
    AFW_UTF8_LITERAL("testHybrid"),
    AFW_UTF8_LITERAL("afwTestHybrid"),
    AFW_UTF8_LITERAL("Test hybrid"),
    AFW_UTF8_LITERAL("Compile and evaluate a string containing adaptive hybrid syntax which can be an adaptive template or adaptive expression tuple and then compare the results to an expected value. Return object with the test's results."),
    AFW_UTF8_LITERAL("(id: string, description: string, hybrid: string, expected: any, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): object"),
    AFW_UTF8_LITERAL("/* Test hybrid */\nfunction test_hybrid (\n    id: string,\n    description: string,\n    hybrid: string,\n    expected: any,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_test_hybrid,
    NULL,
    4,
    5,
    &impl_test_hybrid_parameters[0],
    5,
    &impl_test_hybrid_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- test_script ---------- */

static const afw_utf8_t
impl_object_path__test_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/test_script");

static const afw_runtime_object_indirect_t
impl_object__test_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_test_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__test_script
        }
    },
    (void *)&afw_function_definition_test_script
};

static const afw_value_function_parameter_t
impl_test_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Test results."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("id"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("description"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Description of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_script_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Script to compile and evaluate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_script_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expected"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expected result."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_script_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_test_script_parameters[] = {
    &impl_test_script_parameter_1,
    &impl_test_script_parameter_2,
    &impl_test_script_parameter_3,
    &impl_test_script_parameter_4,
    &impl_test_script_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__test_script,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("test_script"),
    AFW_UTF8_LITERAL("test_script"),
    AFW_UTF8_LITERAL("test_script"),
    AFW_UTF8_LITERAL("testScript"),
    AFW_UTF8_LITERAL("afwTestScript"),
    AFW_UTF8_LITERAL("Test an adaptive script"),
    AFW_UTF8_LITERAL("Compile and evaluate an adaptive script and compare the results to an expected value. Return object with the test's results."),
    AFW_UTF8_LITERAL("(id: string, description: string, script: string, expected: any, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): object"),
    AFW_UTF8_LITERAL("/* Test an adaptive script */\nfunction test_script (\n    id: string,\n    description: string,\n    script: string,\n    expected: any,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_test_script,
    NULL,
    4,
    5,
    &impl_test_script_parameters[0],
    5,
    &impl_test_script_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- test_script_runtime_support ---------- */

static const afw_utf8_t
impl_object_path__test_script_runtime_support =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/test_script_runtime_support");

static const afw_runtime_object_indirect_t
impl_object__test_script_runtime_support = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_test_script_runtime_support,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__test_script_runtime_support
        }
    },
    (void *)&afw_function_definition_test_script_runtime_support
};

static const afw_value_function_parameter_t
impl_test_script_runtime_support_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveTestScriptResult_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Completed test_script object"),
    AFW_UTF8_LITERAL("The testScriptObject object with test result properties set."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_script_runtime_support_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveTestScriptResult_"),
    AFW_UTF8_LITERAL("testScriptObject"),
    AFW_UTF8_LITERAL("test_script object"),
    AFW_UTF8_LITERAL("A test script results object with the required evaluation result properties missing. The sources will be evaluated and the corresponding test result properties will be set."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_test_script_runtime_support_parameters[] = {
    &impl_test_script_runtime_support_parameter_1,
    NULL
};

static const afw_utf8_t
impl_test_script_runtime_support_sideEffects[] = {
    AFW_UTF8_LITERAL("testScriptObject object modified."),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_script_runtime_support = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__test_script_runtime_support,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("test_script_runtime_support"),
    AFW_UTF8_LITERAL("test_script_runtime_support"),
    AFW_UTF8_LITERAL("test_script_runtime_support"),
    AFW_UTF8_LITERAL("testScriptRuntimeSupport"),
    AFW_UTF8_LITERAL("afwTestScriptRuntimeSupport"),
    AFW_UTF8_LITERAL("Internal test script runtime support"),
    AFW_UTF8_LITERAL("This is a function called internally as the result of a test_script compile. This function is not intended to be called directly."),
    AFW_UTF8_LITERAL("(testScriptObject: (object _AdaptiveTestScriptResult_)): (object _AdaptiveTestScriptResult_)"),
    AFW_UTF8_LITERAL("/* Internal test script runtime support */\nfunction test_script_runtime_support (\n    testScriptObject: (object _AdaptiveTestScriptResult_) /* test_script object */\n): (object _AdaptiveTestScriptResult_); /* Completed test_script object */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_test_script_runtime_support,
    NULL,
    1,
    1,
    &impl_test_script_runtime_support_parameters[0],
    1,
    &impl_test_script_runtime_support_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_test_script_runtime_support_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- test_template ---------- */

static const afw_utf8_t
impl_object_path__test_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/test_template");

static const afw_runtime_object_indirect_t
impl_object__test_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_test_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__test_template
        }
    },
    (void *)&afw_function_definition_test_template
};

static const afw_value_function_parameter_t
impl_test_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Test results."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("id"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("description"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Description of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_template_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Template to compile and evaluate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_template_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expected"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expected evaluated result."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_template_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_test_template_parameters[] = {
    &impl_test_template_parameter_1,
    &impl_test_template_parameter_2,
    &impl_test_template_parameter_3,
    &impl_test_template_parameter_4,
    &impl_test_template_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__test_template,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("test_template"),
    AFW_UTF8_LITERAL("test_template"),
    AFW_UTF8_LITERAL("test_template"),
    AFW_UTF8_LITERAL("testTemplate"),
    AFW_UTF8_LITERAL("afwTestTemplate"),
    AFW_UTF8_LITERAL("Test template"),
    AFW_UTF8_LITERAL("Compile and evaluate an adaptive template and compare the results to an expected value. Return object with the test's results."),
    AFW_UTF8_LITERAL("(id: string, description: string, template: string, expected: any, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): object"),
    AFW_UTF8_LITERAL("/* Test template */\nfunction test_template (\n    id: string,\n    description: string,\n    template: string,\n    expected: any,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_test_template,
    NULL,
    4,
    5,
    &impl_test_template_parameters[0],
    5,
    &impl_test_template_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- test_value ---------- */

static const afw_utf8_t
impl_object_path__test_value =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/test_value");

static const afw_runtime_object_indirect_t
impl_object__test_value = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_test_value,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__test_value
        }
    },
    (void *)&afw_function_definition_test_value
};

static const afw_value_function_parameter_t
impl_test_value_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Test results."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_value_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("id"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_value_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("description"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Description of test"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_value_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to evaluate"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_value_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("expected"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expected result."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_test_value_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_test_value_parameters[] = {
    &impl_test_value_parameter_1,
    &impl_test_value_parameter_2,
    &impl_test_value_parameter_3,
    &impl_test_value_parameter_4,
    &impl_test_value_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_value = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__test_value,
    AFW_UTF8_LITERAL("compiler"),
    AFW_UTF8_LITERAL("test_value"),
    AFW_UTF8_LITERAL("test_value"),
    AFW_UTF8_LITERAL("test_value"),
    AFW_UTF8_LITERAL("testValue"),
    AFW_UTF8_LITERAL("afwTestValue"),
    AFW_UTF8_LITERAL("Test value"),
    AFW_UTF8_LITERAL("Evaluate an adaptive value and compare it to an expected value. Return object with the test's results."),
    AFW_UTF8_LITERAL("(id: string, description: string, value: string, expected: any, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): object"),
    AFW_UTF8_LITERAL("/* Test value */\nfunction test_value (\n    id: string,\n    description: string,\n    value: string,\n    expected: any,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_test_value,
    NULL,
    4,
    5,
    &impl_test_value_parameters[0],
    5,
    &impl_test_value_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- add_dayTimeDuration<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__add_dayTimeDuration_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_dayTimeDuration_dateTime");

static const afw_runtime_object_indirect_t
impl_object__add_dayTimeDuration_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_dayTimeDuration_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_dayTimeDuration_dateTime
        }
    },
    (void *)&afw_function_definition_add_dayTimeDuration_dateTime
};

static const afw_value_function_parameter_t
impl_add_dayTimeDuration_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_dayTimeDuration_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_dayTimeDuration_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_dayTimeDuration_dateTime_parameters[] = {
    &impl_add_dayTimeDuration_dateTime_parameter_1,
    &impl_add_dayTimeDuration_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_dayTimeDuration_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_dayTimeDuration_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("add_dayTimeDuration<dateTime>"),
    AFW_UTF8_LITERAL("add_dayTimeDuration"),
    AFW_UTF8_LITERAL("add_dayTimeDuration_dateTime"),
    AFW_UTF8_LITERAL("addDayTimeDurationDateTime"),
    AFW_UTF8_LITERAL("afwAddDayTimeDurationDateTime"),
    AFW_UTF8_LITERAL("Add duration"),
    AFW_UTF8_LITERAL("Add dateTime arg1 to dayTimeDuration arg2 and return the dateTime result."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: dayTimeDuration): dateTime"),
    AFW_UTF8_LITERAL("/* Add duration */\nfunction add_dayTimeDuration<dateTime> (\n    arg1: dateTime,\n    arg2: dayTimeDuration\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_add_dayTimeDuration_dateTime,
    NULL,
    2,
    2,
    &impl_add_dayTimeDuration_dateTime_parameters[0],
    2,
    &impl_add_dayTimeDuration_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_add_dayTimeDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- add_yearMonthDuration<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__add_yearMonthDuration_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_yearMonthDuration_dateTime");

static const afw_runtime_object_indirect_t
impl_object__add_yearMonthDuration_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_yearMonthDuration_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_yearMonthDuration_dateTime
        }
    },
    (void *)&afw_function_definition_add_yearMonthDuration_dateTime
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_yearMonthDuration_dateTime_parameters[] = {
    &impl_add_yearMonthDuration_dateTime_parameter_1,
    &impl_add_yearMonthDuration_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_yearMonthDuration_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_yearMonthDuration_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("add_yearMonthDuration<dateTime>"),
    AFW_UTF8_LITERAL("add_yearMonthDuration"),
    AFW_UTF8_LITERAL("add_yearMonthDuration_dateTime"),
    AFW_UTF8_LITERAL("addYearMonthDurationDateTime"),
    AFW_UTF8_LITERAL("afwAddYearMonthDurationDateTime"),
    AFW_UTF8_LITERAL("Add duration"),
    AFW_UTF8_LITERAL("Add dateTime arg1 to yearMonthDuration arg2 and return the dateTime result."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: yearMonthDuration): dateTime"),
    AFW_UTF8_LITERAL("/* Add duration */\nfunction add_yearMonthDuration<dateTime> (\n    arg1: dateTime,\n    arg2: yearMonthDuration\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_add_yearMonthDuration_dateTime,
    NULL,
    2,
    2,
    &impl_add_yearMonthDuration_dateTime_parameters[0],
    2,
    &impl_add_yearMonthDuration_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_add_yearMonthDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_dateTime");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_dateTime
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_dateTime
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_dateTime_parameters[] = {
    &impl_at_least_one_member_of_dateTime_parameter_1,
    &impl_at_least_one_member_of_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("at_least_one_member_of<dateTime>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_dateTime"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfDateTime"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfDateTime"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in dateTime list1 is in dateTime list2."),
    AFW_UTF8_LITERAL("(list1: (list dateTime), list2: (list dateTime)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<dateTime> (\n    list1: (list dateTime),\n    list2: (list dateTime)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_dateTime_parameters[0],
    2,
    &impl_at_least_one_member_of_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__bag_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_dateTime");

static const afw_runtime_object_indirect_t
impl_object__bag_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_dateTime
        }
    },
    (void *)&afw_function_definition_bag_dateTime
};

static const afw_value_function_parameter_t
impl_bag_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_dateTime_parameters[] = {
    &impl_bag_dateTime_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("bag<dateTime>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_dateTime"),
    AFW_UTF8_LITERAL("bagDateTime"),
    AFW_UTF8_LITERAL("afwBagDateTime"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of dateTime values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list dateTime))): (list dateTime)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<dateTime> (\n    ...values: (list of (list dateTime))\n): (list dateTime);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_dateTime_parameters[0],
    1,
    &impl_bag_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_dateTime");

static const afw_runtime_object_indirect_t
impl_object__bag_size_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_dateTime
        }
    },
    (void *)&afw_function_definition_bag_size_dateTime
};

static const afw_value_function_parameter_t
impl_bag_size_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_dateTime_parameters[] = {
    &impl_bag_size_dateTime_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("bag_size<dateTime>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_dateTime"),
    AFW_UTF8_LITERAL("bagSizeDateTime"),
    AFW_UTF8_LITERAL("afwBagSizeDateTime"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list dateTime)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<dateTime> (\n    value: (list dateTime)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_dateTime_parameters[0],
    1,
    &impl_bag_size_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- dateTime ---------- */

static const afw_utf8_t
impl_object_path__dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/dateTime");

static const afw_runtime_object_indirect_t
impl_object__dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__dateTime
        }
    },
    (void *)&afw_function_definition_dateTime
};

static const afw_value_function_parameter_t
impl_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_dateTime_parameters[] = {
    &impl_dateTime_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_dateTime_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("afwDateTime"),
    AFW_UTF8_LITERAL("Convert to data type dateTime"),
    AFW_UTF8_LITERAL("Converts value to data type dateTime returning dateTime result."),
    AFW_UTF8_LITERAL("(value: any): dateTime"),
    AFW_UTF8_LITERAL("/* Convert to data type dateTime */\nfunction dateTime (\n    value: any\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_dateTime_parameters[0],
    1,
    &impl_dateTime_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_dateTime_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__eq_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_dateTime");

static const afw_runtime_object_indirect_t
impl_object__eq_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_dateTime
        }
    },
    (void *)&afw_function_definition_eq_dateTime
};

static const afw_value_function_parameter_t
impl_eq_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_dateTime_parameters[] = {
    &impl_eq_dateTime_parameter_1,
    &impl_eq_dateTime_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_dateTime_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("eq<dateTime>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_dateTime"),
    AFW_UTF8_LITERAL("eqDateTime"),
    AFW_UTF8_LITERAL("afwEqDateTime"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if dateTime arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<dateTime> (\n    arg1: dateTime,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_dateTime_parameters[0],
    2,
    &impl_eq_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    &impl_eq_dateTime_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__eqx_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_dateTime");

static const afw_runtime_object_indirect_t
impl_object__eqx_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_dateTime
        }
    },
    (void *)&afw_function_definition_eqx_dateTime
};

static const afw_value_function_parameter_t
impl_eqx_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_dateTime_parameters[] = {
    &impl_eqx_dateTime_parameter_1,
    &impl_eqx_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("eqx<dateTime>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_dateTime"),
    AFW_UTF8_LITERAL("eqxDateTime"),
    AFW_UTF8_LITERAL("afwEqxDateTime"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for dateTime arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<dateTime> (\n    arg1: dateTime,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_dateTime_parameters[0],
    2,
    &impl_eqx_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__ge_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_dateTime");

static const afw_runtime_object_indirect_t
impl_object__ge_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_dateTime
        }
    },
    (void *)&afw_function_definition_ge_dateTime
};

static const afw_value_function_parameter_t
impl_ge_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_dateTime_parameters[] = {
    &impl_ge_dateTime_parameter_1,
    &impl_ge_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("ge<dateTime>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_dateTime"),
    AFW_UTF8_LITERAL("geDateTime"),
    AFW_UTF8_LITERAL("afwGeDateTime"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for dateTime arg1 is greater than or equal to dateTime arg2 and return the boolean result.\n\nIf a dateTime value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: dateTime): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<dateTime> (\n    arg1: dateTime,\n    arg2: dateTime\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_dateTime_parameters[0],
    2,
    &impl_ge_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__gt_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_dateTime");

static const afw_runtime_object_indirect_t
impl_object__gt_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_dateTime
        }
    },
    (void *)&afw_function_definition_gt_dateTime
};

static const afw_value_function_parameter_t
impl_gt_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_dateTime_parameters[] = {
    &impl_gt_dateTime_parameter_1,
    &impl_gt_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("gt<dateTime>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_dateTime"),
    AFW_UTF8_LITERAL("gtDateTime"),
    AFW_UTF8_LITERAL("afwGtDateTime"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for dateTime arg1 is greater than dateTime arg2 and return the boolean result.\n\nIf a dateTime value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: dateTime): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<dateTime> (\n    arg1: dateTime,\n    arg2: dateTime\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_dateTime_parameters[0],
    2,
    &impl_gt_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__intersection_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_dateTime");

static const afw_runtime_object_indirect_t
impl_object__intersection_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_dateTime
        }
    },
    (void *)&afw_function_definition_intersection_dateTime
};

static const afw_value_function_parameter_t
impl_intersection_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_dateTime_parameters[] = {
    &impl_intersection_dateTime_parameter_1,
    &impl_intersection_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("intersection<dateTime>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_dateTime"),
    AFW_UTF8_LITERAL("intersectionDateTime"),
    AFW_UTF8_LITERAL("afwIntersectionDateTime"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of dateTime with the values that are common to both list of dateTime list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list dateTime), list2: (list dateTime)): (list dateTime)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<dateTime> (\n    list1: (list dateTime),\n    list2: (list dateTime)\n): (list dateTime);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_dateTime_parameters[0],
    2,
    &impl_intersection_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__is_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_dateTime");

static const afw_runtime_object_indirect_t
impl_object__is_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_dateTime
        }
    },
    (void *)&afw_function_definition_is_dateTime
};

static const afw_value_function_parameter_t
impl_is_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_dateTime_parameters[] = {
    &impl_is_dateTime_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("is<dateTime>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_dateTime"),
    AFW_UTF8_LITERAL("isDateTime"),
    AFW_UTF8_LITERAL("afwIsDateTime"),
    AFW_UTF8_LITERAL("Checks whether value is dataType dateTime"),
    AFW_UTF8_LITERAL("Checks whether value is dataType dateTime and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType dateTime */\nfunction is<dateTime> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_dateTime_parameters[0],
    1,
    &impl_is_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__is_in_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_dateTime");

static const afw_runtime_object_indirect_t
impl_object__is_in_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_dateTime
        }
    },
    (void *)&afw_function_definition_is_in_dateTime
};

static const afw_value_function_parameter_t
impl_is_in_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_dateTime_parameters[] = {
    &impl_is_in_dateTime_parameter_1,
    &impl_is_in_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("is_in<dateTime>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_dateTime"),
    AFW_UTF8_LITERAL("isInDateTime"),
    AFW_UTF8_LITERAL("afwIsInDateTime"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether dateTime value is in list of dateTime list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: dateTime, list: (list dateTime)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<dateTime> (\n    value: dateTime,\n    list: (list dateTime)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_dateTime_parameters[0],
    2,
    &impl_is_in_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__le_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_dateTime");

static const afw_runtime_object_indirect_t
impl_object__le_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_dateTime
        }
    },
    (void *)&afw_function_definition_le_dateTime
};

static const afw_value_function_parameter_t
impl_le_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_dateTime_parameters[] = {
    &impl_le_dateTime_parameter_1,
    &impl_le_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("le<dateTime>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_dateTime"),
    AFW_UTF8_LITERAL("leDateTime"),
    AFW_UTF8_LITERAL("afwLeDateTime"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for dateTime arg1 is less than or equal to dateTime arg2 and return the boolean result.\n\nIf a dateTime value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<dateTime> (\n    arg1: dateTime,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_dateTime_parameters[0],
    2,
    &impl_le_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__lt_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_dateTime");

static const afw_runtime_object_indirect_t
impl_object__lt_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_dateTime
        }
    },
    (void *)&afw_function_definition_lt_dateTime
};

static const afw_value_function_parameter_t
impl_lt_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_dateTime_parameters[] = {
    &impl_lt_dateTime_parameter_1,
    &impl_lt_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("lt<dateTime>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_dateTime"),
    AFW_UTF8_LITERAL("ltDateTime"),
    AFW_UTF8_LITERAL("afwLtDateTime"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for dateTime arg1 is less that dateTime arg2 and return the boolean result.\n\nIf a dateTime value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: dateTime): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<dateTime> (\n    arg1: dateTime,\n    arg2: dateTime\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_dateTime_parameters[0],
    2,
    &impl_lt_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- max<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__max_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/max_dateTime");

static const afw_runtime_object_indirect_t
impl_object__max_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_max_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__max_dateTime
        }
    },
    (void *)&afw_function_definition_max_dateTime
};

static const afw_value_function_parameter_t
impl_max_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_max_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_max_dateTime_parameters[] = {
    &impl_max_dateTime_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__max_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("max<dateTime>"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max_dateTime"),
    AFW_UTF8_LITERAL("maxDateTime"),
    AFW_UTF8_LITERAL("afwMaxDateTime"),
    AFW_UTF8_LITERAL("Maximum value"),
    AFW_UTF8_LITERAL("Return the dateTime value that is greater than or equal to the others.\n\nIf a dateTime value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(values_1: dateTime, ...values_rest: (list of dateTime)): dateTime"),
    AFW_UTF8_LITERAL("/* Maximum value */\nfunction max<dateTime> (\n    values_1: dateTime,\n    ...values_rest: (list of dateTime)\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_max,
    NULL,
    1,
    -1,
    &impl_max_dateTime_parameters[0],
    1,
    &impl_max_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_max,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- min<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__min_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/min_dateTime");

static const afw_runtime_object_indirect_t
impl_object__min_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_min_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__min_dateTime
        }
    },
    (void *)&afw_function_definition_min_dateTime
};

static const afw_value_function_parameter_t
impl_min_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_min_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_min_dateTime_parameters[] = {
    &impl_min_dateTime_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__min_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("min<dateTime>"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min_dateTime"),
    AFW_UTF8_LITERAL("minDateTime"),
    AFW_UTF8_LITERAL("afwMinDateTime"),
    AFW_UTF8_LITERAL("Minimum value"),
    AFW_UTF8_LITERAL("Return the dateTime value that is less than or equal to the others.\n\nIf a dateTime value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(values_1: dateTime, ...values_rest: (list of dateTime)): dateTime"),
    AFW_UTF8_LITERAL("/* Minimum value */\nfunction min<dateTime> (\n    values_1: dateTime,\n    ...values_rest: (list of dateTime)\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_min,
    NULL,
    1,
    -1,
    &impl_min_dateTime_parameters[0],
    1,
    &impl_min_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_min,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__ne_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_dateTime");

static const afw_runtime_object_indirect_t
impl_object__ne_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_dateTime
        }
    },
    (void *)&afw_function_definition_ne_dateTime
};

static const afw_value_function_parameter_t
impl_ne_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_dateTime_parameters[] = {
    &impl_ne_dateTime_parameter_1,
    &impl_ne_dateTime_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_dateTime_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("ne<dateTime>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_dateTime"),
    AFW_UTF8_LITERAL("neDateTime"),
    AFW_UTF8_LITERAL("afwNeDateTime"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if dateTime arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<dateTime> (\n    arg1: dateTime,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_dateTime_parameters[0],
    2,
    &impl_ne_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    &impl_ne_dateTime_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__nex_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_dateTime");

static const afw_runtime_object_indirect_t
impl_object__nex_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_dateTime
        }
    },
    (void *)&afw_function_definition_nex_dateTime
};

static const afw_value_function_parameter_t
impl_nex_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_dateTime_parameters[] = {
    &impl_nex_dateTime_parameter_1,
    &impl_nex_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("nex<dateTime>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_dateTime"),
    AFW_UTF8_LITERAL("nexDateTime"),
    AFW_UTF8_LITERAL("afwNexDateTime"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for dateTime arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<dateTime> (\n    arg1: dateTime,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_dateTime_parameters[0],
    2,
    &impl_nex_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_dateTime");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_dateTime
        }
    },
    (void *)&afw_function_definition_one_and_only_dateTime
};

static const afw_value_function_parameter_t
impl_one_and_only_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_dateTime_parameters[] = {
    &impl_one_and_only_dateTime_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_dateTime_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("one_and_only<dateTime>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_dateTime"),
    AFW_UTF8_LITERAL("oneAndOnlyDateTime"),
    AFW_UTF8_LITERAL("afwOneAndOnlyDateTime"),
    AFW_UTF8_LITERAL("Converts a one value list to a dateTime value"),
    AFW_UTF8_LITERAL("This converts a list of dateTime values that contains one value to a single dateTime value."),
    AFW_UTF8_LITERAL("(list: (list list)): dateTime"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a dateTime value */\nfunction one_and_only<dateTime> (\n    list: (list list)\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_dateTime_parameters[0],
    1,
    &impl_one_and_only_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    &impl_one_and_only_dateTime_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_dateTime");

static const afw_runtime_object_indirect_t
impl_object__set_equals_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_dateTime
        }
    },
    (void *)&afw_function_definition_set_equals_dateTime
};

static const afw_value_function_parameter_t
impl_set_equals_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_dateTime_parameters[] = {
    &impl_set_equals_dateTime_parameter_1,
    &impl_set_equals_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("set_equals<dateTime>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_dateTime"),
    AFW_UTF8_LITERAL("setEqualsDateTime"),
    AFW_UTF8_LITERAL("afwSetEqualsDateTime"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if dateTime list1 and dateTime list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list dateTime), list2: (list dateTime)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<dateTime> (\n    list1: (list dateTime),\n    list2: (list dateTime)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_dateTime_parameters[0],
    2,
    &impl_set_equals_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__subset_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_dateTime");

static const afw_runtime_object_indirect_t
impl_object__subset_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_dateTime
        }
    },
    (void *)&afw_function_definition_subset_dateTime
};

static const afw_value_function_parameter_t
impl_subset_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_dateTime_parameters[] = {
    &impl_subset_dateTime_parameter_1,
    &impl_subset_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("subset<dateTime>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_dateTime"),
    AFW_UTF8_LITERAL("subsetDateTime"),
    AFW_UTF8_LITERAL("afwSubsetDateTime"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in dateTime list1 are all in dateTime list2."),
    AFW_UTF8_LITERAL("(list1: (list dateTime), list2: (list dateTime)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<dateTime> (\n    list1: (list dateTime),\n    list2: (list dateTime)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_dateTime_parameters[0],
    2,
    &impl_subset_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subtract_dayTimeDuration<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__subtract_dayTimeDuration_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract_dayTimeDuration_dateTime");

static const afw_runtime_object_indirect_t
impl_object__subtract_dayTimeDuration_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract_dayTimeDuration_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract_dayTimeDuration_dateTime
        }
    },
    (void *)&afw_function_definition_subtract_dayTimeDuration_dateTime
};

static const afw_value_function_parameter_t
impl_subtract_dayTimeDuration_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_dayTimeDuration_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_dayTimeDuration_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_dayTimeDuration_dateTime_parameters[] = {
    &impl_subtract_dayTimeDuration_dateTime_parameter_1,
    &impl_subtract_dayTimeDuration_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_dayTimeDuration_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract_dayTimeDuration_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("subtract_dayTimeDuration<dateTime>"),
    AFW_UTF8_LITERAL("subtract_dayTimeDuration"),
    AFW_UTF8_LITERAL("subtract_dayTimeDuration_dateTime"),
    AFW_UTF8_LITERAL("subtractDayTimeDurationDateTime"),
    AFW_UTF8_LITERAL("afwSubtractDayTimeDurationDateTime"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract dayTimeDuration arg2 from dateTime arg1 and return the dateTime result."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: dayTimeDuration): dateTime"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract_dayTimeDuration<dateTime> (\n    arg1: dateTime,\n    arg2: dayTimeDuration\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subtract_dayTimeDuration_dateTime,
    NULL,
    2,
    2,
    &impl_subtract_dayTimeDuration_dateTime_parameters[0],
    2,
    &impl_subtract_dayTimeDuration_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_subtract_dayTimeDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subtract_yearMonthDuration<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__subtract_yearMonthDuration_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract_yearMonthDuration_dateTime");

static const afw_runtime_object_indirect_t
impl_object__subtract_yearMonthDuration_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract_yearMonthDuration_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract_yearMonthDuration_dateTime
        }
    },
    (void *)&afw_function_definition_subtract_yearMonthDuration_dateTime
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_dateTime_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_yearMonthDuration_dateTime_parameters[] = {
    &impl_subtract_yearMonthDuration_dateTime_parameter_1,
    &impl_subtract_yearMonthDuration_dateTime_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_yearMonthDuration_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract_yearMonthDuration_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration<dateTime>"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration_dateTime"),
    AFW_UTF8_LITERAL("subtractYearMonthDurationDateTime"),
    AFW_UTF8_LITERAL("afwSubtractYearMonthDurationDateTime"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract yearMonthDuration arg2 from dateTime arg1 and return the dateTime result."),
    AFW_UTF8_LITERAL("(arg1: dateTime, arg2: yearMonthDuration): dateTime"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract_yearMonthDuration<dateTime> (\n    arg1: dateTime,\n    arg2: yearMonthDuration\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subtract_yearMonthDuration_dateTime,
    NULL,
    2,
    2,
    &impl_subtract_yearMonthDuration_dateTime_parameters[0],
    2,
    &impl_subtract_yearMonthDuration_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_subtract_yearMonthDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__to_string_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_dateTime");

static const afw_runtime_object_indirect_t
impl_object__to_string_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_dateTime
        }
    },
    (void *)&afw_function_definition_to_string_dateTime
};

static const afw_value_function_parameter_t
impl_to_string_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A dateTime value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_dateTime_parameters[] = {
    &impl_to_string_dateTime_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("to_string<dateTime>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_dateTime"),
    AFW_UTF8_LITERAL("toStringDateTime"),
    AFW_UTF8_LITERAL("afwToStringDateTime"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts dateTime value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: dateTime): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<dateTime> (\n    value: dateTime\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_dateTime_parameters[0],
    1,
    &impl_to_string_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<dateTime> ---------- */

static const afw_utf8_t
impl_object_path__union_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_dateTime");

static const afw_runtime_object_indirect_t
impl_object__union_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_dateTime
        }
    },
    (void *)&afw_function_definition_union_dateTime
};

static const afw_value_function_parameter_t
impl_union_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_dateTime_parameters[] = {
    &impl_union_dateTime_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_dateTime,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("union<dateTime>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_dateTime"),
    AFW_UTF8_LITERAL("unionDateTime"),
    AFW_UTF8_LITERAL("afwUnionDateTime"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of dateTime contains all of the unique values in two or more list of dateTime values."),
    AFW_UTF8_LITERAL("(lists_1: (list dateTime), lists_2: (list dateTime), ...lists_rest: (list of (list dateTime))): (list dateTime)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<dateTime> (\n    lists_1: (list dateTime),\n    lists_2: (list dateTime),\n    ...lists_rest: (list of (list dateTime))\n): (list dateTime);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_dateTime_parameters[0],
    1,
    &impl_union_dateTime_returns,
    NULL,
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- add_yearMonthDuration<date> ---------- */

static const afw_utf8_t
impl_object_path__add_yearMonthDuration_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_yearMonthDuration_date");

static const afw_runtime_object_indirect_t
impl_object__add_yearMonthDuration_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_yearMonthDuration_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_yearMonthDuration_date
        }
    },
    (void *)&afw_function_definition_add_yearMonthDuration_date
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_yearMonthDuration_date_parameters[] = {
    &impl_add_yearMonthDuration_date_parameter_1,
    &impl_add_yearMonthDuration_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_yearMonthDuration_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_yearMonthDuration_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("add_yearMonthDuration<date>"),
    AFW_UTF8_LITERAL("add_yearMonthDuration"),
    AFW_UTF8_LITERAL("add_yearMonthDuration_date"),
    AFW_UTF8_LITERAL("addYearMonthDurationDate"),
    AFW_UTF8_LITERAL("afwAddYearMonthDurationDate"),
    AFW_UTF8_LITERAL("Add duration"),
    AFW_UTF8_LITERAL("Add date arg1 to yearMonthDuration arg2 and return the date result."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: yearMonthDuration): date"),
    AFW_UTF8_LITERAL("/* Add duration */\nfunction add_yearMonthDuration<date> (\n    arg1: date,\n    arg2: yearMonthDuration\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_add_yearMonthDuration_date,
    NULL,
    2,
    2,
    &impl_add_yearMonthDuration_date_parameters[0],
    2,
    &impl_add_yearMonthDuration_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_add_yearMonthDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<date> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_date");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_date
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_date
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_date_parameters[] = {
    &impl_at_least_one_member_of_date_parameter_1,
    &impl_at_least_one_member_of_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("at_least_one_member_of<date>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_date"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfDate"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfDate"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in date list1 is in date list2."),
    AFW_UTF8_LITERAL("(list1: (list date), list2: (list date)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<date> (\n    list1: (list date),\n    list2: (list date)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_date_parameters[0],
    2,
    &impl_at_least_one_member_of_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<date> ---------- */

static const afw_utf8_t
impl_object_path__bag_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_date");

static const afw_runtime_object_indirect_t
impl_object__bag_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_date
        }
    },
    (void *)&afw_function_definition_bag_date
};

static const afw_value_function_parameter_t
impl_bag_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_date_parameters[] = {
    &impl_bag_date_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("bag<date>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_date"),
    AFW_UTF8_LITERAL("bagDate"),
    AFW_UTF8_LITERAL("afwBagDate"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of date values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list date))): (list date)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<date> (\n    ...values: (list of (list date))\n): (list date);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_date_parameters[0],
    1,
    &impl_bag_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<date> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_date");

static const afw_runtime_object_indirect_t
impl_object__bag_size_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_date
        }
    },
    (void *)&afw_function_definition_bag_size_date
};

static const afw_value_function_parameter_t
impl_bag_size_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_date_parameters[] = {
    &impl_bag_size_date_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("bag_size<date>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_date"),
    AFW_UTF8_LITERAL("bagSizeDate"),
    AFW_UTF8_LITERAL("afwBagSizeDate"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list date)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<date> (\n    value: (list date)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_date_parameters[0],
    1,
    &impl_bag_size_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- date ---------- */

static const afw_utf8_t
impl_object_path__date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/date");

static const afw_runtime_object_indirect_t
impl_object__date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__date
        }
    },
    (void *)&afw_function_definition_date
};

static const afw_value_function_parameter_t
impl_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_date_parameters[] = {
    &impl_date_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_date_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("afwDate"),
    AFW_UTF8_LITERAL("Convert to data type date"),
    AFW_UTF8_LITERAL("Converts value to data type date returning date result."),
    AFW_UTF8_LITERAL("(value: any): date"),
    AFW_UTF8_LITERAL("/* Convert to data type date */\nfunction date (\n    value: any\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_date_parameters[0],
    1,
    &impl_date_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_date_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<date> ---------- */

static const afw_utf8_t
impl_object_path__eq_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_date");

static const afw_runtime_object_indirect_t
impl_object__eq_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_date
        }
    },
    (void *)&afw_function_definition_eq_date
};

static const afw_value_function_parameter_t
impl_eq_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_date_parameters[] = {
    &impl_eq_date_parameter_1,
    &impl_eq_date_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_date_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("eq<date>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_date"),
    AFW_UTF8_LITERAL("eqDate"),
    AFW_UTF8_LITERAL("afwEqDate"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if date arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<date> (\n    arg1: date,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_date_parameters[0],
    2,
    &impl_eq_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    &impl_eq_date_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<date> ---------- */

static const afw_utf8_t
impl_object_path__eqx_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_date");

static const afw_runtime_object_indirect_t
impl_object__eqx_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_date
        }
    },
    (void *)&afw_function_definition_eqx_date
};

static const afw_value_function_parameter_t
impl_eqx_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_date_parameters[] = {
    &impl_eqx_date_parameter_1,
    &impl_eqx_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("eqx<date>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_date"),
    AFW_UTF8_LITERAL("eqxDate"),
    AFW_UTF8_LITERAL("afwEqxDate"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for date arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<date> (\n    arg1: date,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_date_parameters[0],
    2,
    &impl_eqx_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<date> ---------- */

static const afw_utf8_t
impl_object_path__ge_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_date");

static const afw_runtime_object_indirect_t
impl_object__ge_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_date
        }
    },
    (void *)&afw_function_definition_ge_date
};

static const afw_value_function_parameter_t
impl_ge_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_date_parameters[] = {
    &impl_ge_date_parameter_1,
    &impl_ge_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("ge<date>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_date"),
    AFW_UTF8_LITERAL("geDate"),
    AFW_UTF8_LITERAL("afwGeDate"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for date arg1 is greater than or equal to date arg2 and return the boolean result.\n\nIf a date value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: date): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<date> (\n    arg1: date,\n    arg2: date\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_date_parameters[0],
    2,
    &impl_ge_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<date> ---------- */

static const afw_utf8_t
impl_object_path__gt_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_date");

static const afw_runtime_object_indirect_t
impl_object__gt_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_date
        }
    },
    (void *)&afw_function_definition_gt_date
};

static const afw_value_function_parameter_t
impl_gt_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_date_parameters[] = {
    &impl_gt_date_parameter_1,
    &impl_gt_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("gt<date>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_date"),
    AFW_UTF8_LITERAL("gtDate"),
    AFW_UTF8_LITERAL("afwGtDate"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for date arg1 is greater than date arg2 and return the boolean result.\n\nIf a date value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: date): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<date> (\n    arg1: date,\n    arg2: date\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_date_parameters[0],
    2,
    &impl_gt_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<date> ---------- */

static const afw_utf8_t
impl_object_path__intersection_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_date");

static const afw_runtime_object_indirect_t
impl_object__intersection_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_date
        }
    },
    (void *)&afw_function_definition_intersection_date
};

static const afw_value_function_parameter_t
impl_intersection_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_date_parameters[] = {
    &impl_intersection_date_parameter_1,
    &impl_intersection_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("intersection<date>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_date"),
    AFW_UTF8_LITERAL("intersectionDate"),
    AFW_UTF8_LITERAL("afwIntersectionDate"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of date with the values that are common to both list of date list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list date), list2: (list date)): (list date)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<date> (\n    list1: (list date),\n    list2: (list date)\n): (list date);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_date_parameters[0],
    2,
    &impl_intersection_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<date> ---------- */

static const afw_utf8_t
impl_object_path__is_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_date");

static const afw_runtime_object_indirect_t
impl_object__is_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_date
        }
    },
    (void *)&afw_function_definition_is_date
};

static const afw_value_function_parameter_t
impl_is_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_date_parameters[] = {
    &impl_is_date_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("is<date>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_date"),
    AFW_UTF8_LITERAL("isDate"),
    AFW_UTF8_LITERAL("afwIsDate"),
    AFW_UTF8_LITERAL("Checks whether value is dataType date"),
    AFW_UTF8_LITERAL("Checks whether value is dataType date and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType date */\nfunction is<date> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_date_parameters[0],
    1,
    &impl_is_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<date> ---------- */

static const afw_utf8_t
impl_object_path__is_in_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_date");

static const afw_runtime_object_indirect_t
impl_object__is_in_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_date
        }
    },
    (void *)&afw_function_definition_is_in_date
};

static const afw_value_function_parameter_t
impl_is_in_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_date_parameters[] = {
    &impl_is_in_date_parameter_1,
    &impl_is_in_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("is_in<date>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_date"),
    AFW_UTF8_LITERAL("isInDate"),
    AFW_UTF8_LITERAL("afwIsInDate"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether date value is in list of date list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: date, list: (list date)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<date> (\n    value: date,\n    list: (list date)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_date_parameters[0],
    2,
    &impl_is_in_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<date> ---------- */

static const afw_utf8_t
impl_object_path__le_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_date");

static const afw_runtime_object_indirect_t
impl_object__le_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_date
        }
    },
    (void *)&afw_function_definition_le_date
};

static const afw_value_function_parameter_t
impl_le_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_date_parameters[] = {
    &impl_le_date_parameter_1,
    &impl_le_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("le<date>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_date"),
    AFW_UTF8_LITERAL("leDate"),
    AFW_UTF8_LITERAL("afwLeDate"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for date arg1 is less than or equal to date arg2 and return the boolean result.\n\nIf a date value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<date> (\n    arg1: date,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_date_parameters[0],
    2,
    &impl_le_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<date> ---------- */

static const afw_utf8_t
impl_object_path__lt_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_date");

static const afw_runtime_object_indirect_t
impl_object__lt_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_date
        }
    },
    (void *)&afw_function_definition_lt_date
};

static const afw_value_function_parameter_t
impl_lt_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_date_parameters[] = {
    &impl_lt_date_parameter_1,
    &impl_lt_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("lt<date>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_date"),
    AFW_UTF8_LITERAL("ltDate"),
    AFW_UTF8_LITERAL("afwLtDate"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for date arg1 is less that date arg2 and return the boolean result.\n\nIf a date value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: date): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<date> (\n    arg1: date,\n    arg2: date\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_date_parameters[0],
    2,
    &impl_lt_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- max<date> ---------- */

static const afw_utf8_t
impl_object_path__max_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/max_date");

static const afw_runtime_object_indirect_t
impl_object__max_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_max_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__max_date
        }
    },
    (void *)&afw_function_definition_max_date
};

static const afw_value_function_parameter_t
impl_max_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_max_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_max_date_parameters[] = {
    &impl_max_date_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__max_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("max<date>"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max_date"),
    AFW_UTF8_LITERAL("maxDate"),
    AFW_UTF8_LITERAL("afwMaxDate"),
    AFW_UTF8_LITERAL("Maximum value"),
    AFW_UTF8_LITERAL("Return the date value that is greater than or equal to the others..\n\nIf a date value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(values_1: date, ...values_rest: (list of date)): date"),
    AFW_UTF8_LITERAL("/* Maximum value */\nfunction max<date> (\n    values_1: date,\n    ...values_rest: (list of date)\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_max,
    NULL,
    1,
    -1,
    &impl_max_date_parameters[0],
    1,
    &impl_max_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_max,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- min<date> ---------- */

static const afw_utf8_t
impl_object_path__min_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/min_date");

static const afw_runtime_object_indirect_t
impl_object__min_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_min_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__min_date
        }
    },
    (void *)&afw_function_definition_min_date
};

static const afw_value_function_parameter_t
impl_min_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_min_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_min_date_parameters[] = {
    &impl_min_date_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__min_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("min<date>"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min_date"),
    AFW_UTF8_LITERAL("minDate"),
    AFW_UTF8_LITERAL("afwMinDate"),
    AFW_UTF8_LITERAL("Minimum value"),
    AFW_UTF8_LITERAL("Return the date value that is less than or equal to the others..\n\nIf a date value does not include a time-zone value, then the local time-zone value will be assigned."),
    AFW_UTF8_LITERAL("(values_1: date, ...values_rest: (list of date)): date"),
    AFW_UTF8_LITERAL("/* Minimum value */\nfunction min<date> (\n    values_1: date,\n    ...values_rest: (list of date)\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_min,
    NULL,
    1,
    -1,
    &impl_min_date_parameters[0],
    1,
    &impl_min_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_min,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<date> ---------- */

static const afw_utf8_t
impl_object_path__ne_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_date");

static const afw_runtime_object_indirect_t
impl_object__ne_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_date
        }
    },
    (void *)&afw_function_definition_ne_date
};

static const afw_value_function_parameter_t
impl_ne_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_date_parameters[] = {
    &impl_ne_date_parameter_1,
    &impl_ne_date_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_date_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("ne<date>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_date"),
    AFW_UTF8_LITERAL("neDate"),
    AFW_UTF8_LITERAL("afwNeDate"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if date arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<date> (\n    arg1: date,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_date_parameters[0],
    2,
    &impl_ne_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    &impl_ne_date_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<date> ---------- */

static const afw_utf8_t
impl_object_path__nex_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_date");

static const afw_runtime_object_indirect_t
impl_object__nex_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_date
        }
    },
    (void *)&afw_function_definition_nex_date
};

static const afw_value_function_parameter_t
impl_nex_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_date_parameters[] = {
    &impl_nex_date_parameter_1,
    &impl_nex_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("nex<date>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_date"),
    AFW_UTF8_LITERAL("nexDate"),
    AFW_UTF8_LITERAL("afwNexDate"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for date arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<date> (\n    arg1: date,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_date_parameters[0],
    2,
    &impl_nex_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<date> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_date");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_date
        }
    },
    (void *)&afw_function_definition_one_and_only_date
};

static const afw_value_function_parameter_t
impl_one_and_only_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_date_parameters[] = {
    &impl_one_and_only_date_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_date_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("one_and_only<date>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_date"),
    AFW_UTF8_LITERAL("oneAndOnlyDate"),
    AFW_UTF8_LITERAL("afwOneAndOnlyDate"),
    AFW_UTF8_LITERAL("Converts a one value list to a date value"),
    AFW_UTF8_LITERAL("This converts a list of date values that contains one value to a single date value."),
    AFW_UTF8_LITERAL("(list: (list list)): date"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a date value */\nfunction one_and_only<date> (\n    list: (list list)\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_date_parameters[0],
    1,
    &impl_one_and_only_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    &impl_one_and_only_date_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<date> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_date");

static const afw_runtime_object_indirect_t
impl_object__set_equals_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_date
        }
    },
    (void *)&afw_function_definition_set_equals_date
};

static const afw_value_function_parameter_t
impl_set_equals_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_date_parameters[] = {
    &impl_set_equals_date_parameter_1,
    &impl_set_equals_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("set_equals<date>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_date"),
    AFW_UTF8_LITERAL("setEqualsDate"),
    AFW_UTF8_LITERAL("afwSetEqualsDate"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if date list1 and date list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list date), list2: (list date)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<date> (\n    list1: (list date),\n    list2: (list date)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_date_parameters[0],
    2,
    &impl_set_equals_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<date> ---------- */

static const afw_utf8_t
impl_object_path__subset_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_date");

static const afw_runtime_object_indirect_t
impl_object__subset_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_date
        }
    },
    (void *)&afw_function_definition_subset_date
};

static const afw_value_function_parameter_t
impl_subset_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_date_parameters[] = {
    &impl_subset_date_parameter_1,
    &impl_subset_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("subset<date>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_date"),
    AFW_UTF8_LITERAL("subsetDate"),
    AFW_UTF8_LITERAL("afwSubsetDate"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in date list1 are all in date list2."),
    AFW_UTF8_LITERAL("(list1: (list date), list2: (list date)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<date> (\n    list1: (list date),\n    list2: (list date)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_date_parameters[0],
    2,
    &impl_subset_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subtract_yearMonthDuration<date> ---------- */

static const afw_utf8_t
impl_object_path__subtract_yearMonthDuration_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract_yearMonthDuration_date");

static const afw_runtime_object_indirect_t
impl_object__subtract_yearMonthDuration_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract_yearMonthDuration_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract_yearMonthDuration_date
        }
    },
    (void *)&afw_function_definition_subtract_yearMonthDuration_date
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_date_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_yearMonthDuration_date_parameters[] = {
    &impl_subtract_yearMonthDuration_date_parameter_1,
    &impl_subtract_yearMonthDuration_date_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_yearMonthDuration_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract_yearMonthDuration_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration<date>"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration_date"),
    AFW_UTF8_LITERAL("subtractYearMonthDurationDate"),
    AFW_UTF8_LITERAL("afwSubtractYearMonthDurationDate"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract yearMonthDuration arg2 from date arg1 and return the date result."),
    AFW_UTF8_LITERAL("(arg1: date, arg2: yearMonthDuration): date"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract_yearMonthDuration<date> (\n    arg1: date,\n    arg2: yearMonthDuration\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subtract_yearMonthDuration_date,
    NULL,
    2,
    2,
    &impl_subtract_yearMonthDuration_date_parameters[0],
    2,
    &impl_subtract_yearMonthDuration_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_subtract_yearMonthDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<date> ---------- */

static const afw_utf8_t
impl_object_path__to_string_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_date");

static const afw_runtime_object_indirect_t
impl_object__to_string_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_date
        }
    },
    (void *)&afw_function_definition_to_string_date
};

static const afw_value_function_parameter_t
impl_to_string_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A date value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_date_parameters[] = {
    &impl_to_string_date_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("to_string<date>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_date"),
    AFW_UTF8_LITERAL("toStringDate"),
    AFW_UTF8_LITERAL("afwToStringDate"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts date value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: date): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<date> (\n    value: date\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_date_parameters[0],
    1,
    &impl_to_string_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<date> ---------- */

static const afw_utf8_t
impl_object_path__union_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_date");

static const afw_runtime_object_indirect_t
impl_object__union_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_date
        }
    },
    (void *)&afw_function_definition_union_date
};

static const afw_value_function_parameter_t
impl_union_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_date_parameters[] = {
    &impl_union_date_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_date,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("union<date>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_date"),
    AFW_UTF8_LITERAL("unionDate"),
    AFW_UTF8_LITERAL("afwUnionDate"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of date contains all of the unique values in two or more list of date values."),
    AFW_UTF8_LITERAL("(lists_1: (list date), lists_2: (list date), ...lists_rest: (list of (list date))): (list date)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<date> (\n    lists_1: (list date),\n    lists_2: (list date),\n    ...lists_rest: (list of (list date))\n): (list date);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_date_parameters[0],
    1,
    &impl_union_date_returns,
    NULL,
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_dayTimeDuration_parameters[] = {
    &impl_at_least_one_member_of_dayTimeDuration_parameter_1,
    &impl_at_least_one_member_of_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("at_least_one_member_of<dayTimeDuration>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_dayTimeDuration"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfDayTimeDuration"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in dayTimeDuration list1 is in dayTimeDuration list2."),
    AFW_UTF8_LITERAL("(list1: (list dayTimeDuration), list2: (list dayTimeDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<dayTimeDuration> (\n    list1: (list dayTimeDuration),\n    list2: (list dayTimeDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_dayTimeDuration_parameters[0],
    2,
    &impl_at_least_one_member_of_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__bag_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__bag_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_bag_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_bag_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_dayTimeDuration_parameters[] = {
    &impl_bag_dayTimeDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("bag<dayTimeDuration>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_dayTimeDuration"),
    AFW_UTF8_LITERAL("bagDayTimeDuration"),
    AFW_UTF8_LITERAL("afwBagDayTimeDuration"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of dayTimeDuration values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list dayTimeDuration))): (list dayTimeDuration)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<dayTimeDuration> (\n    ...values: (list of (list dayTimeDuration))\n): (list dayTimeDuration);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_dayTimeDuration_parameters[0],
    1,
    &impl_bag_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__bag_size_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_bag_size_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_bag_size_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_dayTimeDuration_parameters[] = {
    &impl_bag_size_dayTimeDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("bag_size<dayTimeDuration>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_dayTimeDuration"),
    AFW_UTF8_LITERAL("bagSizeDayTimeDuration"),
    AFW_UTF8_LITERAL("afwBagSizeDayTimeDuration"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list dayTimeDuration)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<dayTimeDuration> (\n    value: (list dayTimeDuration)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_dayTimeDuration_parameters[0],
    1,
    &impl_bag_size_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- dayTimeDuration ---------- */

static const afw_utf8_t
impl_object_path__dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__dayTimeDuration
        }
    },
    (void *)&afw_function_definition_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_dayTimeDuration_parameters[] = {
    &impl_dayTimeDuration_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_dayTimeDuration_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("afwDayTimeDuration"),
    AFW_UTF8_LITERAL("Convert to data type dateTimeDuration"),
    AFW_UTF8_LITERAL("Converts value to data type dayTimeDuration returning dayTimeDuration result."),
    AFW_UTF8_LITERAL("(value: any): dayTimeDuration"),
    AFW_UTF8_LITERAL("/* Convert to data type dateTimeDuration */\nfunction dayTimeDuration (\n    value: any\n): dayTimeDuration;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_dayTimeDuration_parameters[0],
    1,
    &impl_dayTimeDuration_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_dayTimeDuration_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__eq_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__eq_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_eq_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_eq_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_dayTimeDuration_parameters[] = {
    &impl_eq_dayTimeDuration_parameter_1,
    &impl_eq_dayTimeDuration_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_dayTimeDuration_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("eq<dayTimeDuration>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_dayTimeDuration"),
    AFW_UTF8_LITERAL("eqDayTimeDuration"),
    AFW_UTF8_LITERAL("afwEqDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if dayTimeDuration arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_dayTimeDuration_parameters[0],
    2,
    &impl_eq_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    &impl_eq_dayTimeDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__eqx_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__eqx_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_eqx_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_eqx_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_dayTimeDuration_parameters[] = {
    &impl_eqx_dayTimeDuration_parameter_1,
    &impl_eqx_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("eqx<dayTimeDuration>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_dayTimeDuration"),
    AFW_UTF8_LITERAL("eqxDayTimeDuration"),
    AFW_UTF8_LITERAL("afwEqxDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for dayTimeDuration arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_dayTimeDuration_parameters[0],
    2,
    &impl_eqx_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__ge_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__ge_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_ge_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_ge_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_dayTimeDuration_parameters[] = {
    &impl_ge_dayTimeDuration_parameter_1,
    &impl_ge_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("ge<dayTimeDuration>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_dayTimeDuration"),
    AFW_UTF8_LITERAL("geDayTimeDuration"),
    AFW_UTF8_LITERAL("afwGeDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for dayTimeDuration arg1 is greater than or equal to dayTimeDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: dayTimeDuration): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: dayTimeDuration\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_dayTimeDuration_parameters[0],
    2,
    &impl_ge_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__gt_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__gt_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_gt_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_gt_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_dayTimeDuration_parameters[] = {
    &impl_gt_dayTimeDuration_parameter_1,
    &impl_gt_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("gt<dayTimeDuration>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_dayTimeDuration"),
    AFW_UTF8_LITERAL("gtDayTimeDuration"),
    AFW_UTF8_LITERAL("afwGtDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for dayTimeDuration arg1 is greater than dayTimeDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: dayTimeDuration): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: dayTimeDuration\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_dayTimeDuration_parameters[0],
    2,
    &impl_gt_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__intersection_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__intersection_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_intersection_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_intersection_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_dayTimeDuration_parameters[] = {
    &impl_intersection_dayTimeDuration_parameter_1,
    &impl_intersection_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("intersection<dayTimeDuration>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_dayTimeDuration"),
    AFW_UTF8_LITERAL("intersectionDayTimeDuration"),
    AFW_UTF8_LITERAL("afwIntersectionDayTimeDuration"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of dayTimeDuration with the values that are common to both list of dayTimeDuration list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list dayTimeDuration), list2: (list dayTimeDuration)): (list dayTimeDuration)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<dayTimeDuration> (\n    list1: (list dayTimeDuration),\n    list2: (list dayTimeDuration)\n): (list dayTimeDuration);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_dayTimeDuration_parameters[0],
    2,
    &impl_intersection_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__is_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__is_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_is_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_is_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_dayTimeDuration_parameters[] = {
    &impl_is_dayTimeDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("is<dayTimeDuration>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_dayTimeDuration"),
    AFW_UTF8_LITERAL("isDayTimeDuration"),
    AFW_UTF8_LITERAL("afwIsDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks whether value is dataType dayTimeDuration"),
    AFW_UTF8_LITERAL("Checks whether value is dataType dayTimeDuration and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType dayTimeDuration */\nfunction is<dayTimeDuration> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_dayTimeDuration_parameters[0],
    1,
    &impl_is_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__is_in_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__is_in_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_is_in_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_is_in_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_dayTimeDuration_parameters[] = {
    &impl_is_in_dayTimeDuration_parameter_1,
    &impl_is_in_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("is_in<dayTimeDuration>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_dayTimeDuration"),
    AFW_UTF8_LITERAL("isInDayTimeDuration"),
    AFW_UTF8_LITERAL("afwIsInDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether dayTimeDuration value is in list of dayTimeDuration list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: dayTimeDuration, list: (list dayTimeDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<dayTimeDuration> (\n    value: dayTimeDuration,\n    list: (list dayTimeDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_dayTimeDuration_parameters[0],
    2,
    &impl_is_in_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__le_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__le_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_le_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_le_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_dayTimeDuration_parameters[] = {
    &impl_le_dayTimeDuration_parameter_1,
    &impl_le_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("le<dayTimeDuration>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_dayTimeDuration"),
    AFW_UTF8_LITERAL("leDayTimeDuration"),
    AFW_UTF8_LITERAL("afwLeDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for dayTimeDuration arg1 is less than or equal to dayTimeDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_dayTimeDuration_parameters[0],
    2,
    &impl_le_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__lt_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__lt_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_lt_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_lt_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_dayTimeDuration_parameters[] = {
    &impl_lt_dayTimeDuration_parameter_1,
    &impl_lt_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("lt<dayTimeDuration>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_dayTimeDuration"),
    AFW_UTF8_LITERAL("ltDayTimeDuration"),
    AFW_UTF8_LITERAL("afwLtDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for dayTimeDuration arg1 is less that dayTimeDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: dayTimeDuration): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: dayTimeDuration\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_dayTimeDuration_parameters[0],
    2,
    &impl_lt_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__ne_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__ne_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_ne_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_ne_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_dayTimeDuration_parameters[] = {
    &impl_ne_dayTimeDuration_parameter_1,
    &impl_ne_dayTimeDuration_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_dayTimeDuration_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("ne<dayTimeDuration>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_dayTimeDuration"),
    AFW_UTF8_LITERAL("neDayTimeDuration"),
    AFW_UTF8_LITERAL("afwNeDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if dayTimeDuration arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_dayTimeDuration_parameters[0],
    2,
    &impl_ne_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    &impl_ne_dayTimeDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__nex_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__nex_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_nex_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_nex_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_dayTimeDuration_parameters[] = {
    &impl_nex_dayTimeDuration_parameter_1,
    &impl_nex_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("nex<dayTimeDuration>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_dayTimeDuration"),
    AFW_UTF8_LITERAL("nexDayTimeDuration"),
    AFW_UTF8_LITERAL("afwNexDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for dayTimeDuration arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: dayTimeDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<dayTimeDuration> (\n    arg1: dayTimeDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_dayTimeDuration_parameters[0],
    2,
    &impl_nex_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_one_and_only_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_one_and_only_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_dayTimeDuration_parameters[] = {
    &impl_one_and_only_dayTimeDuration_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_dayTimeDuration_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("one_and_only<dayTimeDuration>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_dayTimeDuration"),
    AFW_UTF8_LITERAL("oneAndOnlyDayTimeDuration"),
    AFW_UTF8_LITERAL("afwOneAndOnlyDayTimeDuration"),
    AFW_UTF8_LITERAL("Converts a one value list to a dayTimeDuration value"),
    AFW_UTF8_LITERAL("This converts a list of dayTimeDuration values that contains one value to a single dayTimeDuration value."),
    AFW_UTF8_LITERAL("(list: (list list)): dayTimeDuration"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a dayTimeDuration value */\nfunction one_and_only<dayTimeDuration> (\n    list: (list list)\n): dayTimeDuration;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_dayTimeDuration_parameters[0],
    1,
    &impl_one_and_only_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    &impl_one_and_only_dayTimeDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__set_equals_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_set_equals_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_set_equals_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_dayTimeDuration_parameters[] = {
    &impl_set_equals_dayTimeDuration_parameter_1,
    &impl_set_equals_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("set_equals<dayTimeDuration>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_dayTimeDuration"),
    AFW_UTF8_LITERAL("setEqualsDayTimeDuration"),
    AFW_UTF8_LITERAL("afwSetEqualsDayTimeDuration"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if dayTimeDuration list1 and dayTimeDuration list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list dayTimeDuration), list2: (list dayTimeDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<dayTimeDuration> (\n    list1: (list dayTimeDuration),\n    list2: (list dayTimeDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_dayTimeDuration_parameters[0],
    2,
    &impl_set_equals_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__subset_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__subset_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_subset_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_subset_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_dayTimeDuration_parameters[] = {
    &impl_subset_dayTimeDuration_parameter_1,
    &impl_subset_dayTimeDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("subset<dayTimeDuration>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_dayTimeDuration"),
    AFW_UTF8_LITERAL("subsetDayTimeDuration"),
    AFW_UTF8_LITERAL("afwSubsetDayTimeDuration"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in dayTimeDuration list1 are all in dayTimeDuration list2."),
    AFW_UTF8_LITERAL("(list1: (list dayTimeDuration), list2: (list dayTimeDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<dayTimeDuration> (\n    list1: (list dayTimeDuration),\n    list2: (list dayTimeDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_dayTimeDuration_parameters[0],
    2,
    &impl_subset_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__to_string_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__to_string_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_to_string_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_to_string_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A dayTimeDuration value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_dayTimeDuration_parameters[] = {
    &impl_to_string_dayTimeDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("to_string<dayTimeDuration>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_dayTimeDuration"),
    AFW_UTF8_LITERAL("toStringDayTimeDuration"),
    AFW_UTF8_LITERAL("afwToStringDayTimeDuration"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts dayTimeDuration value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: dayTimeDuration): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<dayTimeDuration> (\n    value: dayTimeDuration\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_dayTimeDuration_parameters[0],
    1,
    &impl_to_string_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<dayTimeDuration> ---------- */

static const afw_utf8_t
impl_object_path__union_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__union_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_union_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_union_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_dayTimeDuration_parameters[] = {
    &impl_union_dayTimeDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_dayTimeDuration,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("union<dayTimeDuration>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_dayTimeDuration"),
    AFW_UTF8_LITERAL("unionDayTimeDuration"),
    AFW_UTF8_LITERAL("afwUnionDayTimeDuration"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of dayTimeDuration contains all of the unique values in two or more list of dayTimeDuration values."),
    AFW_UTF8_LITERAL("(lists_1: (list dayTimeDuration), lists_2: (list dayTimeDuration), ...lists_rest: (list of (list dayTimeDuration))): (list dayTimeDuration)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<dayTimeDuration> (\n    lists_1: (list dayTimeDuration),\n    lists_2: (list dayTimeDuration),\n    ...lists_rest: (list of (list dayTimeDuration))\n): (list dayTimeDuration);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_dayTimeDuration_parameters[0],
    1,
    &impl_union_dayTimeDuration_returns,
    NULL,
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__bag_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_dnsName");

static const afw_runtime_object_indirect_t
impl_object__bag_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_dnsName
        }
    },
    (void *)&afw_function_definition_bag_dnsName
};

static const afw_value_function_parameter_t
impl_bag_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_dnsName_parameters[] = {
    &impl_bag_dnsName_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("bag<dnsName>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_dnsName"),
    AFW_UTF8_LITERAL("bagDnsName"),
    AFW_UTF8_LITERAL("afwBagDnsName"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of dnsName values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list dnsName))): (list dnsName)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<dnsName> (\n    ...values: (list of (list dnsName))\n): (list dnsName);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_dnsName_parameters[0],
    1,
    &impl_bag_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_dnsName");

static const afw_runtime_object_indirect_t
impl_object__bag_size_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_dnsName
        }
    },
    (void *)&afw_function_definition_bag_size_dnsName
};

static const afw_value_function_parameter_t
impl_bag_size_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_dnsName_parameters[] = {
    &impl_bag_size_dnsName_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("bag_size<dnsName>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_dnsName"),
    AFW_UTF8_LITERAL("bagSizeDnsName"),
    AFW_UTF8_LITERAL("afwBagSizeDnsName"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list dnsName)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<dnsName> (\n    value: (list dnsName)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_dnsName_parameters[0],
    1,
    &impl_bag_size_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- dnsName ---------- */

static const afw_utf8_t
impl_object_path__dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/dnsName");

static const afw_runtime_object_indirect_t
impl_object__dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__dnsName
        }
    },
    (void *)&afw_function_definition_dnsName
};

static const afw_value_function_parameter_t
impl_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_dnsName_parameters[] = {
    &impl_dnsName_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_dnsName_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("afwDnsName"),
    AFW_UTF8_LITERAL("Convert to data type dnsName"),
    AFW_UTF8_LITERAL("Converts value to data type dnsName returning dnsName result."),
    AFW_UTF8_LITERAL("(value: any): dnsName"),
    AFW_UTF8_LITERAL("/* Convert to data type dnsName */\nfunction dnsName (\n    value: any\n): dnsName;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_dnsName_parameters[0],
    1,
    &impl_dnsName_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_dnsName_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__eq_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_dnsName");

static const afw_runtime_object_indirect_t
impl_object__eq_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_dnsName
        }
    },
    (void *)&afw_function_definition_eq_dnsName
};

static const afw_value_function_parameter_t
impl_eq_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_dnsName_parameters[] = {
    &impl_eq_dnsName_parameter_1,
    &impl_eq_dnsName_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_dnsName_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("eq<dnsName>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_dnsName"),
    AFW_UTF8_LITERAL("eqDnsName"),
    AFW_UTF8_LITERAL("afwEqDnsName"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if dnsName arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<dnsName> (\n    arg1: dnsName,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_dnsName_parameters[0],
    2,
    &impl_eq_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    &impl_eq_dnsName_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__eqx_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_dnsName");

static const afw_runtime_object_indirect_t
impl_object__eqx_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_dnsName
        }
    },
    (void *)&afw_function_definition_eqx_dnsName
};

static const afw_value_function_parameter_t
impl_eqx_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_dnsName_parameters[] = {
    &impl_eqx_dnsName_parameter_1,
    &impl_eqx_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("eqx<dnsName>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_dnsName"),
    AFW_UTF8_LITERAL("eqxDnsName"),
    AFW_UTF8_LITERAL("afwEqxDnsName"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for dnsName arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<dnsName> (\n    arg1: dnsName,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_dnsName_parameters[0],
    2,
    &impl_eqx_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__ge_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_dnsName");

static const afw_runtime_object_indirect_t
impl_object__ge_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_dnsName
        }
    },
    (void *)&afw_function_definition_ge_dnsName
};

static const afw_value_function_parameter_t
impl_ge_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_dnsName_parameters[] = {
    &impl_ge_dnsName_parameter_1,
    &impl_ge_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("ge<dnsName>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_dnsName"),
    AFW_UTF8_LITERAL("geDnsName"),
    AFW_UTF8_LITERAL("afwGeDnsName"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for dnsName arg1 is greater than or equal to dnsName arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: dnsName): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<dnsName> (\n    arg1: dnsName,\n    arg2: dnsName\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_dnsName_parameters[0],
    2,
    &impl_ge_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__gt_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_dnsName");

static const afw_runtime_object_indirect_t
impl_object__gt_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_dnsName
        }
    },
    (void *)&afw_function_definition_gt_dnsName
};

static const afw_value_function_parameter_t
impl_gt_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_dnsName_parameters[] = {
    &impl_gt_dnsName_parameter_1,
    &impl_gt_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("gt<dnsName>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_dnsName"),
    AFW_UTF8_LITERAL("gtDnsName"),
    AFW_UTF8_LITERAL("afwGtDnsName"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for dnsName arg1 is greater than dnsName arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: dnsName): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<dnsName> (\n    arg1: dnsName,\n    arg2: dnsName\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_dnsName_parameters[0],
    2,
    &impl_gt_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__is_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_dnsName");

static const afw_runtime_object_indirect_t
impl_object__is_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_dnsName
        }
    },
    (void *)&afw_function_definition_is_dnsName
};

static const afw_value_function_parameter_t
impl_is_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_dnsName_parameters[] = {
    &impl_is_dnsName_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("is<dnsName>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_dnsName"),
    AFW_UTF8_LITERAL("isDnsName"),
    AFW_UTF8_LITERAL("afwIsDnsName"),
    AFW_UTF8_LITERAL("Checks whether value is dataType dnsName"),
    AFW_UTF8_LITERAL("Checks whether value is dataType dnsName and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType dnsName */\nfunction is<dnsName> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_dnsName_parameters[0],
    1,
    &impl_is_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__is_in_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_dnsName");

static const afw_runtime_object_indirect_t
impl_object__is_in_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_dnsName
        }
    },
    (void *)&afw_function_definition_is_in_dnsName
};

static const afw_value_function_parameter_t
impl_is_in_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_dnsName_parameters[] = {
    &impl_is_in_dnsName_parameter_1,
    &impl_is_in_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("is_in<dnsName>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_dnsName"),
    AFW_UTF8_LITERAL("isInDnsName"),
    AFW_UTF8_LITERAL("afwIsInDnsName"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether dnsName value is in list of dnsName list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: dnsName, list: (list dnsName)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<dnsName> (\n    value: dnsName,\n    list: (list dnsName)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_dnsName_parameters[0],
    2,
    &impl_is_in_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__le_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_dnsName");

static const afw_runtime_object_indirect_t
impl_object__le_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_dnsName
        }
    },
    (void *)&afw_function_definition_le_dnsName
};

static const afw_value_function_parameter_t
impl_le_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_dnsName_parameters[] = {
    &impl_le_dnsName_parameter_1,
    &impl_le_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("le<dnsName>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_dnsName"),
    AFW_UTF8_LITERAL("leDnsName"),
    AFW_UTF8_LITERAL("afwLeDnsName"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for dnsName arg1 is less than or equal to dnsName arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<dnsName> (\n    arg1: dnsName,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_dnsName_parameters[0],
    2,
    &impl_le_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__lt_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_dnsName");

static const afw_runtime_object_indirect_t
impl_object__lt_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_dnsName
        }
    },
    (void *)&afw_function_definition_lt_dnsName
};

static const afw_value_function_parameter_t
impl_lt_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_dnsName_parameters[] = {
    &impl_lt_dnsName_parameter_1,
    &impl_lt_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("lt<dnsName>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_dnsName"),
    AFW_UTF8_LITERAL("ltDnsName"),
    AFW_UTF8_LITERAL("afwLtDnsName"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for dnsName arg1 is less that dnsName arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: dnsName): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<dnsName> (\n    arg1: dnsName,\n    arg2: dnsName\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_dnsName_parameters[0],
    2,
    &impl_lt_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__ne_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_dnsName");

static const afw_runtime_object_indirect_t
impl_object__ne_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_dnsName
        }
    },
    (void *)&afw_function_definition_ne_dnsName
};

static const afw_value_function_parameter_t
impl_ne_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_dnsName_parameters[] = {
    &impl_ne_dnsName_parameter_1,
    &impl_ne_dnsName_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_dnsName_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("ne<dnsName>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_dnsName"),
    AFW_UTF8_LITERAL("neDnsName"),
    AFW_UTF8_LITERAL("afwNeDnsName"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if dnsName arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<dnsName> (\n    arg1: dnsName,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_dnsName_parameters[0],
    2,
    &impl_ne_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    &impl_ne_dnsName_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__nex_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_dnsName");

static const afw_runtime_object_indirect_t
impl_object__nex_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_dnsName
        }
    },
    (void *)&afw_function_definition_nex_dnsName
};

static const afw_value_function_parameter_t
impl_nex_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_dnsName_parameters[] = {
    &impl_nex_dnsName_parameter_1,
    &impl_nex_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("nex<dnsName>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_dnsName"),
    AFW_UTF8_LITERAL("nexDnsName"),
    AFW_UTF8_LITERAL("afwNexDnsName"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for dnsName arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: dnsName, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<dnsName> (\n    arg1: dnsName,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_dnsName_parameters[0],
    2,
    &impl_nex_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_dnsName");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_dnsName
        }
    },
    (void *)&afw_function_definition_one_and_only_dnsName
};

static const afw_value_function_parameter_t
impl_one_and_only_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_dnsName_parameters[] = {
    &impl_one_and_only_dnsName_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_dnsName_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("one_and_only<dnsName>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_dnsName"),
    AFW_UTF8_LITERAL("oneAndOnlyDnsName"),
    AFW_UTF8_LITERAL("afwOneAndOnlyDnsName"),
    AFW_UTF8_LITERAL("Converts a one value list to a dnsName value"),
    AFW_UTF8_LITERAL("This converts a list of dnsName values that contains one value to a single dnsName value."),
    AFW_UTF8_LITERAL("(list: (list list)): dnsName"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a dnsName value */\nfunction one_and_only<dnsName> (\n    list: (list list)\n): dnsName;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_dnsName_parameters[0],
    1,
    &impl_one_and_only_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    &impl_one_and_only_dnsName_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_match<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__regexp_match_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_match_dnsName");

static const afw_runtime_object_indirect_t
impl_object__regexp_match_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_match_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_match_dnsName
        }
    },
    (void *)&afw_function_definition_regexp_match_dnsName
};

static const afw_value_function_parameter_t
impl_regexp_match_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_dnsName_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_match_dnsName_parameters[] = {
    &impl_regexp_match_dnsName_parameter_1,
    &impl_regexp_match_dnsName_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_match_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("regexp_match<dnsName>"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match_dnsName"),
    AFW_UTF8_LITERAL("regexpMatchDnsName"),
    AFW_UTF8_LITERAL("afwRegexpMatchDnsName"),
    AFW_UTF8_LITERAL("Search for a match using a regular expression"),
    AFW_UTF8_LITERAL("Checks whether dnsName value matches the regular expression regexp and return the boolean result."),
    AFW_UTF8_LITERAL("(value: dnsName, regexp: string): boolean"),
    AFW_UTF8_LITERAL("/* Search for a match using a regular expression */\nfunction regexp_match<dnsName> (\n    value: dnsName,\n    regexp: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_match,
    NULL,
    2,
    2,
    &impl_regexp_match_dnsName_parameters[0],
    2,
    &impl_regexp_match_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<dnsName> ---------- */

static const afw_utf8_t
impl_object_path__to_string_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_dnsName");

static const afw_runtime_object_indirect_t
impl_object__to_string_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_dnsName
        }
    },
    (void *)&afw_function_definition_to_string_dnsName
};

static const afw_value_function_parameter_t
impl_to_string_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A dnsName value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_dnsName_parameters[] = {
    &impl_to_string_dnsName_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_dnsName,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("to_string<dnsName>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_dnsName"),
    AFW_UTF8_LITERAL("toStringDnsName"),
    AFW_UTF8_LITERAL("afwToStringDnsName"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts dnsName value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: dnsName): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<dnsName> (\n    value: dnsName\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_dnsName_parameters[0],
    1,
    &impl_to_string_dnsName_returns,
    NULL,
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- abs<double> ---------- */

static const afw_utf8_t
impl_object_path__abs_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/abs_double");

static const afw_runtime_object_indirect_t
impl_object__abs_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_abs_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__abs_double
        }
    },
    (void *)&afw_function_definition_abs_double
};

static const afw_value_function_parameter_t
impl_abs_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_abs_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_abs_double_parameters[] = {
    &impl_abs_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_abs_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__abs_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("abs<double>"),
    AFW_UTF8_LITERAL("abs"),
    AFW_UTF8_LITERAL("abs_double"),
    AFW_UTF8_LITERAL("absDouble"),
    AFW_UTF8_LITERAL("afwAbsDouble"),
    AFW_UTF8_LITERAL("Absolute value"),
    AFW_UTF8_LITERAL("Compute the absolute value of the double value and return the double result."),
    AFW_UTF8_LITERAL("(value: double): double"),
    AFW_UTF8_LITERAL("/* Absolute value */\nfunction abs<double> (\n    value: double\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_abs_double,
    NULL,
    1,
    1,
    &impl_abs_double_parameters[0],
    1,
    &impl_abs_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_abs,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- add<double> ---------- */

static const afw_utf8_t
impl_object_path__add_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_double");

static const afw_runtime_object_indirect_t
impl_object__add_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_double
        }
    },
    (void *)&afw_function_definition_add_double
};

static const afw_value_function_parameter_t
impl_add_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_double_parameters[] = {
    &impl_add_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("add<double>"),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL("add_double"),
    AFW_UTF8_LITERAL("addDouble"),
    AFW_UTF8_LITERAL("afwAddDouble"),
    AFW_UTF8_LITERAL("Add"),
    AFW_UTF8_LITERAL("Add 2 or more double values and return the double result."),
    AFW_UTF8_LITERAL("(values_1: double, values_2: double, ...values_rest: (list of double)): double"),
    AFW_UTF8_LITERAL("/* Add */\nfunction add<double> (\n    values_1: double,\n    values_2: double,\n    ...values_rest: (list of double)\n): double;\n"),
    AFW_UTF8_LITERAL("+"),
    afw_function_execute_add_double,
    NULL,
    2,
    -1,
    &impl_add_double_parameters[0],
    1,
    &impl_add_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_add,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<double> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_double");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_double
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_double
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_double_parameters[] = {
    &impl_at_least_one_member_of_double_parameter_1,
    &impl_at_least_one_member_of_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("at_least_one_member_of<double>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_double"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfDouble"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfDouble"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in double list1 is in double list2."),
    AFW_UTF8_LITERAL("(list1: (list double), list2: (list double)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<double> (\n    list1: (list double),\n    list2: (list double)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_double_parameters[0],
    2,
    &impl_at_least_one_member_of_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<double> ---------- */

static const afw_utf8_t
impl_object_path__bag_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_double");

static const afw_runtime_object_indirect_t
impl_object__bag_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_double
        }
    },
    (void *)&afw_function_definition_bag_double
};

static const afw_value_function_parameter_t
impl_bag_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_double_parameters[] = {
    &impl_bag_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("bag<double>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_double"),
    AFW_UTF8_LITERAL("bagDouble"),
    AFW_UTF8_LITERAL("afwBagDouble"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of double values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list double))): (list double)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<double> (\n    ...values: (list of (list double))\n): (list double);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_double_parameters[0],
    1,
    &impl_bag_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<double> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_double");

static const afw_runtime_object_indirect_t
impl_object__bag_size_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_double
        }
    },
    (void *)&afw_function_definition_bag_size_double
};

static const afw_value_function_parameter_t
impl_bag_size_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_double_parameters[] = {
    &impl_bag_size_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("bag_size<double>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_double"),
    AFW_UTF8_LITERAL("bagSizeDouble"),
    AFW_UTF8_LITERAL("afwBagSizeDouble"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list double)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<double> (\n    value: (list double)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_double_parameters[0],
    1,
    &impl_bag_size_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ceil<double> ---------- */

static const afw_utf8_t
impl_object_path__ceil_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ceil_double");

static const afw_runtime_object_indirect_t
impl_object__ceil_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ceil_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ceil_double
        }
    },
    (void *)&afw_function_definition_ceil_double
};

static const afw_value_function_parameter_t
impl_ceil_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ceil_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ceil_double_parameters[] = {
    &impl_ceil_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ceil_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ceil_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("ceil<double>"),
    AFW_UTF8_LITERAL("ceil"),
    AFW_UTF8_LITERAL("ceil_double"),
    AFW_UTF8_LITERAL("ceilDouble"),
    AFW_UTF8_LITERAL("afwCeilDouble"),
    AFW_UTF8_LITERAL("Round upward to nearest integer"),
    AFW_UTF8_LITERAL("Determine the smallest integer that is greater then or equal to the double value and return the double result."),
    AFW_UTF8_LITERAL("(value: double): double"),
    AFW_UTF8_LITERAL("/* Round upward to nearest integer */\nfunction ceil<double> (\n    value: double\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_ceil_double,
    NULL,
    1,
    1,
    &impl_ceil_double_parameters[0],
    1,
    &impl_ceil_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_ceil,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- divide<double> ---------- */

static const afw_utf8_t
impl_object_path__divide_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/divide_double");

static const afw_runtime_object_indirect_t
impl_object__divide_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_divide_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__divide_double
        }
    },
    (void *)&afw_function_definition_divide_double
};

static const afw_value_function_parameter_t
impl_divide_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_divide_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("dividend"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_divide_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("divisor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_divide_double_parameters[] = {
    &impl_divide_double_parameter_1,
    &impl_divide_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_divide_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__divide_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("divide<double>"),
    AFW_UTF8_LITERAL("divide"),
    AFW_UTF8_LITERAL("divide_double"),
    AFW_UTF8_LITERAL("divideDouble"),
    AFW_UTF8_LITERAL("afwDivideDouble"),
    AFW_UTF8_LITERAL("Divide numbers"),
    AFW_UTF8_LITERAL("Divide double dividend by double divisor and return the double quotient."),
    AFW_UTF8_LITERAL("(dividend: double, divisor: double): double"),
    AFW_UTF8_LITERAL("/* Divide numbers */\nfunction divide<double> (\n    dividend: double,\n    divisor: double\n): double;\n"),
    AFW_UTF8_LITERAL("/"),
    afw_function_execute_divide_double,
    NULL,
    2,
    2,
    &impl_divide_double_parameters[0],
    2,
    &impl_divide_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_divide,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- double ---------- */

static const afw_utf8_t
impl_object_path__double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/double");

static const afw_runtime_object_indirect_t
impl_object__double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__double
        }
    },
    (void *)&afw_function_definition_double
};

static const afw_value_function_parameter_t
impl_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_double_parameters[] = {
    &impl_double_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_double_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("afwDouble"),
    AFW_UTF8_LITERAL("Convert to data type double"),
    AFW_UTF8_LITERAL("Converts value to data type double returning double result."),
    AFW_UTF8_LITERAL("(value: any): double"),
    AFW_UTF8_LITERAL("/* Convert to data type double */\nfunction double (\n    value: any\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_double_parameters[0],
    1,
    &impl_double_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_double_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<double> ---------- */

static const afw_utf8_t
impl_object_path__eq_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_double");

static const afw_runtime_object_indirect_t
impl_object__eq_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_double
        }
    },
    (void *)&afw_function_definition_eq_double
};

static const afw_value_function_parameter_t
impl_eq_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_double_parameters[] = {
    &impl_eq_double_parameter_1,
    &impl_eq_double_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_double_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("eq<double>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_double"),
    AFW_UTF8_LITERAL("eqDouble"),
    AFW_UTF8_LITERAL("afwEqDouble"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if double arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<double> (\n    arg1: double,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_double_parameters[0],
    2,
    &impl_eq_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    &impl_eq_double_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<double> ---------- */

static const afw_utf8_t
impl_object_path__eqx_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_double");

static const afw_runtime_object_indirect_t
impl_object__eqx_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_double
        }
    },
    (void *)&afw_function_definition_eqx_double
};

static const afw_value_function_parameter_t
impl_eqx_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_double_parameters[] = {
    &impl_eqx_double_parameter_1,
    &impl_eqx_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("eqx<double>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_double"),
    AFW_UTF8_LITERAL("eqxDouble"),
    AFW_UTF8_LITERAL("afwEqxDouble"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for double arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<double> (\n    arg1: double,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_double_parameters[0],
    2,
    &impl_eqx_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- floor<double> ---------- */

static const afw_utf8_t
impl_object_path__floor_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/floor_double");

static const afw_runtime_object_indirect_t
impl_object__floor_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_floor_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__floor_double
        }
    },
    (void *)&afw_function_definition_floor_double
};

static const afw_value_function_parameter_t
impl_floor_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_floor_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("number"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_floor_double_parameters[] = {
    &impl_floor_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_floor_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__floor_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("floor<double>"),
    AFW_UTF8_LITERAL("floor"),
    AFW_UTF8_LITERAL("floor_double"),
    AFW_UTF8_LITERAL("floorDouble"),
    AFW_UTF8_LITERAL("afwFloorDouble"),
    AFW_UTF8_LITERAL("Round downwards to nearest integer"),
    AFW_UTF8_LITERAL("Determine the largest integer that is smaller then or equal to the double value and return the double result."),
    AFW_UTF8_LITERAL("(number: double): double"),
    AFW_UTF8_LITERAL("/* Round downwards to nearest integer */\nfunction floor<double> (\n    number: double\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_floor_double,
    NULL,
    1,
    1,
    &impl_floor_double_parameters[0],
    1,
    &impl_floor_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_floor,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<double> ---------- */

static const afw_utf8_t
impl_object_path__ge_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_double");

static const afw_runtime_object_indirect_t
impl_object__ge_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_double
        }
    },
    (void *)&afw_function_definition_ge_double
};

static const afw_value_function_parameter_t
impl_ge_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_double_parameters[] = {
    &impl_ge_double_parameter_1,
    &impl_ge_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("ge<double>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_double"),
    AFW_UTF8_LITERAL("geDouble"),
    AFW_UTF8_LITERAL("afwGeDouble"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for double arg1 is greater than or equal to double arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: double): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<double> (\n    arg1: double,\n    arg2: double\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_double_parameters[0],
    2,
    &impl_ge_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<double> ---------- */

static const afw_utf8_t
impl_object_path__gt_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_double");

static const afw_runtime_object_indirect_t
impl_object__gt_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_double
        }
    },
    (void *)&afw_function_definition_gt_double
};

static const afw_value_function_parameter_t
impl_gt_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_double_parameters[] = {
    &impl_gt_double_parameter_1,
    &impl_gt_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("gt<double>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_double"),
    AFW_UTF8_LITERAL("gtDouble"),
    AFW_UTF8_LITERAL("afwGtDouble"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for double arg1 is greater than double arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: double): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<double> (\n    arg1: double,\n    arg2: double\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_double_parameters[0],
    2,
    &impl_gt_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<double> ---------- */

static const afw_utf8_t
impl_object_path__intersection_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_double");

static const afw_runtime_object_indirect_t
impl_object__intersection_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_double
        }
    },
    (void *)&afw_function_definition_intersection_double
};

static const afw_value_function_parameter_t
impl_intersection_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_double_parameters[] = {
    &impl_intersection_double_parameter_1,
    &impl_intersection_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("intersection<double>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_double"),
    AFW_UTF8_LITERAL("intersectionDouble"),
    AFW_UTF8_LITERAL("afwIntersectionDouble"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of double with the values that are common to both list of double list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list double), list2: (list double)): (list double)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<double> (\n    list1: (list double),\n    list2: (list double)\n): (list double);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_double_parameters[0],
    2,
    &impl_intersection_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_NaN ---------- */

static const afw_utf8_t
impl_object_path__is_NaN =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_NaN");

static const afw_runtime_object_indirect_t
impl_object__is_NaN = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_NaN,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_NaN
        }
    },
    (void *)&afw_function_definition_is_NaN
};

static const afw_value_function_parameter_t
impl_is_NaN_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if the argument 'number' is not a number."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_NaN_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("number"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Number to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_NaN_parameters[] = {
    &impl_is_NaN_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_NaN = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_NaN,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("is_NaN"),
    AFW_UTF8_LITERAL("is_NaN"),
    AFW_UTF8_LITERAL("is_NaN"),
    AFW_UTF8_LITERAL("isNaN"),
    AFW_UTF8_LITERAL("afwIsNaN"),
    AFW_UTF8_LITERAL("Is not a number(NaN)"),
    AFW_UTF8_LITERAL("Checks if the argument 'number' is not a number(NaN) and returns the boolean result."),
    AFW_UTF8_LITERAL("(number: double): boolean"),
    AFW_UTF8_LITERAL("/* Is not a number(NaN) */\nfunction is_NaN (\n    number: double\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_NaN,
    NULL,
    1,
    1,
    &impl_is_NaN_parameters[0],
    1,
    &impl_is_NaN_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<double> ---------- */

static const afw_utf8_t
impl_object_path__is_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_double");

static const afw_runtime_object_indirect_t
impl_object__is_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_double
        }
    },
    (void *)&afw_function_definition_is_double
};

static const afw_value_function_parameter_t
impl_is_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_double_parameters[] = {
    &impl_is_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("is<double>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_double"),
    AFW_UTF8_LITERAL("isDouble"),
    AFW_UTF8_LITERAL("afwIsDouble"),
    AFW_UTF8_LITERAL("Checks whether value is dataType double"),
    AFW_UTF8_LITERAL("Checks whether value is dataType double and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType double */\nfunction is<double> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_double_parameters[0],
    1,
    &impl_is_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_finite ---------- */

static const afw_utf8_t
impl_object_path__is_finite =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_finite");

static const afw_runtime_object_indirect_t
impl_object__is_finite = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_finite,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_finite
        }
    },
    (void *)&afw_function_definition_is_finite
};

static const afw_value_function_parameter_t
impl_is_finite_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if the argument 'number' is finite."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_finite_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("number"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Number to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_finite_parameters[] = {
    &impl_is_finite_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_finite = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_finite,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("is_finite"),
    AFW_UTF8_LITERAL("is_finite"),
    AFW_UTF8_LITERAL("is_finite"),
    AFW_UTF8_LITERAL("isFinite"),
    AFW_UTF8_LITERAL("afwIsFinite"),
    AFW_UTF8_LITERAL("Is a number finite"),
    AFW_UTF8_LITERAL("Checks if the argument 'number' is finite and returns the boolean result."),
    AFW_UTF8_LITERAL("(number: double): boolean"),
    AFW_UTF8_LITERAL("/* Is a number finite */\nfunction is_finite (\n    number: double\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_finite,
    NULL,
    1,
    1,
    &impl_is_finite_parameters[0],
    1,
    &impl_is_finite_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<double> ---------- */

static const afw_utf8_t
impl_object_path__is_in_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_double");

static const afw_runtime_object_indirect_t
impl_object__is_in_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_double
        }
    },
    (void *)&afw_function_definition_is_in_double
};

static const afw_value_function_parameter_t
impl_is_in_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_double_parameters[] = {
    &impl_is_in_double_parameter_1,
    &impl_is_in_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("is_in<double>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_double"),
    AFW_UTF8_LITERAL("isInDouble"),
    AFW_UTF8_LITERAL("afwIsInDouble"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether double value is in list of double list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: double, list: (list double)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<double> (\n    value: double,\n    list: (list double)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_double_parameters[0],
    2,
    &impl_is_in_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<double> ---------- */

static const afw_utf8_t
impl_object_path__le_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_double");

static const afw_runtime_object_indirect_t
impl_object__le_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_double
        }
    },
    (void *)&afw_function_definition_le_double
};

static const afw_value_function_parameter_t
impl_le_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_double_parameters[] = {
    &impl_le_double_parameter_1,
    &impl_le_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("le<double>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_double"),
    AFW_UTF8_LITERAL("leDouble"),
    AFW_UTF8_LITERAL("afwLeDouble"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for double arg1 is less than or equal to double arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<double> (\n    arg1: double,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_double_parameters[0],
    2,
    &impl_le_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<double> ---------- */

static const afw_utf8_t
impl_object_path__lt_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_double");

static const afw_runtime_object_indirect_t
impl_object__lt_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_double
        }
    },
    (void *)&afw_function_definition_lt_double
};

static const afw_value_function_parameter_t
impl_lt_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_double_parameters[] = {
    &impl_lt_double_parameter_1,
    &impl_lt_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("lt<double>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_double"),
    AFW_UTF8_LITERAL("ltDouble"),
    AFW_UTF8_LITERAL("afwLtDouble"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for double arg1 is less that double arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: double): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<double> (\n    arg1: double,\n    arg2: double\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_double_parameters[0],
    2,
    &impl_lt_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- max<double> ---------- */

static const afw_utf8_t
impl_object_path__max_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/max_double");

static const afw_runtime_object_indirect_t
impl_object__max_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_max_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__max_double
        }
    },
    (void *)&afw_function_definition_max_double
};

static const afw_value_function_parameter_t
impl_max_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_max_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_max_double_parameters[] = {
    &impl_max_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__max_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("max<double>"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max_double"),
    AFW_UTF8_LITERAL("maxDouble"),
    AFW_UTF8_LITERAL("afwMaxDouble"),
    AFW_UTF8_LITERAL("Maximum value"),
    AFW_UTF8_LITERAL("Return the double value that is greater than or equal to the others."),
    AFW_UTF8_LITERAL("(values_1: double, ...values_rest: (list of double)): double"),
    AFW_UTF8_LITERAL("/* Maximum value */\nfunction max<double> (\n    values_1: double,\n    ...values_rest: (list of double)\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_max,
    NULL,
    1,
    -1,
    &impl_max_double_parameters[0],
    1,
    &impl_max_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_max,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- min<double> ---------- */

static const afw_utf8_t
impl_object_path__min_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/min_double");

static const afw_runtime_object_indirect_t
impl_object__min_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_min_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__min_double
        }
    },
    (void *)&afw_function_definition_min_double
};

static const afw_value_function_parameter_t
impl_min_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_min_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_min_double_parameters[] = {
    &impl_min_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__min_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("min<double>"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min_double"),
    AFW_UTF8_LITERAL("minDouble"),
    AFW_UTF8_LITERAL("afwMinDouble"),
    AFW_UTF8_LITERAL("Minimum value"),
    AFW_UTF8_LITERAL("Return the double value that is less than or equal to the others."),
    AFW_UTF8_LITERAL("(values_1: double, ...values_rest: (list of double)): double"),
    AFW_UTF8_LITERAL("/* Minimum value */\nfunction min<double> (\n    values_1: double,\n    ...values_rest: (list of double)\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_min,
    NULL,
    1,
    -1,
    &impl_min_double_parameters[0],
    1,
    &impl_min_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_min,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- multiply<double> ---------- */

static const afw_utf8_t
impl_object_path__multiply_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/multiply_double");

static const afw_runtime_object_indirect_t
impl_object__multiply_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_multiply_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__multiply_double
        }
    },
    (void *)&afw_function_definition_multiply_double
};

static const afw_value_function_parameter_t
impl_multiply_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_multiply_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_multiply_double_parameters[] = {
    &impl_multiply_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_multiply_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__multiply_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("multiply<double>"),
    AFW_UTF8_LITERAL("multiply"),
    AFW_UTF8_LITERAL("multiply_double"),
    AFW_UTF8_LITERAL("multiplyDouble"),
    AFW_UTF8_LITERAL("afwMultiplyDouble"),
    AFW_UTF8_LITERAL("Multiply numbers"),
    AFW_UTF8_LITERAL("Multiply 2 or more double values and return the double result."),
    AFW_UTF8_LITERAL("(values_1: double, values_2: double, ...values_rest: (list of double)): double"),
    AFW_UTF8_LITERAL("/* Multiply numbers */\nfunction multiply<double> (\n    values_1: double,\n    values_2: double,\n    ...values_rest: (list of double)\n): double;\n"),
    AFW_UTF8_LITERAL("*"),
    afw_function_execute_multiply_double,
    NULL,
    2,
    -1,
    &impl_multiply_double_parameters[0],
    1,
    &impl_multiply_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_multiply,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<double> ---------- */

static const afw_utf8_t
impl_object_path__ne_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_double");

static const afw_runtime_object_indirect_t
impl_object__ne_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_double
        }
    },
    (void *)&afw_function_definition_ne_double
};

static const afw_value_function_parameter_t
impl_ne_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_double_parameters[] = {
    &impl_ne_double_parameter_1,
    &impl_ne_double_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_double_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("ne<double>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_double"),
    AFW_UTF8_LITERAL("neDouble"),
    AFW_UTF8_LITERAL("afwNeDouble"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if double arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<double> (\n    arg1: double,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_double_parameters[0],
    2,
    &impl_ne_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    &impl_ne_double_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- negative<double> ---------- */

static const afw_utf8_t
impl_object_path__negative_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/negative_double");

static const afw_runtime_object_indirect_t
impl_object__negative_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_negative_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__negative_double
        }
    },
    (void *)&afw_function_definition_negative_double
};

static const afw_value_function_parameter_t
impl_negative_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_negative_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_negative_double_parameters[] = {
    &impl_negative_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_negative_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__negative_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("negative<double>"),
    AFW_UTF8_LITERAL("negative"),
    AFW_UTF8_LITERAL("negative_double"),
    AFW_UTF8_LITERAL("negativeDouble"),
    AFW_UTF8_LITERAL("afwNegativeDouble"),
    AFW_UTF8_LITERAL("Negative of a number"),
    AFW_UTF8_LITERAL("Return negative of double value."),
    AFW_UTF8_LITERAL("(value: double): double"),
    AFW_UTF8_LITERAL("/* Negative of a number */\nfunction negative<double> (\n    value: double\n): double;\n"),
    AFW_UTF8_LITERAL("-"),
    afw_function_execute_negative_double,
    NULL,
    1,
    1,
    &impl_negative_double_parameters[0],
    1,
    &impl_negative_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_negative,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<double> ---------- */

static const afw_utf8_t
impl_object_path__nex_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_double");

static const afw_runtime_object_indirect_t
impl_object__nex_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_double
        }
    },
    (void *)&afw_function_definition_nex_double
};

static const afw_value_function_parameter_t
impl_nex_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_double_parameters[] = {
    &impl_nex_double_parameter_1,
    &impl_nex_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("nex<double>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_double"),
    AFW_UTF8_LITERAL("nexDouble"),
    AFW_UTF8_LITERAL("afwNexDouble"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for double arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<double> (\n    arg1: double,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_double_parameters[0],
    2,
    &impl_nex_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<double> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_double");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_double
        }
    },
    (void *)&afw_function_definition_one_and_only_double
};

static const afw_value_function_parameter_t
impl_one_and_only_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_double_parameters[] = {
    &impl_one_and_only_double_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_double_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("one_and_only<double>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_double"),
    AFW_UTF8_LITERAL("oneAndOnlyDouble"),
    AFW_UTF8_LITERAL("afwOneAndOnlyDouble"),
    AFW_UTF8_LITERAL("Converts a one value list to a double value"),
    AFW_UTF8_LITERAL("This converts a list of double values that contains one value to a single double value."),
    AFW_UTF8_LITERAL("(list: (list list)): double"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a double value */\nfunction one_and_only<double> (\n    list: (list list)\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_double_parameters[0],
    1,
    &impl_one_and_only_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    &impl_one_and_only_double_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- pow<double> ---------- */

static const afw_utf8_t
impl_object_path__pow_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/pow_double");

static const afw_runtime_object_indirect_t
impl_object__pow_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_pow_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__pow_double
        }
    },
    (void *)&afw_function_definition_pow_double
};

static const afw_value_function_parameter_t
impl_pow_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Base raised to the power."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_pow_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("base"),
    AFW_UTF8_LITERAL("Base value"),
    AFW_UTF8_LITERAL("Base value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_pow_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("exponent"),
    AFW_UTF8_LITERAL("Exponent value"),
    AFW_UTF8_LITERAL("Exponent value."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_pow_double_parameters[] = {
    &impl_pow_double_parameter_1,
    &impl_pow_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_pow_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__pow_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("pow<double>"),
    AFW_UTF8_LITERAL("pow"),
    AFW_UTF8_LITERAL("pow_double"),
    AFW_UTF8_LITERAL("powDouble"),
    AFW_UTF8_LITERAL("afwPowDouble"),
    AFW_UTF8_LITERAL("Base raised to a power"),
    AFW_UTF8_LITERAL("This returns the value of base raised to a power. Multiple exponents can be specified to raise the previous exponent to the power of the latter exponent."),
    AFW_UTF8_LITERAL("(base: double, exponent_1: double, ...exponent_rest: (list of double)): double"),
    AFW_UTF8_LITERAL("/* Base raised to a power */\nfunction pow<double> (\n    base: double     /* Base value */,\n    exponent_1: double,\n    ...exponent_rest: (list of double) /* Exponent value */\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_pow_double,
    NULL,
    2,
    -1,
    &impl_pow_double_parameters[0],
    2,
    &impl_pow_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_pow,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- round<double> ---------- */

static const afw_utf8_t
impl_object_path__round_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/round_double");

static const afw_runtime_object_indirect_t
impl_object__round_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_round_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__round_double
        }
    },
    (void *)&afw_function_definition_round_double
};

static const afw_value_function_parameter_t
impl_round_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_round_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("number"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_round_double_parameters[] = {
    &impl_round_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_round_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__round_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("round<double>"),
    AFW_UTF8_LITERAL("round"),
    AFW_UTF8_LITERAL("round_double"),
    AFW_UTF8_LITERAL("roundDouble"),
    AFW_UTF8_LITERAL("afwRoundDouble"),
    AFW_UTF8_LITERAL("Round to nearest integer"),
    AFW_UTF8_LITERAL("Determine the integer closest to double value and return the double result."),
    AFW_UTF8_LITERAL("(number: double): double"),
    AFW_UTF8_LITERAL("/* Round to nearest integer */\nfunction round<double> (\n    number: double\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_round_double,
    NULL,
    1,
    1,
    &impl_round_double_parameters[0],
    1,
    &impl_round_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_round,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<double> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_double");

static const afw_runtime_object_indirect_t
impl_object__set_equals_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_double
        }
    },
    (void *)&afw_function_definition_set_equals_double
};

static const afw_value_function_parameter_t
impl_set_equals_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_double_parameters[] = {
    &impl_set_equals_double_parameter_1,
    &impl_set_equals_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("set_equals<double>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_double"),
    AFW_UTF8_LITERAL("setEqualsDouble"),
    AFW_UTF8_LITERAL("afwSetEqualsDouble"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if double list1 and double list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list double), list2: (list double)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<double> (\n    list1: (list double),\n    list2: (list double)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_double_parameters[0],
    2,
    &impl_set_equals_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<double> ---------- */

static const afw_utf8_t
impl_object_path__subset_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_double");

static const afw_runtime_object_indirect_t
impl_object__subset_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_double
        }
    },
    (void *)&afw_function_definition_subset_double
};

static const afw_value_function_parameter_t
impl_subset_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_double_parameters[] = {
    &impl_subset_double_parameter_1,
    &impl_subset_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("subset<double>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_double"),
    AFW_UTF8_LITERAL("subsetDouble"),
    AFW_UTF8_LITERAL("afwSubsetDouble"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in double list1 are all in double list2."),
    AFW_UTF8_LITERAL("(list1: (list double), list2: (list double)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<double> (\n    list1: (list double),\n    list2: (list double)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_double_parameters[0],
    2,
    &impl_subset_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subtract<double> ---------- */

static const afw_utf8_t
impl_object_path__subtract_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract_double");

static const afw_runtime_object_indirect_t
impl_object__subtract_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract_double
        }
    },
    (void *)&afw_function_definition_subtract_double
};

static const afw_value_function_parameter_t
impl_subtract_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_double_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_double_parameters[] = {
    &impl_subtract_double_parameter_1,
    &impl_subtract_double_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("subtract<double>"),
    AFW_UTF8_LITERAL("subtract"),
    AFW_UTF8_LITERAL("subtract_double"),
    AFW_UTF8_LITERAL("subtractDouble"),
    AFW_UTF8_LITERAL("afwSubtractDouble"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract double arg2 from double arg1 and return the double result."),
    AFW_UTF8_LITERAL("(arg1: double, arg2: double): double"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract<double> (\n    arg1: double,\n    arg2: double\n): double;\n"),
    AFW_UTF8_LITERAL("-"),
    afw_function_execute_subtract_double,
    NULL,
    2,
    2,
    &impl_subtract_double_parameters[0],
    2,
    &impl_subtract_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_subtract,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_integer<double> ---------- */

static const afw_utf8_t
impl_object_path__to_integer_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_integer_double");

static const afw_runtime_object_indirect_t
impl_object__to_integer_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_integer_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_integer_double
        }
    },
    (void *)&afw_function_definition_to_integer_double
};

static const afw_value_function_parameter_t
impl_to_integer_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_integer_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_integer_double_parameters[] = {
    &impl_to_integer_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_integer_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_integer_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("to_integer<double>"),
    AFW_UTF8_LITERAL("to_integer"),
    AFW_UTF8_LITERAL("to_integer_double"),
    AFW_UTF8_LITERAL("toIntegerDouble"),
    AFW_UTF8_LITERAL("afwToIntegerDouble"),
    AFW_UTF8_LITERAL("Converts to integer"),
    AFW_UTF8_LITERAL("Truncate double value to a whole number and returns integer result."),
    AFW_UTF8_LITERAL("(value: double): integer"),
    AFW_UTF8_LITERAL("/* Converts to integer */\nfunction to_integer<double> (\n    value: double\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_to_integer_double,
    NULL,
    1,
    1,
    &impl_to_integer_double_parameters[0],
    1,
    &impl_to_integer_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_to_integer,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<double> ---------- */

static const afw_utf8_t
impl_object_path__to_string_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_double");

static const afw_runtime_object_indirect_t
impl_object__to_string_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_double
        }
    },
    (void *)&afw_function_definition_to_string_double
};

static const afw_value_function_parameter_t
impl_to_string_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A double value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_double_parameters[] = {
    &impl_to_string_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("to_string<double>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_double"),
    AFW_UTF8_LITERAL("toStringDouble"),
    AFW_UTF8_LITERAL("afwToStringDouble"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts double value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: double): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<double> (\n    value: double\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_double_parameters[0],
    1,
    &impl_to_string_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<double> ---------- */

static const afw_utf8_t
impl_object_path__union_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_double");

static const afw_runtime_object_indirect_t
impl_object__union_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_double
        }
    },
    (void *)&afw_function_definition_union_double
};

static const afw_value_function_parameter_t
impl_union_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_double_parameters[] = {
    &impl_union_double_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_double,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("union<double>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_double"),
    AFW_UTF8_LITERAL("unionDouble"),
    AFW_UTF8_LITERAL("afwUnionDouble"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of double contains all of the unique values in two or more list of double values."),
    AFW_UTF8_LITERAL("(lists_1: (list double), lists_2: (list double), ...lists_rest: (list of (list double))): (list double)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<double> (\n    lists_1: (list double),\n    lists_2: (list double),\n    ...lists_rest: (list of (list double))\n): (list double);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_double_parameters[0],
    1,
    &impl_union_double_returns,
    NULL,
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<expression> ---------- */

static const afw_utf8_t
impl_object_path__bag_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_expression");

static const afw_runtime_object_indirect_t
impl_object__bag_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_expression
        }
    },
    (void *)&afw_function_definition_bag_expression
};

static const afw_value_function_parameter_t
impl_bag_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_expression_parameters[] = {
    &impl_bag_expression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("bag<expression>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_expression"),
    AFW_UTF8_LITERAL("bagExpression"),
    AFW_UTF8_LITERAL("afwBagExpression"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of expression values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list expression))): (list expression)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<expression> (\n    ...values: (list of (list expression))\n): (list expression);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_expression_parameters[0],
    1,
    &impl_bag_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<expression> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_expression");

static const afw_runtime_object_indirect_t
impl_object__bag_size_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_expression
        }
    },
    (void *)&afw_function_definition_bag_size_expression
};

static const afw_value_function_parameter_t
impl_bag_size_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_expression_parameters[] = {
    &impl_bag_size_expression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("bag_size<expression>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_expression"),
    AFW_UTF8_LITERAL("bagSizeExpression"),
    AFW_UTF8_LITERAL("afwBagSizeExpression"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list expression)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<expression> (\n    value: (list expression)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_expression_parameters[0],
    1,
    &impl_bag_size_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compile<expression> ---------- */

static const afw_utf8_t
impl_object_path__compile_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_expression");

static const afw_runtime_object_indirect_t
impl_object__compile_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_expression
        }
    },
    (void *)&afw_function_definition_compile_expression
};

static const afw_value_function_parameter_t
impl_compile_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to compile"),
    AFW_UTF8_LITERAL("expression string to compile"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL("Listing option"),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_expression_parameters[] = {
    &impl_compile_expression_parameter_1,
    &impl_compile_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("compile<expression>"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile_expression"),
    AFW_UTF8_LITERAL("compileExpression"),
    AFW_UTF8_LITERAL("afwCompileExpression"),
    AFW_UTF8_LITERAL("Compile expression value"),
    AFW_UTF8_LITERAL("Compile expression value and return either an unevaluated adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(source: expression, listing?: any): unevaluated"),
    AFW_UTF8_LITERAL("/* Compile expression value */\nfunction compile<expression> (\n    source: expression /* Source to compile */,\n    listing?: any      /* Listing option */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_expression,
    NULL,
    1,
    2,
    &impl_compile_expression_parameters[0],
    2,
    &impl_compile_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_compile,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<expression> ---------- */

static const afw_utf8_t
impl_object_path__eq_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_expression");

static const afw_runtime_object_indirect_t
impl_object__eq_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_expression
        }
    },
    (void *)&afw_function_definition_eq_expression
};

static const afw_value_function_parameter_t
impl_eq_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_expression_parameters[] = {
    &impl_eq_expression_parameter_1,
    &impl_eq_expression_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_expression_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("eq<expression>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_expression"),
    AFW_UTF8_LITERAL("eqExpression"),
    AFW_UTF8_LITERAL("afwEqExpression"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if expression arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<expression> (\n    arg1: expression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_expression_parameters[0],
    2,
    &impl_eq_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    &impl_eq_expression_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<expression> ---------- */

static const afw_utf8_t
impl_object_path__eqx_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_expression");

static const afw_runtime_object_indirect_t
impl_object__eqx_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_expression
        }
    },
    (void *)&afw_function_definition_eqx_expression
};

static const afw_value_function_parameter_t
impl_eqx_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_expression_parameters[] = {
    &impl_eqx_expression_parameter_1,
    &impl_eqx_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("eqx<expression>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_expression"),
    AFW_UTF8_LITERAL("eqxExpression"),
    AFW_UTF8_LITERAL("afwEqxExpression"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for expression arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<expression> (\n    arg1: expression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_expression_parameters[0],
    2,
    &impl_eqx_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- evaluate<expression> ---------- */

static const afw_utf8_t
impl_object_path__evaluate_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_expression");

static const afw_runtime_object_indirect_t
impl_object__evaluate_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_expression
        }
    },
    (void *)&afw_function_definition_evaluate_expression
};

static const afw_value_function_parameter_t
impl_evaluate_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to evaluate"),
    AFW_UTF8_LITERAL("expression string to compile and evaluate"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_expression_parameters[] = {
    &impl_evaluate_expression_parameter_1,
    &impl_evaluate_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("evaluate<expression>"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate_expression"),
    AFW_UTF8_LITERAL("evaluateExpression"),
    AFW_UTF8_LITERAL("afwEvaluateExpression"),
    AFW_UTF8_LITERAL("Evaluate expression value"),
    AFW_UTF8_LITERAL("Compile and evaluate expression value."),
    AFW_UTF8_LITERAL("(source: expression, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): unevaluated"),
    AFW_UTF8_LITERAL("/* Evaluate expression value */\nfunction evaluate<expression> (\n    source: expression                                                                 /* Source to evaluate */,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_expression,
    NULL,
    1,
    2,
    &impl_evaluate_expression_parameters[0],
    2,
    &impl_evaluate_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_evaluate,
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- expression ---------- */

static const afw_utf8_t
impl_object_path__expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/expression");

static const afw_runtime_object_indirect_t
impl_object__expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__expression
        }
    },
    (void *)&afw_function_definition_expression
};

static const afw_value_function_parameter_t
impl_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_expression_parameters[] = {
    &impl_expression_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_expression_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("afwExpression"),
    AFW_UTF8_LITERAL("Convert to data type expression"),
    AFW_UTF8_LITERAL("Converts value to data type expression returning expression result."),
    AFW_UTF8_LITERAL("(value: any): expression"),
    AFW_UTF8_LITERAL("/* Convert to data type expression */\nfunction expression (\n    value: any\n): expression;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_expression_parameters[0],
    1,
    &impl_expression_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_expression_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<expression> ---------- */

static const afw_utf8_t
impl_object_path__ge_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_expression");

static const afw_runtime_object_indirect_t
impl_object__ge_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_expression
        }
    },
    (void *)&afw_function_definition_ge_expression
};

static const afw_value_function_parameter_t
impl_ge_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_expression_parameters[] = {
    &impl_ge_expression_parameter_1,
    &impl_ge_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("ge<expression>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_expression"),
    AFW_UTF8_LITERAL("geExpression"),
    AFW_UTF8_LITERAL("afwGeExpression"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for expression arg1 is greater than or equal to expression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: expression): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<expression> (\n    arg1: expression,\n    arg2: expression\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_expression_parameters[0],
    2,
    &impl_ge_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<expression> ---------- */

static const afw_utf8_t
impl_object_path__gt_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_expression");

static const afw_runtime_object_indirect_t
impl_object__gt_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_expression
        }
    },
    (void *)&afw_function_definition_gt_expression
};

static const afw_value_function_parameter_t
impl_gt_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_expression_parameters[] = {
    &impl_gt_expression_parameter_1,
    &impl_gt_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("gt<expression>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_expression"),
    AFW_UTF8_LITERAL("gtExpression"),
    AFW_UTF8_LITERAL("afwGtExpression"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for expression arg1 is greater than expression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: expression): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<expression> (\n    arg1: expression,\n    arg2: expression\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_expression_parameters[0],
    2,
    &impl_gt_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<expression> ---------- */

static const afw_utf8_t
impl_object_path__is_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_expression");

static const afw_runtime_object_indirect_t
impl_object__is_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_expression
        }
    },
    (void *)&afw_function_definition_is_expression
};

static const afw_value_function_parameter_t
impl_is_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_expression_parameters[] = {
    &impl_is_expression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("is<expression>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_expression"),
    AFW_UTF8_LITERAL("isExpression"),
    AFW_UTF8_LITERAL("afwIsExpression"),
    AFW_UTF8_LITERAL("Checks whether value is dataType expression"),
    AFW_UTF8_LITERAL("Checks whether value is dataType expression and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType expression */\nfunction is<expression> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_expression_parameters[0],
    1,
    &impl_is_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<expression> ---------- */

static const afw_utf8_t
impl_object_path__le_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_expression");

static const afw_runtime_object_indirect_t
impl_object__le_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_expression
        }
    },
    (void *)&afw_function_definition_le_expression
};

static const afw_value_function_parameter_t
impl_le_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_expression_parameters[] = {
    &impl_le_expression_parameter_1,
    &impl_le_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("le<expression>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_expression"),
    AFW_UTF8_LITERAL("leExpression"),
    AFW_UTF8_LITERAL("afwLeExpression"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for expression arg1 is less than or equal to expression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<expression> (\n    arg1: expression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_expression_parameters[0],
    2,
    &impl_le_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<expression> ---------- */

static const afw_utf8_t
impl_object_path__lt_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_expression");

static const afw_runtime_object_indirect_t
impl_object__lt_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_expression
        }
    },
    (void *)&afw_function_definition_lt_expression
};

static const afw_value_function_parameter_t
impl_lt_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_expression_parameters[] = {
    &impl_lt_expression_parameter_1,
    &impl_lt_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("lt<expression>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_expression"),
    AFW_UTF8_LITERAL("ltExpression"),
    AFW_UTF8_LITERAL("afwLtExpression"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for expression arg1 is less that expression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: expression): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<expression> (\n    arg1: expression,\n    arg2: expression\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_expression_parameters[0],
    2,
    &impl_lt_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<expression> ---------- */

static const afw_utf8_t
impl_object_path__ne_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_expression");

static const afw_runtime_object_indirect_t
impl_object__ne_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_expression
        }
    },
    (void *)&afw_function_definition_ne_expression
};

static const afw_value_function_parameter_t
impl_ne_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_expression_parameters[] = {
    &impl_ne_expression_parameter_1,
    &impl_ne_expression_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_expression_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("ne<expression>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_expression"),
    AFW_UTF8_LITERAL("neExpression"),
    AFW_UTF8_LITERAL("afwNeExpression"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if expression arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<expression> (\n    arg1: expression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_expression_parameters[0],
    2,
    &impl_ne_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    &impl_ne_expression_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<expression> ---------- */

static const afw_utf8_t
impl_object_path__nex_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_expression");

static const afw_runtime_object_indirect_t
impl_object__nex_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_expression
        }
    },
    (void *)&afw_function_definition_nex_expression
};

static const afw_value_function_parameter_t
impl_nex_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_expression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_expression_parameters[] = {
    &impl_nex_expression_parameter_1,
    &impl_nex_expression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("nex<expression>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_expression"),
    AFW_UTF8_LITERAL("nexExpression"),
    AFW_UTF8_LITERAL("afwNexExpression"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for expression arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: expression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<expression> (\n    arg1: expression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_expression_parameters[0],
    2,
    &impl_nex_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<expression> ---------- */

static const afw_utf8_t
impl_object_path__to_string_expression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_expression");

static const afw_runtime_object_indirect_t
impl_object__to_string_expression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_expression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_expression
        }
    },
    (void *)&afw_function_definition_to_string_expression
};

static const afw_value_function_parameter_t
impl_to_string_expression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_expression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A expression value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_expression_parameters[] = {
    &impl_to_string_expression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_expression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_expression,
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("to_string<expression>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_expression"),
    AFW_UTF8_LITERAL("toStringExpression"),
    AFW_UTF8_LITERAL("afwToStringExpression"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts expression value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: expression): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<expression> (\n    value: expression\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_expression_parameters[0],
    1,
    &impl_to_string_expression_returns,
    NULL,
    &afw_data_type_expression_direct,
    AFW_UTF8_LITERAL("expression"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<function> ---------- */

static const afw_utf8_t
impl_object_path__bag_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_function");

static const afw_runtime_object_indirect_t
impl_object__bag_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_function
        }
    },
    (void *)&afw_function_definition_bag_function
};

static const afw_value_function_parameter_t
impl_bag_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_function_parameters[] = {
    &impl_bag_function_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("bag<function>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_function"),
    AFW_UTF8_LITERAL("bagFunction"),
    AFW_UTF8_LITERAL("afwBagFunction"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of function values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list function))): (list function)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<function> (\n    ...values: (list of (list function))\n): (list function);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_function_parameters[0],
    1,
    &impl_bag_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<function> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_function");

static const afw_runtime_object_indirect_t
impl_object__bag_size_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_function
        }
    },
    (void *)&afw_function_definition_bag_size_function
};

static const afw_value_function_parameter_t
impl_bag_size_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_function_parameters[] = {
    &impl_bag_size_function_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("bag_size<function>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_function"),
    AFW_UTF8_LITERAL("bagSizeFunction"),
    AFW_UTF8_LITERAL("afwBagSizeFunction"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list function)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<function> (\n    value: (list function)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_function_parameters[0],
    1,
    &impl_bag_size_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<function> ---------- */

static const afw_utf8_t
impl_object_path__eq_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_function");

static const afw_runtime_object_indirect_t
impl_object__eq_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_function
        }
    },
    (void *)&afw_function_definition_eq_function
};

static const afw_value_function_parameter_t
impl_eq_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_function_parameters[] = {
    &impl_eq_function_parameter_1,
    &impl_eq_function_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_function_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("eq<function>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_function"),
    AFW_UTF8_LITERAL("eqFunction"),
    AFW_UTF8_LITERAL("afwEqFunction"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if function arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<function> (\n    arg1: function,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_function_parameters[0],
    2,
    &impl_eq_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    &impl_eq_function_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<function> ---------- */

static const afw_utf8_t
impl_object_path__eqx_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_function");

static const afw_runtime_object_indirect_t
impl_object__eqx_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_function
        }
    },
    (void *)&afw_function_definition_eqx_function
};

static const afw_value_function_parameter_t
impl_eqx_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_function_parameters[] = {
    &impl_eqx_function_parameter_1,
    &impl_eqx_function_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("eqx<function>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_function"),
    AFW_UTF8_LITERAL("eqxFunction"),
    AFW_UTF8_LITERAL("afwEqxFunction"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for function arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<function> (\n    arg1: function,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_function_parameters[0],
    2,
    &impl_eqx_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- function ---------- */

static const afw_utf8_t
impl_object_path__function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/function");

static const afw_runtime_object_indirect_t
impl_object__function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__function
        }
    },
    (void *)&afw_function_definition_function
};

static const afw_value_function_parameter_t
impl_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_function_parameters[] = {
    &impl_function_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_function_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("afwFunction"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converts value to data type function returning function result."),
    AFW_UTF8_LITERAL("(value: any): function"),
    AFW_UTF8_LITERAL("function function (\n    value: any\n): function;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_function_parameters[0],
    1,
    &impl_function_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_function_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<function> ---------- */

static const afw_utf8_t
impl_object_path__ge_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_function");

static const afw_runtime_object_indirect_t
impl_object__ge_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_function
        }
    },
    (void *)&afw_function_definition_ge_function
};

static const afw_value_function_parameter_t
impl_ge_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_function_parameters[] = {
    &impl_ge_function_parameter_1,
    &impl_ge_function_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("ge<function>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_function"),
    AFW_UTF8_LITERAL("geFunction"),
    AFW_UTF8_LITERAL("afwGeFunction"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for function arg1 is greater than or equal to function arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: function): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<function> (\n    arg1: function,\n    arg2: function\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_function_parameters[0],
    2,
    &impl_ge_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<function> ---------- */

static const afw_utf8_t
impl_object_path__gt_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_function");

static const afw_runtime_object_indirect_t
impl_object__gt_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_function
        }
    },
    (void *)&afw_function_definition_gt_function
};

static const afw_value_function_parameter_t
impl_gt_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_function_parameters[] = {
    &impl_gt_function_parameter_1,
    &impl_gt_function_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("gt<function>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_function"),
    AFW_UTF8_LITERAL("gtFunction"),
    AFW_UTF8_LITERAL("afwGtFunction"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for function arg1 is greater than function arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: function): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<function> (\n    arg1: function,\n    arg2: function\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_function_parameters[0],
    2,
    &impl_gt_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<function> ---------- */

static const afw_utf8_t
impl_object_path__is_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_function");

static const afw_runtime_object_indirect_t
impl_object__is_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_function
        }
    },
    (void *)&afw_function_definition_is_function
};

static const afw_value_function_parameter_t
impl_is_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_function_parameters[] = {
    &impl_is_function_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("is<function>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_function"),
    AFW_UTF8_LITERAL("isFunction"),
    AFW_UTF8_LITERAL("afwIsFunction"),
    AFW_UTF8_LITERAL("Checks whether value is dataType function"),
    AFW_UTF8_LITERAL("Checks whether value is dataType function and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType function */\nfunction is<function> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_function_parameters[0],
    1,
    &impl_is_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<function> ---------- */

static const afw_utf8_t
impl_object_path__le_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_function");

static const afw_runtime_object_indirect_t
impl_object__le_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_function
        }
    },
    (void *)&afw_function_definition_le_function
};

static const afw_value_function_parameter_t
impl_le_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_function_parameters[] = {
    &impl_le_function_parameter_1,
    &impl_le_function_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("le<function>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_function"),
    AFW_UTF8_LITERAL("leFunction"),
    AFW_UTF8_LITERAL("afwLeFunction"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for function arg1 is less than or equal to function arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<function> (\n    arg1: function,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_function_parameters[0],
    2,
    &impl_le_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<function> ---------- */

static const afw_utf8_t
impl_object_path__lt_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_function");

static const afw_runtime_object_indirect_t
impl_object__lt_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_function
        }
    },
    (void *)&afw_function_definition_lt_function
};

static const afw_value_function_parameter_t
impl_lt_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_function_parameters[] = {
    &impl_lt_function_parameter_1,
    &impl_lt_function_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("lt<function>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_function"),
    AFW_UTF8_LITERAL("ltFunction"),
    AFW_UTF8_LITERAL("afwLtFunction"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for function arg1 is less that function arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: function): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<function> (\n    arg1: function,\n    arg2: function\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_function_parameters[0],
    2,
    &impl_lt_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<function> ---------- */

static const afw_utf8_t
impl_object_path__ne_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_function");

static const afw_runtime_object_indirect_t
impl_object__ne_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_function
        }
    },
    (void *)&afw_function_definition_ne_function
};

static const afw_value_function_parameter_t
impl_ne_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_function_parameters[] = {
    &impl_ne_function_parameter_1,
    &impl_ne_function_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_function_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("ne<function>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_function"),
    AFW_UTF8_LITERAL("neFunction"),
    AFW_UTF8_LITERAL("afwNeFunction"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if function arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<function> (\n    arg1: function,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_function_parameters[0],
    2,
    &impl_ne_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    &impl_ne_function_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<function> ---------- */

static const afw_utf8_t
impl_object_path__nex_function =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_function");

static const afw_runtime_object_indirect_t
impl_object__nex_function = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_function,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_function
        }
    },
    (void *)&afw_function_definition_nex_function
};

static const afw_value_function_parameter_t
impl_nex_function_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_function_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_function_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_function_parameters[] = {
    &impl_nex_function_parameter_1,
    &impl_nex_function_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_function = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_function,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("nex<function>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_function"),
    AFW_UTF8_LITERAL("nexFunction"),
    AFW_UTF8_LITERAL("afwNexFunction"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for function arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: function, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<function> (\n    arg1: function,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_function_parameters[0],
    2,
    &impl_nex_function_returns,
    NULL,
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_hexBinary
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_hexBinary
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_hexBinary_parameters[] = {
    &impl_at_least_one_member_of_hexBinary_parameter_1,
    &impl_at_least_one_member_of_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("at_least_one_member_of<hexBinary>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_hexBinary"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfHexBinary"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfHexBinary"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in hexBinary list1 is in hexBinary list2."),
    AFW_UTF8_LITERAL("(list1: (list hexBinary), list2: (list hexBinary)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<hexBinary> (\n    list1: (list hexBinary),\n    list2: (list hexBinary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_hexBinary_parameters[0],
    2,
    &impl_at_least_one_member_of_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__bag_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__bag_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_hexBinary
        }
    },
    (void *)&afw_function_definition_bag_hexBinary
};

static const afw_value_function_parameter_t
impl_bag_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_hexBinary_parameters[] = {
    &impl_bag_hexBinary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("bag<hexBinary>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_hexBinary"),
    AFW_UTF8_LITERAL("bagHexBinary"),
    AFW_UTF8_LITERAL("afwBagHexBinary"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of hexBinary values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list hexBinary))): (list hexBinary)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<hexBinary> (\n    ...values: (list of (list hexBinary))\n): (list hexBinary);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_hexBinary_parameters[0],
    1,
    &impl_bag_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__bag_size_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_hexBinary
        }
    },
    (void *)&afw_function_definition_bag_size_hexBinary
};

static const afw_value_function_parameter_t
impl_bag_size_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_hexBinary_parameters[] = {
    &impl_bag_size_hexBinary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("bag_size<hexBinary>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_hexBinary"),
    AFW_UTF8_LITERAL("bagSizeHexBinary"),
    AFW_UTF8_LITERAL("afwBagSizeHexBinary"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list hexBinary)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<hexBinary> (\n    value: (list hexBinary)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_hexBinary_parameters[0],
    1,
    &impl_bag_size_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- decode_to_string<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__decode_to_string_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/decode_to_string_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__decode_to_string_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_decode_to_string_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__decode_to_string_hexBinary
        }
    },
    (void *)&afw_function_definition_decode_to_string_hexBinary
};

static const afw_value_function_parameter_t
impl_decode_to_string_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The decoded string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_decode_to_string_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The hexBinary value to decode."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_decode_to_string_hexBinary_parameters[] = {
    &impl_decode_to_string_hexBinary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decode_to_string_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__decode_to_string_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("decode_to_string<hexBinary>"),
    AFW_UTF8_LITERAL("decode_to_string"),
    AFW_UTF8_LITERAL("decode_to_string_hexBinary"),
    AFW_UTF8_LITERAL("decodeToStringHexBinary"),
    AFW_UTF8_LITERAL("afwDecodeToStringHexBinary"),
    AFW_UTF8_LITERAL("Decode hexBinary to string"),
    AFW_UTF8_LITERAL("Decode hexBinary value to string. An error is thrown if decoded value is not valid UTF-8."),
    AFW_UTF8_LITERAL("(value: hexBinary): string"),
    AFW_UTF8_LITERAL("/* Decode hexBinary to string */\nfunction decode_to_string<hexBinary> (\n    value: hexBinary\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_decode_to_string_hexBinary,
    NULL,
    1,
    1,
    &impl_decode_to_string_hexBinary_parameters[0],
    1,
    &impl_decode_to_string_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_decode_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__eq_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__eq_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_hexBinary
        }
    },
    (void *)&afw_function_definition_eq_hexBinary
};

static const afw_value_function_parameter_t
impl_eq_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_hexBinary_parameters[] = {
    &impl_eq_hexBinary_parameter_1,
    &impl_eq_hexBinary_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_hexBinary_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("eq<hexBinary>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_hexBinary"),
    AFW_UTF8_LITERAL("eqHexBinary"),
    AFW_UTF8_LITERAL("afwEqHexBinary"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if hexBinary arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<hexBinary> (\n    arg1: hexBinary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_hexBinary_parameters[0],
    2,
    &impl_eq_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    &impl_eq_hexBinary_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__eqx_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__eqx_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_hexBinary
        }
    },
    (void *)&afw_function_definition_eqx_hexBinary
};

static const afw_value_function_parameter_t
impl_eqx_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_hexBinary_parameters[] = {
    &impl_eqx_hexBinary_parameter_1,
    &impl_eqx_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("eqx<hexBinary>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_hexBinary"),
    AFW_UTF8_LITERAL("eqxHexBinary"),
    AFW_UTF8_LITERAL("afwEqxHexBinary"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for hexBinary arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<hexBinary> (\n    arg1: hexBinary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_hexBinary_parameters[0],
    2,
    &impl_eqx_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__ge_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__ge_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_hexBinary
        }
    },
    (void *)&afw_function_definition_ge_hexBinary
};

static const afw_value_function_parameter_t
impl_ge_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_hexBinary_parameters[] = {
    &impl_ge_hexBinary_parameter_1,
    &impl_ge_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("ge<hexBinary>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_hexBinary"),
    AFW_UTF8_LITERAL("geHexBinary"),
    AFW_UTF8_LITERAL("afwGeHexBinary"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for hexBinary arg1 is greater than or equal to hexBinary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: hexBinary): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<hexBinary> (\n    arg1: hexBinary,\n    arg2: hexBinary\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_hexBinary_parameters[0],
    2,
    &impl_ge_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__gt_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__gt_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_hexBinary
        }
    },
    (void *)&afw_function_definition_gt_hexBinary
};

static const afw_value_function_parameter_t
impl_gt_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_hexBinary_parameters[] = {
    &impl_gt_hexBinary_parameter_1,
    &impl_gt_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("gt<hexBinary>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_hexBinary"),
    AFW_UTF8_LITERAL("gtHexBinary"),
    AFW_UTF8_LITERAL("afwGtHexBinary"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for hexBinary arg1 is greater than hexBinary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: hexBinary): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<hexBinary> (\n    arg1: hexBinary,\n    arg2: hexBinary\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_hexBinary_parameters[0],
    2,
    &impl_gt_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- hexBinary ---------- */

static const afw_utf8_t
impl_object_path__hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/hexBinary");

static const afw_runtime_object_indirect_t
impl_object__hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__hexBinary
        }
    },
    (void *)&afw_function_definition_hexBinary
};

static const afw_value_function_parameter_t
impl_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_hexBinary_parameters[] = {
    &impl_hexBinary_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_hexBinary_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("afwHexBinary"),
    AFW_UTF8_LITERAL("Convert to data type hexBinary"),
    AFW_UTF8_LITERAL("Converts value to data type hexBinary returning hexBinary result."),
    AFW_UTF8_LITERAL("(value: any): hexBinary"),
    AFW_UTF8_LITERAL("/* Convert to data type hexBinary */\nfunction hexBinary (\n    value: any\n): hexBinary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_hexBinary_parameters[0],
    1,
    &impl_hexBinary_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_hexBinary_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__intersection_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__intersection_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_hexBinary
        }
    },
    (void *)&afw_function_definition_intersection_hexBinary
};

static const afw_value_function_parameter_t
impl_intersection_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_hexBinary_parameters[] = {
    &impl_intersection_hexBinary_parameter_1,
    &impl_intersection_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("intersection<hexBinary>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_hexBinary"),
    AFW_UTF8_LITERAL("intersectionHexBinary"),
    AFW_UTF8_LITERAL("afwIntersectionHexBinary"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of hexBinary with the values that are common to both list of hexBinary list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list hexBinary), list2: (list hexBinary)): (list hexBinary)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<hexBinary> (\n    list1: (list hexBinary),\n    list2: (list hexBinary)\n): (list hexBinary);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_hexBinary_parameters[0],
    2,
    &impl_intersection_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__is_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__is_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_hexBinary
        }
    },
    (void *)&afw_function_definition_is_hexBinary
};

static const afw_value_function_parameter_t
impl_is_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_hexBinary_parameters[] = {
    &impl_is_hexBinary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("is<hexBinary>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_hexBinary"),
    AFW_UTF8_LITERAL("isHexBinary"),
    AFW_UTF8_LITERAL("afwIsHexBinary"),
    AFW_UTF8_LITERAL("Checks whether value is dataType hexBinary"),
    AFW_UTF8_LITERAL("Checks whether value is dataType hexBinary and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType hexBinary */\nfunction is<hexBinary> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_hexBinary_parameters[0],
    1,
    &impl_is_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__is_in_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__is_in_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_hexBinary
        }
    },
    (void *)&afw_function_definition_is_in_hexBinary
};

static const afw_value_function_parameter_t
impl_is_in_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_hexBinary_parameters[] = {
    &impl_is_in_hexBinary_parameter_1,
    &impl_is_in_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("is_in<hexBinary>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_hexBinary"),
    AFW_UTF8_LITERAL("isInHexBinary"),
    AFW_UTF8_LITERAL("afwIsInHexBinary"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether hexBinary value is in list of hexBinary list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: hexBinary, list: (list hexBinary)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<hexBinary> (\n    value: hexBinary,\n    list: (list hexBinary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_hexBinary_parameters[0],
    2,
    &impl_is_in_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__le_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__le_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_hexBinary
        }
    },
    (void *)&afw_function_definition_le_hexBinary
};

static const afw_value_function_parameter_t
impl_le_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_hexBinary_parameters[] = {
    &impl_le_hexBinary_parameter_1,
    &impl_le_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("le<hexBinary>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_hexBinary"),
    AFW_UTF8_LITERAL("leHexBinary"),
    AFW_UTF8_LITERAL("afwLeHexBinary"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for hexBinary arg1 is less than or equal to hexBinary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<hexBinary> (\n    arg1: hexBinary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_hexBinary_parameters[0],
    2,
    &impl_le_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__lt_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__lt_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_hexBinary
        }
    },
    (void *)&afw_function_definition_lt_hexBinary
};

static const afw_value_function_parameter_t
impl_lt_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_hexBinary_parameters[] = {
    &impl_lt_hexBinary_parameter_1,
    &impl_lt_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("lt<hexBinary>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_hexBinary"),
    AFW_UTF8_LITERAL("ltHexBinary"),
    AFW_UTF8_LITERAL("afwLtHexBinary"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for hexBinary arg1 is less that hexBinary arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: hexBinary): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<hexBinary> (\n    arg1: hexBinary,\n    arg2: hexBinary\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_hexBinary_parameters[0],
    2,
    &impl_lt_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__ne_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__ne_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_hexBinary
        }
    },
    (void *)&afw_function_definition_ne_hexBinary
};

static const afw_value_function_parameter_t
impl_ne_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_hexBinary_parameters[] = {
    &impl_ne_hexBinary_parameter_1,
    &impl_ne_hexBinary_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_hexBinary_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("ne<hexBinary>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_hexBinary"),
    AFW_UTF8_LITERAL("neHexBinary"),
    AFW_UTF8_LITERAL("afwNeHexBinary"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if hexBinary arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<hexBinary> (\n    arg1: hexBinary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_hexBinary_parameters[0],
    2,
    &impl_ne_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    &impl_ne_hexBinary_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__nex_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__nex_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_hexBinary
        }
    },
    (void *)&afw_function_definition_nex_hexBinary
};

static const afw_value_function_parameter_t
impl_nex_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_hexBinary_parameters[] = {
    &impl_nex_hexBinary_parameter_1,
    &impl_nex_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("nex<hexBinary>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_hexBinary"),
    AFW_UTF8_LITERAL("nexHexBinary"),
    AFW_UTF8_LITERAL("afwNexHexBinary"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for hexBinary arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: hexBinary, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<hexBinary> (\n    arg1: hexBinary,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_hexBinary_parameters[0],
    2,
    &impl_nex_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_hexBinary
        }
    },
    (void *)&afw_function_definition_one_and_only_hexBinary
};

static const afw_value_function_parameter_t
impl_one_and_only_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_hexBinary_parameters[] = {
    &impl_one_and_only_hexBinary_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_hexBinary_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("one_and_only<hexBinary>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_hexBinary"),
    AFW_UTF8_LITERAL("oneAndOnlyHexBinary"),
    AFW_UTF8_LITERAL("afwOneAndOnlyHexBinary"),
    AFW_UTF8_LITERAL("Converts a one value list to a hexBinary value"),
    AFW_UTF8_LITERAL("This converts a list of hexBinary values that contains one value to a single hexBinary value."),
    AFW_UTF8_LITERAL("(list: (list list)): hexBinary"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a hexBinary value */\nfunction one_and_only<hexBinary> (\n    list: (list list)\n): hexBinary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_hexBinary_parameters[0],
    1,
    &impl_one_and_only_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    &impl_one_and_only_hexBinary_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__set_equals_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_hexBinary
        }
    },
    (void *)&afw_function_definition_set_equals_hexBinary
};

static const afw_value_function_parameter_t
impl_set_equals_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_hexBinary_parameters[] = {
    &impl_set_equals_hexBinary_parameter_1,
    &impl_set_equals_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("set_equals<hexBinary>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_hexBinary"),
    AFW_UTF8_LITERAL("setEqualsHexBinary"),
    AFW_UTF8_LITERAL("afwSetEqualsHexBinary"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if hexBinary list1 and hexBinary list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list hexBinary), list2: (list hexBinary)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<hexBinary> (\n    list1: (list hexBinary),\n    list2: (list hexBinary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_hexBinary_parameters[0],
    2,
    &impl_set_equals_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__subset_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__subset_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_hexBinary
        }
    },
    (void *)&afw_function_definition_subset_hexBinary
};

static const afw_value_function_parameter_t
impl_subset_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_hexBinary_parameters[] = {
    &impl_subset_hexBinary_parameter_1,
    &impl_subset_hexBinary_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("subset<hexBinary>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_hexBinary"),
    AFW_UTF8_LITERAL("subsetHexBinary"),
    AFW_UTF8_LITERAL("afwSubsetHexBinary"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in hexBinary list1 are all in hexBinary list2."),
    AFW_UTF8_LITERAL("(list1: (list hexBinary), list2: (list hexBinary)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<hexBinary> (\n    list1: (list hexBinary),\n    list2: (list hexBinary)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_hexBinary_parameters[0],
    2,
    &impl_subset_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__to_string_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__to_string_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_hexBinary
        }
    },
    (void *)&afw_function_definition_to_string_hexBinary
};

static const afw_value_function_parameter_t
impl_to_string_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A hexBinary value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_hexBinary_parameters[] = {
    &impl_to_string_hexBinary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("to_string<hexBinary>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_hexBinary"),
    AFW_UTF8_LITERAL("toStringHexBinary"),
    AFW_UTF8_LITERAL("afwToStringHexBinary"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts hexBinary value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: hexBinary): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<hexBinary> (\n    value: hexBinary\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_hexBinary_parameters[0],
    1,
    &impl_to_string_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<hexBinary> ---------- */

static const afw_utf8_t
impl_object_path__union_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__union_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_hexBinary
        }
    },
    (void *)&afw_function_definition_union_hexBinary
};

static const afw_value_function_parameter_t
impl_union_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_hexBinary_parameters[] = {
    &impl_union_hexBinary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_hexBinary,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("union<hexBinary>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_hexBinary"),
    AFW_UTF8_LITERAL("unionHexBinary"),
    AFW_UTF8_LITERAL("afwUnionHexBinary"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of hexBinary contains all of the unique values in two or more list of hexBinary values."),
    AFW_UTF8_LITERAL("(lists_1: (list hexBinary), lists_2: (list hexBinary), ...lists_rest: (list of (list hexBinary))): (list hexBinary)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<hexBinary> (\n    lists_1: (list hexBinary),\n    lists_2: (list hexBinary),\n    ...lists_rest: (list of (list hexBinary))\n): (list hexBinary);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_hexBinary_parameters[0],
    1,
    &impl_union_hexBinary_returns,
    NULL,
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- all_of ---------- */

static const afw_utf8_t
impl_object_path__all_of =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/all_of");

static const afw_runtime_object_indirect_t
impl_object__all_of = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_all_of,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__all_of
        }
    },
    (void *)&afw_function_definition_all_of
};

static const afw_value_function_parameter_t
impl_all_of_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(... values: any): boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This function is called for each value in the first list in values or until false is returned. If no calls return false, the result is true."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("These are the parameters passed to predicate with the exception that the first list is passed one value at a time. At least one list is required."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_all_of_parameters[] = {
    &impl_all_of_parameter_1,
    &impl_all_of_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_all_of = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__all_of,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("all_of"),
    AFW_UTF8_LITERAL("all_of"),
    AFW_UTF8_LITERAL("all_of"),
    AFW_UTF8_LITERAL("allOf"),
    AFW_UTF8_LITERAL("afwAllOf"),
    AFW_UTF8_LITERAL("All values pass a test"),
    AFW_UTF8_LITERAL("Returns true if all values in a list pass the predicate test."),
    AFW_UTF8_LITERAL("(predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any)): boolean"),
    AFW_UTF8_LITERAL("/* All values pass a test */\nfunction all_of (\n    predicate: (function (... values: any): boolean),\n    values_1: any,\n    ...values_rest: (list of any)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_all_of,
    NULL,
    2,
    -1,
    &impl_all_of_parameters[0],
    2,
    &impl_all_of_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- all_of_all ---------- */

static const afw_utf8_t
impl_object_path__all_of_all =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/all_of_all");

static const afw_runtime_object_indirect_t
impl_object__all_of_all = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_all_of_all,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__all_of_all
        }
    },
    (void *)&afw_function_definition_all_of_all
};

static const afw_value_function_parameter_t
impl_all_of_all_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_all_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(any value1: any, value2: any): boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_all_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_all_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_all_of_all_parameters[] = {
    &impl_all_of_all_parameter_1,
    &impl_all_of_all_parameter_2,
    &impl_all_of_all_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_all_of_all = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__all_of_all,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("all_of_all"),
    AFW_UTF8_LITERAL("all_of_all"),
    AFW_UTF8_LITERAL("all_of_all"),
    AFW_UTF8_LITERAL("allOfAll"),
    AFW_UTF8_LITERAL("afwAllOfAll"),
    AFW_UTF8_LITERAL("All combinations true"),
    AFW_UTF8_LITERAL("Returns true if the result of calling predicate with all of the combination of values from list1 and list2 returns true."),
    AFW_UTF8_LITERAL("(predicate: (function (any value1: any, value2: any): boolean), list1: list, list2: list): boolean"),
    AFW_UTF8_LITERAL("/* All combinations true */\nfunction all_of_all (\n    predicate: (function (any value1: any, value2: any): boolean),\n    list1: list,\n    list2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_all_of_all,
    NULL,
    3,
    3,
    &impl_all_of_all_parameters[0],
    3,
    &impl_all_of_all_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- all_of_any ---------- */

static const afw_utf8_t
impl_object_path__all_of_any =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/all_of_any");

static const afw_runtime_object_indirect_t
impl_object__all_of_any = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_all_of_any,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__all_of_any
        }
    },
    (void *)&afw_function_definition_all_of_any
};

static const afw_value_function_parameter_t
impl_all_of_any_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_any_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(value1: any, value2: any): boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_any_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_all_of_any_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_all_of_any_parameters[] = {
    &impl_all_of_any_parameter_1,
    &impl_all_of_any_parameter_2,
    &impl_all_of_any_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_all_of_any = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__all_of_any,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("all_of_any"),
    AFW_UTF8_LITERAL("all_of_any"),
    AFW_UTF8_LITERAL("all_of_any"),
    AFW_UTF8_LITERAL("allOfAny"),
    AFW_UTF8_LITERAL("afwAllOfAny"),
    AFW_UTF8_LITERAL("Combinations of all in list1 and any in list2 true"),
    AFW_UTF8_LITERAL("This function returns true if the result of calling predicate with all of the combination of values from list1 and any of the values of list2 returns true."),
    AFW_UTF8_LITERAL("(predicate: (function (value1: any, value2: any): boolean), list1: list, list2: list): boolean"),
    AFW_UTF8_LITERAL("/* Combinations of all in list1 and any in list2 true */\nfunction all_of_any (\n    predicate: (function (value1: any, value2: any): boolean),\n    list1: list,\n    list2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_all_of_any,
    NULL,
    3,
    3,
    &impl_all_of_any_parameters[0],
    3,
    &impl_all_of_any_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- any_of ---------- */

static const afw_utf8_t
impl_object_path__any_of =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/any_of");

static const afw_runtime_object_indirect_t
impl_object__any_of = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_any_of,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__any_of
        }
    },
    (void *)&afw_function_definition_any_of
};

static const afw_value_function_parameter_t
impl_any_of_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(... values: any): boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This function is called for each value in the first list in values or until true is returned. If no calls return true, the result is false."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("These are the parameters passed to predicate with the exception that the first list is passed one value at a time. At least one list is required."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_any_of_parameters[] = {
    &impl_any_of_parameter_1,
    &impl_any_of_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_any_of = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__any_of,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("any_of"),
    AFW_UTF8_LITERAL("any_of"),
    AFW_UTF8_LITERAL("any_of"),
    AFW_UTF8_LITERAL("anyOf"),
    AFW_UTF8_LITERAL("afwAnyOf"),
    AFW_UTF8_LITERAL("Any values pass a test"),
    AFW_UTF8_LITERAL("Returns true if any value in a list pass the predicate test."),
    AFW_UTF8_LITERAL("(predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any)): boolean"),
    AFW_UTF8_LITERAL("/* Any values pass a test */\nfunction any_of (\n    predicate: (function (... values: any): boolean),\n    values_1: any,\n    ...values_rest: (list of any)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_any_of,
    NULL,
    2,
    -1,
    &impl_any_of_parameters[0],
    2,
    &impl_any_of_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- any_of_all ---------- */

static const afw_utf8_t
impl_object_path__any_of_all =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/any_of_all");

static const afw_runtime_object_indirect_t
impl_object__any_of_all = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_any_of_all,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__any_of_all
        }
    },
    (void *)&afw_function_definition_any_of_all
};

static const afw_value_function_parameter_t
impl_any_of_all_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_all_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(value1: any, value2: any):boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_all_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_all_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_any_of_all_parameters[] = {
    &impl_any_of_all_parameter_1,
    &impl_any_of_all_parameter_2,
    &impl_any_of_all_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_any_of_all = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__any_of_all,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("any_of_all"),
    AFW_UTF8_LITERAL("any_of_all"),
    AFW_UTF8_LITERAL("any_of_all"),
    AFW_UTF8_LITERAL("anyOfAll"),
    AFW_UTF8_LITERAL("afwAnyOfAll"),
    AFW_UTF8_LITERAL("Combinations of any in list1 and all in list2 true"),
    AFW_UTF8_LITERAL("Returns true if the result of calling predicate with all of the combination of values from list2 and any of the values of list1 returns true."),
    AFW_UTF8_LITERAL("(predicate: (function (value1: any, value2: any):boolean), list1: list, list2: list): boolean"),
    AFW_UTF8_LITERAL("/* Combinations of any in list1 and all in list2 true */\nfunction any_of_all (\n    predicate: (function (value1: any, value2: any):boolean),\n    list1: list,\n    list2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_any_of_all,
    NULL,
    3,
    3,
    &impl_any_of_all_parameters[0],
    3,
    &impl_any_of_all_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- any_of_any ---------- */

static const afw_utf8_t
impl_object_path__any_of_any =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/any_of_any");

static const afw_runtime_object_indirect_t
impl_object__any_of_any = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_any_of_any,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__any_of_any
        }
    },
    (void *)&afw_function_definition_any_of_any
};

static const afw_value_function_parameter_t
impl_any_of_any_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_any_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(value1: any, value2: any): boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_any_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_any_of_any_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_any_of_any_parameters[] = {
    &impl_any_of_any_parameter_1,
    &impl_any_of_any_parameter_2,
    &impl_any_of_any_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_any_of_any = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__any_of_any,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("any_of_any"),
    AFW_UTF8_LITERAL("any_of_any"),
    AFW_UTF8_LITERAL("any_of_any"),
    AFW_UTF8_LITERAL("anyOfAny"),
    AFW_UTF8_LITERAL("afwAnyOfAny"),
    AFW_UTF8_LITERAL("Any combinations true"),
    AFW_UTF8_LITERAL("This function returns true if the result of calling predicate with any of the combination of values from list1 and list2 returns true."),
    AFW_UTF8_LITERAL("(predicate: (function (value1: any, value2: any): boolean), list1: list, list2: list): boolean"),
    AFW_UTF8_LITERAL("/* Any combinations true */\nfunction any_of_any (\n    predicate: (function (value1: any, value2: any): boolean),\n    list1: list,\n    list2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_any_of_any,
    NULL,
    3,
    3,
    &impl_any_of_any_parameters[0],
    3,
    &impl_any_of_any_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- filter ---------- */

static const afw_utf8_t
impl_object_path__filter =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/filter");

static const afw_runtime_object_indirect_t
impl_object__filter = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_filter,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__filter
        }
    },
    (void *)&afw_function_definition_filter
};

static const afw_value_function_parameter_t
impl_filter_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the resulting filtered list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_filter_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(... values: any): boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a boolean function that is called to determine if a list entry should be included in the returned list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_filter_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("These are the values passed to the predicate with the exception that the first list is passed as the single current value from the list. At least one list is required."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_filter_parameters[] = {
    &impl_filter_parameter_1,
    &impl_filter_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_filter = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__filter,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("filter"),
    AFW_UTF8_LITERAL("filter"),
    AFW_UTF8_LITERAL("filter"),
    AFW_UTF8_LITERAL("filter"),
    AFW_UTF8_LITERAL("afwFilter"),
    AFW_UTF8_LITERAL("Filter a list"),
    AFW_UTF8_LITERAL("This produces a list containing only values from another list that pass a predicate test."),
    AFW_UTF8_LITERAL("(predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any)): list"),
    AFW_UTF8_LITERAL("/* Filter a list */\nfunction filter (\n    predicate: (function (... values: any): boolean),\n    values_1: any,\n    ...values_rest: (list of any)\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_filter,
    NULL,
    2,
    -1,
    &impl_filter_parameters[0],
    2,
    &impl_filter_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- find ---------- */

static const afw_utf8_t
impl_object_path__find =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/find");

static const afw_runtime_object_indirect_t
impl_object__find = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_find,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__find
        }
    },
    (void *)&afw_function_definition_find
};

static const afw_value_function_parameter_t
impl_find_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first value that passes the test is returned."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_find_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(... values: any): boolean"),
    AFW_UTF8_LITERAL("predicate"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a boolean function that is called to determine if a list entry passes the test."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_find_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("These are the values passed to the predicate with the exception that the first list is passed as the single current value from the list. At least one list is required."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_find_parameters[] = {
    &impl_find_parameter_1,
    &impl_find_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_find = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__find,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("find"),
    AFW_UTF8_LITERAL("find"),
    AFW_UTF8_LITERAL("find"),
    AFW_UTF8_LITERAL("find"),
    AFW_UTF8_LITERAL("afwFind"),
    AFW_UTF8_LITERAL("Returns the first value in a list that passes a test"),
    AFW_UTF8_LITERAL("The predicate is called for each value in the first list in values until true is returned, then that value is returned."),
    AFW_UTF8_LITERAL("(predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any)): any"),
    AFW_UTF8_LITERAL("/* Returns the first value in a list that passes a test */\nfunction find (\n    predicate: (function (... values: any): boolean),\n    values_1: any,\n    ...values_rest: (list of any)\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_find,
    NULL,
    2,
    -1,
    &impl_find_parameters[0],
    2,
    &impl_find_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- map ---------- */

static const afw_utf8_t
impl_object_path__map =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/map");

static const afw_runtime_object_indirect_t
impl_object__map = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_map,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__map
        }
    },
    (void *)&afw_function_definition_map
};

static const afw_value_function_parameter_t
impl_map_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_map_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(... values: any): any"),
    AFW_UTF8_LITERAL("functor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_map_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("These are the parameters passed to functor with the exception that the first list is passed one value at a time. At least one list is required."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_map_parameters[] = {
    &impl_map_parameter_1,
    &impl_map_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_map = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__map,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("map"),
    AFW_UTF8_LITERAL("map"),
    AFW_UTF8_LITERAL("map"),
    AFW_UTF8_LITERAL("map"),
    AFW_UTF8_LITERAL("afwMap"),
    AFW_UTF8_LITERAL("Maps values of a list"),
    AFW_UTF8_LITERAL("This function creates a list of the results of calling functor with each value of the first list in values"),
    AFW_UTF8_LITERAL("(functor: (function (... values: any): any), values_1: any, ...values_rest: (list of any)): list"),
    AFW_UTF8_LITERAL("/* Maps values of a list */\nfunction map (\n    functor: (function (... values: any): any),\n    values_1: any,\n    ...values_rest: (list of any)\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_map,
    NULL,
    2,
    -1,
    &impl_map_parameters[0],
    2,
    &impl_map_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- reduce ---------- */

static const afw_utf8_t
impl_object_path__reduce =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/reduce");

static const afw_runtime_object_indirect_t
impl_object__reduce = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_reduce,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__reduce
        }
    },
    (void *)&afw_function_definition_reduce
};

static const afw_value_function_parameter_t
impl_reduce_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the final return value from functor() or the accumulator parameter value if list is empty."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_reduce_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(accumulator: any, value: any): any"),
    AFW_UTF8_LITERAL("functor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This function is called for each value in a list. The returned value is passed as the accumulator parameter on the next call to functor()."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_reduce_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("accumulator"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an initial accumulator value passed to functor(). Normally, the dataType of accumulator will be the dataTape for the reduce() return value, but this is not required."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_reduce_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list to be reduced."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_reduce_parameters[] = {
    &impl_reduce_parameter_1,
    &impl_reduce_parameter_2,
    &impl_reduce_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_reduce = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__reduce,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("reduce"),
    AFW_UTF8_LITERAL("reduce"),
    AFW_UTF8_LITERAL("reduce"),
    AFW_UTF8_LITERAL("reduce"),
    AFW_UTF8_LITERAL("afwReduce"),
    AFW_UTF8_LITERAL("Reduce values of a list to a single value"),
    AFW_UTF8_LITERAL("Reduce calls functor for each value in list with two parameters, accumulator and value, and must return a value of any dataType. Parameter accumulator is the reduce() accumulator parameter value on first call and the return value of previous functor() call on subsequent calls. The dataType of the return value should normally be the same as accumulator, but this is not required."),
    AFW_UTF8_LITERAL("(functor: (function (accumulator: any, value: any): any), accumulator: any, list: list): any"),
    AFW_UTF8_LITERAL("/* Reduce values of a list to a single value */\nfunction reduce (\n    functor: (function (accumulator: any, value: any): any),\n    accumulator: any,\n    list: list\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_reduce,
    NULL,
    3,
    3,
    &impl_reduce_parameters[0],
    3,
    &impl_reduce_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- sort ---------- */

static const afw_utf8_t
impl_object_path__sort =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/sort");

static const afw_runtime_object_indirect_t
impl_object__sort = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_sort,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__sort
        }
    },
    (void *)&afw_function_definition_sort
};

static const afw_value_function_parameter_t
impl_sort_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This the the resulting sorted list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_sort_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_function_direct,
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("(value1: any, value2: any): integer"),
    AFW_UTF8_LITERAL("compareFunction"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This function is called with two value from list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_sort_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the list to sort."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_sort_parameters[] = {
    &impl_sort_parameter_1,
    &impl_sort_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_sort = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__sort,
    AFW_UTF8_LITERAL("higher_order_list"),
    AFW_UTF8_LITERAL("sort"),
    AFW_UTF8_LITERAL("sort"),
    AFW_UTF8_LITERAL("sort"),
    AFW_UTF8_LITERAL("sort"),
    AFW_UTF8_LITERAL("afwSort"),
    AFW_UTF8_LITERAL("Sort values in a list"),
    AFW_UTF8_LITERAL("This produces a list with values sorted based on result of compareFunction. The compareFunction is passed two values from the list and must return an integer less than 0 if the first value is less than the second value, 0 if they are equal, and a integer greater than 0 if the first value is greater than the second value."),
    AFW_UTF8_LITERAL("(compareFunction: (function (value1: any, value2: any): integer), list: list): list"),
    AFW_UTF8_LITERAL("/* Sort values in a list */\nfunction sort (\n    compareFunction: (function (value1: any, value2: any): integer),\n    list: list\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_sort,
    NULL,
    2,
    2,
    &impl_sort_parameters[0],
    2,
    &impl_sort_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__bag_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_hybrid");

static const afw_runtime_object_indirect_t
impl_object__bag_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_hybrid
        }
    },
    (void *)&afw_function_definition_bag_hybrid
};

static const afw_value_function_parameter_t
impl_bag_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_hybrid_parameters[] = {
    &impl_bag_hybrid_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("bag<hybrid>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_hybrid"),
    AFW_UTF8_LITERAL("bagHybrid"),
    AFW_UTF8_LITERAL("afwBagHybrid"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of hybrid values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list hybrid))): (list hybrid)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<hybrid> (\n    ...values: (list of (list hybrid))\n): (list hybrid);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_hybrid_parameters[0],
    1,
    &impl_bag_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_hybrid");

static const afw_runtime_object_indirect_t
impl_object__bag_size_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_hybrid
        }
    },
    (void *)&afw_function_definition_bag_size_hybrid
};

static const afw_value_function_parameter_t
impl_bag_size_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_hybrid_parameters[] = {
    &impl_bag_size_hybrid_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("bag_size<hybrid>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_hybrid"),
    AFW_UTF8_LITERAL("bagSizeHybrid"),
    AFW_UTF8_LITERAL("afwBagSizeHybrid"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list hybrid)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<hybrid> (\n    value: (list hybrid)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_hybrid_parameters[0],
    1,
    &impl_bag_size_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compile<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__compile_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_hybrid");

static const afw_runtime_object_indirect_t
impl_object__compile_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_hybrid
        }
    },
    (void *)&afw_function_definition_compile_hybrid
};

static const afw_value_function_parameter_t
impl_compile_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to compile"),
    AFW_UTF8_LITERAL("hybrid string to compile"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL("Listing option"),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_hybrid_parameters[] = {
    &impl_compile_hybrid_parameter_1,
    &impl_compile_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("compile<hybrid>"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile_hybrid"),
    AFW_UTF8_LITERAL("compileHybrid"),
    AFW_UTF8_LITERAL("afwCompileHybrid"),
    AFW_UTF8_LITERAL("Compile hybrid value"),
    AFW_UTF8_LITERAL("Compile hybrid value and return either an unevaluated adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(source: hybrid, listing?: any): unevaluated"),
    AFW_UTF8_LITERAL("/* Compile hybrid value */\nfunction compile<hybrid> (\n    source: hybrid /* Source to compile */,\n    listing?: any  /* Listing option */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_hybrid,
    NULL,
    1,
    2,
    &impl_compile_hybrid_parameters[0],
    2,
    &impl_compile_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_compile,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__eq_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_hybrid");

static const afw_runtime_object_indirect_t
impl_object__eq_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_hybrid
        }
    },
    (void *)&afw_function_definition_eq_hybrid
};

static const afw_value_function_parameter_t
impl_eq_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_hybrid_parameters[] = {
    &impl_eq_hybrid_parameter_1,
    &impl_eq_hybrid_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_hybrid_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("eq<hybrid>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_hybrid"),
    AFW_UTF8_LITERAL("eqHybrid"),
    AFW_UTF8_LITERAL("afwEqHybrid"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if hybrid arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<hybrid> (\n    arg1: hybrid,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_hybrid_parameters[0],
    2,
    &impl_eq_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    &impl_eq_hybrid_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__eqx_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_hybrid");

static const afw_runtime_object_indirect_t
impl_object__eqx_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_hybrid
        }
    },
    (void *)&afw_function_definition_eqx_hybrid
};

static const afw_value_function_parameter_t
impl_eqx_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_hybrid_parameters[] = {
    &impl_eqx_hybrid_parameter_1,
    &impl_eqx_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("eqx<hybrid>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_hybrid"),
    AFW_UTF8_LITERAL("eqxHybrid"),
    AFW_UTF8_LITERAL("afwEqxHybrid"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for hybrid arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<hybrid> (\n    arg1: hybrid,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_hybrid_parameters[0],
    2,
    &impl_eqx_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- evaluate<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__evaluate_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_hybrid");

static const afw_runtime_object_indirect_t
impl_object__evaluate_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_hybrid
        }
    },
    (void *)&afw_function_definition_evaluate_hybrid
};

static const afw_value_function_parameter_t
impl_evaluate_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to evaluate"),
    AFW_UTF8_LITERAL("hybrid string to compile and evaluate"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_hybrid_parameters[] = {
    &impl_evaluate_hybrid_parameter_1,
    &impl_evaluate_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("evaluate<hybrid>"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate_hybrid"),
    AFW_UTF8_LITERAL("evaluateHybrid"),
    AFW_UTF8_LITERAL("afwEvaluateHybrid"),
    AFW_UTF8_LITERAL("Evaluate hybrid value"),
    AFW_UTF8_LITERAL("Compile and evaluate hybrid value."),
    AFW_UTF8_LITERAL("(source: hybrid, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): unevaluated"),
    AFW_UTF8_LITERAL("/* Evaluate hybrid value */\nfunction evaluate<hybrid> (\n    source: hybrid                                                                     /* Source to evaluate */,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_hybrid,
    NULL,
    1,
    2,
    &impl_evaluate_hybrid_parameters[0],
    2,
    &impl_evaluate_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_evaluate,
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- ge<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__ge_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_hybrid");

static const afw_runtime_object_indirect_t
impl_object__ge_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_hybrid
        }
    },
    (void *)&afw_function_definition_ge_hybrid
};

static const afw_value_function_parameter_t
impl_ge_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_hybrid_parameters[] = {
    &impl_ge_hybrid_parameter_1,
    &impl_ge_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ge<hybrid>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_hybrid"),
    AFW_UTF8_LITERAL("geHybrid"),
    AFW_UTF8_LITERAL("afwGeHybrid"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for hybrid arg1 is greater than or equal to hybrid arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: hybrid): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<hybrid> (\n    arg1: hybrid,\n    arg2: hybrid\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_hybrid_parameters[0],
    2,
    &impl_ge_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__gt_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_hybrid");

static const afw_runtime_object_indirect_t
impl_object__gt_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_hybrid
        }
    },
    (void *)&afw_function_definition_gt_hybrid
};

static const afw_value_function_parameter_t
impl_gt_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_hybrid_parameters[] = {
    &impl_gt_hybrid_parameter_1,
    &impl_gt_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("gt<hybrid>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_hybrid"),
    AFW_UTF8_LITERAL("gtHybrid"),
    AFW_UTF8_LITERAL("afwGtHybrid"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for hybrid arg1 is greater than hybrid arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: hybrid): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<hybrid> (\n    arg1: hybrid,\n    arg2: hybrid\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_hybrid_parameters[0],
    2,
    &impl_gt_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- hybrid ---------- */

static const afw_utf8_t
impl_object_path__hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/hybrid");

static const afw_runtime_object_indirect_t
impl_object__hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__hybrid
        }
    },
    (void *)&afw_function_definition_hybrid
};

static const afw_value_function_parameter_t
impl_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_hybrid_parameters[] = {
    &impl_hybrid_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_hybrid_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("afwHybrid"),
    AFW_UTF8_LITERAL("Convert to data type hybrid"),
    AFW_UTF8_LITERAL("Converts value to data type hybrid returning hybrid result."),
    AFW_UTF8_LITERAL("(value: any): hybrid"),
    AFW_UTF8_LITERAL("/* Convert to data type hybrid */\nfunction hybrid (\n    value: any\n): hybrid;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_hybrid_parameters[0],
    1,
    &impl_hybrid_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_hybrid_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__is_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_hybrid");

static const afw_runtime_object_indirect_t
impl_object__is_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_hybrid
        }
    },
    (void *)&afw_function_definition_is_hybrid
};

static const afw_value_function_parameter_t
impl_is_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_hybrid_parameters[] = {
    &impl_is_hybrid_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("is<hybrid>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_hybrid"),
    AFW_UTF8_LITERAL("isHybrid"),
    AFW_UTF8_LITERAL("afwIsHybrid"),
    AFW_UTF8_LITERAL("Checks whether value is dataType hybrid"),
    AFW_UTF8_LITERAL("Checks whether value is dataType hybrid and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType hybrid */\nfunction is<hybrid> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_hybrid_parameters[0],
    1,
    &impl_is_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__le_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_hybrid");

static const afw_runtime_object_indirect_t
impl_object__le_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_hybrid
        }
    },
    (void *)&afw_function_definition_le_hybrid
};

static const afw_value_function_parameter_t
impl_le_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_hybrid_parameters[] = {
    &impl_le_hybrid_parameter_1,
    &impl_le_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("le<hybrid>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_hybrid"),
    AFW_UTF8_LITERAL("leHybrid"),
    AFW_UTF8_LITERAL("afwLeHybrid"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for hybrid arg1 is less than or equal to hybrid arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<hybrid> (\n    arg1: hybrid,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_hybrid_parameters[0],
    2,
    &impl_le_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__lt_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_hybrid");

static const afw_runtime_object_indirect_t
impl_object__lt_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_hybrid
        }
    },
    (void *)&afw_function_definition_lt_hybrid
};

static const afw_value_function_parameter_t
impl_lt_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_hybrid_parameters[] = {
    &impl_lt_hybrid_parameter_1,
    &impl_lt_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("lt<hybrid>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_hybrid"),
    AFW_UTF8_LITERAL("ltHybrid"),
    AFW_UTF8_LITERAL("afwLtHybrid"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for hybrid arg1 is less that hybrid arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: hybrid): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<hybrid> (\n    arg1: hybrid,\n    arg2: hybrid\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_hybrid_parameters[0],
    2,
    &impl_lt_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__ne_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_hybrid");

static const afw_runtime_object_indirect_t
impl_object__ne_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_hybrid
        }
    },
    (void *)&afw_function_definition_ne_hybrid
};

static const afw_value_function_parameter_t
impl_ne_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_hybrid_parameters[] = {
    &impl_ne_hybrid_parameter_1,
    &impl_ne_hybrid_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_hybrid_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ne<hybrid>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_hybrid"),
    AFW_UTF8_LITERAL("neHybrid"),
    AFW_UTF8_LITERAL("afwNeHybrid"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if hybrid arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<hybrid> (\n    arg1: hybrid,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_hybrid_parameters[0],
    2,
    &impl_ne_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    &impl_ne_hybrid_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__nex_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_hybrid");

static const afw_runtime_object_indirect_t
impl_object__nex_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_hybrid
        }
    },
    (void *)&afw_function_definition_nex_hybrid
};

static const afw_value_function_parameter_t
impl_nex_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_hybrid_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_hybrid_parameters[] = {
    &impl_nex_hybrid_parameter_1,
    &impl_nex_hybrid_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("nex<hybrid>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_hybrid"),
    AFW_UTF8_LITERAL("nexHybrid"),
    AFW_UTF8_LITERAL("afwNexHybrid"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for hybrid arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: hybrid, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<hybrid> (\n    arg1: hybrid,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_hybrid_parameters[0],
    2,
    &impl_nex_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<hybrid> ---------- */

static const afw_utf8_t
impl_object_path__to_string_hybrid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_hybrid");

static const afw_runtime_object_indirect_t
impl_object__to_string_hybrid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_hybrid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_hybrid
        }
    },
    (void *)&afw_function_definition_to_string_hybrid
};

static const afw_value_function_parameter_t
impl_to_string_hybrid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_hybrid_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A hybrid value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_hybrid_parameters[] = {
    &impl_to_string_hybrid_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_hybrid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_hybrid,
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("to_string<hybrid>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_hybrid"),
    AFW_UTF8_LITERAL("toStringHybrid"),
    AFW_UTF8_LITERAL("afwToStringHybrid"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts hybrid value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: hybrid): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<hybrid> (\n    value: hybrid\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_hybrid_parameters[0],
    1,
    &impl_to_string_hybrid_returns,
    NULL,
    &afw_data_type_hybrid_direct,
    AFW_UTF8_LITERAL("hybrid"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__bag_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_ia5String");

static const afw_runtime_object_indirect_t
impl_object__bag_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_ia5String
        }
    },
    (void *)&afw_function_definition_bag_ia5String
};

static const afw_value_function_parameter_t
impl_bag_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_ia5String_parameters[] = {
    &impl_bag_ia5String_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("bag<ia5String>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_ia5String"),
    AFW_UTF8_LITERAL("bagIa5String"),
    AFW_UTF8_LITERAL("afwBagIa5String"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of ia5String values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list ia5String))): (list ia5String)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<ia5String> (\n    ...values: (list of (list ia5String))\n): (list ia5String);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_ia5String_parameters[0],
    1,
    &impl_bag_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_ia5String");

static const afw_runtime_object_indirect_t
impl_object__bag_size_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_ia5String
        }
    },
    (void *)&afw_function_definition_bag_size_ia5String
};

static const afw_value_function_parameter_t
impl_bag_size_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_ia5String_parameters[] = {
    &impl_bag_size_ia5String_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("bag_size<ia5String>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_ia5String"),
    AFW_UTF8_LITERAL("bagSizeIa5String"),
    AFW_UTF8_LITERAL("afwBagSizeIa5String"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list ia5String)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<ia5String> (\n    value: (list ia5String)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_ia5String_parameters[0],
    1,
    &impl_bag_size_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__eq_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_ia5String");

static const afw_runtime_object_indirect_t
impl_object__eq_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_ia5String
        }
    },
    (void *)&afw_function_definition_eq_ia5String
};

static const afw_value_function_parameter_t
impl_eq_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_ia5String_parameters[] = {
    &impl_eq_ia5String_parameter_1,
    &impl_eq_ia5String_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_ia5String_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("eq<ia5String>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_ia5String"),
    AFW_UTF8_LITERAL("eqIa5String"),
    AFW_UTF8_LITERAL("afwEqIa5String"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if ia5String arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<ia5String> (\n    arg1: ia5String,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_ia5String_parameters[0],
    2,
    &impl_eq_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    &impl_eq_ia5String_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__eqx_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_ia5String");

static const afw_runtime_object_indirect_t
impl_object__eqx_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_ia5String
        }
    },
    (void *)&afw_function_definition_eqx_ia5String
};

static const afw_value_function_parameter_t
impl_eqx_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_ia5String_parameters[] = {
    &impl_eqx_ia5String_parameter_1,
    &impl_eqx_ia5String_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("eqx<ia5String>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_ia5String"),
    AFW_UTF8_LITERAL("eqxIa5String"),
    AFW_UTF8_LITERAL("afwEqxIa5String"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for ia5String arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<ia5String> (\n    arg1: ia5String,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_ia5String_parameters[0],
    2,
    &impl_eqx_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__ge_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_ia5String");

static const afw_runtime_object_indirect_t
impl_object__ge_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_ia5String
        }
    },
    (void *)&afw_function_definition_ge_ia5String
};

static const afw_value_function_parameter_t
impl_ge_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_ia5String_parameters[] = {
    &impl_ge_ia5String_parameter_1,
    &impl_ge_ia5String_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("ge<ia5String>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_ia5String"),
    AFW_UTF8_LITERAL("geIa5String"),
    AFW_UTF8_LITERAL("afwGeIa5String"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for ia5String arg1 is greater than or equal to ia5String arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: ia5String): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<ia5String> (\n    arg1: ia5String,\n    arg2: ia5String\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_ia5String_parameters[0],
    2,
    &impl_ge_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__gt_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_ia5String");

static const afw_runtime_object_indirect_t
impl_object__gt_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_ia5String
        }
    },
    (void *)&afw_function_definition_gt_ia5String
};

static const afw_value_function_parameter_t
impl_gt_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_ia5String_parameters[] = {
    &impl_gt_ia5String_parameter_1,
    &impl_gt_ia5String_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("gt<ia5String>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_ia5String"),
    AFW_UTF8_LITERAL("gtIa5String"),
    AFW_UTF8_LITERAL("afwGtIa5String"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for ia5String arg1 is greater than ia5String arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: ia5String): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<ia5String> (\n    arg1: ia5String,\n    arg2: ia5String\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_ia5String_parameters[0],
    2,
    &impl_gt_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ia5String ---------- */

static const afw_utf8_t
impl_object_path__ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ia5String");

static const afw_runtime_object_indirect_t
impl_object__ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ia5String
        }
    },
    (void *)&afw_function_definition_ia5String
};

static const afw_value_function_parameter_t
impl_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ia5String_parameters[] = {
    &impl_ia5String_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_ia5String_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("afwIa5String"),
    AFW_UTF8_LITERAL("Convert to data type ia5String"),
    AFW_UTF8_LITERAL("Converts value to data type ia5String returning ia5String result."),
    AFW_UTF8_LITERAL("(value: any): ia5String"),
    AFW_UTF8_LITERAL("/* Convert to data type ia5String */\nfunction ia5String (\n    value: any\n): ia5String;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_ia5String_parameters[0],
    1,
    &impl_ia5String_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_ia5String_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__is_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_ia5String");

static const afw_runtime_object_indirect_t
impl_object__is_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_ia5String
        }
    },
    (void *)&afw_function_definition_is_ia5String
};

static const afw_value_function_parameter_t
impl_is_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_ia5String_parameters[] = {
    &impl_is_ia5String_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("is<ia5String>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_ia5String"),
    AFW_UTF8_LITERAL("isIa5String"),
    AFW_UTF8_LITERAL("afwIsIa5String"),
    AFW_UTF8_LITERAL("Checks whether value is dataType ia5String"),
    AFW_UTF8_LITERAL("Checks whether value is dataType ia5String and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType ia5String */\nfunction is<ia5String> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_ia5String_parameters[0],
    1,
    &impl_is_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__le_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_ia5String");

static const afw_runtime_object_indirect_t
impl_object__le_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_ia5String
        }
    },
    (void *)&afw_function_definition_le_ia5String
};

static const afw_value_function_parameter_t
impl_le_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_ia5String_parameters[] = {
    &impl_le_ia5String_parameter_1,
    &impl_le_ia5String_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("le<ia5String>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_ia5String"),
    AFW_UTF8_LITERAL("leIa5String"),
    AFW_UTF8_LITERAL("afwLeIa5String"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for ia5String arg1 is less than or equal to ia5String arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<ia5String> (\n    arg1: ia5String,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_ia5String_parameters[0],
    2,
    &impl_le_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__lt_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_ia5String");

static const afw_runtime_object_indirect_t
impl_object__lt_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_ia5String
        }
    },
    (void *)&afw_function_definition_lt_ia5String
};

static const afw_value_function_parameter_t
impl_lt_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_ia5String_parameters[] = {
    &impl_lt_ia5String_parameter_1,
    &impl_lt_ia5String_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("lt<ia5String>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_ia5String"),
    AFW_UTF8_LITERAL("ltIa5String"),
    AFW_UTF8_LITERAL("afwLtIa5String"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for ia5String arg1 is less that ia5String arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: ia5String): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<ia5String> (\n    arg1: ia5String,\n    arg2: ia5String\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_ia5String_parameters[0],
    2,
    &impl_lt_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__ne_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_ia5String");

static const afw_runtime_object_indirect_t
impl_object__ne_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_ia5String
        }
    },
    (void *)&afw_function_definition_ne_ia5String
};

static const afw_value_function_parameter_t
impl_ne_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_ia5String_parameters[] = {
    &impl_ne_ia5String_parameter_1,
    &impl_ne_ia5String_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_ia5String_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("ne<ia5String>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_ia5String"),
    AFW_UTF8_LITERAL("neIa5String"),
    AFW_UTF8_LITERAL("afwNeIa5String"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if ia5String arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<ia5String> (\n    arg1: ia5String,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_ia5String_parameters[0],
    2,
    &impl_ne_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    &impl_ne_ia5String_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__nex_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_ia5String");

static const afw_runtime_object_indirect_t
impl_object__nex_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_ia5String
        }
    },
    (void *)&afw_function_definition_nex_ia5String
};

static const afw_value_function_parameter_t
impl_nex_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_ia5String_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_ia5String_parameters[] = {
    &impl_nex_ia5String_parameter_1,
    &impl_nex_ia5String_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("nex<ia5String>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_ia5String"),
    AFW_UTF8_LITERAL("nexIa5String"),
    AFW_UTF8_LITERAL("afwNexIa5String"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for ia5String arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: ia5String, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<ia5String> (\n    arg1: ia5String,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_ia5String_parameters[0],
    2,
    &impl_nex_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<ia5String> ---------- */

static const afw_utf8_t
impl_object_path__to_string_ia5String =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_ia5String");

static const afw_runtime_object_indirect_t
impl_object__to_string_ia5String = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_ia5String,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_ia5String
        }
    },
    (void *)&afw_function_definition_to_string_ia5String
};

static const afw_value_function_parameter_t
impl_to_string_ia5String_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_ia5String_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A ia5String value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_ia5String_parameters[] = {
    &impl_to_string_ia5String_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_ia5String = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_ia5String,
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("to_string<ia5String>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_ia5String"),
    AFW_UTF8_LITERAL("toStringIa5String"),
    AFW_UTF8_LITERAL("afwToStringIa5String"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts ia5String value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: ia5String): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<ia5String> (\n    value: ia5String\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_ia5String_parameters[0],
    1,
    &impl_to_string_ia5String_returns,
    NULL,
    &afw_data_type_ia5String_direct,
    AFW_UTF8_LITERAL("ia5String"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- index_create ---------- */

static const afw_utf8_t
impl_object_path__index_create =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/index_create");

static const afw_runtime_object_indirect_t
impl_object__index_create = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_index_create,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__index_create
        }
    },
    (void *)&afw_function_definition_index_create
};

static const afw_value_function_parameter_t
impl_index_create_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object response from the indexing process"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("key"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Name of the property index to be created."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expression to calculate the index value(s)."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object Type(s) this index may apply to."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("filter"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Expression to determine if this index applies to a particular object."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Indexing options."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_7 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("retroactive"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Retroactively generate indexes for existing objects."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_create_parameter_8 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("test"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Test create (don't actually perform)."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_index_create_parameters[] = {
    &impl_index_create_parameter_1,
    &impl_index_create_parameter_2,
    &impl_index_create_parameter_3,
    &impl_index_create_parameter_4,
    &impl_index_create_parameter_5,
    &impl_index_create_parameter_6,
    &impl_index_create_parameter_7,
    &impl_index_create_parameter_8,
    NULL
};

static const afw_utf8_t
impl_index_create_sideEffects[] = {
    AFW_UTF8_LITERAL("Index created"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_create = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__index_create,
    AFW_UTF8_LITERAL("indexes"),
    AFW_UTF8_LITERAL("index_create"),
    AFW_UTF8_LITERAL("index_create"),
    AFW_UTF8_LITERAL("index_create"),
    AFW_UTF8_LITERAL("indexCreate"),
    AFW_UTF8_LITERAL("afwIndexCreate"),
    AFW_UTF8_LITERAL("Create index definition"),
    AFW_UTF8_LITERAL("Create an index definition."),
    AFW_UTF8_LITERAL("(adaptorId: string, key: string, value?: string, objectType?: string, filter?: string, options?: string, retroactive?: boolean, test?: boolean): object"),
    AFW_UTF8_LITERAL("/* Create index definition */\nfunction index_create (\n    adaptorId: string,\n    key: string,\n    value?: string,\n    objectType?: string,\n    filter?: string,\n    options?: string,\n    retroactive?: boolean,\n    test?: boolean\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_index_create,
    NULL,
    2,
    8,
    &impl_index_create_parameters[0],
    8,
    &impl_index_create_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_index_create_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- index_list ---------- */

static const afw_utf8_t
impl_object_path__index_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/index_list");

static const afw_runtime_object_indirect_t
impl_object__index_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_index_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__index_list
        }
    },
    (void *)&afw_function_definition_index_list
};

static const afw_value_function_parameter_t
impl_index_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object response from the index repair process"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptive object type indexes"),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_index_list_parameters[] = {
    &impl_index_list_parameter_1,
    &impl_index_list_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__index_list,
    AFW_UTF8_LITERAL("indexes"),
    AFW_UTF8_LITERAL("index_list"),
    AFW_UTF8_LITERAL("index_list"),
    AFW_UTF8_LITERAL("index_list"),
    AFW_UTF8_LITERAL("indexList"),
    AFW_UTF8_LITERAL("afwIndexList"),
    AFW_UTF8_LITERAL("List property indexes"),
    AFW_UTF8_LITERAL("List property indexes"),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType?: string): object"),
    AFW_UTF8_LITERAL("/* List property indexes */\nfunction index_list (\n    adaptorId: string,\n    objectType?: string\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_index_list,
    NULL,
    1,
    2,
    &impl_index_list_parameters[0],
    2,
    &impl_index_list_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- index_remove ---------- */

static const afw_utf8_t
impl_object_path__index_remove =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/index_remove");

static const afw_runtime_object_indirect_t
impl_object__index_remove = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_index_remove,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__index_remove
        }
    },
    (void *)&afw_function_definition_index_remove
};

static const afw_value_function_parameter_t
impl_index_remove_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object response from the indexing process"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_remove_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_remove_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("key"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The index key to be removed."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_index_remove_parameters[] = {
    &impl_index_remove_parameter_1,
    &impl_index_remove_parameter_2,
    NULL
};

static const afw_utf8_t
impl_index_remove_sideEffects[] = {
    AFW_UTF8_LITERAL("Index removed"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_remove = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__index_remove,
    AFW_UTF8_LITERAL("indexes"),
    AFW_UTF8_LITERAL("index_remove"),
    AFW_UTF8_LITERAL("index_remove"),
    AFW_UTF8_LITERAL("index_remove"),
    AFW_UTF8_LITERAL("indexRemove"),
    AFW_UTF8_LITERAL("afwIndexRemove"),
    AFW_UTF8_LITERAL("Remove index definition"),
    AFW_UTF8_LITERAL("Remove an index definition."),
    AFW_UTF8_LITERAL("(adaptorId: string, key: string): object"),
    AFW_UTF8_LITERAL("/* Remove index definition */\nfunction index_remove (\n    adaptorId: string,\n    key: string\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_index_remove,
    NULL,
    2,
    2,
    &impl_index_remove_parameters[0],
    2,
    &impl_index_remove_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_index_remove_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- abs<integer> ---------- */

static const afw_utf8_t
impl_object_path__abs_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/abs_integer");

static const afw_runtime_object_indirect_t
impl_object__abs_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_abs_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__abs_integer
        }
    },
    (void *)&afw_function_definition_abs_integer
};

static const afw_value_function_parameter_t
impl_abs_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_abs_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_abs_integer_parameters[] = {
    &impl_abs_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_abs_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__abs_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("abs<integer>"),
    AFW_UTF8_LITERAL("abs"),
    AFW_UTF8_LITERAL("abs_integer"),
    AFW_UTF8_LITERAL("absInteger"),
    AFW_UTF8_LITERAL("afwAbsInteger"),
    AFW_UTF8_LITERAL("Absolute value"),
    AFW_UTF8_LITERAL("Compute the absolute value of the integer value and return the integer result."),
    AFW_UTF8_LITERAL("(value: integer): integer"),
    AFW_UTF8_LITERAL("/* Absolute value */\nfunction abs<integer> (\n    value: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_abs_integer,
    NULL,
    1,
    1,
    &impl_abs_integer_parameters[0],
    1,
    &impl_abs_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_abs,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- add<integer> ---------- */

static const afw_utf8_t
impl_object_path__add_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_integer");

static const afw_runtime_object_indirect_t
impl_object__add_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_integer
        }
    },
    (void *)&afw_function_definition_add_integer
};

static const afw_value_function_parameter_t
impl_add_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_integer_parameters[] = {
    &impl_add_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("add<integer>"),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL("add_integer"),
    AFW_UTF8_LITERAL("addInteger"),
    AFW_UTF8_LITERAL("afwAddInteger"),
    AFW_UTF8_LITERAL("Add"),
    AFW_UTF8_LITERAL("Add 2 or more integer values and return the integer result."),
    AFW_UTF8_LITERAL("(values_1: integer, values_2: integer, ...values_rest: (list of integer)): integer"),
    AFW_UTF8_LITERAL("/* Add */\nfunction add<integer> (\n    values_1: integer,\n    values_2: integer,\n    ...values_rest: (list of integer)\n): integer;\n"),
    AFW_UTF8_LITERAL("+"),
    afw_function_execute_add_integer,
    NULL,
    2,
    -1,
    &impl_add_integer_parameters[0],
    1,
    &impl_add_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_add,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<integer> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_integer");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_integer
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_integer
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_integer_parameters[] = {
    &impl_at_least_one_member_of_integer_parameter_1,
    &impl_at_least_one_member_of_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("at_least_one_member_of<integer>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_integer"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfInteger"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfInteger"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in integer list1 is in integer list2."),
    AFW_UTF8_LITERAL("(list1: (list integer), list2: (list integer)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<integer> (\n    list1: (list integer),\n    list2: (list integer)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_integer_parameters[0],
    2,
    &impl_at_least_one_member_of_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<integer> ---------- */

static const afw_utf8_t
impl_object_path__bag_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_integer");

static const afw_runtime_object_indirect_t
impl_object__bag_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_integer
        }
    },
    (void *)&afw_function_definition_bag_integer
};

static const afw_value_function_parameter_t
impl_bag_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_integer_parameters[] = {
    &impl_bag_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("bag<integer>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_integer"),
    AFW_UTF8_LITERAL("bagInteger"),
    AFW_UTF8_LITERAL("afwBagInteger"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of integer values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list integer))): (list integer)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<integer> (\n    ...values: (list of (list integer))\n): (list integer);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_integer_parameters[0],
    1,
    &impl_bag_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<integer> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_integer");

static const afw_runtime_object_indirect_t
impl_object__bag_size_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_integer
        }
    },
    (void *)&afw_function_definition_bag_size_integer
};

static const afw_value_function_parameter_t
impl_bag_size_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_integer_parameters[] = {
    &impl_bag_size_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("bag_size<integer>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_integer"),
    AFW_UTF8_LITERAL("bagSizeInteger"),
    AFW_UTF8_LITERAL("afwBagSizeInteger"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list integer)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<integer> (\n    value: (list integer)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_integer_parameters[0],
    1,
    &impl_bag_size_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- divide<integer> ---------- */

static const afw_utf8_t
impl_object_path__divide_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/divide_integer");

static const afw_runtime_object_indirect_t
impl_object__divide_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_divide_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__divide_integer
        }
    },
    (void *)&afw_function_definition_divide_integer
};

static const afw_value_function_parameter_t
impl_divide_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_divide_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("dividend"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_divide_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("divisor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_divide_integer_parameters[] = {
    &impl_divide_integer_parameter_1,
    &impl_divide_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_divide_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__divide_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("divide<integer>"),
    AFW_UTF8_LITERAL("divide"),
    AFW_UTF8_LITERAL("divide_integer"),
    AFW_UTF8_LITERAL("divideInteger"),
    AFW_UTF8_LITERAL("afwDivideInteger"),
    AFW_UTF8_LITERAL("Divide numbers"),
    AFW_UTF8_LITERAL("Divide integer dividend by integer divisor and return the integer quotient."),
    AFW_UTF8_LITERAL("(dividend: integer, divisor: integer): integer"),
    AFW_UTF8_LITERAL("/* Divide numbers */\nfunction divide<integer> (\n    dividend: integer,\n    divisor: integer\n): integer;\n"),
    AFW_UTF8_LITERAL("/"),
    afw_function_execute_divide_integer,
    NULL,
    2,
    2,
    &impl_divide_integer_parameters[0],
    2,
    &impl_divide_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_divide,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<integer> ---------- */

static const afw_utf8_t
impl_object_path__eq_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_integer");

static const afw_runtime_object_indirect_t
impl_object__eq_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_integer
        }
    },
    (void *)&afw_function_definition_eq_integer
};

static const afw_value_function_parameter_t
impl_eq_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_integer_parameters[] = {
    &impl_eq_integer_parameter_1,
    &impl_eq_integer_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_integer_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("eq<integer>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_integer"),
    AFW_UTF8_LITERAL("eqInteger"),
    AFW_UTF8_LITERAL("afwEqInteger"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if integer arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<integer> (\n    arg1: integer,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_integer_parameters[0],
    2,
    &impl_eq_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    &impl_eq_integer_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<integer> ---------- */

static const afw_utf8_t
impl_object_path__eqx_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_integer");

static const afw_runtime_object_indirect_t
impl_object__eqx_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_integer
        }
    },
    (void *)&afw_function_definition_eqx_integer
};

static const afw_value_function_parameter_t
impl_eqx_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_integer_parameters[] = {
    &impl_eqx_integer_parameter_1,
    &impl_eqx_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("eqx<integer>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_integer"),
    AFW_UTF8_LITERAL("eqxInteger"),
    AFW_UTF8_LITERAL("afwEqxInteger"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for integer arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<integer> (\n    arg1: integer,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_integer_parameters[0],
    2,
    &impl_eqx_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<integer> ---------- */

static const afw_utf8_t
impl_object_path__ge_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_integer");

static const afw_runtime_object_indirect_t
impl_object__ge_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_integer
        }
    },
    (void *)&afw_function_definition_ge_integer
};

static const afw_value_function_parameter_t
impl_ge_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_integer_parameters[] = {
    &impl_ge_integer_parameter_1,
    &impl_ge_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ge<integer>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_integer"),
    AFW_UTF8_LITERAL("geInteger"),
    AFW_UTF8_LITERAL("afwGeInteger"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for integer arg1 is greater than or equal to integer arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: integer): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<integer> (\n    arg1: integer,\n    arg2: integer\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_integer_parameters[0],
    2,
    &impl_ge_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<integer> ---------- */

static const afw_utf8_t
impl_object_path__gt_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_integer");

static const afw_runtime_object_indirect_t
impl_object__gt_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_integer
        }
    },
    (void *)&afw_function_definition_gt_integer
};

static const afw_value_function_parameter_t
impl_gt_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_integer_parameters[] = {
    &impl_gt_integer_parameter_1,
    &impl_gt_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("gt<integer>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_integer"),
    AFW_UTF8_LITERAL("gtInteger"),
    AFW_UTF8_LITERAL("afwGtInteger"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for integer arg1 is greater than integer arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: integer): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<integer> (\n    arg1: integer,\n    arg2: integer\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_integer_parameters[0],
    2,
    &impl_gt_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- integer ---------- */

static const afw_utf8_t
impl_object_path__integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/integer");

static const afw_runtime_object_indirect_t
impl_object__integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__integer
        }
    },
    (void *)&afw_function_definition_integer
};

static const afw_value_function_parameter_t
impl_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_integer_parameters[] = {
    &impl_integer_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_integer_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("afwInteger"),
    AFW_UTF8_LITERAL("Convert to data type integer"),
    AFW_UTF8_LITERAL("Converts value to data type integer returning integer result."),
    AFW_UTF8_LITERAL("(value: any): integer"),
    AFW_UTF8_LITERAL("/* Convert to data type integer */\nfunction integer (\n    value: any\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_integer_parameters[0],
    1,
    &impl_integer_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_integer_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<integer> ---------- */

static const afw_utf8_t
impl_object_path__intersection_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_integer");

static const afw_runtime_object_indirect_t
impl_object__intersection_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_integer
        }
    },
    (void *)&afw_function_definition_intersection_integer
};

static const afw_value_function_parameter_t
impl_intersection_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_integer_parameters[] = {
    &impl_intersection_integer_parameter_1,
    &impl_intersection_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("intersection<integer>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_integer"),
    AFW_UTF8_LITERAL("intersectionInteger"),
    AFW_UTF8_LITERAL("afwIntersectionInteger"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of integer with the values that are common to both list of integer list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list integer), list2: (list integer)): (list integer)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<integer> (\n    list1: (list integer),\n    list2: (list integer)\n): (list integer);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_integer_parameters[0],
    2,
    &impl_intersection_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<integer> ---------- */

static const afw_utf8_t
impl_object_path__is_in_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_integer");

static const afw_runtime_object_indirect_t
impl_object__is_in_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_integer
        }
    },
    (void *)&afw_function_definition_is_in_integer
};

static const afw_value_function_parameter_t
impl_is_in_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_integer_parameters[] = {
    &impl_is_in_integer_parameter_1,
    &impl_is_in_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("is_in<integer>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_integer"),
    AFW_UTF8_LITERAL("isInInteger"),
    AFW_UTF8_LITERAL("afwIsInInteger"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether integer value is in list of integer list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: integer, list: (list integer)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<integer> (\n    value: integer,\n    list: (list integer)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_integer_parameters[0],
    2,
    &impl_is_in_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<integer> ---------- */

static const afw_utf8_t
impl_object_path__is_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_integer");

static const afw_runtime_object_indirect_t
impl_object__is_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_integer
        }
    },
    (void *)&afw_function_definition_is_integer
};

static const afw_value_function_parameter_t
impl_is_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_integer_parameters[] = {
    &impl_is_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("is<integer>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_integer"),
    AFW_UTF8_LITERAL("isInteger"),
    AFW_UTF8_LITERAL("afwIsInteger"),
    AFW_UTF8_LITERAL("Checks whether value is dataType integer"),
    AFW_UTF8_LITERAL("Checks whether value is dataType integer and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType integer */\nfunction is<integer> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_integer_parameters[0],
    1,
    &impl_is_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<integer> ---------- */

static const afw_utf8_t
impl_object_path__le_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_integer");

static const afw_runtime_object_indirect_t
impl_object__le_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_integer
        }
    },
    (void *)&afw_function_definition_le_integer
};

static const afw_value_function_parameter_t
impl_le_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_integer_parameters[] = {
    &impl_le_integer_parameter_1,
    &impl_le_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("le<integer>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_integer"),
    AFW_UTF8_LITERAL("leInteger"),
    AFW_UTF8_LITERAL("afwLeInteger"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for integer arg1 is less than or equal to integer arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<integer> (\n    arg1: integer,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_integer_parameters[0],
    2,
    &impl_le_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<integer> ---------- */

static const afw_utf8_t
impl_object_path__lt_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_integer");

static const afw_runtime_object_indirect_t
impl_object__lt_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_integer
        }
    },
    (void *)&afw_function_definition_lt_integer
};

static const afw_value_function_parameter_t
impl_lt_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_integer_parameters[] = {
    &impl_lt_integer_parameter_1,
    &impl_lt_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("lt<integer>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_integer"),
    AFW_UTF8_LITERAL("ltInteger"),
    AFW_UTF8_LITERAL("afwLtInteger"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for integer arg1 is less that integer arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: integer): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<integer> (\n    arg1: integer,\n    arg2: integer\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_integer_parameters[0],
    2,
    &impl_lt_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- max<integer> ---------- */

static const afw_utf8_t
impl_object_path__max_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/max_integer");

static const afw_runtime_object_indirect_t
impl_object__max_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_max_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__max_integer
        }
    },
    (void *)&afw_function_definition_max_integer
};

static const afw_value_function_parameter_t
impl_max_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_max_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_max_integer_parameters[] = {
    &impl_max_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__max_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("max<integer>"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max_integer"),
    AFW_UTF8_LITERAL("maxInteger"),
    AFW_UTF8_LITERAL("afwMaxInteger"),
    AFW_UTF8_LITERAL("Maximum value"),
    AFW_UTF8_LITERAL("Return the integer value that is greater than or equal to the others."),
    AFW_UTF8_LITERAL("(values_1: integer, ...values_rest: (list of integer)): integer"),
    AFW_UTF8_LITERAL("/* Maximum value */\nfunction max<integer> (\n    values_1: integer,\n    ...values_rest: (list of integer)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_max,
    NULL,
    1,
    -1,
    &impl_max_integer_parameters[0],
    1,
    &impl_max_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_max,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- min<integer> ---------- */

static const afw_utf8_t
impl_object_path__min_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/min_integer");

static const afw_runtime_object_indirect_t
impl_object__min_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_min_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__min_integer
        }
    },
    (void *)&afw_function_definition_min_integer
};

static const afw_value_function_parameter_t
impl_min_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_min_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_min_integer_parameters[] = {
    &impl_min_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__min_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("min<integer>"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min_integer"),
    AFW_UTF8_LITERAL("minInteger"),
    AFW_UTF8_LITERAL("afwMinInteger"),
    AFW_UTF8_LITERAL("Minimum value"),
    AFW_UTF8_LITERAL("Return the integer value that is less than or equal to the others."),
    AFW_UTF8_LITERAL("(values_1: integer, ...values_rest: (list of integer)): integer"),
    AFW_UTF8_LITERAL("/* Minimum value */\nfunction min<integer> (\n    values_1: integer,\n    ...values_rest: (list of integer)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_min,
    NULL,
    1,
    -1,
    &impl_min_integer_parameters[0],
    1,
    &impl_min_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_min,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- mod<integer> ---------- */

static const afw_utf8_t
impl_object_path__mod_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/mod_integer");

static const afw_runtime_object_indirect_t
impl_object__mod_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_mod_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__mod_integer
        }
    },
    (void *)&afw_function_definition_mod_integer
};

static const afw_value_function_parameter_t
impl_mod_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_mod_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("dividend"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_mod_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("divisor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_mod_integer_parameters[] = {
    &impl_mod_integer_parameter_1,
    &impl_mod_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_mod_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__mod_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("mod<integer>"),
    AFW_UTF8_LITERAL("mod"),
    AFW_UTF8_LITERAL("mod_integer"),
    AFW_UTF8_LITERAL("modInteger"),
    AFW_UTF8_LITERAL("afwModInteger"),
    AFW_UTF8_LITERAL("Remainder of dividing numbers"),
    AFW_UTF8_LITERAL("Divide integer dividend by integer divisor and return the integer remainder."),
    AFW_UTF8_LITERAL("(dividend: integer, divisor: integer): integer"),
    AFW_UTF8_LITERAL("/* Remainder of dividing numbers */\nfunction mod<integer> (\n    dividend: integer,\n    divisor: integer\n): integer;\n"),
    AFW_UTF8_LITERAL("%"),
    afw_function_execute_mod_integer,
    NULL,
    2,
    2,
    &impl_mod_integer_parameters[0],
    2,
    &impl_mod_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_mod,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- multiply<integer> ---------- */

static const afw_utf8_t
impl_object_path__multiply_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/multiply_integer");

static const afw_runtime_object_indirect_t
impl_object__multiply_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_multiply_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__multiply_integer
        }
    },
    (void *)&afw_function_definition_multiply_integer
};

static const afw_value_function_parameter_t
impl_multiply_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_multiply_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_multiply_integer_parameters[] = {
    &impl_multiply_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_multiply_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__multiply_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("multiply<integer>"),
    AFW_UTF8_LITERAL("multiply"),
    AFW_UTF8_LITERAL("multiply_integer"),
    AFW_UTF8_LITERAL("multiplyInteger"),
    AFW_UTF8_LITERAL("afwMultiplyInteger"),
    AFW_UTF8_LITERAL("Multiply numbers"),
    AFW_UTF8_LITERAL("Multiply 2 or more integer values and return the integer result."),
    AFW_UTF8_LITERAL("(values_1: integer, values_2: integer, ...values_rest: (list of integer)): integer"),
    AFW_UTF8_LITERAL("/* Multiply numbers */\nfunction multiply<integer> (\n    values_1: integer,\n    values_2: integer,\n    ...values_rest: (list of integer)\n): integer;\n"),
    AFW_UTF8_LITERAL("*"),
    afw_function_execute_multiply_integer,
    NULL,
    2,
    -1,
    &impl_multiply_integer_parameters[0],
    1,
    &impl_multiply_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_multiply,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<integer> ---------- */

static const afw_utf8_t
impl_object_path__ne_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_integer");

static const afw_runtime_object_indirect_t
impl_object__ne_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_integer
        }
    },
    (void *)&afw_function_definition_ne_integer
};

static const afw_value_function_parameter_t
impl_ne_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_integer_parameters[] = {
    &impl_ne_integer_parameter_1,
    &impl_ne_integer_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_integer_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ne<integer>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_integer"),
    AFW_UTF8_LITERAL("neInteger"),
    AFW_UTF8_LITERAL("afwNeInteger"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if integer arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<integer> (\n    arg1: integer,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_integer_parameters[0],
    2,
    &impl_ne_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    &impl_ne_integer_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- negative<integer> ---------- */

static const afw_utf8_t
impl_object_path__negative_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/negative_integer");

static const afw_runtime_object_indirect_t
impl_object__negative_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_negative_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__negative_integer
        }
    },
    (void *)&afw_function_definition_negative_integer
};

static const afw_value_function_parameter_t
impl_negative_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_negative_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_negative_integer_parameters[] = {
    &impl_negative_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_negative_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__negative_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("negative<integer>"),
    AFW_UTF8_LITERAL("negative"),
    AFW_UTF8_LITERAL("negative_integer"),
    AFW_UTF8_LITERAL("negativeInteger"),
    AFW_UTF8_LITERAL("afwNegativeInteger"),
    AFW_UTF8_LITERAL("Negative of a number"),
    AFW_UTF8_LITERAL("Return negative of integer value."),
    AFW_UTF8_LITERAL("(value: integer): integer"),
    AFW_UTF8_LITERAL("/* Negative of a number */\nfunction negative<integer> (\n    value: integer\n): integer;\n"),
    AFW_UTF8_LITERAL("-"),
    afw_function_execute_negative_integer,
    NULL,
    1,
    1,
    &impl_negative_integer_parameters[0],
    1,
    &impl_negative_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_negative,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<integer> ---------- */

static const afw_utf8_t
impl_object_path__nex_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_integer");

static const afw_runtime_object_indirect_t
impl_object__nex_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_integer
        }
    },
    (void *)&afw_function_definition_nex_integer
};

static const afw_value_function_parameter_t
impl_nex_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_integer_parameters[] = {
    &impl_nex_integer_parameter_1,
    &impl_nex_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("nex<integer>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_integer"),
    AFW_UTF8_LITERAL("nexInteger"),
    AFW_UTF8_LITERAL("afwNexInteger"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for integer arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<integer> (\n    arg1: integer,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_integer_parameters[0],
    2,
    &impl_nex_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<integer> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_integer");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_integer
        }
    },
    (void *)&afw_function_definition_one_and_only_integer
};

static const afw_value_function_parameter_t
impl_one_and_only_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_integer_parameters[] = {
    &impl_one_and_only_integer_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_integer_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("one_and_only<integer>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_integer"),
    AFW_UTF8_LITERAL("oneAndOnlyInteger"),
    AFW_UTF8_LITERAL("afwOneAndOnlyInteger"),
    AFW_UTF8_LITERAL("Converts a one value list to a integer value"),
    AFW_UTF8_LITERAL("This converts a list of integer values that contains one value to a single integer value."),
    AFW_UTF8_LITERAL("(list: (list list)): integer"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a integer value */\nfunction one_and_only<integer> (\n    list: (list list)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_integer_parameters[0],
    1,
    &impl_one_and_only_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    &impl_one_and_only_integer_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<integer> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_integer");

static const afw_runtime_object_indirect_t
impl_object__set_equals_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_integer
        }
    },
    (void *)&afw_function_definition_set_equals_integer
};

static const afw_value_function_parameter_t
impl_set_equals_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_integer_parameters[] = {
    &impl_set_equals_integer_parameter_1,
    &impl_set_equals_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("set_equals<integer>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_integer"),
    AFW_UTF8_LITERAL("setEqualsInteger"),
    AFW_UTF8_LITERAL("afwSetEqualsInteger"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if integer list1 and integer list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list integer), list2: (list integer)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<integer> (\n    list1: (list integer),\n    list2: (list integer)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_integer_parameters[0],
    2,
    &impl_set_equals_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<integer> ---------- */

static const afw_utf8_t
impl_object_path__subset_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_integer");

static const afw_runtime_object_indirect_t
impl_object__subset_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_integer
        }
    },
    (void *)&afw_function_definition_subset_integer
};

static const afw_value_function_parameter_t
impl_subset_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_integer_parameters[] = {
    &impl_subset_integer_parameter_1,
    &impl_subset_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("subset<integer>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_integer"),
    AFW_UTF8_LITERAL("subsetInteger"),
    AFW_UTF8_LITERAL("afwSubsetInteger"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in integer list1 are all in integer list2."),
    AFW_UTF8_LITERAL("(list1: (list integer), list2: (list integer)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<integer> (\n    list1: (list integer),\n    list2: (list integer)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_integer_parameters[0],
    2,
    &impl_subset_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subtract<integer> ---------- */

static const afw_utf8_t
impl_object_path__subtract_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract_integer");

static const afw_runtime_object_indirect_t
impl_object__subtract_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract_integer
        }
    },
    (void *)&afw_function_definition_subtract_integer
};

static const afw_value_function_parameter_t
impl_subtract_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_integer_parameters[] = {
    &impl_subtract_integer_parameter_1,
    &impl_subtract_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("subtract<integer>"),
    AFW_UTF8_LITERAL("subtract"),
    AFW_UTF8_LITERAL("subtract_integer"),
    AFW_UTF8_LITERAL("subtractInteger"),
    AFW_UTF8_LITERAL("afwSubtractInteger"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract integer arg2 from integer arg1 and return the integer result."),
    AFW_UTF8_LITERAL("(arg1: integer, arg2: integer): integer"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract<integer> (\n    arg1: integer,\n    arg2: integer\n): integer;\n"),
    AFW_UTF8_LITERAL("-"),
    afw_function_execute_subtract_integer,
    NULL,
    2,
    2,
    &impl_subtract_integer_parameters[0],
    2,
    &impl_subtract_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_subtract,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_double<integer> ---------- */

static const afw_utf8_t
impl_object_path__to_double_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_double_integer");

static const afw_runtime_object_indirect_t
impl_object__to_double_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_double_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_double_integer
        }
    },
    (void *)&afw_function_definition_to_double_integer
};

static const afw_value_function_parameter_t
impl_to_double_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_double_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_double_integer_parameters[] = {
    &impl_to_double_integer_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_double_integer_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_double_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_double_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("to_double<integer>"),
    AFW_UTF8_LITERAL("to_double"),
    AFW_UTF8_LITERAL("to_double_integer"),
    AFW_UTF8_LITERAL("toDoubleInteger"),
    AFW_UTF8_LITERAL("afwToDoubleInteger"),
    AFW_UTF8_LITERAL("Converts to double"),
    AFW_UTF8_LITERAL("Converts integer value to double and returns double result."),
    AFW_UTF8_LITERAL("(value: integer): double"),
    AFW_UTF8_LITERAL("/* Converts to double */\nfunction to_double<integer> (\n    value: integer\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_to_double_integer,
    NULL,
    1,
    1,
    &impl_to_double_integer_parameters[0],
    1,
    &impl_to_double_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    &impl_to_double_integer_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_double,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<integer> ---------- */

static const afw_utf8_t
impl_object_path__to_string_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_integer");

static const afw_runtime_object_indirect_t
impl_object__to_string_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_integer
        }
    },
    (void *)&afw_function_definition_to_string_integer
};

static const afw_value_function_parameter_t
impl_to_string_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A integer value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_integer_parameters[] = {
    &impl_to_string_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("to_string<integer>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_integer"),
    AFW_UTF8_LITERAL("toStringInteger"),
    AFW_UTF8_LITERAL("afwToStringInteger"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts integer value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: integer): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<integer> (\n    value: integer\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_integer_parameters[0],
    1,
    &impl_to_string_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<integer> ---------- */

static const afw_utf8_t
impl_object_path__union_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_integer");

static const afw_runtime_object_indirect_t
impl_object__union_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_integer
        }
    },
    (void *)&afw_function_definition_union_integer
};

static const afw_value_function_parameter_t
impl_union_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_integer_parameters[] = {
    &impl_union_integer_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_integer,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("union<integer>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_integer"),
    AFW_UTF8_LITERAL("unionInteger"),
    AFW_UTF8_LITERAL("afwUnionInteger"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of integer contains all of the unique values in two or more list of integer values."),
    AFW_UTF8_LITERAL("(lists_1: (list integer), lists_2: (list integer), ...lists_rest: (list of (list integer))): (list integer)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<integer> (\n    lists_1: (list integer),\n    lists_2: (list integer),\n    ...lists_rest: (list of (list integer))\n): (list integer);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_integer_parameters[0],
    1,
    &impl_union_integer_returns,
    NULL,
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__bag_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__bag_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_ipAddress
        }
    },
    (void *)&afw_function_definition_bag_ipAddress
};

static const afw_value_function_parameter_t
impl_bag_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_ipAddress_parameters[] = {
    &impl_bag_ipAddress_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("bag<ipAddress>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_ipAddress"),
    AFW_UTF8_LITERAL("bagIpAddress"),
    AFW_UTF8_LITERAL("afwBagIpAddress"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of ipAddress values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list ipAddress))): (list ipAddress)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<ipAddress> (\n    ...values: (list of (list ipAddress))\n): (list ipAddress);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_ipAddress_parameters[0],
    1,
    &impl_bag_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__bag_size_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_ipAddress
        }
    },
    (void *)&afw_function_definition_bag_size_ipAddress
};

static const afw_value_function_parameter_t
impl_bag_size_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_ipAddress_parameters[] = {
    &impl_bag_size_ipAddress_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("bag_size<ipAddress>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_ipAddress"),
    AFW_UTF8_LITERAL("bagSizeIpAddress"),
    AFW_UTF8_LITERAL("afwBagSizeIpAddress"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list ipAddress)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<ipAddress> (\n    value: (list ipAddress)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_ipAddress_parameters[0],
    1,
    &impl_bag_size_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__eq_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__eq_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_ipAddress
        }
    },
    (void *)&afw_function_definition_eq_ipAddress
};

static const afw_value_function_parameter_t
impl_eq_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_ipAddress_parameters[] = {
    &impl_eq_ipAddress_parameter_1,
    &impl_eq_ipAddress_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_ipAddress_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("eq<ipAddress>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_ipAddress"),
    AFW_UTF8_LITERAL("eqIpAddress"),
    AFW_UTF8_LITERAL("afwEqIpAddress"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if ipAddress arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<ipAddress> (\n    arg1: ipAddress,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_ipAddress_parameters[0],
    2,
    &impl_eq_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    &impl_eq_ipAddress_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__eqx_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__eqx_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_ipAddress
        }
    },
    (void *)&afw_function_definition_eqx_ipAddress
};

static const afw_value_function_parameter_t
impl_eqx_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_ipAddress_parameters[] = {
    &impl_eqx_ipAddress_parameter_1,
    &impl_eqx_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("eqx<ipAddress>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_ipAddress"),
    AFW_UTF8_LITERAL("eqxIpAddress"),
    AFW_UTF8_LITERAL("afwEqxIpAddress"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for ipAddress arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<ipAddress> (\n    arg1: ipAddress,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_ipAddress_parameters[0],
    2,
    &impl_eqx_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__ge_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__ge_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_ipAddress
        }
    },
    (void *)&afw_function_definition_ge_ipAddress
};

static const afw_value_function_parameter_t
impl_ge_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_ipAddress_parameters[] = {
    &impl_ge_ipAddress_parameter_1,
    &impl_ge_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("ge<ipAddress>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_ipAddress"),
    AFW_UTF8_LITERAL("geIpAddress"),
    AFW_UTF8_LITERAL("afwGeIpAddress"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for ipAddress arg1 is greater than or equal to ipAddress arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: ipAddress): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<ipAddress> (\n    arg1: ipAddress,\n    arg2: ipAddress\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_ipAddress_parameters[0],
    2,
    &impl_ge_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__gt_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__gt_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_ipAddress
        }
    },
    (void *)&afw_function_definition_gt_ipAddress
};

static const afw_value_function_parameter_t
impl_gt_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_ipAddress_parameters[] = {
    &impl_gt_ipAddress_parameter_1,
    &impl_gt_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("gt<ipAddress>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_ipAddress"),
    AFW_UTF8_LITERAL("gtIpAddress"),
    AFW_UTF8_LITERAL("afwGtIpAddress"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for ipAddress arg1 is greater than ipAddress arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: ipAddress): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<ipAddress> (\n    arg1: ipAddress,\n    arg2: ipAddress\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_ipAddress_parameters[0],
    2,
    &impl_gt_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ipAddress ---------- */

static const afw_utf8_t
impl_object_path__ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ipAddress");

static const afw_runtime_object_indirect_t
impl_object__ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ipAddress
        }
    },
    (void *)&afw_function_definition_ipAddress
};

static const afw_value_function_parameter_t
impl_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ipAddress_parameters[] = {
    &impl_ipAddress_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_ipAddress_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("afwIpAddress"),
    AFW_UTF8_LITERAL("Convert to data type ipAddress"),
    AFW_UTF8_LITERAL("Converts value to data type ipAddress returning ipAddress result."),
    AFW_UTF8_LITERAL("(value: any): ipAddress"),
    AFW_UTF8_LITERAL("/* Convert to data type ipAddress */\nfunction ipAddress (\n    value: any\n): ipAddress;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_ipAddress_parameters[0],
    1,
    &impl_ipAddress_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_ipAddress_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__is_in_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__is_in_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_ipAddress
        }
    },
    (void *)&afw_function_definition_is_in_ipAddress
};

static const afw_value_function_parameter_t
impl_is_in_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_ipAddress_parameters[] = {
    &impl_is_in_ipAddress_parameter_1,
    &impl_is_in_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("is_in<ipAddress>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_ipAddress"),
    AFW_UTF8_LITERAL("isInIpAddress"),
    AFW_UTF8_LITERAL("afwIsInIpAddress"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether ipAddress value is in list of ipAddress list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: ipAddress, list: (list ipAddress)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<ipAddress> (\n    value: ipAddress,\n    list: (list ipAddress)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_ipAddress_parameters[0],
    2,
    &impl_is_in_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__is_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__is_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_ipAddress
        }
    },
    (void *)&afw_function_definition_is_ipAddress
};

static const afw_value_function_parameter_t
impl_is_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_ipAddress_parameters[] = {
    &impl_is_ipAddress_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("is<ipAddress>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_ipAddress"),
    AFW_UTF8_LITERAL("isIpAddress"),
    AFW_UTF8_LITERAL("afwIsIpAddress"),
    AFW_UTF8_LITERAL("Checks whether value is dataType ipAddress"),
    AFW_UTF8_LITERAL("Checks whether value is dataType ipAddress and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType ipAddress */\nfunction is<ipAddress> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_ipAddress_parameters[0],
    1,
    &impl_is_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__le_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__le_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_ipAddress
        }
    },
    (void *)&afw_function_definition_le_ipAddress
};

static const afw_value_function_parameter_t
impl_le_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_ipAddress_parameters[] = {
    &impl_le_ipAddress_parameter_1,
    &impl_le_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("le<ipAddress>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_ipAddress"),
    AFW_UTF8_LITERAL("leIpAddress"),
    AFW_UTF8_LITERAL("afwLeIpAddress"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for ipAddress arg1 is less than or equal to ipAddress arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<ipAddress> (\n    arg1: ipAddress,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_ipAddress_parameters[0],
    2,
    &impl_le_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__lt_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__lt_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_ipAddress
        }
    },
    (void *)&afw_function_definition_lt_ipAddress
};

static const afw_value_function_parameter_t
impl_lt_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_ipAddress_parameters[] = {
    &impl_lt_ipAddress_parameter_1,
    &impl_lt_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("lt<ipAddress>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_ipAddress"),
    AFW_UTF8_LITERAL("ltIpAddress"),
    AFW_UTF8_LITERAL("afwLtIpAddress"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for ipAddress arg1 is less that ipAddress arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: ipAddress): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<ipAddress> (\n    arg1: ipAddress,\n    arg2: ipAddress\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_ipAddress_parameters[0],
    2,
    &impl_lt_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__ne_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__ne_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_ipAddress
        }
    },
    (void *)&afw_function_definition_ne_ipAddress
};

static const afw_value_function_parameter_t
impl_ne_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_ipAddress_parameters[] = {
    &impl_ne_ipAddress_parameter_1,
    &impl_ne_ipAddress_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_ipAddress_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("ne<ipAddress>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_ipAddress"),
    AFW_UTF8_LITERAL("neIpAddress"),
    AFW_UTF8_LITERAL("afwNeIpAddress"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if ipAddress arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<ipAddress> (\n    arg1: ipAddress,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_ipAddress_parameters[0],
    2,
    &impl_ne_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    &impl_ne_ipAddress_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__nex_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__nex_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_ipAddress
        }
    },
    (void *)&afw_function_definition_nex_ipAddress
};

static const afw_value_function_parameter_t
impl_nex_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_ipAddress_parameters[] = {
    &impl_nex_ipAddress_parameter_1,
    &impl_nex_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("nex<ipAddress>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_ipAddress"),
    AFW_UTF8_LITERAL("nexIpAddress"),
    AFW_UTF8_LITERAL("afwNexIpAddress"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for ipAddress arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: ipAddress, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<ipAddress> (\n    arg1: ipAddress,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_ipAddress_parameters[0],
    2,
    &impl_nex_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_ipAddress
        }
    },
    (void *)&afw_function_definition_one_and_only_ipAddress
};

static const afw_value_function_parameter_t
impl_one_and_only_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_ipAddress_parameters[] = {
    &impl_one_and_only_ipAddress_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_ipAddress_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("one_and_only<ipAddress>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_ipAddress"),
    AFW_UTF8_LITERAL("oneAndOnlyIpAddress"),
    AFW_UTF8_LITERAL("afwOneAndOnlyIpAddress"),
    AFW_UTF8_LITERAL("Converts a one value list to a ipAddress value"),
    AFW_UTF8_LITERAL("This converts a list of ipAddress values that contains one value to a single ipAddress value."),
    AFW_UTF8_LITERAL("(list: (list list)): ipAddress"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a ipAddress value */\nfunction one_and_only<ipAddress> (\n    list: (list list)\n): ipAddress;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_ipAddress_parameters[0],
    1,
    &impl_one_and_only_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    &impl_one_and_only_ipAddress_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_match<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__regexp_match_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_match_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__regexp_match_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_match_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_match_ipAddress
        }
    },
    (void *)&afw_function_definition_regexp_match_ipAddress
};

static const afw_value_function_parameter_t
impl_regexp_match_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_ipAddress_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_match_ipAddress_parameters[] = {
    &impl_regexp_match_ipAddress_parameter_1,
    &impl_regexp_match_ipAddress_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_match_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("regexp_match<ipAddress>"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match_ipAddress"),
    AFW_UTF8_LITERAL("regexpMatchIpAddress"),
    AFW_UTF8_LITERAL("afwRegexpMatchIpAddress"),
    AFW_UTF8_LITERAL("Search for a match using a regular expression"),
    AFW_UTF8_LITERAL("Checks whether ipAddress value matches the regular expression regexp and return the boolean result."),
    AFW_UTF8_LITERAL("(value: ipAddress, regexp: string): boolean"),
    AFW_UTF8_LITERAL("/* Search for a match using a regular expression */\nfunction regexp_match<ipAddress> (\n    value: ipAddress,\n    regexp: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_match,
    NULL,
    2,
    2,
    &impl_regexp_match_ipAddress_parameters[0],
    2,
    &impl_regexp_match_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<ipAddress> ---------- */

static const afw_utf8_t
impl_object_path__to_string_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__to_string_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_ipAddress
        }
    },
    (void *)&afw_function_definition_to_string_ipAddress
};

static const afw_value_function_parameter_t
impl_to_string_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A ipAddress value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_ipAddress_parameters[] = {
    &impl_to_string_ipAddress_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_ipAddress,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("to_string<ipAddress>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_ipAddress"),
    AFW_UTF8_LITERAL("toStringIpAddress"),
    AFW_UTF8_LITERAL("afwToStringIpAddress"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts ipAddress value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: ipAddress): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<ipAddress> (\n    value: ipAddress\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_ipAddress_parameters[0],
    1,
    &impl_to_string_ipAddress_returns,
    NULL,
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- journal_advance_cursor_for_consumer ---------- */

static const afw_utf8_t
impl_object_path__journal_advance_cursor_for_consumer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/journal_advance_cursor_for_consumer");

static const afw_runtime_object_indirect_t
impl_object__journal_advance_cursor_for_consumer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_journal_advance_cursor_for_consumer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__journal_advance_cursor_for_consumer
        }
    },
    (void *)&afw_function_definition_journal_advance_cursor_for_consumer
};

static const afw_value_function_parameter_t
impl_journal_advance_cursor_for_consumer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Response object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_advance_cursor_for_consumer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_advance_cursor_for_consumer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("consumerId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The consumerId property value of the associated _AdaptiveProvisioningPeer_ object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_advance_cursor_for_consumer_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The maximum number of entries that will be scanned for an entry where the consumerFilter expression in the associated _AdaptiveProvisioningPeer_ object evaluates to true."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_journal_advance_cursor_for_consumer_parameters[] = {
    &impl_journal_advance_cursor_for_consumer_parameter_1,
    &impl_journal_advance_cursor_for_consumer_parameter_2,
    &impl_journal_advance_cursor_for_consumer_parameter_3,
    NULL
};

static const afw_utf8_t
impl_journal_advance_cursor_for_consumer_sideEffects[] = {
    AFW_UTF8_LITERAL("Journal cursor consumed"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_advance_cursor_for_consumer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__journal_advance_cursor_for_consumer,
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL("journal_advance_cursor_for_consumer"),
    AFW_UTF8_LITERAL("journal_advance_cursor_for_consumer"),
    AFW_UTF8_LITERAL("journal_advance_cursor_for_consumer"),
    AFW_UTF8_LITERAL("journalAdvanceCursorForConsumer"),
    AFW_UTF8_LITERAL("afwJournalAdvanceCursorForConsumer"),
    AFW_UTF8_LITERAL("Advance journal cursor for consumer"),
    AFW_UTF8_LITERAL("Update the advance cursor for a consumer referenced by the consumerId parameter. The limit parameter specifies the maximum number of entries to scan for an applicable entry for consumer before returning. NULL is always returned.\n\nThere are no response properties set by this function.\n\nThe properties of the _AdaptiveProvisioningPeer_ object associated with the consumer_id are used in the following way:\n\nThe consumerFilter expression is used to determine if an entry is applicable.\n\nJournal entries are scanned beginning at the entry at the cursor in the advanceCursor property. If the advanceCursor property is not present, the scan begins after the cursor in currentCursor. If neither are present, the scan begins at the start of the journal.\n\nIf an new applicable entry is found or if the limit is met, the advanceCursor property is set to the currently scanned entry's cursor."),
    AFW_UTF8_LITERAL("(adaptorId: string, consumerId: string, limit?: integer): object"),
    AFW_UTF8_LITERAL("/* Advance journal cursor for consumer */\nfunction journal_advance_cursor_for_consumer (\n    adaptorId: string,\n    consumerId: string,\n    limit?: integer\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_journal_advance_cursor_for_consumer,
    NULL,
    2,
    3,
    &impl_journal_advance_cursor_for_consumer_parameters[0],
    3,
    &impl_journal_advance_cursor_for_consumer_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_journal_advance_cursor_for_consumer_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- journal_get_by_cursor ---------- */

static const afw_utf8_t
impl_object_path__journal_get_by_cursor =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/journal_get_by_cursor");

static const afw_runtime_object_indirect_t
impl_object__journal_get_by_cursor = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_journal_get_by_cursor,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__journal_get_by_cursor
        }
    },
    (void *)&afw_function_definition_journal_get_by_cursor
};

static const afw_value_function_parameter_t
impl_journal_get_by_cursor_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Response object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_by_cursor_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_by_cursor_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("cursor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Journal entry cursor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_journal_get_by_cursor_parameters[] = {
    &impl_journal_get_by_cursor_parameter_1,
    &impl_journal_get_by_cursor_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_by_cursor = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__journal_get_by_cursor,
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL("journal_get_by_cursor"),
    AFW_UTF8_LITERAL("journal_get_by_cursor"),
    AFW_UTF8_LITERAL("journal_get_by_cursor"),
    AFW_UTF8_LITERAL("journalGetByCursor"),
    AFW_UTF8_LITERAL("afwJournalGetByCursor"),
    AFW_UTF8_LITERAL("Get journal entry at cursor"),
    AFW_UTF8_LITERAL("Get journal entry specified by entry_cursor parameter.\n\nThis option will set response properties \"entry\" and \"cursor\" if there is an entry to retrieve. If an entry with the supplied cursor does not exist, a not_found error is thrown."),
    AFW_UTF8_LITERAL("(adaptorId: string, cursor: string): object"),
    AFW_UTF8_LITERAL("/* Get journal entry at cursor */\nfunction journal_get_by_cursor (\n    adaptorId: string,\n    cursor: string\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_journal_get_by_cursor,
    NULL,
    2,
    2,
    &impl_journal_get_by_cursor_parameters[0],
    2,
    &impl_journal_get_by_cursor_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- journal_get_first ---------- */

static const afw_utf8_t
impl_object_path__journal_get_first =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/journal_get_first");

static const afw_runtime_object_indirect_t
impl_object__journal_get_first = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_journal_get_first,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__journal_get_first
        }
    },
    (void *)&afw_function_definition_journal_get_first
};

static const afw_value_function_parameter_t
impl_journal_get_first_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Response object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_first_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_journal_get_first_parameters[] = {
    &impl_journal_get_first_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_first = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__journal_get_first,
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL("journal_get_first"),
    AFW_UTF8_LITERAL("journal_get_first"),
    AFW_UTF8_LITERAL("journal_get_first"),
    AFW_UTF8_LITERAL("journalGetFirst"),
    AFW_UTF8_LITERAL("afwJournalGetFirst"),
    AFW_UTF8_LITERAL("Get first journal entry"),
    AFW_UTF8_LITERAL("Get first journal entry.\n\nThis option will set response properties \"entry\" and \"cursor\" if there is a first entry to return."),
    AFW_UTF8_LITERAL("(adaptorId: string): object"),
    AFW_UTF8_LITERAL("/* Get first journal entry */\nfunction journal_get_first (\n    adaptorId: string\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_journal_get_first,
    NULL,
    1,
    1,
    &impl_journal_get_first_parameters[0],
    1,
    &impl_journal_get_first_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- journal_get_next_after_cursor ---------- */

static const afw_utf8_t
impl_object_path__journal_get_next_after_cursor =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/journal_get_next_after_cursor");

static const afw_runtime_object_indirect_t
impl_object__journal_get_next_after_cursor = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_journal_get_next_after_cursor,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__journal_get_next_after_cursor
        }
    },
    (void *)&afw_function_definition_journal_get_next_after_cursor
};

static const afw_value_function_parameter_t
impl_journal_get_next_after_cursor_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Response object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_after_cursor_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_after_cursor_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("cursor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Journal entry cursor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_journal_get_next_after_cursor_parameters[] = {
    &impl_journal_get_next_after_cursor_parameter_1,
    &impl_journal_get_next_after_cursor_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_next_after_cursor = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__journal_get_next_after_cursor,
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL("journal_get_next_after_cursor"),
    AFW_UTF8_LITERAL("journal_get_next_after_cursor"),
    AFW_UTF8_LITERAL("journal_get_next_after_cursor"),
    AFW_UTF8_LITERAL("journalGetNextAfterCursor"),
    AFW_UTF8_LITERAL("afwJournalGetNextAfterCursor"),
    AFW_UTF8_LITERAL("Get next journal entry after cursor"),
    AFW_UTF8_LITERAL("Get the next journal entry after the one specified by the entry_cursor parameter.\n\nThis option will set response properties \"entry\" and \"cursor\" if there is a next entry to retrieve."),
    AFW_UTF8_LITERAL("(adaptorId: string, cursor: string): object"),
    AFW_UTF8_LITERAL("/* Get next journal entry after cursor */\nfunction journal_get_next_after_cursor (\n    adaptorId: string,\n    cursor: string\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_journal_get_next_after_cursor,
    NULL,
    2,
    2,
    &impl_journal_get_next_after_cursor_parameters[0],
    2,
    &impl_journal_get_next_after_cursor_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- journal_get_next_for_consumer ---------- */

static const afw_utf8_t
impl_object_path__journal_get_next_for_consumer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/journal_get_next_for_consumer");

static const afw_runtime_object_indirect_t
impl_object__journal_get_next_for_consumer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_journal_get_next_for_consumer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__journal_get_next_for_consumer
        }
    },
    (void *)&afw_function_definition_journal_get_next_for_consumer
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Response object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("consumerId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The consumerId property value of the associated _AdaptiveProvisioningPeer_ object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The maximum number of entries that will be scanned for an entry where the consumerFilter expression in the associated _AdaptiveProvisioningPeer_ object evaluates to true."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_journal_get_next_for_consumer_parameters[] = {
    &impl_journal_get_next_for_consumer_parameter_1,
    &impl_journal_get_next_for_consumer_parameter_2,
    &impl_journal_get_next_for_consumer_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_next_for_consumer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__journal_get_next_for_consumer,
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL("journal_get_next_for_consumer"),
    AFW_UTF8_LITERAL("journal_get_next_for_consumer"),
    AFW_UTF8_LITERAL("journal_get_next_for_consumer"),
    AFW_UTF8_LITERAL("journalGetNextForConsumer"),
    AFW_UTF8_LITERAL("afwJournalGetNextForConsumer"),
    AFW_UTF8_LITERAL("Get next journal entry for consumer"),
    AFW_UTF8_LITERAL("Get the next journal entry for a consumer referenced by the consumer_id parameter. The entry_cursor parameter is ignored. The limit parameter specifies the maximum number of entries to scan for an applicable entry for consumer before returning.\n\n This option will set response properties \"entry\" and \"entryCursor\" if an applicable entry is retrieved. Property \"reissue\" will be set as described below.\n\nThe properties of the _AdaptiveProvisioningPeer_ object associated with the consumer_id are used in the following way:\n\nThe consumerFilter expression is used to determine if an entry is applicable.\n\nIf consumeCursor property exists, return that entry at that cursor again immediately with a \"reissue\" property added and set to true.\n\nJournal entries are scanned beginning at the entry at the cursor in the advanceCursor property. If the advanceCursor property is not present, the scan begins after the cursor in currentCursor. If neither are present, the scan begins at the start of the journal.\n\nIf an applicable entry is found, properties consumeStart and consumeCursor are set, advanceCursor is removed, and the entry is returned. Method mark_entry_consumed() will remove these properties.\n\nIf no applicable entry is found, advanceCursor is set to the last entry scanned."),
    AFW_UTF8_LITERAL("(adaptorId: string, consumerId: string, limit?: integer): object"),
    AFW_UTF8_LITERAL("/* Get next journal entry for consumer */\nfunction journal_get_next_for_consumer (\n    adaptorId: string,\n    consumerId: string,\n    limit?: integer\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_journal_get_next_for_consumer,
    NULL,
    2,
    3,
    &impl_journal_get_next_for_consumer_parameters[0],
    3,
    &impl_journal_get_next_for_consumer_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- journal_get_next_for_consumer_after_cursor ---------- */

static const afw_utf8_t
impl_object_path__journal_get_next_for_consumer_after_cursor =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/journal_get_next_for_consumer_after_cursor");

static const afw_runtime_object_indirect_t
impl_object__journal_get_next_for_consumer_after_cursor = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_journal_get_next_for_consumer_after_cursor,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__journal_get_next_for_consumer_after_cursor
        }
    },
    (void *)&afw_function_definition_journal_get_next_for_consumer_after_cursor
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_after_cursor_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Response object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_after_cursor_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_after_cursor_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("consumerId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The consumerId property value of the associated _AdaptiveProvisioningPeer_ object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_after_cursor_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("cursor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Journal entry cursor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_get_next_for_consumer_after_cursor_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The maximum number of entries that will be scanned for an entry where the consumerFilter expression in the associated _AdaptiveProvisioningPeer_ object evaluates to true."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_journal_get_next_for_consumer_after_cursor_parameters[] = {
    &impl_journal_get_next_for_consumer_after_cursor_parameter_1,
    &impl_journal_get_next_for_consumer_after_cursor_parameter_2,
    &impl_journal_get_next_for_consumer_after_cursor_parameter_3,
    &impl_journal_get_next_for_consumer_after_cursor_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_next_for_consumer_after_cursor = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__journal_get_next_for_consumer_after_cursor,
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL("journal_get_next_for_consumer_after_cursor"),
    AFW_UTF8_LITERAL("journal_get_next_for_consumer_after_cursor"),
    AFW_UTF8_LITERAL("journal_get_next_for_consumer_after_cursor"),
    AFW_UTF8_LITERAL("journalGetNextForConsumerAfterCursor"),
    AFW_UTF8_LITERAL("afwJournalGetNextForConsumerAfterCursor"),
    AFW_UTF8_LITERAL("Get next journal entry for consumer after cursor"),
    AFW_UTF8_LITERAL("Get the next journal entry for a consumer referenced by the consumer_id after the one specified by the entry_cursor parameter. The limit parameter specifies the maximum number of entries to scan for an applicable entry for consumer before returning.\n\nThis option will set response properties \"entry\" and \"cursor\" if an applicable entry is retrieved.\n\nThe properties of the _AdaptiveProvisioningPeer_ object associated with the consumer_id are used in the following way:\n\nThe consumerFilter expression is used to determine if an entry is applicable.\n\nUnlike option get_next_for_consumer, no other properties are referenced or modified."),
    AFW_UTF8_LITERAL("(adaptorId: string, consumerId: string, cursor: string, limit?: integer): object"),
    AFW_UTF8_LITERAL("/* Get next journal entry for consumer after cursor */\nfunction journal_get_next_for_consumer_after_cursor (\n    adaptorId: string,\n    consumerId: string,\n    cursor: string,\n    limit?: integer\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_journal_get_next_for_consumer_after_cursor,
    NULL,
    3,
    4,
    &impl_journal_get_next_for_consumer_after_cursor_parameters[0],
    4,
    &impl_journal_get_next_for_consumer_after_cursor_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- journal_mark_consumed ---------- */

static const afw_utf8_t
impl_object_path__journal_mark_consumed =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/journal_mark_consumed");

static const afw_runtime_object_indirect_t
impl_object__journal_mark_consumed = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_journal_mark_consumed,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__journal_mark_consumed
        }
    },
    (void *)&afw_function_definition_journal_mark_consumed
};

static const afw_value_function_parameter_t
impl_journal_mark_consumed_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_mark_consumed_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Id of adaptor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_mark_consumed_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("consumerId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The consumerId property value of the associated _AdaptiveProvisioningPeer_ object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_journal_mark_consumed_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("cursor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Journal entry cursor."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_journal_mark_consumed_parameters[] = {
    &impl_journal_mark_consumed_parameter_1,
    &impl_journal_mark_consumed_parameter_2,
    &impl_journal_mark_consumed_parameter_3,
    NULL
};

static const afw_utf8_t
impl_journal_mark_consumed_sideEffects[] = {
    AFW_UTF8_LITERAL("Journal cursor consumed"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_mark_consumed = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__journal_mark_consumed,
    AFW_UTF8_LITERAL("journal"),
    AFW_UTF8_LITERAL("journal_mark_consumed"),
    AFW_UTF8_LITERAL("journal_mark_consumed"),
    AFW_UTF8_LITERAL("journal_mark_consumed"),
    AFW_UTF8_LITERAL("journalMarkConsumed"),
    AFW_UTF8_LITERAL("afwJournalMarkConsumed"),
    AFW_UTF8_LITERAL("Mark journal entry consumed"),
    AFW_UTF8_LITERAL("Mark a journal entry returned by get_next_for_consumer() as consumed."),
    AFW_UTF8_LITERAL("(adaptorId: string, consumerId: string, cursor: string): null"),
    AFW_UTF8_LITERAL("/* Mark journal entry consumed */\nfunction journal_mark_consumed (\n    adaptorId: string,\n    consumerId: string,\n    cursor: string\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_journal_mark_consumed,
    NULL,
    3,
    3,
    &impl_journal_mark_consumed_parameters[0],
    3,
    &impl_journal_mark_consumed_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_journal_mark_consumed_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- add_entries ---------- */

static const afw_utf8_t
impl_object_path__add_entries =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_entries");

static const afw_runtime_object_indirect_t
impl_object__add_entries = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_entries,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_entries
        }
    },
    (void *)&afw_function_definition_add_entries
};

static const afw_value_function_parameter_t
impl_add_entries_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The modified target list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_entries_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("target"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Target list. This list must not be immutable."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_entries_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Source list(s)."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_entries_parameters[] = {
    &impl_add_entries_parameter_1,
    &impl_add_entries_parameter_2,
    NULL
};

static const afw_utf8_t
impl_add_entries_sideEffects[] = {
    AFW_UTF8_LITERAL("Target list is modified."),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_entries = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_entries,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("add_entries"),
    AFW_UTF8_LITERAL("add_entries"),
    AFW_UTF8_LITERAL("add_entries"),
    AFW_UTF8_LITERAL("addEntries"),
    AFW_UTF8_LITERAL("afwAddEntries"),
    AFW_UTF8_LITERAL("Add entries of one or more lists to another"),
    AFW_UTF8_LITERAL("Add the entries of one or more lists to another."),
    AFW_UTF8_LITERAL("(target: list, source_1: list, ...source_rest: (list of list)): list"),
    AFW_UTF8_LITERAL("/* Add entries of one or more lists to another */\nfunction add_entries (\n    target: list,\n    source_1: list,\n    ...source_rest: (list of list)\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_add_entries,
    NULL,
    2,
    -1,
    &impl_add_entries_parameters[0],
    2,
    &impl_add_entries_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_add_entries_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- bag<list> ---------- */

static const afw_utf8_t
impl_object_path__bag_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_list");

static const afw_runtime_object_indirect_t
impl_object__bag_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_list
        }
    },
    (void *)&afw_function_definition_bag_list
};

static const afw_value_function_parameter_t
impl_bag_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_list_parameters[] = {
    &impl_bag_list_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("bag<list>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_list"),
    AFW_UTF8_LITERAL("bagList"),
    AFW_UTF8_LITERAL("afwBagList"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of list values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list list))): (list list)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<list> (\n    ...values: (list of (list list))\n): (list list);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_list_parameters[0],
    1,
    &impl_bag_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<list> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_list");

static const afw_runtime_object_indirect_t
impl_object__bag_size_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_list
        }
    },
    (void *)&afw_function_definition_bag_size_list
};

static const afw_value_function_parameter_t
impl_bag_size_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_list_parameters[] = {
    &impl_bag_size_list_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("bag_size<list>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_list"),
    AFW_UTF8_LITERAL("bagSizeList"),
    AFW_UTF8_LITERAL("afwBagSizeList"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list list)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<list> (\n    value: (list list)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_list_parameters[0],
    1,
    &impl_bag_size_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- clone<list> ---------- */

static const afw_utf8_t
impl_object_path__clone_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/clone_list");

static const afw_runtime_object_indirect_t
impl_object__clone_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_clone_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__clone_list
        }
    },
    (void *)&afw_function_definition_clone_list
};

static const afw_value_function_parameter_t
impl_clone_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The cloned list value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_clone_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The list value to clone."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_clone_list_parameters[] = {
    &impl_clone_list_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_clone_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__clone_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("clone<list>"),
    AFW_UTF8_LITERAL("clone"),
    AFW_UTF8_LITERAL("clone_list"),
    AFW_UTF8_LITERAL("cloneList"),
    AFW_UTF8_LITERAL("afwCloneList"),
    AFW_UTF8_LITERAL("Clone list value"),
    AFW_UTF8_LITERAL("Deep clone a list value."),
    AFW_UTF8_LITERAL("(value: list): list"),
    AFW_UTF8_LITERAL("/* Clone list value */\nfunction clone<list> (\n    value: list\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_clone,
    NULL,
    1,
    1,
    &impl_clone_list_parameters[0],
    1,
    &impl_clone_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_clone,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<list> ---------- */

static const afw_utf8_t
impl_object_path__eq_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_list");

static const afw_runtime_object_indirect_t
impl_object__eq_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_list
        }
    },
    (void *)&afw_function_definition_eq_list
};

static const afw_value_function_parameter_t
impl_eq_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_list_parameters[] = {
    &impl_eq_list_parameter_1,
    &impl_eq_list_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_list_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("eq<list>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_list"),
    AFW_UTF8_LITERAL("eqList"),
    AFW_UTF8_LITERAL("afwEqList"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if list arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<list> (\n    arg1: list,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_list_parameters[0],
    2,
    &impl_eq_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    &impl_eq_list_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<list> ---------- */

static const afw_utf8_t
impl_object_path__eqx_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_list");

static const afw_runtime_object_indirect_t
impl_object__eqx_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_list
        }
    },
    (void *)&afw_function_definition_eqx_list
};

static const afw_value_function_parameter_t
impl_eqx_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_list_parameters[] = {
    &impl_eqx_list_parameter_1,
    &impl_eqx_list_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("eqx<list>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_list"),
    AFW_UTF8_LITERAL("eqxList"),
    AFW_UTF8_LITERAL("afwEqxList"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for list arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<list> (\n    arg1: list,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_list_parameters[0],
    2,
    &impl_eqx_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<list> ---------- */

static const afw_utf8_t
impl_object_path__ge_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_list");

static const afw_runtime_object_indirect_t
impl_object__ge_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_list
        }
    },
    (void *)&afw_function_definition_ge_list
};

static const afw_value_function_parameter_t
impl_ge_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_list_parameters[] = {
    &impl_ge_list_parameter_1,
    &impl_ge_list_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ge<list>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_list"),
    AFW_UTF8_LITERAL("geList"),
    AFW_UTF8_LITERAL("afwGeList"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for list arg1 is greater than or equal to list arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: list): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<list> (\n    arg1: list,\n    arg2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_list_parameters[0],
    2,
    &impl_ge_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<list> ---------- */

static const afw_utf8_t
impl_object_path__gt_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_list");

static const afw_runtime_object_indirect_t
impl_object__gt_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_list
        }
    },
    (void *)&afw_function_definition_gt_list
};

static const afw_value_function_parameter_t
impl_gt_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_list_parameters[] = {
    &impl_gt_list_parameter_1,
    &impl_gt_list_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("gt<list>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_list"),
    AFW_UTF8_LITERAL("gtList"),
    AFW_UTF8_LITERAL("afwGtList"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for list arg1 is greater than list arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: list): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<list> (\n    arg1: list,\n    arg2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_list_parameters[0],
    2,
    &impl_gt_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- includes<list> ---------- */

static const afw_utf8_t
impl_object_path__includes_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/includes_list");

static const afw_runtime_object_indirect_t
impl_object__includes_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_includes_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__includes_list
        }
    },
    (void *)&afw_function_definition_includes_list
};

static const afw_value_function_parameter_t
impl_includes_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Indicates if the element is found"),
    AFW_UTF8_LITERAL("Indicates if the element is found in list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("The list to search"),
    AFW_UTF8_LITERAL("The list to search."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_includes_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("searchElement"),
    AFW_UTF8_LITERAL("Element to find"),
    AFW_UTF8_LITERAL("Element to find."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_list_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("fromIndex"),
    AFW_UTF8_LITERAL("Index in the list to start"),
    AFW_UTF8_LITERAL("Index in the list to start search."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_includes_list_parameters[] = {
    &impl_includes_list_parameter_1,
    &impl_includes_list_parameter_2,
    &impl_includes_list_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__includes_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("includes<list>"),
    AFW_UTF8_LITERAL("includes"),
    AFW_UTF8_LITERAL("includes_list"),
    AFW_UTF8_LITERAL("includesList"),
    AFW_UTF8_LITERAL("afwIncludesList"),
    AFW_UTF8_LITERAL("Checks whether or not a list contains any value"),
    AFW_UTF8_LITERAL("Checks whether or not a list contains any value."),
    AFW_UTF8_LITERAL("(list: list, searchElement: any, fromIndex?: integer): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether or not a list contains any value */\nfunction includes<list> (\n    list: list          /* The list to search */,\n    searchElement: any  /* Element to find */,\n    fromIndex?: integer /* Index in the list to start */\n): boolean; /* Indicates if the element is found */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_includes_list,
    NULL,
    2,
    3,
    &impl_includes_list_parameters[0],
    3,
    &impl_includes_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_includes,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<list> ---------- */

static const afw_utf8_t
impl_object_path__is_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_list");

static const afw_runtime_object_indirect_t
impl_object__is_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_list
        }
    },
    (void *)&afw_function_definition_is_list
};

static const afw_value_function_parameter_t
impl_is_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_list_parameters[] = {
    &impl_is_list_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("is<list>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_list"),
    AFW_UTF8_LITERAL("isList"),
    AFW_UTF8_LITERAL("afwIsList"),
    AFW_UTF8_LITERAL("Checks whether value is dataType list"),
    AFW_UTF8_LITERAL("Checks whether value is dataType list and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType list */\nfunction is<list> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_list_parameters[0],
    1,
    &impl_is_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- join ---------- */

static const afw_utf8_t
impl_object_path__join =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/join");

static const afw_runtime_object_indirect_t
impl_object__join = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_join,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__join
        }
    },
    (void *)&afw_function_definition_join
};

static const afw_value_function_parameter_t
impl_join_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Joined list values."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_join_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A list of values of any data type."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_join_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("separator"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The separator to use. If not specified, a comma (,) is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_join_parameters[] = {
    &impl_join_parameter_1,
    &impl_join_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_join = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__join,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("join"),
    AFW_UTF8_LITERAL("join"),
    AFW_UTF8_LITERAL("join"),
    AFW_UTF8_LITERAL("join"),
    AFW_UTF8_LITERAL("afwJoin"),
    AFW_UTF8_LITERAL("Join the string values of list elements"),
    AFW_UTF8_LITERAL("Concatenate the string values of the elements of a list with a separator."),
    AFW_UTF8_LITERAL("(value: list, separator?: string): string"),
    AFW_UTF8_LITERAL("/* Join the string values of list elements */\nfunction join (\n    value: list,\n    separator?: string\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_join,
    NULL,
    1,
    2,
    &impl_join_parameters[0],
    2,
    &impl_join_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_join,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<list> ---------- */

static const afw_utf8_t
impl_object_path__le_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_list");

static const afw_runtime_object_indirect_t
impl_object__le_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_list
        }
    },
    (void *)&afw_function_definition_le_list
};

static const afw_value_function_parameter_t
impl_le_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_list_parameters[] = {
    &impl_le_list_parameter_1,
    &impl_le_list_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("le<list>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_list"),
    AFW_UTF8_LITERAL("leList"),
    AFW_UTF8_LITERAL("afwLeList"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for list arg1 is less than or equal to list arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<list> (\n    arg1: list,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_list_parameters[0],
    2,
    &impl_le_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- length<list> ---------- */

static const afw_utf8_t
impl_object_path__length_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/length_list");

static const afw_runtime_object_indirect_t
impl_object__length_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_length_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__length_list
        }
    },
    (void *)&afw_function_definition_length_list
};

static const afw_value_function_parameter_t
impl_length_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_length_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Returns the number of entries in a list or code points in others."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_length_list_parameters[] = {
    &impl_length_list_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__length_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("length<list>"),
    AFW_UTF8_LITERAL("length"),
    AFW_UTF8_LITERAL("length_list"),
    AFW_UTF8_LITERAL("lengthList"),
    AFW_UTF8_LITERAL("afwLengthList"),
    AFW_UTF8_LITERAL("Returns number of codepoints or entries in value"),
    AFW_UTF8_LITERAL("This is a polymorphic function where list can be any of the supported data types. Return the integer number of entries in datatype list or codepoints in others."),
    AFW_UTF8_LITERAL("(value: list): integer"),
    AFW_UTF8_LITERAL("/* Returns number of codepoints or entries in value */\nfunction length<list> (\n    value: list\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_length,
    NULL,
    1,
    1,
    &impl_length_list_parameters[0],
    1,
    &impl_length_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_length,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- list ---------- */

static const afw_utf8_t
impl_object_path__list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/list");

static const afw_runtime_object_indirect_t
impl_object__list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__list
        }
    },
    (void *)&afw_function_definition_list
};

static const afw_value_function_parameter_t
impl_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_list_parameters[] = {
    &impl_list_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_list_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("afwList"),
    AFW_UTF8_LITERAL("Convert to data type list"),
    AFW_UTF8_LITERAL("Converts 1 or more values in a list. If A value is a list, its individual values are included.\n\nIf the data types of all values in the resulting list are the same, the list will be a list of that data type. Otherwise, the resulting list will be untyped."),
    AFW_UTF8_LITERAL("(...values: (list of any)): list"),
    AFW_UTF8_LITERAL("/* Convert to data type list */\nfunction list (\n    ...values: (list of any)\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_list,
    NULL,
    0,
    -1,
    &impl_list_parameters[0],
    1,
    &impl_list_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_list_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<list> ---------- */

static const afw_utf8_t
impl_object_path__lt_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_list");

static const afw_runtime_object_indirect_t
impl_object__lt_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_list
        }
    },
    (void *)&afw_function_definition_lt_list
};

static const afw_value_function_parameter_t
impl_lt_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_list_parameters[] = {
    &impl_lt_list_parameter_1,
    &impl_lt_list_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("lt<list>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_list"),
    AFW_UTF8_LITERAL("ltList"),
    AFW_UTF8_LITERAL("afwLtList"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for list arg1 is less that list arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: list): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<list> (\n    arg1: list,\n    arg2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_list_parameters[0],
    2,
    &impl_lt_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<list> ---------- */

static const afw_utf8_t
impl_object_path__ne_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_list");

static const afw_runtime_object_indirect_t
impl_object__ne_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_list
        }
    },
    (void *)&afw_function_definition_ne_list
};

static const afw_value_function_parameter_t
impl_ne_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_list_parameters[] = {
    &impl_ne_list_parameter_1,
    &impl_ne_list_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_list_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("ne<list>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_list"),
    AFW_UTF8_LITERAL("neList"),
    AFW_UTF8_LITERAL("afwNeList"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if list arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<list> (\n    arg1: list,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_list_parameters[0],
    2,
    &impl_ne_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    &impl_ne_list_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<list> ---------- */

static const afw_utf8_t
impl_object_path__nex_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_list");

static const afw_runtime_object_indirect_t
impl_object__nex_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_list
        }
    },
    (void *)&afw_function_definition_nex_list
};

static const afw_value_function_parameter_t
impl_nex_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_list_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_list_parameters[] = {
    &impl_nex_list_parameter_1,
    &impl_nex_list_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("nex<list>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_list"),
    AFW_UTF8_LITERAL("nexList"),
    AFW_UTF8_LITERAL("afwNexList"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for list arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: list, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<list> (\n    arg1: list,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_list_parameters[0],
    2,
    &impl_nex_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- reverse ---------- */

static const afw_utf8_t
impl_object_path__reverse =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/reverse");

static const afw_runtime_object_indirect_t
impl_object__reverse = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_reverse,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__reverse
        }
    },
    (void *)&afw_function_definition_reverse
};

static const afw_value_function_parameter_t
impl_reverse_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A list with elements reversed."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_reverse_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A list to reverse."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_reverse_parameters[] = {
    &impl_reverse_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_reverse = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__reverse,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("reverse"),
    AFW_UTF8_LITERAL("reverse"),
    AFW_UTF8_LITERAL("reverse"),
    AFW_UTF8_LITERAL("reverse"),
    AFW_UTF8_LITERAL("afwReverse"),
    AFW_UTF8_LITERAL("Return list with elements reversed"),
    AFW_UTF8_LITERAL("Reverse the order of the elements in a list. If the list is typed, the resulting list will be the same type."),
    AFW_UTF8_LITERAL("(list: list): list"),
    AFW_UTF8_LITERAL("/* Return list with elements reversed */\nfunction reverse (\n    list: list\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_reverse,
    NULL,
    1,
    1,
    &impl_reverse_parameters[0],
    1,
    &impl_reverse_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_reverse,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- slice ---------- */

static const afw_utf8_t
impl_object_path__slice =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/slice");

static const afw_runtime_object_indirect_t
impl_object__slice = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_slice,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__slice
        }
    },
    (void *)&afw_function_definition_slice
};

static const afw_value_function_parameter_t
impl_slice_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A list containing the selected values. If all of the values are the same data type, the list will be a list of that data type."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_slice_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The list to slice."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_slice_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the zero based starting index. Use negative number to index from the end of the list. If not specified, an index of 0 is assumed."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_slice_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("endIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the zero based ending index. If positive, this is one more than the index of the last value to include in the list. If negative, the index is from the end of the list. If not specified, the slice is from startIndex up to and including the end of the list."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_slice_parameters[] = {
    &impl_slice_parameter_1,
    &impl_slice_parameter_2,
    &impl_slice_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_slice = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__slice,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("slice"),
    AFW_UTF8_LITERAL("slice"),
    AFW_UTF8_LITERAL("slice"),
    AFW_UTF8_LITERAL("slice"),
    AFW_UTF8_LITERAL("afwSlice"),
    AFW_UTF8_LITERAL("Return a consecutive slice of values from a list"),
    AFW_UTF8_LITERAL("This function extracts a consecutive slice of values from a list."),
    AFW_UTF8_LITERAL("(list: list, startIndex?: integer, endIndex?: integer): list"),
    AFW_UTF8_LITERAL("/* Return a consecutive slice of values from a list */\nfunction slice (\n    list: list,\n    startIndex?: integer,\n    endIndex?: integer\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_slice,
    NULL,
    1,
    3,
    &impl_slice_parameters[0],
    3,
    &impl_slice_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<list> ---------- */

static const afw_utf8_t
impl_object_path__to_string_list =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_list");

static const afw_runtime_object_indirect_t
impl_object__to_string_list = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_list,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_list
        }
    },
    (void *)&afw_function_definition_to_string_list
};

static const afw_value_function_parameter_t
impl_to_string_list_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_list_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A list value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_list_parameters[] = {
    &impl_to_string_list_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_list = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_list,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("to_string<list>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_list"),
    AFW_UTF8_LITERAL("toStringList"),
    AFW_UTF8_LITERAL("afwToStringList"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts list value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: list): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<list> (\n    value: list\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_list_parameters[0],
    1,
    &impl_to_string_list_returns,
    NULL,
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- and ---------- */

static const afw_utf8_t
impl_object_path__and =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/and");

static const afw_runtime_object_indirect_t
impl_object__and = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_and,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__and
        }
    },
    (void *)&afw_function_definition_and
};

static const afw_value_function_parameter_t
impl_and_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_and_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("conditions"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_and_parameters[] = {
    &impl_and_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_and = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__and,
    AFW_UTF8_LITERAL("logical"),
    AFW_UTF8_LITERAL("and"),
    AFW_UTF8_LITERAL("and"),
    AFW_UTF8_LITERAL("and"),
    AFW_UTF8_LITERAL("and"),
    AFW_UTF8_LITERAL("afwAnd"),
    AFW_UTF8_LITERAL("Logical and"),
    AFW_UTF8_LITERAL("Evaluates 0 or more boolean conditions returning boolean true if there are no conditions and boolean false if any condition evaluate to false. All conditions after the first false remain unevaluated."),
    AFW_UTF8_LITERAL("(...conditions: (list of boolean)): boolean"),
    AFW_UTF8_LITERAL("/* Logical and */\nfunction and (\n    ...conditions: (list of boolean)\n): boolean;\n"),
    AFW_UTF8_LITERAL("&&"),
    afw_function_execute_and,
    NULL,
    0,
    -1,
    &impl_and_parameters[0],
    1,
    &impl_and_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- n_of ---------- */

static const afw_utf8_t
impl_object_path__n_of =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/n_of");

static const afw_runtime_object_indirect_t
impl_object__n_of = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_n_of,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__n_of
        }
    },
    (void *)&afw_function_definition_n_of
};

static const afw_value_function_parameter_t
impl_n_of_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_n_of_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("n"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_n_of_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("conditions"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_n_of_parameters[] = {
    &impl_n_of_parameter_1,
    &impl_n_of_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_n_of_errorsThrown[] = {
    "error", "arg_error",
    "reason", "there are less than n conditions",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_n_of = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__n_of,
    AFW_UTF8_LITERAL("logical"),
    AFW_UTF8_LITERAL("n_of"),
    AFW_UTF8_LITERAL("n_of"),
    AFW_UTF8_LITERAL("n_of"),
    AFW_UTF8_LITERAL("nOf"),
    AFW_UTF8_LITERAL("afwNOf"),
    AFW_UTF8_LITERAL("Check for n true values"),
    AFW_UTF8_LITERAL("integer n specifies the number of boolean conditions that follow that must evaluate to true for boolean true to be returned. If n is 0, true is returned. Once n conditions evaluate to true, true is returned and the remaining conditions remain unevaluated."),
    AFW_UTF8_LITERAL("(n: integer, ...conditions: (list of boolean)): boolean"),
    AFW_UTF8_LITERAL("/* Check for n true values */\nfunction n_of (\n    n: integer,\n    ...conditions: (list of boolean)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_n_of,
    NULL,
    1,
    -1,
    &impl_n_of_parameters[0],
    2,
    &impl_n_of_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_n_of_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- not ---------- */

static const afw_utf8_t
impl_object_path__not =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/not");

static const afw_runtime_object_indirect_t
impl_object__not = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_not,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__not
        }
    },
    (void *)&afw_function_definition_not
};

static const afw_value_function_parameter_t
impl_not_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_not_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("condition"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_not_parameters[] = {
    &impl_not_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_not = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__not,
    AFW_UTF8_LITERAL("logical"),
    AFW_UTF8_LITERAL("not"),
    AFW_UTF8_LITERAL("not"),
    AFW_UTF8_LITERAL("not"),
    AFW_UTF8_LITERAL("not"),
    AFW_UTF8_LITERAL("afwNot"),
    AFW_UTF8_LITERAL("Logical not"),
    AFW_UTF8_LITERAL("Evaluates boolean condition returning boolean true if condition evaluates to false and false if condition evaluates to true."),
    AFW_UTF8_LITERAL("(condition: boolean): boolean"),
    AFW_UTF8_LITERAL("/* Logical not */\nfunction not (\n    condition: boolean\n): boolean;\n"),
    AFW_UTF8_LITERAL("!"),
    afw_function_execute_not,
    NULL,
    1,
    1,
    &impl_not_parameters[0],
    1,
    &impl_not_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- or ---------- */

static const afw_utf8_t
impl_object_path__or =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/or");

static const afw_runtime_object_indirect_t
impl_object__or = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_or,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__or
        }
    },
    (void *)&afw_function_definition_or
};

static const afw_value_function_parameter_t
impl_or_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_or_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("conditions"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_or_parameters[] = {
    &impl_or_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_or = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__or,
    AFW_UTF8_LITERAL("logical"),
    AFW_UTF8_LITERAL("or"),
    AFW_UTF8_LITERAL("or"),
    AFW_UTF8_LITERAL("or"),
    AFW_UTF8_LITERAL("or"),
    AFW_UTF8_LITERAL("afwOr"),
    AFW_UTF8_LITERAL("Logical or"),
    AFW_UTF8_LITERAL("Evaluates 0 or more boolean conditions returning boolean false if there are no conditions and boolean true if any condition evaluate to true. All conditions after the first true remain unevaluated."),
    AFW_UTF8_LITERAL("(...conditions: (list of boolean)): boolean"),
    AFW_UTF8_LITERAL("/* Logical or */\nfunction or (\n    ...conditions: (list of boolean)\n): boolean;\n"),
    AFW_UTF8_LITERAL("||"),
    afw_function_execute_or,
    NULL,
    0,
    -1,
    &impl_or_parameters[0],
    1,
    &impl_or_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- annotate ---------- */

static const afw_utf8_t
impl_object_path__annotate =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/annotate");

static const afw_runtime_object_indirect_t
impl_object__annotate = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_annotate,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__annotate
        }
    },
    (void *)&afw_function_definition_annotate
};

static const afw_value_function_parameter_t
impl_annotate_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Unevaluated annotated value ready for use by function evaluate()."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_annotate_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveAnnotation_"),
    AFW_UTF8_LITERAL("annotation"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Annotation for value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_annotate_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Any value. This value will not be evaluated."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_annotate_parameters[] = {
    &impl_annotate_parameter_1,
    &impl_annotate_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_annotate = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__annotate,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("annotate"),
    AFW_UTF8_LITERAL("annotate"),
    AFW_UTF8_LITERAL("annotate"),
    AFW_UTF8_LITERAL("annotate"),
    AFW_UTF8_LITERAL("afwAnnotate"),
    AFW_UTF8_LITERAL("Annotate a value"),
    AFW_UTF8_LITERAL("Create an annotated value."),
    AFW_UTF8_LITERAL("(annotation: (object _AdaptiveAnnotation_), value: any): any"),
    AFW_UTF8_LITERAL("/* Annotate a value */\nfunction annotate (\n    annotation: (object _AdaptiveAnnotation_),\n    value: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_annotate,
    NULL,
    2,
    2,
    &impl_annotate_parameters[0],
    2,
    &impl_annotate_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compare_uri ---------- */

static const afw_utf8_t
impl_object_path__compare_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compare_uri");

static const afw_runtime_object_indirect_t
impl_object__compare_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compare_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compare_uri
        }
    },
    (void *)&afw_function_definition_compare_uri
};

static const afw_value_function_parameter_t
impl_compare_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Result of comparison."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compare_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("First URI for compare. This URI can not contain an asterisk (\"*\")"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compare_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Second URI for compare. This URI can contain asterisk (\"*\") for substitution if isValuePath is true and currentPath2 is specified."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compare_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("isValuePath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The URIs are adaptive value paths. If one of the URIs begins with a single slash \"/\", both must, and each URI will be parsed as an adaptive value path (example: /adaptorId/objectType/objectId.propertyNames)."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compare_uri_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("currentPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If isValuePath is true, this is the current path that is used to resolve a relative path in the URIs. If isValuePath is not true, this parameter is ignored."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compare_uri_parameters[] = {
    &impl_compare_uri_parameter_1,
    &impl_compare_uri_parameter_2,
    &impl_compare_uri_parameter_3,
    &impl_compare_uri_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compare_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compare_uri,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("compare_uri"),
    AFW_UTF8_LITERAL("compare_uri"),
    AFW_UTF8_LITERAL("compare_uri"),
    AFW_UTF8_LITERAL("compareUri"),
    AFW_UTF8_LITERAL("afwCompareUri"),
    AFW_UTF8_LITERAL("Compare URIs"),
    AFW_UTF8_LITERAL("Compare two URIs."),
    AFW_UTF8_LITERAL("(uri1: string, uri2: string, isValuePath?: boolean, currentPath?: string): boolean"),
    AFW_UTF8_LITERAL("/* Compare URIs */\nfunction compare_uri (\n    uri1: string,\n    uri2: string,\n    isValuePath?: boolean,\n    currentPath?: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compare_uri,
    NULL,
    2,
    4,
    &impl_compare_uri_parameters[0],
    4,
    &impl_compare_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- debug ---------- */

static const afw_utf8_t
impl_object_path__debug =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/debug");

static const afw_runtime_object_indirect_t
impl_object__debug = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_debug,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__debug
        }
    },
    (void *)&afw_function_definition_debug
};

static const afw_value_function_parameter_t
impl_debug_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_debug_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the value that will be converted to its string representation and written. An undefined value is represented by '<undefined>'."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_debug_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("detail"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If true, the string will only written if the debug:function_active:detail flag is on. If false or not specified, the string will only written if the debug:function_active flag is on."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_debug_parameters[] = {
    &impl_debug_parameter_1,
    &impl_debug_parameter_2,
    NULL
};

static const afw_utf8_t
impl_debug_sideEffects[] = {
    AFW_UTF8_LITERAL("Value written"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_debug = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__debug,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("debug"),
    AFW_UTF8_LITERAL("debug"),
    AFW_UTF8_LITERAL("debug"),
    AFW_UTF8_LITERAL("debug"),
    AFW_UTF8_LITERAL("afwDebug"),
    AFW_UTF8_LITERAL("Conditionally write a debug value"),
    AFW_UTF8_LITERAL("Conditionally, based on the detail parameter, write a value as a string to the debug file descriptor (usually stderr)."),
    AFW_UTF8_LITERAL("(value: any, detail?: boolean): null"),
    AFW_UTF8_LITERAL("/* Conditionally write a debug value */\nfunction debug (\n    value: any,\n    detail?: boolean\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_debug,
    NULL,
    1,
    2,
    &impl_debug_parameters[0],
    2,
    &impl_debug_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_debug_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- execution_start_time_local ---------- */

static const afw_utf8_t
impl_object_path__execution_start_time_local =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/execution_start_time_local");

static const afw_runtime_object_indirect_t
impl_object__execution_start_time_local = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_execution_start_time_local,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__execution_start_time_local
        }
    },
    (void *)&afw_function_definition_execution_start_time_local
};

static const afw_value_function_parameter_t
impl_execution_start_time_local_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_execution_start_time_local_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_execution_start_time_local = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__execution_start_time_local,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("execution_start_time_local"),
    AFW_UTF8_LITERAL("execution_start_time_local"),
    AFW_UTF8_LITERAL("execution_start_time_local"),
    AFW_UTF8_LITERAL("executionStartTimeLocal"),
    AFW_UTF8_LITERAL("afwExecutionStartTimeLocal"),
    AFW_UTF8_LITERAL("The execution context (xctx) local create dataTime"),
    AFW_UTF8_LITERAL("Return local dateTime when the execution context was created. This will usually be the start of request time."),
    AFW_UTF8_LITERAL("(): dateTime"),
    AFW_UTF8_LITERAL("/* The execution context (xctx) local create dataTime */\nfunction execution_start_time_local (\n\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_execution_start_time_local,
    NULL,
    0,
    0,
    &impl_execution_start_time_local_parameters[0],
    0,
    &impl_execution_start_time_local_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- execution_start_time_utc ---------- */

static const afw_utf8_t
impl_object_path__execution_start_time_utc =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/execution_start_time_utc");

static const afw_runtime_object_indirect_t
impl_object__execution_start_time_utc = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_execution_start_time_utc,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__execution_start_time_utc
        }
    },
    (void *)&afw_function_definition_execution_start_time_utc
};

static const afw_value_function_parameter_t
impl_execution_start_time_utc_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_execution_start_time_utc_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_execution_start_time_utc = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__execution_start_time_utc,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("execution_start_time_utc"),
    AFW_UTF8_LITERAL("execution_start_time_utc"),
    AFW_UTF8_LITERAL("execution_start_time_utc"),
    AFW_UTF8_LITERAL("executionStartTimeUtc"),
    AFW_UTF8_LITERAL("afwExecutionStartTimeUtc"),
    AFW_UTF8_LITERAL("The execution context (xctx) UTC create dataTime"),
    AFW_UTF8_LITERAL("Return UTC dateTime when the execution context was created. This will usually be the start of request time."),
    AFW_UTF8_LITERAL("(): dateTime"),
    AFW_UTF8_LITERAL("/* The execution context (xctx) UTC create dataTime */\nfunction execution_start_time_utc (\n\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_execution_start_time_utc,
    NULL,
    0,
    0,
    &impl_execution_start_time_utc_parameters[0],
    0,
    &impl_execution_start_time_utc_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- generate_uuid ---------- */

static const afw_utf8_t
impl_object_path__generate_uuid =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/generate_uuid");

static const afw_runtime_object_indirect_t
impl_object__generate_uuid = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_generate_uuid,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__generate_uuid
        }
    },
    (void *)&afw_function_definition_generate_uuid
};

static const afw_value_function_parameter_t
impl_generate_uuid_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_generate_uuid_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_generate_uuid = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__generate_uuid,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("generate_uuid"),
    AFW_UTF8_LITERAL("generate_uuid"),
    AFW_UTF8_LITERAL("generate_uuid"),
    AFW_UTF8_LITERAL("generateUuid"),
    AFW_UTF8_LITERAL("afwGenerateUuid"),
    AFW_UTF8_LITERAL("Generate UUID"),
    AFW_UTF8_LITERAL("Generate a UUID."),
    AFW_UTF8_LITERAL("(): string"),
    AFW_UTF8_LITERAL("/* Generate UUID */\nfunction generate_uuid (\n\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_generate_uuid,
    NULL,
    0,
    0,
    &impl_generate_uuid_parameters[0],
    0,
    &impl_generate_uuid_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- is_defined ---------- */

static const afw_utf8_t
impl_object_path__is_defined =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_defined");

static const afw_runtime_object_indirect_t
impl_object__is_defined = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_defined,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_defined
        }
    },
    (void *)&afw_function_definition_is_defined
};

static const afw_value_function_parameter_t
impl_is_defined_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if value is not undefined."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_defined_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_defined_parameters[] = {
    &impl_is_defined_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_defined = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_defined,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("is_defined"),
    AFW_UTF8_LITERAL("is_defined"),
    AFW_UTF8_LITERAL("is_defined"),
    AFW_UTF8_LITERAL("isDefined"),
    AFW_UTF8_LITERAL("afwIsDefined"),
    AFW_UTF8_LITERAL("Is defined"),
    AFW_UTF8_LITERAL("Test value returning boolean True if it is not undefined."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Is defined */\nfunction is_defined (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_defined,
    NULL,
    1,
    1,
    &impl_is_defined_parameters[0],
    1,
    &impl_is_defined_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_nullish ---------- */

static const afw_utf8_t
impl_object_path__is_nullish =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_nullish");

static const afw_runtime_object_indirect_t
impl_object__is_nullish = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_nullish,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_nullish
        }
    },
    (void *)&afw_function_definition_is_nullish
};

static const afw_value_function_parameter_t
impl_is_nullish_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if value is null or undefined."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_nullish_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_nullish_parameters[] = {
    &impl_is_nullish_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_nullish = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_nullish,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("is_nullish"),
    AFW_UTF8_LITERAL("is_nullish"),
    AFW_UTF8_LITERAL("is_nullish"),
    AFW_UTF8_LITERAL("isNullish"),
    AFW_UTF8_LITERAL("afwIsNullish"),
    AFW_UTF8_LITERAL("Is nullish"),
    AFW_UTF8_LITERAL("Test value returning boolean True if it is null or undefined."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Is nullish */\nfunction is_nullish (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_nullish,
    NULL,
    1,
    1,
    &impl_is_nullish_parameters[0],
    1,
    &impl_is_nullish_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- log ---------- */

static const afw_utf8_t
impl_object_path__log =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/log");

static const afw_runtime_object_indirect_t
impl_object__log = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_log,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__log
        }
    },
    (void *)&afw_function_definition_log
};

static const afw_value_function_parameter_t
impl_log_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_log_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to log."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_log_parameters[] = {
    &impl_log_parameter_1,
    NULL
};

static const afw_utf8_t
impl_log_sideEffects[] = {
    AFW_UTF8_LITERAL("Value written to log"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_log = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__log,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("log"),
    AFW_UTF8_LITERAL("log"),
    AFW_UTF8_LITERAL("log"),
    AFW_UTF8_LITERAL("log"),
    AFW_UTF8_LITERAL("afwLog"),
    AFW_UTF8_LITERAL("Log value"),
    AFW_UTF8_LITERAL("Evaluate and convert value to String and log it."),
    AFW_UTF8_LITERAL("(value: any): null"),
    AFW_UTF8_LITERAL("/* Log value */\nfunction log (\n    value: any\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_log,
    NULL,
    1,
    1,
    &impl_log_parameters[0],
    1,
    &impl_log_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_log_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- now_local ---------- */

static const afw_utf8_t
impl_object_path__now_local =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/now_local");

static const afw_runtime_object_indirect_t
impl_object__now_local = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_now_local,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__now_local
        }
    },
    (void *)&afw_function_definition_now_local
};

static const afw_value_function_parameter_t
impl_now_local_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_now_local_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_now_local = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__now_local,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("now_local"),
    AFW_UTF8_LITERAL("now_local"),
    AFW_UTF8_LITERAL("now_local"),
    AFW_UTF8_LITERAL("nowLocal"),
    AFW_UTF8_LITERAL("afwNowLocal"),
    AFW_UTF8_LITERAL("Local dataTime"),
    AFW_UTF8_LITERAL("Return current local dateTime."),
    AFW_UTF8_LITERAL("(): dateTime"),
    AFW_UTF8_LITERAL("/* Local dataTime */\nfunction now_local (\n\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_now_local,
    NULL,
    0,
    0,
    &impl_now_local_parameters[0],
    0,
    &impl_now_local_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- now_utc ---------- */

static const afw_utf8_t
impl_object_path__now_utc =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/now_utc");

static const afw_runtime_object_indirect_t
impl_object__now_utc = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_now_utc,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__now_utc
        }
    },
    (void *)&afw_function_definition_now_utc
};

static const afw_value_function_parameter_t
impl_now_utc_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_now_utc_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_now_utc = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__now_utc,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("now_utc"),
    AFW_UTF8_LITERAL("now_utc"),
    AFW_UTF8_LITERAL("now_utc"),
    AFW_UTF8_LITERAL("nowUtc"),
    AFW_UTF8_LITERAL("afwNowUtc"),
    AFW_UTF8_LITERAL("UTC dataTime"),
    AFW_UTF8_LITERAL("Return current UTC dateTime."),
    AFW_UTF8_LITERAL("(): dateTime"),
    AFW_UTF8_LITERAL("/* UTC dataTime */\nfunction now_utc (\n\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_now_utc,
    NULL,
    0,
    0,
    &impl_now_utc_parameters[0],
    0,
    &impl_now_utc_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- nullish_coalescing ---------- */

static const afw_utf8_t
impl_object_path__nullish_coalescing =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nullish_coalescing");

static const afw_runtime_object_indirect_t
impl_object__nullish_coalescing = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nullish_coalescing,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nullish_coalescing
        }
    },
    (void *)&afw_function_definition_nullish_coalescing
};

static const afw_value_function_parameter_t
impl_nullish_coalescing_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first value of values that is not null or undefined."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nullish_coalescing_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nullish_coalescing_parameters[] = {
    &impl_nullish_coalescing_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nullish_coalescing = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nullish_coalescing,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("nullish_coalescing"),
    AFW_UTF8_LITERAL("nullish_coalescing"),
    AFW_UTF8_LITERAL("nullish_coalescing"),
    AFW_UTF8_LITERAL("nullishCoalescing"),
    AFW_UTF8_LITERAL("afwNullishCoalescing"),
    AFW_UTF8_LITERAL("Nullish coalescing"),
    AFW_UTF8_LITERAL("Returns the first value of values that is not null or undefined leaving the remaining values unevaluated."),
    AFW_UTF8_LITERAL("(values_1: any, values_2: any, ...values_rest: (list of any)): any"),
    AFW_UTF8_LITERAL("/* Nullish coalescing */\nfunction nullish_coalescing (\n    values_1: any,\n    values_2: any,\n    ...values_rest: (list of any)\n): any;\n"),
    AFW_UTF8_LITERAL("??"),
    afw_function_execute_nullish_coalescing,
    NULL,
    2,
    -1,
    &impl_nullish_coalescing_parameters[0],
    1,
    &impl_nullish_coalescing_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- optional_chaining ---------- */

static const afw_utf8_t
impl_object_path__optional_chaining =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/optional_chaining");

static const afw_runtime_object_indirect_t
impl_object__optional_chaining = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_optional_chaining,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__optional_chaining
        }
    },
    (void *)&afw_function_definition_optional_chaining
};

static const afw_value_function_parameter_t
impl_optional_chaining_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Undefined value if arg1 is null or undefined but otherwise evaluated arg2."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_optional_chaining_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_optional_chaining_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_optional_chaining_parameters[] = {
    &impl_optional_chaining_parameter_1,
    &impl_optional_chaining_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_optional_chaining = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__optional_chaining,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("optional_chaining"),
    AFW_UTF8_LITERAL("optional_chaining"),
    AFW_UTF8_LITERAL("optional_chaining"),
    AFW_UTF8_LITERAL("optionalChaining"),
    AFW_UTF8_LITERAL("afwOptionalChaining"),
    AFW_UTF8_LITERAL("Optional chaining"),
    AFW_UTF8_LITERAL("Returns undefined if arg1 is null or undefined without evaluating arg2, but otherwise returns evaluated value of arg2."),
    AFW_UTF8_LITERAL("(arg1: any, arg2: any): any"),
    AFW_UTF8_LITERAL("/* Optional chaining */\nfunction optional_chaining (\n    arg1: any,\n    arg2: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_optional_chaining,
    NULL,
    2,
    2,
    &impl_optional_chaining_parameters[0],
    2,
    &impl_optional_chaining_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- parse_uri ---------- */

static const afw_utf8_t
impl_object_path__parse_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/parse_uri");

static const afw_runtime_object_indirect_t
impl_object__parse_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_parse_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__parse_uri
        }
    },
    (void *)&afw_function_definition_parse_uri
};

static const afw_value_function_parameter_t
impl_parse_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveParsedURI_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object with results of parse."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_parse_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI to parse"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_parse_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("isValuePath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The URI is an adaptive value path. If the path begins with a single slash \"/\", the URI will be parsed as an adaptive value path (example: /adaptorId/objectType/objectId.propertyNames)"),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_parse_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("currentPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If isValuePath is true, this is the current path that is used to resolve relative paths. If isValuePath is not true, this parameter is ignored."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_parse_uri_parameters[] = {
    &impl_parse_uri_parameter_1,
    &impl_parse_uri_parameter_2,
    &impl_parse_uri_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_parse_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__parse_uri,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("parse_uri"),
    AFW_UTF8_LITERAL("parse_uri"),
    AFW_UTF8_LITERAL("parse_uri"),
    AFW_UTF8_LITERAL("parseUri"),
    AFW_UTF8_LITERAL("afwParseUri"),
    AFW_UTF8_LITERAL("Parse URI"),
    AFW_UTF8_LITERAL("Parse a URI."),
    AFW_UTF8_LITERAL("(uri: string, isValuePath?: boolean, currentPath?: string): (object _AdaptiveParsedURI_)"),
    AFW_UTF8_LITERAL("/* Parse URI */\nfunction parse_uri (\n    uri: string,\n    isValuePath?: boolean,\n    currentPath?: string\n): (object _AdaptiveParsedURI_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_parse_uri,
    NULL,
    1,
    3,
    &impl_parse_uri_parameters[0],
    3,
    &impl_parse_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- perform ---------- */

static const afw_utf8_t
impl_object_path__perform =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/perform");

static const afw_runtime_object_indirect_t
impl_object__perform = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_perform,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__perform
        }
    },
    (void *)&afw_function_definition_perform
};

static const afw_value_function_parameter_t
impl_perform_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveResponse_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Response object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_perform_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveActions_"),
    AFW_UTF8_LITERAL("request"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("See /afw/_AdaptiveObjectType_/_AdaptiveActions_ for more information."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_perform_parameters[] = {
    &impl_perform_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_perform = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__perform,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("perform"),
    AFW_UTF8_LITERAL("perform"),
    AFW_UTF8_LITERAL("perform"),
    AFW_UTF8_LITERAL("perform"),
    AFW_UTF8_LITERAL("afwPerform"),
    AFW_UTF8_LITERAL("Perform actions"),
    AFW_UTF8_LITERAL("Perform actions right away."),
    AFW_UTF8_LITERAL("(request: (object _AdaptiveActions_)): (object _AdaptiveResponse_)"),
    AFW_UTF8_LITERAL("/* Perform actions */\nfunction perform (\n    request: (object _AdaptiveActions_)\n): (object _AdaptiveResponse_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_perform,
    NULL,
    1,
    1,
    &impl_perform_parameters[0],
    1,
    &impl_perform_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- trace ---------- */

static const afw_utf8_t
impl_object_path__trace =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/trace");

static const afw_runtime_object_indirect_t
impl_object__trace = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_trace,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__trace
        }
    },
    (void *)&afw_function_definition_trace
};

static const afw_value_function_parameter_t
impl_trace_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_trace_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the value that will be converted to its string representation and written the trace log. An undefined value is represented by '<undefined>'."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_trace_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("filter"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If this optional filter is false, nothing will be written to the trace log. The default is true."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_trace_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("number"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an optional number between 1 and 8 that is appended to \"trace\" to identify the trace log. The default is 1."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_trace_parameters[] = {
    &impl_trace_parameter_1,
    &impl_trace_parameter_2,
    &impl_trace_parameter_3,
    NULL
};

static const afw_utf8_t
impl_trace_sideEffects[] = {
    AFW_UTF8_LITERAL("Value written to log"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_trace = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__trace,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("trace"),
    AFW_UTF8_LITERAL("trace"),
    AFW_UTF8_LITERAL("trace"),
    AFW_UTF8_LITERAL("trace"),
    AFW_UTF8_LITERAL("afwTrace"),
    AFW_UTF8_LITERAL("Write a value to the a trace log"),
    AFW_UTF8_LITERAL("Write a value to a trace log."),
    AFW_UTF8_LITERAL("(value: any, filter?: boolean, number?: integer): null"),
    AFW_UTF8_LITERAL("/* Write a value to the a trace log */\nfunction trace (\n    value: any,\n    filter?: boolean,\n    number?: integer\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_trace,
    NULL,
    1,
    3,
    &impl_trace_parameters[0],
    3,
    &impl_trace_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_trace_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- variable_exists ---------- */

static const afw_utf8_t
impl_object_path__variable_exists =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/variable_exists");

static const afw_runtime_object_indirect_t
impl_object__variable_exists = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_variable_exists,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__variable_exists
        }
    },
    (void *)&afw_function_definition_variable_exists
};

static const afw_value_function_parameter_t
impl_variable_exists_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if variable exists."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_variable_exists_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Name of variable to check. The name can optionally be preceded with a qualifier followed by \"::\"."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_variable_exists_parameters[] = {
    &impl_variable_exists_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_variable_exists = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__variable_exists,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("variable_exists"),
    AFW_UTF8_LITERAL("variable_exists"),
    AFW_UTF8_LITERAL("variable_exists"),
    AFW_UTF8_LITERAL("variableExists"),
    AFW_UTF8_LITERAL("afwVariableExists"),
    AFW_UTF8_LITERAL("Determine if a variable exists"),
    AFW_UTF8_LITERAL("Return the true if the named variable exists."),
    AFW_UTF8_LITERAL("(name: string): boolean"),
    AFW_UTF8_LITERAL("/* Determine if a variable exists */\nfunction variable_exists (\n    name: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_variable_exists,
    NULL,
    1,
    1,
    &impl_variable_exists_parameters[0],
    1,
    &impl_variable_exists_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- variable_get ---------- */

static const afw_utf8_t
impl_object_path__variable_get =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/variable_get");

static const afw_runtime_object_indirect_t
impl_object__variable_get = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_variable_get,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__variable_get
        }
    },
    (void *)&afw_function_definition_variable_get
};

static const afw_value_function_parameter_t
impl_variable_get_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Evaluated variable value or default."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_variable_get_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Name of variable to get. The name can optionally be preceded with a qualifier followed by \"::\"."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_variable_get_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("defaultValue"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The default value of variable if it does not exist in object. If not specified, null value is the default."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_variable_get_parameters[] = {
    &impl_variable_get_parameter_1,
    &impl_variable_get_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_variable_get = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__variable_get,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("variable_get"),
    AFW_UTF8_LITERAL("variable_get"),
    AFW_UTF8_LITERAL("variable_get"),
    AFW_UTF8_LITERAL("variableGet"),
    AFW_UTF8_LITERAL("afwVariableGet"),
    AFW_UTF8_LITERAL("Get a variable value"),
    AFW_UTF8_LITERAL("Return the value of a variable. If variable is not available, return a default or null value."),
    AFW_UTF8_LITERAL("(name: string, defaultValue?: any): any"),
    AFW_UTF8_LITERAL("/* Get a variable value */\nfunction variable_get (\n    name: string,\n    defaultValue?: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_variable_get,
    NULL,
    1,
    2,
    &impl_variable_get_parameters[0],
    2,
    &impl_variable_get_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- variable_is_not_null ---------- */

static const afw_utf8_t
impl_object_path__variable_is_not_null =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/variable_is_not_null");

static const afw_runtime_object_indirect_t
impl_object__variable_is_not_null = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_variable_is_not_null,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__variable_is_not_null
        }
    },
    (void *)&afw_function_definition_variable_is_not_null
};

static const afw_value_function_parameter_t
impl_variable_is_not_null_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if variable exists and is not null."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_variable_is_not_null_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Name of variable to check. The name can optionally be preceded with a qualifier followed by \"::\"."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_variable_is_not_null_parameters[] = {
    &impl_variable_is_not_null_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_variable_is_not_null = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__variable_is_not_null,
    AFW_UTF8_LITERAL("miscellaneous"),
    AFW_UTF8_LITERAL("variable_is_not_null"),
    AFW_UTF8_LITERAL("variable_is_not_null"),
    AFW_UTF8_LITERAL("variable_is_not_null"),
    AFW_UTF8_LITERAL("variableIsNotNull"),
    AFW_UTF8_LITERAL("afwVariableIsNotNull"),
    AFW_UTF8_LITERAL("Determine if a variable exists and is not null"),
    AFW_UTF8_LITERAL("Return the true if the named variable exists and is not null."),
    AFW_UTF8_LITERAL("(name: string): boolean"),
    AFW_UTF8_LITERAL("/* Determine if a variable exists and is not null */\nfunction variable_is_not_null (\n    name: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_variable_is_not_null,
    NULL,
    1,
    1,
    &impl_variable_is_not_null_parameters[0],
    1,
    &impl_variable_is_not_null_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- model_default_add_object_action ---------- */

static const afw_utf8_t
impl_object_path__model_default_add_object_action =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/model_default_add_object_action");

static const afw_runtime_object_indirect_t
impl_object__model_default_add_object_action = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_model_default_add_object_action,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__model_default_add_object_action
        }
    },
    (void *)&afw_function_definition_model_default_add_object_action
};

static const afw_value_function_parameter_t
impl_model_default_add_object_action_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveAction_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The default action object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_add_object_action_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptorId of a model adaptor. Variable custom::adaptorId can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_add_object_action_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptive object type of object being added. Variable custom::objectType can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_add_object_action_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the object to add. Variable custom::object can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_add_object_action_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the optional preferred objectId of object to add. The adaptor may ignore this. Variable custom::objectId can be used to access this value in model expressions."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_add_object_action_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("modelId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifics a modelId of model to use for producing results. If not specified, the adaptor's current model will be used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_add_object_action_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveContextType_"),
    AFW_UTF8_LITERAL("context"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifies additional context information available to model expressions."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_model_default_add_object_action_parameters[] = {
    &impl_model_default_add_object_action_parameter_1,
    &impl_model_default_add_object_action_parameter_2,
    &impl_model_default_add_object_action_parameter_3,
    &impl_model_default_add_object_action_parameter_4,
    &impl_model_default_add_object_action_parameter_5,
    &impl_model_default_add_object_action_parameter_6,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_add_object_action = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__model_default_add_object_action,
    AFW_UTF8_LITERAL("model"),
    AFW_UTF8_LITERAL("model_default_add_object_action"),
    AFW_UTF8_LITERAL("model_default_add_object_action"),
    AFW_UTF8_LITERAL("model_default_add_object_action"),
    AFW_UTF8_LITERAL("modelDefaultAddObjectAction"),
    AFW_UTF8_LITERAL("afwModelDefaultAddObjectAction"),
    AFW_UTF8_LITERAL("Produce a default _AdaptiveAction_ object for an add object request to a model adaptor."),
    AFW_UTF8_LITERAL("This function returns a _AdaptiveAction_ object for the default action performed if a onAdd parameter is not specified on the associated _AdaptiveModelObjectType_. The action is not performed, but be aware that functions called while producing the _AdaptiveAction_ object may cause side effects. This function can be called as part of a onAdd expression or for testing."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, object: object, objectId?: string, modelId?: string, context?: (object _AdaptiveContextType_)): (object _AdaptiveAction_)"),
    AFW_UTF8_LITERAL("/* Produce a default _AdaptiveAction_ object for an add object request to a model adaptor. */\nfunction model_default_add_object_action (\n    adaptorId: string,\n    objectType: string,\n    object: object,\n    objectId?: string,\n    modelId?: string,\n    context?: (object _AdaptiveContextType_)\n): (object _AdaptiveAction_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_model_default_add_object_action,
    NULL,
    3,
    6,
    &impl_model_default_add_object_action_parameters[0],
    6,
    &impl_model_default_add_object_action_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- model_default_delete_object_action ---------- */

static const afw_utf8_t
impl_object_path__model_default_delete_object_action =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/model_default_delete_object_action");

static const afw_runtime_object_indirect_t
impl_object__model_default_delete_object_action = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_model_default_delete_object_action,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__model_default_delete_object_action
        }
    },
    (void *)&afw_function_definition_model_default_delete_object_action
};

static const afw_value_function_parameter_t
impl_model_default_delete_object_action_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveAction_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The default action object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_delete_object_action_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptorId of a model adaptor. Variable custom::adaptorId can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_delete_object_action_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptive object type of object being deleted. Variable custom::objectType can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_delete_object_action_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the objectId of object to delete. Variable custom::object can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_delete_object_action_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("modelId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifics a modelId of model to use for producing results. If not specified, the adaptor's current model will be used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_delete_object_action_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveContextType_"),
    AFW_UTF8_LITERAL("context"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifies additional context information available to model expressions."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_model_default_delete_object_action_parameters[] = {
    &impl_model_default_delete_object_action_parameter_1,
    &impl_model_default_delete_object_action_parameter_2,
    &impl_model_default_delete_object_action_parameter_3,
    &impl_model_default_delete_object_action_parameter_4,
    &impl_model_default_delete_object_action_parameter_5,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_delete_object_action = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__model_default_delete_object_action,
    AFW_UTF8_LITERAL("model"),
    AFW_UTF8_LITERAL("model_default_delete_object_action"),
    AFW_UTF8_LITERAL("model_default_delete_object_action"),
    AFW_UTF8_LITERAL("model_default_delete_object_action"),
    AFW_UTF8_LITERAL("modelDefaultDeleteObjectAction"),
    AFW_UTF8_LITERAL("afwModelDefaultDeleteObjectAction"),
    AFW_UTF8_LITERAL("Produce a default _AdaptiveAction_ object for an delete object request to a model adaptor."),
    AFW_UTF8_LITERAL("This function returns a _AdaptiveAction_ object for the default action performed if a onDeleteObject parameter is not specified on the associated _AdaptiveModelObjectType_. The action is not performed, but be aware that functions called while producing the _AdaptiveAction_ object may cause side effects. This function can be called as part of a onDelete expression or for testing."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, modelId?: string, context?: (object _AdaptiveContextType_)): (object _AdaptiveAction_)"),
    AFW_UTF8_LITERAL("/* Produce a default _AdaptiveAction_ object for an delete object request to a model adaptor. */\nfunction model_default_delete_object_action (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    modelId?: string,\n    context?: (object _AdaptiveContextType_)\n): (object _AdaptiveAction_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_model_default_delete_object_action,
    NULL,
    3,
    5,
    &impl_model_default_delete_object_action_parameters[0],
    5,
    &impl_model_default_delete_object_action_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- model_default_modify_object_action ---------- */

static const afw_utf8_t
impl_object_path__model_default_modify_object_action =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/model_default_modify_object_action");

static const afw_runtime_object_indirect_t
impl_object__model_default_modify_object_action = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_model_default_modify_object_action,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__model_default_modify_object_action
        }
    },
    (void *)&afw_function_definition_model_default_modify_object_action
};

static const afw_value_function_parameter_t
impl_model_default_modify_object_action_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveAction_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The default action object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_modify_object_action_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptorId of a model adaptor. Variable custom::adaptorId can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_modify_object_action_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptive object type of object being modified. Variable custom::objectType can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_modify_object_action_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the objectId of object to modify. Variable custom::objectId can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_modify_object_action_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("entries"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of modifications. Variable custom::actions can be used to access this value in model expressions. Entries are of the form:\n\n    [\n        \"add_value\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]\n\n    [\n        \"remove_property\",\n        \"property name\" or [\"property name\", ... ]\n    ]\n\n    [\n        \"remove_value\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]\n\n    [\n        \"set_property\",\n        \"property name\" or [\"property name\", ... ],\n        value\n    ]"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_modify_object_action_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("modelId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifics a modelId of model to use for producing results. If not specified, the adaptor's current model will be used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_modify_object_action_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveContextType_"),
    AFW_UTF8_LITERAL("context"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifies additional context information available to model expressions."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_model_default_modify_object_action_parameters[] = {
    &impl_model_default_modify_object_action_parameter_1,
    &impl_model_default_modify_object_action_parameter_2,
    &impl_model_default_modify_object_action_parameter_3,
    &impl_model_default_modify_object_action_parameter_4,
    &impl_model_default_modify_object_action_parameter_5,
    &impl_model_default_modify_object_action_parameter_6,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_modify_object_action = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__model_default_modify_object_action,
    AFW_UTF8_LITERAL("model"),
    AFW_UTF8_LITERAL("model_default_modify_object_action"),
    AFW_UTF8_LITERAL("model_default_modify_object_action"),
    AFW_UTF8_LITERAL("model_default_modify_object_action"),
    AFW_UTF8_LITERAL("modelDefaultModifyObjectAction"),
    AFW_UTF8_LITERAL("afwModelDefaultModifyObjectAction"),
    AFW_UTF8_LITERAL("Produce a default _AdaptiveAction_ object for an modify object request to a model adaptor."),
    AFW_UTF8_LITERAL("This function returns a _AdaptiveAction_ object for the default action performed if a onModifyObject parameter is not specified on the associated _AdaptiveModelObjectType_. The action is not performed, but be aware that functions called while producing the _AdaptiveAction_ object may cause side effects. This function can be called as part of a onModify expression or for testing."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, entries: list, modelId?: string, context?: (object _AdaptiveContextType_)): (object _AdaptiveAction_)"),
    AFW_UTF8_LITERAL("/* Produce a default _AdaptiveAction_ object for an modify object request to a model adaptor. */\nfunction model_default_modify_object_action (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    entries: list,\n    modelId?: string,\n    context?: (object _AdaptiveContextType_)\n): (object _AdaptiveAction_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_model_default_modify_object_action,
    NULL,
    4,
    6,
    &impl_model_default_modify_object_action_parameters[0],
    6,
    &impl_model_default_modify_object_action_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- model_default_replace_object_action ---------- */

static const afw_utf8_t
impl_object_path__model_default_replace_object_action =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/model_default_replace_object_action");

static const afw_runtime_object_indirect_t
impl_object__model_default_replace_object_action = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_model_default_replace_object_action,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__model_default_replace_object_action
        }
    },
    (void *)&afw_function_definition_model_default_replace_object_action
};

static const afw_value_function_parameter_t
impl_model_default_replace_object_action_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveAction_"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The default action object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_replace_object_action_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptorId of a model adaptor. Variable custom::adaptorId can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_replace_object_action_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptive object type of object being replaced. Variable custom::objectType can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_replace_object_action_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The objectId of object to replace. Variable custom::objectId can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_replace_object_action_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the object to replace. Variable custom::object can be used to access this value in model expressions."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_replace_object_action_parameter_5 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("modelId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifics a modelId of model to use for producing results. If not specified, the adaptor's current model will be used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_default_replace_object_action_parameter_6 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveContextType_"),
    AFW_UTF8_LITERAL("context"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This specifies additional context information available to model expressions."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_model_default_replace_object_action_parameters[] = {
    &impl_model_default_replace_object_action_parameter_1,
    &impl_model_default_replace_object_action_parameter_2,
    &impl_model_default_replace_object_action_parameter_3,
    &impl_model_default_replace_object_action_parameter_4,
    &impl_model_default_replace_object_action_parameter_5,
    &impl_model_default_replace_object_action_parameter_6,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_replace_object_action = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__model_default_replace_object_action,
    AFW_UTF8_LITERAL("model"),
    AFW_UTF8_LITERAL("model_default_replace_object_action"),
    AFW_UTF8_LITERAL("model_default_replace_object_action"),
    AFW_UTF8_LITERAL("model_default_replace_object_action"),
    AFW_UTF8_LITERAL("modelDefaultReplaceObjectAction"),
    AFW_UTF8_LITERAL("afwModelDefaultReplaceObjectAction"),
    AFW_UTF8_LITERAL("Produce a default _AdaptiveAction_ object for an replace object request to a model adaptor."),
    AFW_UTF8_LITERAL("This function returns a _AdaptiveAction_ object for the default action performed if a onReplaceObject parameter is not specified on the associated _AdaptiveModelObjectType_. The action is not performed, but be aware that functions called while producing the _AdaptiveAction_ object may cause side effects. This function can be called as part of a onReplace expression or for testing."),
    AFW_UTF8_LITERAL("(adaptorId: string, objectType: string, objectId: string, object: object, modelId?: string, context?: (object _AdaptiveContextType_)): (object _AdaptiveAction_)"),
    AFW_UTF8_LITERAL("/* Produce a default _AdaptiveAction_ object for an replace object request to a model adaptor. */\nfunction model_default_replace_object_action (\n    adaptorId: string,\n    objectType: string,\n    objectId: string,\n    object: object,\n    modelId?: string,\n    context?: (object _AdaptiveContextType_)\n): (object _AdaptiveAction_);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_model_default_replace_object_action,
    NULL,
    4,
    6,
    &impl_model_default_replace_object_action_parameters[0],
    6,
    &impl_model_default_replace_object_action_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- model_mapBackObject_signature ---------- */

static const afw_utf8_t
impl_object_path__model_mapBackObject_signature =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/model_mapBackObject_signature");

static const afw_runtime_object_indirect_t
impl_object__model_mapBackObject_signature = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_model_mapBackObject_signature,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__model_mapBackObject_signature
        }
    },
    (void *)&afw_function_definition_model_mapBackObject_signature
};

static const afw_value_function_parameter_t
impl_model_mapBackObject_signature_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The mapped back object"),
    AFW_UTF8_LITERAL("This is the mappedObject mapped back from mapped adaptor object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_mapBackObject_signature_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("mappedObject"),
    AFW_UTF8_LITERAL("The object to map back"),
    AFW_UTF8_LITERAL("This is the object to map back."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_model_mapBackObject_signature_parameters[] = {
    &impl_model_mapBackObject_signature_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_mapBackObject_signature = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__model_mapBackObject_signature,
    AFW_UTF8_LITERAL("model"),
    AFW_UTF8_LITERAL("model_mapBackObject_signature"),
    AFW_UTF8_LITERAL("model_mapBackObject_signature"),
    AFW_UTF8_LITERAL("model_mapBackObject_signature"),
    AFW_UTF8_LITERAL("modelMapBackObjectSignature"),
    AFW_UTF8_LITERAL("afwModelMapBackObjectSignature"),
    AFW_UTF8_LITERAL("Signature used for current:mapBackObject()"),
    AFW_UTF8_LITERAL("This is the function signature for current:mapBackObject used by onGetObjects and onRetrieveObjects. Calling this directly will throw a \"Do not call directly\" error."),
    AFW_UTF8_LITERAL("(mappedObject: object): object"),
    AFW_UTF8_LITERAL("/* Signature used for current:mapBackObject() */\nfunction model_mapBackObject_signature (\n    mappedObject: object /* The object to map back */\n): object; /* The mapped back object */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_model_mapBackObject_signature,
    NULL,
    1,
    1,
    &impl_model_mapBackObject_signature_parameters[0],
    1,
    &impl_model_mapBackObject_signature_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    true
};

/* ---------- model_mapObject_signature ---------- */

static const afw_utf8_t
impl_object_path__model_mapObject_signature =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/model_mapObject_signature");

static const afw_runtime_object_indirect_t
impl_object__model_mapObject_signature = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_model_mapObject_signature,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__model_mapObject_signature
        }
    },
    (void *)&afw_function_definition_model_mapObject_signature
};

static const afw_value_function_parameter_t
impl_model_mapObject_signature_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The mapped object"),
    AFW_UTF8_LITERAL("This is the object mapped to mappedAdaptor object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_mapObject_signature_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("The object to map"),
    AFW_UTF8_LITERAL("This is the object to map."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_model_mapObject_signature_parameters[] = {
    &impl_model_mapObject_signature_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_mapObject_signature = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__model_mapObject_signature,
    AFW_UTF8_LITERAL("model"),
    AFW_UTF8_LITERAL("model_mapObject_signature"),
    AFW_UTF8_LITERAL("model_mapObject_signature"),
    AFW_UTF8_LITERAL("model_mapObject_signature"),
    AFW_UTF8_LITERAL("modelMapObjectSignature"),
    AFW_UTF8_LITERAL("afwModelMapObjectSignature"),
    AFW_UTF8_LITERAL("Signature used for current:mapObject()"),
    AFW_UTF8_LITERAL("This is the function signature for current:mapObject used by onAddObject. onDeleteObject, onModifyObject, and onReplaceObject. Calling this directly will throw a \"Do not call directly\" error."),
    AFW_UTF8_LITERAL("(object: object): object"),
    AFW_UTF8_LITERAL("/* Signature used for current:mapObject() */\nfunction model_mapObject_signature (\n    object: object /* The object to map */\n): object; /* The mapped object */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_model_mapObject_signature,
    NULL,
    1,
    1,
    &impl_model_mapObject_signature_parameters[0],
    1,
    &impl_model_mapObject_signature_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    true
};

/* ---------- model_returnObject_signature ---------- */

static const afw_utf8_t
impl_object_path__model_returnObject_signature =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/model_returnObject_signature");

static const afw_runtime_object_indirect_t
impl_object__model_returnObject_signature = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_model_returnObject_signature,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__model_returnObject_signature
        }
    },
    (void *)&afw_function_definition_model_returnObject_signature
};

static const afw_value_function_parameter_t
impl_model_returnObject_signature_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("true if no more objects can be returned"),
    AFW_UTF8_LITERAL("This will return true if no more objects can be returned for any reason including a limit exceeded, connection closed, or server stopping."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_returnObject_signature_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("The object to return"),
    AFW_UTF8_LITERAL("This is the object to return."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_model_returnObject_signature_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("userData"),
    AFW_UTF8_LITERAL("User data"),
    AFW_UTF8_LITERAL("If this is present and true, the object will be mapped its mapped adaptor's object type to the model adaptor's object type."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_model_returnObject_signature_parameters[] = {
    &impl_model_returnObject_signature_parameter_1,
    &impl_model_returnObject_signature_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_returnObject_signature = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__model_returnObject_signature,
    AFW_UTF8_LITERAL("model"),
    AFW_UTF8_LITERAL("model_returnObject_signature"),
    AFW_UTF8_LITERAL("model_returnObject_signature"),
    AFW_UTF8_LITERAL("model_returnObject_signature"),
    AFW_UTF8_LITERAL("modelReturnObjectSignature"),
    AFW_UTF8_LITERAL("afwModelReturnObjectSignature"),
    AFW_UTF8_LITERAL("Signature used for current:returnObject()"),
    AFW_UTF8_LITERAL("This is the function signature for current:returnObject used by onGetObjects and onRetrieveObjects. Calling this directly will throw a \"Do not call directly\" error."),
    AFW_UTF8_LITERAL("(object: object, userData?: boolean): boolean"),
    AFW_UTF8_LITERAL("/* Signature used for current:returnObject() */\nfunction model_returnObject_signature (\n    object: object     /* The object to return */,\n    userData?: boolean /* User data */\n): boolean; /* true if no more objects can be returned */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_model_returnObject_signature,
    NULL,
    1,
    2,
    &impl_model_returnObject_signature_parameters[0],
    2,
    &impl_model_returnObject_signature_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    true
};

/* ---------- bag<null> ---------- */

static const afw_utf8_t
impl_object_path__bag_null =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_null");

static const afw_runtime_object_indirect_t
impl_object__bag_null = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_null,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_null
        }
    },
    (void *)&afw_function_definition_bag_null
};

static const afw_value_function_parameter_t
impl_bag_null_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_null_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_null_parameters[] = {
    &impl_bag_null_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_null = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_null,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("bag<null>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_null"),
    AFW_UTF8_LITERAL("bagNull"),
    AFW_UTF8_LITERAL("afwBagNull"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of null values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list null))): (list null)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<null> (\n    ...values: (list of (list null))\n): (list null);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_null_parameters[0],
    1,
    &impl_bag_null_returns,
    NULL,
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<null> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_null =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_null");

static const afw_runtime_object_indirect_t
impl_object__bag_size_null = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_null,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_null
        }
    },
    (void *)&afw_function_definition_bag_size_null
};

static const afw_value_function_parameter_t
impl_bag_size_null_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_null_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_null_parameters[] = {
    &impl_bag_size_null_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_null = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_null,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("bag_size<null>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_null"),
    AFW_UTF8_LITERAL("bagSizeNull"),
    AFW_UTF8_LITERAL("afwBagSizeNull"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list null)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<null> (\n    value: (list null)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_null_parameters[0],
    1,
    &impl_bag_size_null_returns,
    NULL,
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<null> ---------- */

static const afw_utf8_t
impl_object_path__is_null =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_null");

static const afw_runtime_object_indirect_t
impl_object__is_null = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_null,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_null
        }
    },
    (void *)&afw_function_definition_is_null
};

static const afw_value_function_parameter_t
impl_is_null_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_null_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_null_parameters[] = {
    &impl_is_null_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_null = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_null,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("is<null>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_null"),
    AFW_UTF8_LITERAL("isNull"),
    AFW_UTF8_LITERAL("afwIsNull"),
    AFW_UTF8_LITERAL("Checks whether value is dataType null"),
    AFW_UTF8_LITERAL("Checks whether value is dataType null and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType null */\nfunction is<null> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_null_parameters[0],
    1,
    &impl_is_null_returns,
    NULL,
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- null ---------- */

static const afw_utf8_t
impl_object_path__null =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/null");

static const afw_runtime_object_indirect_t
impl_object__null = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_null,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__null
        }
    },
    (void *)&afw_function_definition_null
};

static const afw_value_function_parameter_t
impl_null_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_null_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_null_parameters[] = {
    &impl_null_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_null_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_null = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__null,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("afwNull"),
    AFW_UTF8_LITERAL("Convert to data type null"),
    AFW_UTF8_LITERAL("Converts value to data type null returning null result."),
    AFW_UTF8_LITERAL("(value: any): null"),
    AFW_UTF8_LITERAL("/* Convert to data type null */\nfunction null (\n    value: any\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_null_parameters[0],
    1,
    &impl_null_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_null_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<null> ---------- */

static const afw_utf8_t
impl_object_path__to_string_null =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_null");

static const afw_runtime_object_indirect_t
impl_object__to_string_null = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_null,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_null
        }
    },
    (void *)&afw_function_definition_to_string_null
};

static const afw_value_function_parameter_t
impl_to_string_null_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_null_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A null value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_null_parameters[] = {
    &impl_to_string_null_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_null = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_null,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("to_string<null>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_null"),
    AFW_UTF8_LITERAL("toStringNull"),
    AFW_UTF8_LITERAL("afwToStringNull"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts null value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: null): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<null> (\n    value: null\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_null_parameters[0],
    1,
    &impl_to_string_null_returns,
    NULL,
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<objectId> ---------- */

static const afw_utf8_t
impl_object_path__bag_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_objectId");

static const afw_runtime_object_indirect_t
impl_object__bag_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_objectId
        }
    },
    (void *)&afw_function_definition_bag_objectId
};

static const afw_value_function_parameter_t
impl_bag_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_objectId_parameters[] = {
    &impl_bag_objectId_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("bag<objectId>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_objectId"),
    AFW_UTF8_LITERAL("bagObjectId"),
    AFW_UTF8_LITERAL("afwBagObjectId"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of objectId values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list objectId))): (list objectId)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<objectId> (\n    ...values: (list of (list objectId))\n): (list objectId);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_objectId_parameters[0],
    1,
    &impl_bag_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<objectId> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_objectId");

static const afw_runtime_object_indirect_t
impl_object__bag_size_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_objectId
        }
    },
    (void *)&afw_function_definition_bag_size_objectId
};

static const afw_value_function_parameter_t
impl_bag_size_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_objectId_parameters[] = {
    &impl_bag_size_objectId_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("bag_size<objectId>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_objectId"),
    AFW_UTF8_LITERAL("bagSizeObjectId"),
    AFW_UTF8_LITERAL("afwBagSizeObjectId"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list objectId)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<objectId> (\n    value: (list objectId)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_objectId_parameters[0],
    1,
    &impl_bag_size_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<objectId> ---------- */

static const afw_utf8_t
impl_object_path__eq_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_objectId");

static const afw_runtime_object_indirect_t
impl_object__eq_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_objectId
        }
    },
    (void *)&afw_function_definition_eq_objectId
};

static const afw_value_function_parameter_t
impl_eq_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_objectId_parameters[] = {
    &impl_eq_objectId_parameter_1,
    &impl_eq_objectId_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_objectId_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("eq<objectId>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_objectId"),
    AFW_UTF8_LITERAL("eqObjectId"),
    AFW_UTF8_LITERAL("afwEqObjectId"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if objectId arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<objectId> (\n    arg1: objectId,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_objectId_parameters[0],
    2,
    &impl_eq_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    &impl_eq_objectId_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<objectId> ---------- */

static const afw_utf8_t
impl_object_path__eqx_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_objectId");

static const afw_runtime_object_indirect_t
impl_object__eqx_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_objectId
        }
    },
    (void *)&afw_function_definition_eqx_objectId
};

static const afw_value_function_parameter_t
impl_eqx_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_objectId_parameters[] = {
    &impl_eqx_objectId_parameter_1,
    &impl_eqx_objectId_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("eqx<objectId>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_objectId"),
    AFW_UTF8_LITERAL("eqxObjectId"),
    AFW_UTF8_LITERAL("afwEqxObjectId"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for objectId arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<objectId> (\n    arg1: objectId,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_objectId_parameters[0],
    2,
    &impl_eqx_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<objectId> ---------- */

static const afw_utf8_t
impl_object_path__ge_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_objectId");

static const afw_runtime_object_indirect_t
impl_object__ge_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_objectId
        }
    },
    (void *)&afw_function_definition_ge_objectId
};

static const afw_value_function_parameter_t
impl_ge_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_objectId_parameters[] = {
    &impl_ge_objectId_parameter_1,
    &impl_ge_objectId_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("ge<objectId>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_objectId"),
    AFW_UTF8_LITERAL("geObjectId"),
    AFW_UTF8_LITERAL("afwGeObjectId"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for objectId arg1 is greater than or equal to objectId arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: objectId): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<objectId> (\n    arg1: objectId,\n    arg2: objectId\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_objectId_parameters[0],
    2,
    &impl_ge_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<objectId> ---------- */

static const afw_utf8_t
impl_object_path__gt_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_objectId");

static const afw_runtime_object_indirect_t
impl_object__gt_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_objectId
        }
    },
    (void *)&afw_function_definition_gt_objectId
};

static const afw_value_function_parameter_t
impl_gt_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_objectId_parameters[] = {
    &impl_gt_objectId_parameter_1,
    &impl_gt_objectId_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("gt<objectId>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_objectId"),
    AFW_UTF8_LITERAL("gtObjectId"),
    AFW_UTF8_LITERAL("afwGtObjectId"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for objectId arg1 is greater than objectId arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: objectId): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<objectId> (\n    arg1: objectId,\n    arg2: objectId\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_objectId_parameters[0],
    2,
    &impl_gt_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<objectId> ---------- */

static const afw_utf8_t
impl_object_path__is_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_objectId");

static const afw_runtime_object_indirect_t
impl_object__is_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_objectId
        }
    },
    (void *)&afw_function_definition_is_objectId
};

static const afw_value_function_parameter_t
impl_is_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_objectId_parameters[] = {
    &impl_is_objectId_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("is<objectId>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_objectId"),
    AFW_UTF8_LITERAL("isObjectId"),
    AFW_UTF8_LITERAL("afwIsObjectId"),
    AFW_UTF8_LITERAL("Checks whether value is dataType objectId"),
    AFW_UTF8_LITERAL("Checks whether value is dataType objectId and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType objectId */\nfunction is<objectId> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_objectId_parameters[0],
    1,
    &impl_is_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<objectId> ---------- */

static const afw_utf8_t
impl_object_path__le_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_objectId");

static const afw_runtime_object_indirect_t
impl_object__le_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_objectId
        }
    },
    (void *)&afw_function_definition_le_objectId
};

static const afw_value_function_parameter_t
impl_le_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_objectId_parameters[] = {
    &impl_le_objectId_parameter_1,
    &impl_le_objectId_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("le<objectId>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_objectId"),
    AFW_UTF8_LITERAL("leObjectId"),
    AFW_UTF8_LITERAL("afwLeObjectId"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for objectId arg1 is less than or equal to objectId arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<objectId> (\n    arg1: objectId,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_objectId_parameters[0],
    2,
    &impl_le_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<objectId> ---------- */

static const afw_utf8_t
impl_object_path__lt_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_objectId");

static const afw_runtime_object_indirect_t
impl_object__lt_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_objectId
        }
    },
    (void *)&afw_function_definition_lt_objectId
};

static const afw_value_function_parameter_t
impl_lt_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_objectId_parameters[] = {
    &impl_lt_objectId_parameter_1,
    &impl_lt_objectId_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("lt<objectId>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_objectId"),
    AFW_UTF8_LITERAL("ltObjectId"),
    AFW_UTF8_LITERAL("afwLtObjectId"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for objectId arg1 is less that objectId arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: objectId): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<objectId> (\n    arg1: objectId,\n    arg2: objectId\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_objectId_parameters[0],
    2,
    &impl_lt_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<objectId> ---------- */

static const afw_utf8_t
impl_object_path__ne_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_objectId");

static const afw_runtime_object_indirect_t
impl_object__ne_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_objectId
        }
    },
    (void *)&afw_function_definition_ne_objectId
};

static const afw_value_function_parameter_t
impl_ne_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_objectId_parameters[] = {
    &impl_ne_objectId_parameter_1,
    &impl_ne_objectId_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_objectId_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("ne<objectId>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_objectId"),
    AFW_UTF8_LITERAL("neObjectId"),
    AFW_UTF8_LITERAL("afwNeObjectId"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if objectId arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<objectId> (\n    arg1: objectId,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_objectId_parameters[0],
    2,
    &impl_ne_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    &impl_ne_objectId_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<objectId> ---------- */

static const afw_utf8_t
impl_object_path__nex_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_objectId");

static const afw_runtime_object_indirect_t
impl_object__nex_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_objectId
        }
    },
    (void *)&afw_function_definition_nex_objectId
};

static const afw_value_function_parameter_t
impl_nex_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_objectId_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_objectId_parameters[] = {
    &impl_nex_objectId_parameter_1,
    &impl_nex_objectId_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("nex<objectId>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_objectId"),
    AFW_UTF8_LITERAL("nexObjectId"),
    AFW_UTF8_LITERAL("afwNexObjectId"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for objectId arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: objectId, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<objectId> (\n    arg1: objectId,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_objectId_parameters[0],
    2,
    &impl_nex_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- objectId ---------- */

static const afw_utf8_t
impl_object_path__objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/objectId");

static const afw_runtime_object_indirect_t
impl_object__objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__objectId
        }
    },
    (void *)&afw_function_definition_objectId
};

static const afw_value_function_parameter_t
impl_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_objectId_parameters[] = {
    &impl_objectId_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_objectId_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("afwObjectId"),
    AFW_UTF8_LITERAL("Convert to data type objectId"),
    AFW_UTF8_LITERAL("Converts value to data type objectId returning objectId result."),
    AFW_UTF8_LITERAL("(value: any): objectId"),
    AFW_UTF8_LITERAL("/* Convert to data type objectId */\nfunction objectId (\n    value: any\n): objectId;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_objectId_parameters[0],
    1,
    &impl_objectId_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_objectId_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<objectId> ---------- */

static const afw_utf8_t
impl_object_path__to_string_objectId =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_objectId");

static const afw_runtime_object_indirect_t
impl_object__to_string_objectId = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_objectId,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_objectId
        }
    },
    (void *)&afw_function_definition_to_string_objectId
};

static const afw_value_function_parameter_t
impl_to_string_objectId_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_objectId_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A objectId value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_objectId_parameters[] = {
    &impl_to_string_objectId_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_objectId = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_objectId,
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("to_string<objectId>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_objectId"),
    AFW_UTF8_LITERAL("toStringObjectId"),
    AFW_UTF8_LITERAL("afwToStringObjectId"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts objectId value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: objectId): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<objectId> (\n    value: objectId\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_objectId_parameters[0],
    1,
    &impl_to_string_objectId_returns,
    NULL,
    &afw_data_type_objectId_direct,
    AFW_UTF8_LITERAL("objectId"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__bag_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_objectPath");

static const afw_runtime_object_indirect_t
impl_object__bag_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_objectPath
        }
    },
    (void *)&afw_function_definition_bag_objectPath
};

static const afw_value_function_parameter_t
impl_bag_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_objectPath_parameters[] = {
    &impl_bag_objectPath_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("bag<objectPath>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_objectPath"),
    AFW_UTF8_LITERAL("bagObjectPath"),
    AFW_UTF8_LITERAL("afwBagObjectPath"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of objectPath values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list objectPath))): (list objectPath)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<objectPath> (\n    ...values: (list of (list objectPath))\n): (list objectPath);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_objectPath_parameters[0],
    1,
    &impl_bag_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_objectPath");

static const afw_runtime_object_indirect_t
impl_object__bag_size_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_objectPath
        }
    },
    (void *)&afw_function_definition_bag_size_objectPath
};

static const afw_value_function_parameter_t
impl_bag_size_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_objectPath_parameters[] = {
    &impl_bag_size_objectPath_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("bag_size<objectPath>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_objectPath"),
    AFW_UTF8_LITERAL("bagSizeObjectPath"),
    AFW_UTF8_LITERAL("afwBagSizeObjectPath"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list objectPath)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<objectPath> (\n    value: (list objectPath)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_objectPath_parameters[0],
    1,
    &impl_bag_size_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__eq_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_objectPath");

static const afw_runtime_object_indirect_t
impl_object__eq_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_objectPath
        }
    },
    (void *)&afw_function_definition_eq_objectPath
};

static const afw_value_function_parameter_t
impl_eq_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_objectPath_parameters[] = {
    &impl_eq_objectPath_parameter_1,
    &impl_eq_objectPath_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_objectPath_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("eq<objectPath>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_objectPath"),
    AFW_UTF8_LITERAL("eqObjectPath"),
    AFW_UTF8_LITERAL("afwEqObjectPath"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if objectPath arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<objectPath> (\n    arg1: objectPath,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_objectPath_parameters[0],
    2,
    &impl_eq_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    &impl_eq_objectPath_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__eqx_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_objectPath");

static const afw_runtime_object_indirect_t
impl_object__eqx_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_objectPath
        }
    },
    (void *)&afw_function_definition_eqx_objectPath
};

static const afw_value_function_parameter_t
impl_eqx_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_objectPath_parameters[] = {
    &impl_eqx_objectPath_parameter_1,
    &impl_eqx_objectPath_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("eqx<objectPath>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_objectPath"),
    AFW_UTF8_LITERAL("eqxObjectPath"),
    AFW_UTF8_LITERAL("afwEqxObjectPath"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for objectPath arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<objectPath> (\n    arg1: objectPath,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_objectPath_parameters[0],
    2,
    &impl_eqx_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__ge_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_objectPath");

static const afw_runtime_object_indirect_t
impl_object__ge_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_objectPath
        }
    },
    (void *)&afw_function_definition_ge_objectPath
};

static const afw_value_function_parameter_t
impl_ge_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_objectPath_parameters[] = {
    &impl_ge_objectPath_parameter_1,
    &impl_ge_objectPath_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("ge<objectPath>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_objectPath"),
    AFW_UTF8_LITERAL("geObjectPath"),
    AFW_UTF8_LITERAL("afwGeObjectPath"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for objectPath arg1 is greater than or equal to objectPath arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: objectPath): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<objectPath> (\n    arg1: objectPath,\n    arg2: objectPath\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_objectPath_parameters[0],
    2,
    &impl_ge_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__gt_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_objectPath");

static const afw_runtime_object_indirect_t
impl_object__gt_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_objectPath
        }
    },
    (void *)&afw_function_definition_gt_objectPath
};

static const afw_value_function_parameter_t
impl_gt_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_objectPath_parameters[] = {
    &impl_gt_objectPath_parameter_1,
    &impl_gt_objectPath_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("gt<objectPath>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_objectPath"),
    AFW_UTF8_LITERAL("gtObjectPath"),
    AFW_UTF8_LITERAL("afwGtObjectPath"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for objectPath arg1 is greater than objectPath arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: objectPath): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<objectPath> (\n    arg1: objectPath,\n    arg2: objectPath\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_objectPath_parameters[0],
    2,
    &impl_gt_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__is_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_objectPath");

static const afw_runtime_object_indirect_t
impl_object__is_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_objectPath
        }
    },
    (void *)&afw_function_definition_is_objectPath
};

static const afw_value_function_parameter_t
impl_is_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_objectPath_parameters[] = {
    &impl_is_objectPath_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("is<objectPath>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_objectPath"),
    AFW_UTF8_LITERAL("isObjectPath"),
    AFW_UTF8_LITERAL("afwIsObjectPath"),
    AFW_UTF8_LITERAL("Checks whether value is dataType objectPath"),
    AFW_UTF8_LITERAL("Checks whether value is dataType objectPath and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType objectPath */\nfunction is<objectPath> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_objectPath_parameters[0],
    1,
    &impl_is_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__le_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_objectPath");

static const afw_runtime_object_indirect_t
impl_object__le_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_objectPath
        }
    },
    (void *)&afw_function_definition_le_objectPath
};

static const afw_value_function_parameter_t
impl_le_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_objectPath_parameters[] = {
    &impl_le_objectPath_parameter_1,
    &impl_le_objectPath_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("le<objectPath>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_objectPath"),
    AFW_UTF8_LITERAL("leObjectPath"),
    AFW_UTF8_LITERAL("afwLeObjectPath"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for objectPath arg1 is less than or equal to objectPath arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<objectPath> (\n    arg1: objectPath,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_objectPath_parameters[0],
    2,
    &impl_le_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__lt_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_objectPath");

static const afw_runtime_object_indirect_t
impl_object__lt_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_objectPath
        }
    },
    (void *)&afw_function_definition_lt_objectPath
};

static const afw_value_function_parameter_t
impl_lt_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_objectPath_parameters[] = {
    &impl_lt_objectPath_parameter_1,
    &impl_lt_objectPath_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("lt<objectPath>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_objectPath"),
    AFW_UTF8_LITERAL("ltObjectPath"),
    AFW_UTF8_LITERAL("afwLtObjectPath"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for objectPath arg1 is less that objectPath arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: objectPath): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<objectPath> (\n    arg1: objectPath,\n    arg2: objectPath\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_objectPath_parameters[0],
    2,
    &impl_lt_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__ne_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_objectPath");

static const afw_runtime_object_indirect_t
impl_object__ne_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_objectPath
        }
    },
    (void *)&afw_function_definition_ne_objectPath
};

static const afw_value_function_parameter_t
impl_ne_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_objectPath_parameters[] = {
    &impl_ne_objectPath_parameter_1,
    &impl_ne_objectPath_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_objectPath_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("ne<objectPath>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_objectPath"),
    AFW_UTF8_LITERAL("neObjectPath"),
    AFW_UTF8_LITERAL("afwNeObjectPath"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if objectPath arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<objectPath> (\n    arg1: objectPath,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_objectPath_parameters[0],
    2,
    &impl_ne_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    &impl_ne_objectPath_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__nex_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_objectPath");

static const afw_runtime_object_indirect_t
impl_object__nex_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_objectPath
        }
    },
    (void *)&afw_function_definition_nex_objectPath
};

static const afw_value_function_parameter_t
impl_nex_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_objectPath_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_objectPath_parameters[] = {
    &impl_nex_objectPath_parameter_1,
    &impl_nex_objectPath_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("nex<objectPath>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_objectPath"),
    AFW_UTF8_LITERAL("nexObjectPath"),
    AFW_UTF8_LITERAL("afwNexObjectPath"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for objectPath arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: objectPath, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<objectPath> (\n    arg1: objectPath,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_objectPath_parameters[0],
    2,
    &impl_nex_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- objectPath ---------- */

static const afw_utf8_t
impl_object_path__objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/objectPath");

static const afw_runtime_object_indirect_t
impl_object__objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__objectPath
        }
    },
    (void *)&afw_function_definition_objectPath
};

static const afw_value_function_parameter_t
impl_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_objectPath_parameters[] = {
    &impl_objectPath_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_objectPath_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("afwObjectPath"),
    AFW_UTF8_LITERAL("Convert to data type objectPath"),
    AFW_UTF8_LITERAL("Converts value to data type objectPath returning objectPath result."),
    AFW_UTF8_LITERAL("(value: any): objectPath"),
    AFW_UTF8_LITERAL("/* Convert to data type objectPath */\nfunction objectPath (\n    value: any\n): objectPath;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_objectPath_parameters[0],
    1,
    &impl_objectPath_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_objectPath_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<objectPath> ---------- */

static const afw_utf8_t
impl_object_path__to_string_objectPath =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_objectPath");

static const afw_runtime_object_indirect_t
impl_object__to_string_objectPath = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_objectPath,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_objectPath
        }
    },
    (void *)&afw_function_definition_to_string_objectPath
};

static const afw_value_function_parameter_t
impl_to_string_objectPath_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_objectPath_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A objectPath value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_objectPath_parameters[] = {
    &impl_to_string_objectPath_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_objectPath = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_objectPath,
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("to_string<objectPath>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_objectPath"),
    AFW_UTF8_LITERAL("toStringObjectPath"),
    AFW_UTF8_LITERAL("afwToStringObjectPath"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts objectPath value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: objectPath): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<objectPath> (\n    value: objectPath\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_objectPath_parameters[0],
    1,
    &impl_to_string_objectPath_returns,
    NULL,
    &afw_data_type_objectPath_direct,
    AFW_UTF8_LITERAL("objectPath"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- add_properties ---------- */

static const afw_utf8_t
impl_object_path__add_properties =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_properties");

static const afw_runtime_object_indirect_t
impl_object__add_properties = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_properties,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_properties
        }
    },
    (void *)&afw_function_definition_add_properties
};

static const afw_value_function_parameter_t
impl_add_properties_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The modified target object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_properties_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("target"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Target object. This object must not be immutable."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_properties_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Source object(s)."),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_properties_parameters[] = {
    &impl_add_properties_parameter_1,
    &impl_add_properties_parameter_2,
    NULL
};

static const afw_utf8_t
impl_add_properties_sideEffects[] = {
    AFW_UTF8_LITERAL("Target object is modified."),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_properties = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_properties,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("add_properties"),
    AFW_UTF8_LITERAL("add_properties"),
    AFW_UTF8_LITERAL("add_properties"),
    AFW_UTF8_LITERAL("addProperties"),
    AFW_UTF8_LITERAL("afwAddProperties"),
    AFW_UTF8_LITERAL("Add properties of one object to another"),
    AFW_UTF8_LITERAL("Add the properties of one object to another replacing existing properties by the same name."),
    AFW_UTF8_LITERAL("(target: object, source_1: object, ...source_rest: (list of object)): object"),
    AFW_UTF8_LITERAL("/* Add properties of one object to another */\nfunction add_properties (\n    target: object,\n    source_1: object,\n    ...source_rest: (list of object)\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_add_properties,
    NULL,
    2,
    -1,
    &impl_add_properties_parameters[0],
    2,
    &impl_add_properties_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_add_properties_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- apply_object_options ---------- */

static const afw_utf8_t
impl_object_path__apply_object_options =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/apply_object_options");

static const afw_runtime_object_indirect_t
impl_object__apply_object_options = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_apply_object_options,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__apply_object_options
        }
    },
    (void *)&afw_function_definition_apply_object_options
};

static const afw_value_function_parameter_t
impl_apply_object_options_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an object with object options applied."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_apply_object_options_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object used to produce result."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_apply_object_options_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveObjectOptions_"),
    AFW_UTF8_LITERAL("options"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_apply_object_options_parameters[] = {
    &impl_apply_object_options_parameter_1,
    &impl_apply_object_options_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_apply_object_options = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__apply_object_options,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("apply_object_options"),
    AFW_UTF8_LITERAL("apply_object_options"),
    AFW_UTF8_LITERAL("apply_object_options"),
    AFW_UTF8_LITERAL("applyObjectOptions"),
    AFW_UTF8_LITERAL("afwApplyObjectOptions"),
    AFW_UTF8_LITERAL("Apply object options"),
    AFW_UTF8_LITERAL("This will return an object with the specified object options applied."),
    AFW_UTF8_LITERAL("(object: object, options?: (object _AdaptiveObjectOptions_)): object"),
    AFW_UTF8_LITERAL("/* Apply object options */\nfunction apply_object_options (\n    object: object,\n    options?: (object _AdaptiveObjectOptions_)\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_apply_object_options,
    NULL,
    1,
    2,
    &impl_apply_object_options_parameters[0],
    2,
    &impl_apply_object_options_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- bag<object> ---------- */

static const afw_utf8_t
impl_object_path__bag_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_object");

static const afw_runtime_object_indirect_t
impl_object__bag_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_object
        }
    },
    (void *)&afw_function_definition_bag_object
};

static const afw_value_function_parameter_t
impl_bag_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_object_parameters[] = {
    &impl_bag_object_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("bag<object>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_object"),
    AFW_UTF8_LITERAL("bagObject"),
    AFW_UTF8_LITERAL("afwBagObject"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of object values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list object))): (list object)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<object> (\n    ...values: (list of (list object))\n): (list object);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_object_parameters[0],
    1,
    &impl_bag_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<object> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_object");

static const afw_runtime_object_indirect_t
impl_object__bag_size_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_object
        }
    },
    (void *)&afw_function_definition_bag_size_object
};

static const afw_value_function_parameter_t
impl_bag_size_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_object_parameters[] = {
    &impl_bag_size_object_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("bag_size<object>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_object"),
    AFW_UTF8_LITERAL("bagSizeObject"),
    AFW_UTF8_LITERAL("afwBagSizeObject"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list object)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<object> (\n    value: (list object)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_object_parameters[0],
    1,
    &impl_bag_size_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- clone<object> ---------- */

static const afw_utf8_t
impl_object_path__clone_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/clone_object");

static const afw_runtime_object_indirect_t
impl_object__clone_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_clone_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__clone_object
        }
    },
    (void *)&afw_function_definition_clone_object
};

static const afw_value_function_parameter_t
impl_clone_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The cloned object value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_clone_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The object value to clone."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_clone_object_parameters[] = {
    &impl_clone_object_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_clone_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__clone_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("clone<object>"),
    AFW_UTF8_LITERAL("clone"),
    AFW_UTF8_LITERAL("clone_object"),
    AFW_UTF8_LITERAL("cloneObject"),
    AFW_UTF8_LITERAL("afwCloneObject"),
    AFW_UTF8_LITERAL("Clone object value"),
    AFW_UTF8_LITERAL("Deep clone a object value."),
    AFW_UTF8_LITERAL("(value: object): object"),
    AFW_UTF8_LITERAL("/* Clone object value */\nfunction clone<object> (\n    value: object\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_clone,
    NULL,
    1,
    1,
    &impl_clone_object_parameters[0],
    1,
    &impl_clone_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_clone,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<object> ---------- */

static const afw_utf8_t
impl_object_path__eq_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_object");

static const afw_runtime_object_indirect_t
impl_object__eq_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_object
        }
    },
    (void *)&afw_function_definition_eq_object
};

static const afw_value_function_parameter_t
impl_eq_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_object_parameters[] = {
    &impl_eq_object_parameter_1,
    &impl_eq_object_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_object_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("eq<object>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_object"),
    AFW_UTF8_LITERAL("eqObject"),
    AFW_UTF8_LITERAL("afwEqObject"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if object arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<object> (\n    arg1: object,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_object_parameters[0],
    2,
    &impl_eq_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    &impl_eq_object_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<object> ---------- */

static const afw_utf8_t
impl_object_path__eqx_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_object");

static const afw_runtime_object_indirect_t
impl_object__eqx_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_object
        }
    },
    (void *)&afw_function_definition_eqx_object
};

static const afw_value_function_parameter_t
impl_eqx_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_object_parameters[] = {
    &impl_eqx_object_parameter_1,
    &impl_eqx_object_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("eqx<object>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_object"),
    AFW_UTF8_LITERAL("eqxObject"),
    AFW_UTF8_LITERAL("afwEqxObject"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for object arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<object> (\n    arg1: object,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_object_parameters[0],
    2,
    &impl_eqx_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<object> ---------- */

static const afw_utf8_t
impl_object_path__ge_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_object");

static const afw_runtime_object_indirect_t
impl_object__ge_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_object
        }
    },
    (void *)&afw_function_definition_ge_object
};

static const afw_value_function_parameter_t
impl_ge_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_object_parameters[] = {
    &impl_ge_object_parameter_1,
    &impl_ge_object_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("ge<object>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_object"),
    AFW_UTF8_LITERAL("geObject"),
    AFW_UTF8_LITERAL("afwGeObject"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for object arg1 is greater than or equal to object arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: object): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<object> (\n    arg1: object,\n    arg2: object\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_object_parameters[0],
    2,
    &impl_ge_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<object> ---------- */

static const afw_utf8_t
impl_object_path__gt_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_object");

static const afw_runtime_object_indirect_t
impl_object__gt_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_object
        }
    },
    (void *)&afw_function_definition_gt_object
};

static const afw_value_function_parameter_t
impl_gt_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_object_parameters[] = {
    &impl_gt_object_parameter_1,
    &impl_gt_object_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("gt<object>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_object"),
    AFW_UTF8_LITERAL("gtObject"),
    AFW_UTF8_LITERAL("afwGtObject"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for object arg1 is greater than object arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: object): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<object> (\n    arg1: object,\n    arg2: object\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_object_parameters[0],
    2,
    &impl_gt_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<object> ---------- */

static const afw_utf8_t
impl_object_path__is_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_object");

static const afw_runtime_object_indirect_t
impl_object__is_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_object
        }
    },
    (void *)&afw_function_definition_is_object
};

static const afw_value_function_parameter_t
impl_is_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_object_parameters[] = {
    &impl_is_object_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("is<object>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_object"),
    AFW_UTF8_LITERAL("isObject"),
    AFW_UTF8_LITERAL("afwIsObject"),
    AFW_UTF8_LITERAL("Checks whether value is dataType object"),
    AFW_UTF8_LITERAL("Checks whether value is dataType object and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType object */\nfunction is<object> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_object_parameters[0],
    1,
    &impl_is_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<object> ---------- */

static const afw_utf8_t
impl_object_path__le_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_object");

static const afw_runtime_object_indirect_t
impl_object__le_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_object
        }
    },
    (void *)&afw_function_definition_le_object
};

static const afw_value_function_parameter_t
impl_le_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_object_parameters[] = {
    &impl_le_object_parameter_1,
    &impl_le_object_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("le<object>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_object"),
    AFW_UTF8_LITERAL("leObject"),
    AFW_UTF8_LITERAL("afwLeObject"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for object arg1 is less than or equal to object arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<object> (\n    arg1: object,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_object_parameters[0],
    2,
    &impl_le_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- local_object_meta_set_ids ---------- */

static const afw_utf8_t
impl_object_path__local_object_meta_set_ids =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/local_object_meta_set_ids");

static const afw_runtime_object_indirect_t
impl_object__local_object_meta_set_ids = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_local_object_meta_set_ids,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__local_object_meta_set_ids
        }
    },
    (void *)&afw_function_definition_local_object_meta_set_ids
};

static const afw_value_function_parameter_t
impl_local_object_meta_set_ids_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_local_object_meta_set_ids_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object to set ids in."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_local_object_meta_set_ids_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("adaptorId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Adaptor id for object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_local_object_meta_set_ids_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectType"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object type id for object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_local_object_meta_set_ids_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object id for object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_local_object_meta_set_ids_parameters[] = {
    &impl_local_object_meta_set_ids_parameter_1,
    &impl_local_object_meta_set_ids_parameter_2,
    &impl_local_object_meta_set_ids_parameter_3,
    &impl_local_object_meta_set_ids_parameter_4,
    NULL
};

static const afw_utf8_t
impl_local_object_meta_set_ids_sideEffects[] = {
    AFW_UTF8_LITERAL("Object ids set"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_local_object_meta_set_ids = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__local_object_meta_set_ids,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("local_object_meta_set_ids"),
    AFW_UTF8_LITERAL("local_object_meta_set_ids"),
    AFW_UTF8_LITERAL("local_object_meta_set_ids"),
    AFW_UTF8_LITERAL("localObjectMetaSetIds"),
    AFW_UTF8_LITERAL("afwLocalObjectMetaSetIds"),
    AFW_UTF8_LITERAL("Set ids in a local mutable object"),
    AFW_UTF8_LITERAL("This is used to set the ids in a local mutable object. The ids are used to construct a local path."),
    AFW_UTF8_LITERAL("(object: object, adaptorId: string, objectType: string, objectId: string): null"),
    AFW_UTF8_LITERAL("/* Set ids in a local mutable object */\nfunction local_object_meta_set_ids (\n    object: object,\n    adaptorId: string,\n    objectType: string,\n    objectId: string\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_local_object_meta_set_ids,
    NULL,
    4,
    4,
    &impl_local_object_meta_set_ids_parameters[0],
    4,
    &impl_local_object_meta_set_ids_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_local_object_meta_set_ids_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- lt<object> ---------- */

static const afw_utf8_t
impl_object_path__lt_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_object");

static const afw_runtime_object_indirect_t
impl_object__lt_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_object
        }
    },
    (void *)&afw_function_definition_lt_object
};

static const afw_value_function_parameter_t
impl_lt_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_object_parameters[] = {
    &impl_lt_object_parameter_1,
    &impl_lt_object_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("lt<object>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_object"),
    AFW_UTF8_LITERAL("ltObject"),
    AFW_UTF8_LITERAL("afwLtObject"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for object arg1 is less that object arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: object): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<object> (\n    arg1: object,\n    arg2: object\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_object_parameters[0],
    2,
    &impl_lt_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<object> ---------- */

static const afw_utf8_t
impl_object_path__ne_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_object");

static const afw_runtime_object_indirect_t
impl_object__ne_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_object
        }
    },
    (void *)&afw_function_definition_ne_object
};

static const afw_value_function_parameter_t
impl_ne_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_object_parameters[] = {
    &impl_ne_object_parameter_1,
    &impl_ne_object_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_object_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("ne<object>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_object"),
    AFW_UTF8_LITERAL("neObject"),
    AFW_UTF8_LITERAL("afwNeObject"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if object arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<object> (\n    arg1: object,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_object_parameters[0],
    2,
    &impl_ne_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    &impl_ne_object_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<object> ---------- */

static const afw_utf8_t
impl_object_path__nex_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_object");

static const afw_runtime_object_indirect_t
impl_object__nex_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_object
        }
    },
    (void *)&afw_function_definition_nex_object
};

static const afw_value_function_parameter_t
impl_nex_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_object_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_object_parameters[] = {
    &impl_nex_object_parameter_1,
    &impl_nex_object_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("nex<object>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_object"),
    AFW_UTF8_LITERAL("nexObject"),
    AFW_UTF8_LITERAL("afwNexObject"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for object arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: object, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<object> (\n    arg1: object,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_object_parameters[0],
    2,
    &impl_nex_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- object ---------- */

static const afw_utf8_t
impl_object_path__object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/object");

static const afw_runtime_object_indirect_t
impl_object__object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__object
        }
    },
    (void *)&afw_function_definition_object
};

static const afw_value_function_parameter_t
impl_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_object_parameters[] = {
    &impl_object_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_object_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("afwObject"),
    AFW_UTF8_LITERAL("Convert to data type object"),
    AFW_UTF8_LITERAL("Converts value to data type object returning object result."),
    AFW_UTF8_LITERAL("(value: any): object"),
    AFW_UTF8_LITERAL("/* Convert to data type object */\nfunction object (\n    value: any\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_object_parameters[0],
    1,
    &impl_object_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_object_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- property_exists ---------- */

static const afw_utf8_t
impl_object_path__property_exists =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/property_exists");

static const afw_runtime_object_indirect_t
impl_object__property_exists = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_property_exists,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__property_exists
        }
    },
    (void *)&afw_function_definition_property_exists
};

static const afw_value_function_parameter_t
impl_property_exists_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if object has named property."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_property_exists_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object to get property from."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_property_exists_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Name of property to check."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_property_exists_parameters[] = {
    &impl_property_exists_parameter_1,
    &impl_property_exists_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_exists = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__property_exists,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("property_exists"),
    AFW_UTF8_LITERAL("property_exists"),
    AFW_UTF8_LITERAL("property_exists"),
    AFW_UTF8_LITERAL("propertyExists"),
    AFW_UTF8_LITERAL("afwPropertyExists"),
    AFW_UTF8_LITERAL("Determine if a property exists in an object"),
    AFW_UTF8_LITERAL("Return true if the named property exists in an object."),
    AFW_UTF8_LITERAL("(object: object, name: string): boolean"),
    AFW_UTF8_LITERAL("/* Determine if a property exists in an object */\nfunction property_exists (\n    object: object,\n    name: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_property_exists,
    NULL,
    2,
    2,
    &impl_property_exists_parameters[0],
    2,
    &impl_property_exists_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- property_get ---------- */

static const afw_utf8_t
impl_object_path__property_get =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/property_get");

static const afw_runtime_object_indirect_t
impl_object__property_get = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_property_get,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__property_get
        }
    },
    (void *)&afw_function_definition_property_get
};

static const afw_value_function_parameter_t
impl_property_get_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Evaluated property value or default."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_property_get_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object to get property from."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_property_get_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Name of property to get."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_property_get_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("defaultValue"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The default value of property if it does not exist in object. If not specified, null value is the default."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_property_get_parameters[] = {
    &impl_property_get_parameter_1,
    &impl_property_get_parameter_2,
    &impl_property_get_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_get = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__property_get,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("property_get"),
    AFW_UTF8_LITERAL("property_get"),
    AFW_UTF8_LITERAL("property_get"),
    AFW_UTF8_LITERAL("propertyGet"),
    AFW_UTF8_LITERAL("afwPropertyGet"),
    AFW_UTF8_LITERAL("Get property value"),
    AFW_UTF8_LITERAL("Return the value of a property of an object. If property is not available, return a default or null value."),
    AFW_UTF8_LITERAL("(object: object, name: string, defaultValue?: any): any"),
    AFW_UTF8_LITERAL("/* Get property value */\nfunction property_get (\n    object: object,\n    name: string,\n    defaultValue?: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_property_get,
    NULL,
    2,
    3,
    &impl_property_get_parameters[0],
    3,
    &impl_property_get_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- property_is_not_null ---------- */

static const afw_utf8_t
impl_object_path__property_is_not_null =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/property_is_not_null");

static const afw_runtime_object_indirect_t
impl_object__property_is_not_null = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_property_is_not_null,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__property_is_not_null
        }
    },
    (void *)&afw_function_definition_property_is_not_null
};

static const afw_value_function_parameter_t
impl_property_is_not_null_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("True if object has named property that is not null."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_property_is_not_null_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Object to get property from."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_property_is_not_null_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Name of property to check."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_property_is_not_null_parameters[] = {
    &impl_property_is_not_null_parameter_1,
    &impl_property_is_not_null_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_is_not_null = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__property_is_not_null,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("property_is_not_null"),
    AFW_UTF8_LITERAL("property_is_not_null"),
    AFW_UTF8_LITERAL("property_is_not_null"),
    AFW_UTF8_LITERAL("propertyIsNotNull"),
    AFW_UTF8_LITERAL("afwPropertyIsNotNull"),
    AFW_UTF8_LITERAL("Determine if a property exists in an object and is not null"),
    AFW_UTF8_LITERAL("Return true if the named property exists in an object and is not null."),
    AFW_UTF8_LITERAL("(object: object, name: string): boolean"),
    AFW_UTF8_LITERAL("/* Determine if a property exists in an object and is not null */\nfunction property_is_not_null (\n    object: object,\n    name: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_property_is_not_null,
    NULL,
    2,
    2,
    &impl_property_is_not_null_parameters[0],
    2,
    &impl_property_is_not_null_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- to_string<object> ---------- */

static const afw_utf8_t
impl_object_path__to_string_object =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_object");

static const afw_runtime_object_indirect_t
impl_object__to_string_object = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_object,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_object
        }
    },
    (void *)&afw_function_definition_to_string_object
};

static const afw_value_function_parameter_t
impl_to_string_object_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_object_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A object value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_object_parameters[] = {
    &impl_to_string_object_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_object = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_object,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("to_string<object>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_object"),
    AFW_UTF8_LITERAL("toStringObject"),
    AFW_UTF8_LITERAL("afwToStringObject"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts object value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: object): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<object> (\n    value: object\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_object_parameters[0],
    1,
    &impl_to_string_object_returns,
    NULL,
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<password> ---------- */

static const afw_utf8_t
impl_object_path__bag_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_password");

static const afw_runtime_object_indirect_t
impl_object__bag_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_password
        }
    },
    (void *)&afw_function_definition_bag_password
};

static const afw_value_function_parameter_t
impl_bag_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_password_parameters[] = {
    &impl_bag_password_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("bag<password>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_password"),
    AFW_UTF8_LITERAL("bagPassword"),
    AFW_UTF8_LITERAL("afwBagPassword"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of password values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list password))): (list password)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<password> (\n    ...values: (list of (list password))\n): (list password);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_password_parameters[0],
    1,
    &impl_bag_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<password> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_password");

static const afw_runtime_object_indirect_t
impl_object__bag_size_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_password
        }
    },
    (void *)&afw_function_definition_bag_size_password
};

static const afw_value_function_parameter_t
impl_bag_size_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_password_parameters[] = {
    &impl_bag_size_password_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("bag_size<password>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_password"),
    AFW_UTF8_LITERAL("bagSizePassword"),
    AFW_UTF8_LITERAL("afwBagSizePassword"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list password)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<password> (\n    value: (list password)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_password_parameters[0],
    1,
    &impl_bag_size_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<password> ---------- */

static const afw_utf8_t
impl_object_path__eq_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_password");

static const afw_runtime_object_indirect_t
impl_object__eq_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_password
        }
    },
    (void *)&afw_function_definition_eq_password
};

static const afw_value_function_parameter_t
impl_eq_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_password_parameters[] = {
    &impl_eq_password_parameter_1,
    &impl_eq_password_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_password_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("eq<password>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_password"),
    AFW_UTF8_LITERAL("eqPassword"),
    AFW_UTF8_LITERAL("afwEqPassword"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if password arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<password> (\n    arg1: password,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_password_parameters[0],
    2,
    &impl_eq_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    &impl_eq_password_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<password> ---------- */

static const afw_utf8_t
impl_object_path__eqx_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_password");

static const afw_runtime_object_indirect_t
impl_object__eqx_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_password
        }
    },
    (void *)&afw_function_definition_eqx_password
};

static const afw_value_function_parameter_t
impl_eqx_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_password_parameters[] = {
    &impl_eqx_password_parameter_1,
    &impl_eqx_password_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("eqx<password>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_password"),
    AFW_UTF8_LITERAL("eqxPassword"),
    AFW_UTF8_LITERAL("afwEqxPassword"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for password arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<password> (\n    arg1: password,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_password_parameters[0],
    2,
    &impl_eqx_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<password> ---------- */

static const afw_utf8_t
impl_object_path__ge_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_password");

static const afw_runtime_object_indirect_t
impl_object__ge_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_password
        }
    },
    (void *)&afw_function_definition_ge_password
};

static const afw_value_function_parameter_t
impl_ge_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_password_parameters[] = {
    &impl_ge_password_parameter_1,
    &impl_ge_password_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("ge<password>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_password"),
    AFW_UTF8_LITERAL("gePassword"),
    AFW_UTF8_LITERAL("afwGePassword"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for password arg1 is greater than or equal to password arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: password): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<password> (\n    arg1: password,\n    arg2: password\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_password_parameters[0],
    2,
    &impl_ge_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<password> ---------- */

static const afw_utf8_t
impl_object_path__gt_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_password");

static const afw_runtime_object_indirect_t
impl_object__gt_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_password
        }
    },
    (void *)&afw_function_definition_gt_password
};

static const afw_value_function_parameter_t
impl_gt_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_password_parameters[] = {
    &impl_gt_password_parameter_1,
    &impl_gt_password_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("gt<password>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_password"),
    AFW_UTF8_LITERAL("gtPassword"),
    AFW_UTF8_LITERAL("afwGtPassword"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for password arg1 is greater than password arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: password): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<password> (\n    arg1: password,\n    arg2: password\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_password_parameters[0],
    2,
    &impl_gt_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<password> ---------- */

static const afw_utf8_t
impl_object_path__is_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_password");

static const afw_runtime_object_indirect_t
impl_object__is_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_password
        }
    },
    (void *)&afw_function_definition_is_password
};

static const afw_value_function_parameter_t
impl_is_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_password_parameters[] = {
    &impl_is_password_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("is<password>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_password"),
    AFW_UTF8_LITERAL("isPassword"),
    AFW_UTF8_LITERAL("afwIsPassword"),
    AFW_UTF8_LITERAL("Checks whether value is dataType password"),
    AFW_UTF8_LITERAL("Checks whether value is dataType password and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType password */\nfunction is<password> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_password_parameters[0],
    1,
    &impl_is_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<password> ---------- */

static const afw_utf8_t
impl_object_path__le_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_password");

static const afw_runtime_object_indirect_t
impl_object__le_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_password
        }
    },
    (void *)&afw_function_definition_le_password
};

static const afw_value_function_parameter_t
impl_le_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_password_parameters[] = {
    &impl_le_password_parameter_1,
    &impl_le_password_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("le<password>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_password"),
    AFW_UTF8_LITERAL("lePassword"),
    AFW_UTF8_LITERAL("afwLePassword"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for password arg1 is less than or equal to password arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<password> (\n    arg1: password,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_password_parameters[0],
    2,
    &impl_le_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<password> ---------- */

static const afw_utf8_t
impl_object_path__lt_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_password");

static const afw_runtime_object_indirect_t
impl_object__lt_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_password
        }
    },
    (void *)&afw_function_definition_lt_password
};

static const afw_value_function_parameter_t
impl_lt_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_password_parameters[] = {
    &impl_lt_password_parameter_1,
    &impl_lt_password_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("lt<password>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_password"),
    AFW_UTF8_LITERAL("ltPassword"),
    AFW_UTF8_LITERAL("afwLtPassword"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for password arg1 is less that password arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: password): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<password> (\n    arg1: password,\n    arg2: password\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_password_parameters[0],
    2,
    &impl_lt_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<password> ---------- */

static const afw_utf8_t
impl_object_path__ne_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_password");

static const afw_runtime_object_indirect_t
impl_object__ne_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_password
        }
    },
    (void *)&afw_function_definition_ne_password
};

static const afw_value_function_parameter_t
impl_ne_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_password_parameters[] = {
    &impl_ne_password_parameter_1,
    &impl_ne_password_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_password_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("ne<password>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_password"),
    AFW_UTF8_LITERAL("nePassword"),
    AFW_UTF8_LITERAL("afwNePassword"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if password arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<password> (\n    arg1: password,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_password_parameters[0],
    2,
    &impl_ne_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    &impl_ne_password_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<password> ---------- */

static const afw_utf8_t
impl_object_path__nex_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_password");

static const afw_runtime_object_indirect_t
impl_object__nex_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_password
        }
    },
    (void *)&afw_function_definition_nex_password
};

static const afw_value_function_parameter_t
impl_nex_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_password_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_password_parameters[] = {
    &impl_nex_password_parameter_1,
    &impl_nex_password_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("nex<password>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_password"),
    AFW_UTF8_LITERAL("nexPassword"),
    AFW_UTF8_LITERAL("afwNexPassword"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for password arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: password, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<password> (\n    arg1: password,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_password_parameters[0],
    2,
    &impl_nex_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- password ---------- */

static const afw_utf8_t
impl_object_path__password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/password");

static const afw_runtime_object_indirect_t
impl_object__password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__password
        }
    },
    (void *)&afw_function_definition_password
};

static const afw_value_function_parameter_t
impl_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_password_parameters[] = {
    &impl_password_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_password_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("afwPassword"),
    AFW_UTF8_LITERAL("Convert to data type password"),
    AFW_UTF8_LITERAL("Converts value to data type password returning password result."),
    AFW_UTF8_LITERAL("(value: any): password"),
    AFW_UTF8_LITERAL("/* Convert to data type password */\nfunction password (\n    value: any\n): password;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_password_parameters[0],
    1,
    &impl_password_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_password_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<password> ---------- */

static const afw_utf8_t
impl_object_path__to_string_password =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_password");

static const afw_runtime_object_indirect_t
impl_object__to_string_password = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_password,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_password
        }
    },
    (void *)&afw_function_definition_to_string_password
};

static const afw_value_function_parameter_t
impl_to_string_password_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_password_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A password value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_password_parameters[] = {
    &impl_to_string_password_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_password = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_password,
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("to_string<password>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_password"),
    AFW_UTF8_LITERAL("toStringPassword"),
    AFW_UTF8_LITERAL("afwToStringPassword"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts password value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: password): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<password> (\n    value: password\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_password_parameters[0],
    1,
    &impl_to_string_password_returns,
    NULL,
    &afw_data_type_password_direct,
    AFW_UTF8_LITERAL("password"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- abs ---------- */

static const afw_utf8_t
impl_object_path__abs =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/abs");

static const afw_runtime_object_indirect_t
impl_object__abs = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_abs,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__abs
        }
    },
    (void *)&afw_function_definition_abs
};

static const afw_value_function_parameter_t
impl_abs_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_abs_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_abs_parameters[] = {
    &impl_abs_parameter_1,
    NULL
};

static const afw_utf8_t
impl_abs_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_abs = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__abs,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("abs"),
    AFW_UTF8_LITERAL("abs"),
    AFW_UTF8_LITERAL("abs"),
    AFW_UTF8_LITERAL("abs"),
    AFW_UTF8_LITERAL("afwAbs"),
    AFW_UTF8_LITERAL("Absolute value"),
    AFW_UTF8_LITERAL("Compute the absolute value of the <dataType> value and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Absolute value */\nfunction abs `<dataType>`(\n    value: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_abs_parameters[0],
    1,
    &impl_abs_returns,
    &impl_abs_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_abs,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- add ---------- */

static const afw_utf8_t
impl_object_path__add =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add");

static const afw_runtime_object_indirect_t
impl_object__add = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add
        }
    },
    (void *)&afw_function_definition_add
};

static const afw_value_function_parameter_t
impl_add_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_add_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_add_parameters[] = {
    &impl_add_parameter_1,
    NULL
};

static const afw_utf8_t
impl_add_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL("afwAdd"),
    AFW_UTF8_LITERAL("Add"),
    AFW_UTF8_LITERAL("Add 2 or more <dataType> values and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(values_1: dataType, values_2: dataType, ...values_rest: (list of dataType)): dataType"),
    AFW_UTF8_LITERAL("/* Add */\nfunction add `<dataType>`(\n    values_1: dataType,\n    values_2: dataType,\n    ...values_rest: (list of dataType)\n): dataType;\n"),
    AFW_UTF8_LITERAL("+"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    -1,
    &impl_add_parameters[0],
    1,
    &impl_add_returns,
    &impl_add_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_add,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- add_dayTimeDuration ---------- */

static const afw_utf8_t
impl_object_path__add_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__add_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_add_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_add_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_add_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_add_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_dayTimeDuration_parameters[] = {
    &impl_add_dayTimeDuration_parameter_1,
    &impl_add_dayTimeDuration_parameter_2,
    NULL
};

static const afw_utf8_t
impl_add_dayTimeDuration_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("dateTime"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_dayTimeDuration,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("add_dayTimeDuration"),
    AFW_UTF8_LITERAL("add_dayTimeDuration"),
    AFW_UTF8_LITERAL("add_dayTimeDuration"),
    AFW_UTF8_LITERAL("addDayTimeDuration"),
    AFW_UTF8_LITERAL("afwAddDayTimeDuration"),
    AFW_UTF8_LITERAL("Add duration"),
    AFW_UTF8_LITERAL("Add <dataType> arg1 to dayTimeDuration arg2 and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: dayTimeDuration): dataType"),
    AFW_UTF8_LITERAL("/* Add duration */\nfunction add_dayTimeDuration `<dataType>`(\n    arg1: dataType,\n    arg2: dayTimeDuration\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_add_dayTimeDuration_parameters[0],
    2,
    &impl_add_dayTimeDuration_returns,
    &impl_add_dayTimeDuration_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_add_dayTimeDuration,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- add_yearMonthDuration ---------- */

static const afw_utf8_t
impl_object_path__add_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__add_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_add_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_add_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_yearMonthDuration_parameters[] = {
    &impl_add_yearMonthDuration_parameter_1,
    &impl_add_yearMonthDuration_parameter_2,
    NULL
};

static const afw_utf8_t
impl_add_yearMonthDuration_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_yearMonthDuration,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("add_yearMonthDuration"),
    AFW_UTF8_LITERAL("add_yearMonthDuration"),
    AFW_UTF8_LITERAL("add_yearMonthDuration"),
    AFW_UTF8_LITERAL("addYearMonthDuration"),
    AFW_UTF8_LITERAL("afwAddYearMonthDuration"),
    AFW_UTF8_LITERAL("Add duration"),
    AFW_UTF8_LITERAL("Add <dataType> arg1 to yearMonthDuration arg2 and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: yearMonthDuration): dataType"),
    AFW_UTF8_LITERAL("/* Add duration */\nfunction add_yearMonthDuration `<dataType>`(\n    arg1: dataType,\n    arg2: yearMonthDuration\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_add_yearMonthDuration_parameters[0],
    2,
    &impl_add_yearMonthDuration_returns,
    &impl_add_yearMonthDuration_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_add_yearMonthDuration,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_parameters[] = {
    &impl_at_least_one_member_of_parameter_1,
    &impl_at_least_one_member_of_parameter_2,
    NULL
};

static const afw_utf8_t
impl_at_least_one_member_of_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("atLeastOneMemberOf"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOf"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in <dataType> list1 is in <dataType> list2."),
    AFW_UTF8_LITERAL("`<dataType>`(list1: list, list2: list): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of `<dataType>`(\n    list1: list,\n    list2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_parameters[0],
    2,
    &impl_at_least_one_member_of_returns,
    &impl_at_least_one_member_of_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- bag ---------- */

static const afw_utf8_t
impl_object_path__bag =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag");

static const afw_runtime_object_indirect_t
impl_object__bag = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag
        }
    },
    (void *)&afw_function_definition_bag
};

static const afw_value_function_parameter_t
impl_bag_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t
impl_bag_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_bag_parameters[] = {
    &impl_bag_parameter_1,
    NULL
};

static const afw_utf8_t
impl_bag_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("afwBag"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of <dataType> values and returns a list of list."),
    AFW_UTF8_LITERAL("`<dataType>`(...values: (list of list)): list"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag `<dataType>`(\n    ...values: (list of list)\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    0,
    -1,
    &impl_bag_parameters[0],
    1,
    &impl_bag_returns,
    &impl_bag_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- bag_size ---------- */

static const afw_utf8_t
impl_object_path__bag_size =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size");

static const afw_runtime_object_indirect_t
impl_object__bag_size = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size
        }
    },
    (void *)&afw_function_definition_bag_size
};

static const afw_value_function_parameter_t
impl_bag_size_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_bag_size_parameters[] = {
    &impl_bag_size_parameter_1,
    NULL
};

static const afw_utf8_t
impl_bag_size_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bagSize"),
    AFW_UTF8_LITERAL("afwBagSize"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("`<dataType>`(value: list): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size `<dataType>`(\n    value: list\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_bag_size_parameters[0],
    1,
    &impl_bag_size_returns,
    &impl_bag_size_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- ceil ---------- */

static const afw_utf8_t
impl_object_path__ceil =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ceil");

static const afw_runtime_object_indirect_t
impl_object__ceil = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ceil,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ceil
        }
    },
    (void *)&afw_function_definition_ceil
};

static const afw_value_function_parameter_t
impl_ceil_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_ceil_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_ceil_parameters[] = {
    &impl_ceil_parameter_1,
    NULL
};

static const afw_utf8_t
impl_ceil_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ceil = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ceil,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("ceil"),
    AFW_UTF8_LITERAL("ceil"),
    AFW_UTF8_LITERAL("ceil"),
    AFW_UTF8_LITERAL("ceil"),
    AFW_UTF8_LITERAL("afwCeil"),
    AFW_UTF8_LITERAL("Round upward to nearest integer"),
    AFW_UTF8_LITERAL("Determine the smallest integer that is greater then or equal to the <dataType> value and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Round upward to nearest integer */\nfunction ceil `<dataType>`(\n    value: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_ceil_parameters[0],
    1,
    &impl_ceil_returns,
    &impl_ceil_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_ceil,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- clone ---------- */

static const afw_utf8_t
impl_object_path__clone =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/clone");

static const afw_runtime_object_indirect_t
impl_object__clone = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_clone,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__clone
        }
    },
    (void *)&afw_function_definition_clone
};

static const afw_value_function_parameter_t
impl_clone_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The cloned <dataType> value."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_clone_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to clone."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_clone_parameters[] = {
    &impl_clone_parameter_1,
    NULL
};

static const afw_utf8_t
impl_clone_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_clone = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__clone,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("clone"),
    AFW_UTF8_LITERAL("clone"),
    AFW_UTF8_LITERAL("clone"),
    AFW_UTF8_LITERAL("clone"),
    AFW_UTF8_LITERAL("afwClone"),
    AFW_UTF8_LITERAL("Clone <dataType> value"),
    AFW_UTF8_LITERAL("Deep clone a <dataType> value."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Clone <dataType> value */\nfunction clone `<dataType>`(\n    value: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_clone_parameters[0],
    1,
    &impl_clone_returns,
    &impl_clone_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_clone,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- compile ---------- */

static const afw_utf8_t
impl_object_path__compile =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile");

static const afw_runtime_object_indirect_t
impl_object__compile = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile
        }
    },
    (void *)&afw_function_definition_compile
};

static const afw_value_function_parameter_t
impl_compile_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to compile"),
    AFW_UTF8_LITERAL("<dataType> string to compile"),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_compile_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL("Listing option"),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_parameters[] = {
    &impl_compile_parameter_1,
    &impl_compile_parameter_2,
    NULL
};

static const afw_utf8_t
impl_compile_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("xpathExpression"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("afwCompile"),
    AFW_UTF8_LITERAL("Compile <dataType> value"),
    AFW_UTF8_LITERAL("Compile <dataType> value and return either an unevaluated adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("`<dataType>`(source: dataType, listing?: any): unevaluated"),
    AFW_UTF8_LITERAL("/* Compile <dataType> value */\nfunction compile `<dataType>`(\n    source: dataType /* Source to compile */,\n    listing?: any    /* Listing option */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    2,
    &impl_compile_parameters[0],
    2,
    &impl_compile_returns,
    &impl_compile_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_compile,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- decode_to_string ---------- */

static const afw_utf8_t
impl_object_path__decode_to_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/decode_to_string");

static const afw_runtime_object_indirect_t
impl_object__decode_to_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_decode_to_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__decode_to_string
        }
    },
    (void *)&afw_function_definition_decode_to_string
};

static const afw_value_function_parameter_t
impl_decode_to_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The decoded string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_decode_to_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to decode."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_decode_to_string_parameters[] = {
    &impl_decode_to_string_parameter_1,
    NULL
};

static const afw_utf8_t
impl_decode_to_string_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("hexBinary"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decode_to_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__decode_to_string,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("decode_to_string"),
    AFW_UTF8_LITERAL("decode_to_string"),
    AFW_UTF8_LITERAL("decode_to_string"),
    AFW_UTF8_LITERAL("decodeToString"),
    AFW_UTF8_LITERAL("afwDecodeToString"),
    AFW_UTF8_LITERAL("Decode <dataType> to string"),
    AFW_UTF8_LITERAL("Decode <dataType> value to string. An error is thrown if decoded value is not valid UTF-8."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): string"),
    AFW_UTF8_LITERAL("/* Decode <dataType> to string */\nfunction decode_to_string `<dataType>`(\n    value: dataType\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_decode_to_string_parameters[0],
    1,
    &impl_decode_to_string_returns,
    &impl_decode_to_string_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_decode_to_string,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- divide ---------- */

static const afw_utf8_t
impl_object_path__divide =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/divide");

static const afw_runtime_object_indirect_t
impl_object__divide = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_divide,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__divide
        }
    },
    (void *)&afw_function_definition_divide
};

static const afw_value_function_parameter_t
impl_divide_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_divide_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("dividend"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_divide_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("divisor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_divide_parameters[] = {
    &impl_divide_parameter_1,
    &impl_divide_parameter_2,
    NULL
};

static const afw_utf8_t
impl_divide_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_divide = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__divide,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("divide"),
    AFW_UTF8_LITERAL("divide"),
    AFW_UTF8_LITERAL("divide"),
    AFW_UTF8_LITERAL("divide"),
    AFW_UTF8_LITERAL("afwDivide"),
    AFW_UTF8_LITERAL("Divide numbers"),
    AFW_UTF8_LITERAL("Divide <dataType> dividend by <dataType> divisor and return the <dataType> quotient."),
    AFW_UTF8_LITERAL("`<dataType>`(dividend: dataType, divisor: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Divide numbers */\nfunction divide `<dataType>`(\n    dividend: dataType,\n    divisor: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL("/"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_divide_parameters[0],
    2,
    &impl_divide_returns,
    &impl_divide_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_divide,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- encode_as_base64Binary ---------- */

static const afw_utf8_t
impl_object_path__encode_as_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/encode_as_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__encode_as_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_encode_as_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__encode_as_base64Binary
        }
    },
    (void *)&afw_function_definition_encode_as_base64Binary
};

static const afw_value_function_parameter_t
impl_encode_as_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A base64Binary value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_encode_as_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to encode."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_encode_as_base64Binary_parameters[] = {
    &impl_encode_as_base64Binary_parameter_1,
    NULL
};

static const afw_utf8_t
impl_encode_as_base64Binary_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__encode_as_base64Binary,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("encode_as_base64Binary"),
    AFW_UTF8_LITERAL("encode_as_base64Binary"),
    AFW_UTF8_LITERAL("encode_as_base64Binary"),
    AFW_UTF8_LITERAL("encodeAsBase64Binary"),
    AFW_UTF8_LITERAL("afwEncodeAsBase64Binary"),
    AFW_UTF8_LITERAL("Encode to a base64Binary value"),
    AFW_UTF8_LITERAL("Encode a value as a base64Binary. The effect is to create a base64Binary value with an internal value of the value passed."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): base64Binary"),
    AFW_UTF8_LITERAL("/* Encode to a base64Binary value */\nfunction encode_as_base64Binary `<dataType>`(\n    value: dataType\n): base64Binary;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_encode_as_base64Binary_parameters[0],
    1,
    &impl_encode_as_base64Binary_returns,
    &impl_encode_as_base64Binary_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_encode_as_base64Binary,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- encode_as_hexBinary ---------- */

static const afw_utf8_t
impl_object_path__encode_as_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/encode_as_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__encode_as_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_encode_as_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__encode_as_hexBinary
        }
    },
    (void *)&afw_function_definition_encode_as_hexBinary
};

static const afw_value_function_parameter_t
impl_encode_as_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A hexBinary value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_encode_as_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to encode."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_encode_as_hexBinary_parameters[] = {
    &impl_encode_as_hexBinary_parameter_1,
    NULL
};

static const afw_utf8_t
impl_encode_as_hexBinary_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__encode_as_hexBinary,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("encode_as_hexBinary"),
    AFW_UTF8_LITERAL("encode_as_hexBinary"),
    AFW_UTF8_LITERAL("encode_as_hexBinary"),
    AFW_UTF8_LITERAL("encodeAsHexBinary"),
    AFW_UTF8_LITERAL("afwEncodeAsHexBinary"),
    AFW_UTF8_LITERAL("Encode to a hexBinary value"),
    AFW_UTF8_LITERAL("Encode a value as a hexBinary. The effect is to create a hexBinary value with an internal value of the value passed."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): hexBinary"),
    AFW_UTF8_LITERAL("/* Encode to a hexBinary value */\nfunction encode_as_hexBinary `<dataType>`(\n    value: dataType\n): hexBinary;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_encode_as_hexBinary_parameters[0],
    1,
    &impl_encode_as_hexBinary_returns,
    &impl_encode_as_hexBinary_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_encode_as_hexBinary,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- ends_with ---------- */

static const afw_utf8_t
impl_object_path__ends_with =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ends_with");

static const afw_runtime_object_indirect_t
impl_object__ends_with = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ends_with,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ends_with
        }
    },
    (void *)&afw_function_definition_ends_with
};

static const afw_value_function_parameter_t
impl_ends_with_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ends_with_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_ends_with_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ends_with_parameters[] = {
    &impl_ends_with_parameter_1,
    &impl_ends_with_parameter_2,
    NULL
};

static const afw_utf8_t
impl_ends_with_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ends_with = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ends_with,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("ends_with"),
    AFW_UTF8_LITERAL("ends_with"),
    AFW_UTF8_LITERAL("ends_with"),
    AFW_UTF8_LITERAL("endsWith"),
    AFW_UTF8_LITERAL("afwEndsWith"),
    AFW_UTF8_LITERAL("Checks whether value ends with a string"),
    AFW_UTF8_LITERAL("Checks whether <dataType> value ends with a <dataType> and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, subString: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value ends with a string */\nfunction ends_with `<dataType>`(\n    value: dataType,\n    subString: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_ends_with_parameters[0],
    2,
    &impl_ends_with_returns,
    &impl_ends_with_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_ends_with,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- eq ---------- */

static const afw_utf8_t
impl_object_path__eq =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq");

static const afw_runtime_object_indirect_t
impl_object__eq = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq
        }
    },
    (void *)&afw_function_definition_eq
};

static const afw_value_function_parameter_t
impl_eq_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_eq_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_parameters[] = {
    &impl_eq_parameter_1,
    &impl_eq_parameter_2,
    NULL
};

static const afw_utf8_t
impl_eq_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

static const afw_utf8_z_t *
impl_eq_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("afwEq"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if <dataType> arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq `<dataType>`(\n    arg1: dataType,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_parameters[0],
    2,
    &impl_eq_returns,
    &impl_eq_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_eq_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    true,
    true,
    false,
    true,
    false
};

/* ---------- eq_ignore_case ---------- */

static const afw_utf8_t
impl_object_path__eq_ignore_case =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_ignore_case");

static const afw_runtime_object_indirect_t
impl_object__eq_ignore_case = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_ignore_case,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_ignore_case
        }
    },
    (void *)&afw_function_definition_eq_ignore_case
};

static const afw_value_function_parameter_t
impl_eq_ignore_case_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ignore_case_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ignore_case_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_ignore_case_parameters[] = {
    &impl_eq_ignore_case_parameter_1,
    &impl_eq_ignore_case_parameter_2,
    NULL
};

static const afw_utf8_t
impl_eq_ignore_case_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ignore_case = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_ignore_case,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("eq_ignore_case"),
    AFW_UTF8_LITERAL("eq_ignore_case"),
    AFW_UTF8_LITERAL("eq_ignore_case"),
    AFW_UTF8_LITERAL("eqIgnoreCase"),
    AFW_UTF8_LITERAL("afwEqIgnoreCase"),
    AFW_UTF8_LITERAL("Checks for equal ignoring case"),
    AFW_UTF8_LITERAL("Checks for <dataType> arg1 is equal to <dataType> arg2 ignoring case and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: dataType): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal ignoring case */\nfunction eq_ignore_case `<dataType>`(\n    arg1: dataType,\n    arg2: dataType\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_eq_ignore_case_parameters[0],
    2,
    &impl_eq_ignore_case_returns,
    &impl_eq_ignore_case_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_eq_ignore_case,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- eqx ---------- */

static const afw_utf8_t
impl_object_path__eqx =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx");

static const afw_runtime_object_indirect_t
impl_object__eqx = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx
        }
    },
    (void *)&afw_function_definition_eqx
};

static const afw_value_function_parameter_t
impl_eqx_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_parameters[] = {
    &impl_eqx_parameter_1,
    &impl_eqx_parameter_2,
    NULL
};

static const afw_utf8_t
impl_eqx_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("afwEqx"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for <dataType> arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx `<dataType>`(\n    arg1: dataType,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_parameters[0],
    2,
    &impl_eqx_returns,
    &impl_eqx_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    true,
    true,
    false,
    true,
    false
};

/* ---------- evaluate ---------- */

static const afw_utf8_t
impl_object_path__evaluate =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate");

static const afw_runtime_object_indirect_t
impl_object__evaluate = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate
        }
    },
    (void *)&afw_function_definition_evaluate
};

static const afw_value_function_parameter_t
impl_evaluate_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to evaluate"),
    AFW_UTF8_LITERAL("<dataType> string to compile and evaluate"),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_parameters[] = {
    &impl_evaluate_parameter_1,
    &impl_evaluate_parameter_2,
    NULL
};

static const afw_utf8_t
impl_evaluate_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("xpathExpression"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("afwEvaluate"),
    AFW_UTF8_LITERAL("Evaluate <dataType> value"),
    AFW_UTF8_LITERAL("Compile and evaluate <dataType> value."),
    AFW_UTF8_LITERAL("`<dataType>`(source: dataType, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): unevaluated"),
    AFW_UTF8_LITERAL("/* Evaluate <dataType> value */\nfunction evaluate `<dataType>`(\n    source: dataType                                                                   /* Source to evaluate */,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    2,
    &impl_evaluate_parameters[0],
    2,
    &impl_evaluate_returns,
    &impl_evaluate_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_evaluate,
    0,
    true,
    false,
    false,
    false,
    false
};

/* ---------- floor ---------- */

static const afw_utf8_t
impl_object_path__floor =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/floor");

static const afw_runtime_object_indirect_t
impl_object__floor = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_floor,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__floor
        }
    },
    (void *)&afw_function_definition_floor
};

static const afw_value_function_parameter_t
impl_floor_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_floor_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("number"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_floor_parameters[] = {
    &impl_floor_parameter_1,
    NULL
};

static const afw_utf8_t
impl_floor_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_floor = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__floor,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("floor"),
    AFW_UTF8_LITERAL("floor"),
    AFW_UTF8_LITERAL("floor"),
    AFW_UTF8_LITERAL("floor"),
    AFW_UTF8_LITERAL("afwFloor"),
    AFW_UTF8_LITERAL("Round downwards to nearest integer"),
    AFW_UTF8_LITERAL("Determine the largest integer that is smaller then or equal to the <dataType> value and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(number: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Round downwards to nearest integer */\nfunction floor `<dataType>`(\n    number: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_floor_parameters[0],
    1,
    &impl_floor_returns,
    &impl_floor_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_floor,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- ge ---------- */

static const afw_utf8_t
impl_object_path__ge =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge");

static const afw_runtime_object_indirect_t
impl_object__ge = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge
        }
    },
    (void *)&afw_function_definition_ge
};

static const afw_value_function_parameter_t
impl_ge_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_ge_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_parameters[] = {
    &impl_ge_parameter_1,
    &impl_ge_parameter_2,
    NULL
};

static const afw_utf8_t
impl_ge_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("afwGe"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for <dataType> arg1 is greater than or equal to <dataType> arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: dataType): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge `<dataType>`(\n    arg1: dataType,\n    arg2: dataType\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_ge_parameters[0],
    2,
    &impl_ge_returns,
    &impl_ge_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- gt ---------- */

static const afw_utf8_t
impl_object_path__gt =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt");

static const afw_runtime_object_indirect_t
impl_object__gt = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt
        }
    },
    (void *)&afw_function_definition_gt
};

static const afw_value_function_parameter_t
impl_gt_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_gt_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_parameters[] = {
    &impl_gt_parameter_1,
    &impl_gt_parameter_2,
    NULL
};

static const afw_utf8_t
impl_gt_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("afwGt"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for <dataType> arg1 is greater than <dataType> arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: dataType): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt `<dataType>`(\n    arg1: dataType,\n    arg2: dataType\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_gt_parameters[0],
    2,
    &impl_gt_returns,
    &impl_gt_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- in_range ---------- */

static const afw_utf8_t
impl_object_path__in_range =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/in_range");

static const afw_runtime_object_indirect_t
impl_object__in_range = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_in_range,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__in_range
        }
    },
    (void *)&afw_function_definition_in_range
};

static const afw_value_function_parameter_t
impl_in_range_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_in_range_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_in_range_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_in_range_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("endTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_in_range_parameters[] = {
    &impl_in_range_parameter_1,
    &impl_in_range_parameter_2,
    &impl_in_range_parameter_3,
    NULL
};

static const afw_utf8_t
impl_in_range_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("time"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_in_range = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__in_range,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("in_range"),
    AFW_UTF8_LITERAL("in_range"),
    AFW_UTF8_LITERAL("in_range"),
    AFW_UTF8_LITERAL("inRange"),
    AFW_UTF8_LITERAL("afwInRange"),
    AFW_UTF8_LITERAL("Checks if time in range"),
    AFW_UTF8_LITERAL("Checks if <dataType> is between startTime and endTime, inclusive. Regardless of endTime value, it is always considered to be equal to, but less than 24 hours greater than startTime. If no <dataType> zone is specified for <dataType>, the default <dataType> zone is used. If no <dataType> zone is specified for startTime or endTime, the <dataType> zone of <dataType> is used."),
    AFW_UTF8_LITERAL("`<dataType>`(time: dataType, startTime: dataType, endTime: dataType): boolean"),
    AFW_UTF8_LITERAL("/* Checks if time in range */\nfunction in_range `<dataType>`(\n    time: dataType,\n    startTime: dataType,\n    endTime: dataType\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    3,
    3,
    &impl_in_range_parameters[0],
    3,
    &impl_in_range_returns,
    &impl_in_range_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_in_range,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- includes ---------- */

static const afw_utf8_t
impl_object_path__includes =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/includes");

static const afw_runtime_object_indirect_t
impl_object__includes = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_includes,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__includes
        }
    },
    (void *)&afw_function_definition_includes
};

static const afw_value_function_parameter_t
impl_includes_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Indicates if the substring is found"),
    AFW_UTF8_LITERAL("Indicates if the substring is contained in the search string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("searchString"),
    AFW_UTF8_LITERAL("The <dataType> to search"),
    AFW_UTF8_LITERAL("The <dataType> to search."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_includes_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL("Substring to find"),
    AFW_UTF8_LITERAL("Substring to find."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("position"),
    AFW_UTF8_LITERAL("Zero-based position in the search string to start search"),
    AFW_UTF8_LITERAL("Zero-based position in the search string to start search."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_includes_parameters[] = {
    &impl_includes_parameter_1,
    &impl_includes_parameter_2,
    &impl_includes_parameter_3,
    NULL
};

static const afw_utf8_t
impl_includes_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__includes,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("includes"),
    AFW_UTF8_LITERAL("includes"),
    AFW_UTF8_LITERAL("includes"),
    AFW_UTF8_LITERAL("includes"),
    AFW_UTF8_LITERAL("afwIncludes"),
    AFW_UTF8_LITERAL("Checks whether the <dataType> value includes a string"),
    AFW_UTF8_LITERAL("Checks whether the <dataType> value includes a string and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(searchString: dataType, subString: string, position?: integer): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether the <dataType> value includes a string */\nfunction includes `<dataType>`(\n    searchString: dataType /* The <dataType> to search */,\n    subString: string      /* Substring to find */,\n    position?: integer     /* Zero-based position in the search string to start search */\n): boolean; /* Indicates if the substring is found */\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    3,
    &impl_includes_parameters[0],
    3,
    &impl_includes_returns,
    &impl_includes_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_includes,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- index_of ---------- */

static const afw_utf8_t
impl_object_path__index_of =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/index_of");

static const afw_runtime_object_indirect_t
impl_object__index_of = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_index_of,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__index_of
        }
    },
    (void *)&afw_function_definition_index_of
};

static const afw_value_function_parameter_t
impl_index_of_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to search."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Substring to search for."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional start index for search if different than start of string."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_index_of_parameters[] = {
    &impl_index_of_parameter_1,
    &impl_index_of_parameter_2,
    &impl_index_of_parameter_3,
    NULL
};

static const afw_utf8_t
impl_index_of_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_of = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__index_of,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("index_of"),
    AFW_UTF8_LITERAL("index_of"),
    AFW_UTF8_LITERAL("index_of"),
    AFW_UTF8_LITERAL("indexOf"),
    AFW_UTF8_LITERAL("afwIndexOf"),
    AFW_UTF8_LITERAL("Returns index of first occurrence"),
    AFW_UTF8_LITERAL("Returns the zero-based index into <dataType> value of subString. If subString is not found, -1 is returned."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, subString: string, startIndex?: integer): integer"),
    AFW_UTF8_LITERAL("/* Returns index of first occurrence */\nfunction index_of `<dataType>`(\n    value: dataType,\n    subString: string,\n    startIndex?: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    3,
    &impl_index_of_parameters[0],
    3,
    &impl_index_of_returns,
    &impl_index_of_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_index_of,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- intersection ---------- */

static const afw_utf8_t
impl_object_path__intersection =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection");

static const afw_runtime_object_indirect_t
impl_object__intersection = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection
        }
    },
    (void *)&afw_function_definition_intersection
};

static const afw_value_function_parameter_t
impl_intersection_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t
impl_intersection_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t
impl_intersection_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_intersection_parameters[] = {
    &impl_intersection_parameter_1,
    &impl_intersection_parameter_2,
    NULL
};

static const afw_utf8_t
impl_intersection_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("afwIntersection"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of <dataType> with the values that are common to both list of <dataType> list1 and list2."),
    AFW_UTF8_LITERAL("`<dataType>`(list1: list, list2: list): list"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection `<dataType>`(\n    list1: list,\n    list2: list\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_intersection_parameters[0],
    2,
    &impl_intersection_returns,
    &impl_intersection_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- is ---------- */

static const afw_utf8_t
impl_object_path__is =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is");

static const afw_runtime_object_indirect_t
impl_object__is = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is
        }
    },
    (void *)&afw_function_definition_is
};

static const afw_value_function_parameter_t
impl_is_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_parameters[] = {
    &impl_is_parameter_1,
    NULL
};

static const afw_utf8_t
impl_is_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("unevaluated"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("afwIs"),
    AFW_UTF8_LITERAL("Checks whether value is dataType <dataType>"),
    AFW_UTF8_LITERAL("Checks whether value is dataType <dataType> and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType <dataType> */\nfunction is `<dataType>`(\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_parameters[0],
    1,
    &impl_is_returns,
    &impl_is_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    true,
    true,
    false,
    true,
    false
};

/* ---------- is_in ---------- */

static const afw_utf8_t
impl_object_path__is_in =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in");

static const afw_runtime_object_indirect_t
impl_object__is_in = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in
        }
    },
    (void *)&afw_function_definition_is_in
};

static const afw_value_function_parameter_t
impl_is_in_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_is_in_parameters[] = {
    &impl_is_in_parameter_1,
    &impl_is_in_parameter_2,
    NULL
};

static const afw_utf8_t
impl_is_in_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("isIn"),
    AFW_UTF8_LITERAL("afwIsIn"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether <dataType> value is in list of <dataType> list and returns the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, list: list): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in `<dataType>`(\n    value: dataType,\n    list: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_is_in_parameters[0],
    2,
    &impl_is_in_returns,
    &impl_is_in_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- last_index_of ---------- */

static const afw_utf8_t
impl_object_path__last_index_of =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/last_index_of");

static const afw_runtime_object_indirect_t
impl_object__last_index_of = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_last_index_of,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__last_index_of
        }
    },
    (void *)&afw_function_definition_last_index_of
};

static const afw_value_function_parameter_t
impl_last_index_of_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to search."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Substring to search for."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional start index for search if different than start of string."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_last_index_of_parameters[] = {
    &impl_last_index_of_parameter_1,
    &impl_last_index_of_parameter_2,
    &impl_last_index_of_parameter_3,
    NULL
};

static const afw_utf8_t
impl_last_index_of_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_last_index_of = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__last_index_of,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("last_index_of"),
    AFW_UTF8_LITERAL("last_index_of"),
    AFW_UTF8_LITERAL("last_index_of"),
    AFW_UTF8_LITERAL("lastIndexOf"),
    AFW_UTF8_LITERAL("afwLastIndexOf"),
    AFW_UTF8_LITERAL("Returns index of last occurrence"),
    AFW_UTF8_LITERAL("Returns the zero-based index into <dataType> value of the last occurrence of a subString. If subString is not found, -1 is returned."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, subString: string, startIndex?: integer): integer"),
    AFW_UTF8_LITERAL("/* Returns index of last occurrence */\nfunction last_index_of `<dataType>`(\n    value: dataType,\n    subString: string,\n    startIndex?: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    3,
    &impl_last_index_of_parameters[0],
    3,
    &impl_last_index_of_returns,
    &impl_last_index_of_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_last_index_of,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- le ---------- */

static const afw_utf8_t
impl_object_path__le =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le");

static const afw_runtime_object_indirect_t
impl_object__le = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le
        }
    },
    (void *)&afw_function_definition_le
};

static const afw_value_function_parameter_t
impl_le_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_le_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_parameters[] = {
    &impl_le_parameter_1,
    &impl_le_parameter_2,
    NULL
};

static const afw_utf8_t
impl_le_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("afwLe"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for <dataType> arg1 is less than or equal to <dataType> arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le `<dataType>`(\n    arg1: dataType,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_le_parameters[0],
    2,
    &impl_le_returns,
    &impl_le_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- length ---------- */

static const afw_utf8_t
impl_object_path__length =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/length");

static const afw_runtime_object_indirect_t
impl_object__length = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_length,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__length
        }
    },
    (void *)&afw_function_definition_length
};

static const afw_value_function_parameter_t
impl_length_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_length_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Returns the number of entries in a list or code points in others."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_length_parameters[] = {
    &impl_length_parameter_1,
    NULL
};

static const afw_utf8_t
impl_length_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__length,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("length"),
    AFW_UTF8_LITERAL("length"),
    AFW_UTF8_LITERAL("length"),
    AFW_UTF8_LITERAL("length"),
    AFW_UTF8_LITERAL("afwLength"),
    AFW_UTF8_LITERAL("Returns number of codepoints or entries in value"),
    AFW_UTF8_LITERAL("This is a polymorphic function where <dataType> can be any of the supported data types. Return the integer number of entries in datatype list or codepoints in others."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): integer"),
    AFW_UTF8_LITERAL("/* Returns number of codepoints or entries in value */\nfunction length `<dataType>`(\n    value: dataType\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_length_parameters[0],
    1,
    &impl_length_returns,
    &impl_length_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_length,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- lt ---------- */

static const afw_utf8_t
impl_object_path__lt =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt");

static const afw_runtime_object_indirect_t
impl_object__lt = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt
        }
    },
    (void *)&afw_function_definition_lt
};

static const afw_value_function_parameter_t
impl_lt_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_lt_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_parameters[] = {
    &impl_lt_parameter_1,
    &impl_lt_parameter_2,
    NULL
};

static const afw_utf8_t
impl_lt_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("afwLt"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for <dataType> arg1 is less that <dataType> arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: dataType): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt `<dataType>`(\n    arg1: dataType,\n    arg2: dataType\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_lt_parameters[0],
    2,
    &impl_lt_returns,
    &impl_lt_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- match ---------- */

static const afw_utf8_t
impl_object_path__match =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/match");

static const afw_runtime_object_indirect_t
impl_object__match = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_match,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__match
        }
    },
    (void *)&afw_function_definition_match
};

static const afw_value_function_parameter_t
impl_match_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_match_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_match_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_match_parameters[] = {
    &impl_match_parameter_1,
    &impl_match_parameter_2,
    NULL
};

static const afw_utf8_t
impl_match_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("x500Name"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_match = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__match,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL("afwMatch"),
    AFW_UTF8_LITERAL("Checks if x500Name matches"),
    AFW_UTF8_LITERAL("Returns true if arg1 matches some terminal sequence of RDNs from arg2 when compared using equal_<dataType>."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks if x500Name matches */\nfunction match `<dataType>`(\n    arg1: dataType,\n    arg2: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_match_parameters[0],
    2,
    &impl_match_returns,
    &impl_match_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_match,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- max ---------- */

static const afw_utf8_t
impl_object_path__max =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/max");

static const afw_runtime_object_indirect_t
impl_object__max = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_max,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__max
        }
    },
    (void *)&afw_function_definition_max
};

static const afw_value_function_parameter_t
impl_max_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_max_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_max_parameters[] = {
    &impl_max_parameter_1,
    NULL
};

static const afw_utf8_t
impl_max_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__max,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("afwMax"),
    AFW_UTF8_LITERAL("Maximum value"),
    AFW_UTF8_LITERAL("Return the <dataType> value that is greater than or equal to the others."),
    AFW_UTF8_LITERAL("`<dataType>`(values_1: dataType, ...values_rest: (list of dataType)): dataType"),
    AFW_UTF8_LITERAL("/* Maximum value */\nfunction max `<dataType>`(\n    values_1: dataType,\n    ...values_rest: (list of dataType)\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    -1,
    &impl_max_parameters[0],
    1,
    &impl_max_returns,
    &impl_max_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_max,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- min ---------- */

static const afw_utf8_t
impl_object_path__min =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/min");

static const afw_runtime_object_indirect_t
impl_object__min = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_min,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__min
        }
    },
    (void *)&afw_function_definition_min
};

static const afw_value_function_parameter_t
impl_min_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_min_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_min_parameters[] = {
    &impl_min_parameter_1,
    NULL
};

static const afw_utf8_t
impl_min_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__min,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("afwMin"),
    AFW_UTF8_LITERAL("Minimum value"),
    AFW_UTF8_LITERAL("Return the <dataType> value that is less than or equal to the others."),
    AFW_UTF8_LITERAL("`<dataType>`(values_1: dataType, ...values_rest: (list of dataType)): dataType"),
    AFW_UTF8_LITERAL("/* Minimum value */\nfunction min `<dataType>`(\n    values_1: dataType,\n    ...values_rest: (list of dataType)\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    -1,
    &impl_min_parameters[0],
    1,
    &impl_min_returns,
    &impl_min_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_min,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- mod ---------- */

static const afw_utf8_t
impl_object_path__mod =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/mod");

static const afw_runtime_object_indirect_t
impl_object__mod = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_mod,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__mod
        }
    },
    (void *)&afw_function_definition_mod
};

static const afw_value_function_parameter_t
impl_mod_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_mod_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("dividend"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_mod_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("divisor"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_mod_parameters[] = {
    &impl_mod_parameter_1,
    &impl_mod_parameter_2,
    NULL
};

static const afw_utf8_t
impl_mod_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("integer"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_mod = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__mod,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("mod"),
    AFW_UTF8_LITERAL("mod"),
    AFW_UTF8_LITERAL("mod"),
    AFW_UTF8_LITERAL("mod"),
    AFW_UTF8_LITERAL("afwMod"),
    AFW_UTF8_LITERAL("Remainder of dividing numbers"),
    AFW_UTF8_LITERAL("Divide <dataType> dividend by <dataType> divisor and return the <dataType> remainder."),
    AFW_UTF8_LITERAL("`<dataType>`(dividend: dataType, divisor: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Remainder of dividing numbers */\nfunction mod `<dataType>`(\n    dividend: dataType,\n    divisor: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL("%"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_mod_parameters[0],
    2,
    &impl_mod_returns,
    &impl_mod_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_mod,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- multiply ---------- */

static const afw_utf8_t
impl_object_path__multiply =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/multiply");

static const afw_runtime_object_indirect_t
impl_object__multiply = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_multiply,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__multiply
        }
    },
    (void *)&afw_function_definition_multiply
};

static const afw_value_function_parameter_t
impl_multiply_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_multiply_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_multiply_parameters[] = {
    &impl_multiply_parameter_1,
    NULL
};

static const afw_utf8_t
impl_multiply_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_multiply = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__multiply,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("multiply"),
    AFW_UTF8_LITERAL("multiply"),
    AFW_UTF8_LITERAL("multiply"),
    AFW_UTF8_LITERAL("multiply"),
    AFW_UTF8_LITERAL("afwMultiply"),
    AFW_UTF8_LITERAL("Multiply numbers"),
    AFW_UTF8_LITERAL("Multiply 2 or more <dataType> values and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(values_1: dataType, values_2: dataType, ...values_rest: (list of dataType)): dataType"),
    AFW_UTF8_LITERAL("/* Multiply numbers */\nfunction multiply `<dataType>`(\n    values_1: dataType,\n    values_2: dataType,\n    ...values_rest: (list of dataType)\n): dataType;\n"),
    AFW_UTF8_LITERAL("*"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    -1,
    &impl_multiply_parameters[0],
    1,
    &impl_multiply_returns,
    &impl_multiply_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_multiply,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- ne ---------- */

static const afw_utf8_t
impl_object_path__ne =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne");

static const afw_runtime_object_indirect_t
impl_object__ne = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne
        }
    },
    (void *)&afw_function_definition_ne
};

static const afw_value_function_parameter_t
impl_ne_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_ne_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_parameters[] = {
    &impl_ne_parameter_1,
    &impl_ne_parameter_2,
    NULL
};

static const afw_utf8_t
impl_ne_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

static const afw_utf8_z_t *
impl_ne_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("afwNe"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if <dataType> arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne `<dataType>`(\n    arg1: dataType,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_parameters[0],
    2,
    &impl_ne_returns,
    &impl_ne_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_ne_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    true,
    true,
    false,
    true,
    false
};

/* ---------- negative ---------- */

static const afw_utf8_t
impl_object_path__negative =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/negative");

static const afw_runtime_object_indirect_t
impl_object__negative = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_negative,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__negative
        }
    },
    (void *)&afw_function_definition_negative
};

static const afw_value_function_parameter_t
impl_negative_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_negative_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_negative_parameters[] = {
    &impl_negative_parameter_1,
    NULL
};

static const afw_utf8_t
impl_negative_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_negative = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__negative,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("negative"),
    AFW_UTF8_LITERAL("negative"),
    AFW_UTF8_LITERAL("negative"),
    AFW_UTF8_LITERAL("negative"),
    AFW_UTF8_LITERAL("afwNegative"),
    AFW_UTF8_LITERAL("Negative of a number"),
    AFW_UTF8_LITERAL("Return negative of <dataType> value."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Negative of a number */\nfunction negative `<dataType>`(\n    value: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL("-"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_negative_parameters[0],
    1,
    &impl_negative_returns,
    &impl_negative_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_negative,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- nex ---------- */

static const afw_utf8_t
impl_object_path__nex =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex");

static const afw_runtime_object_indirect_t
impl_object__nex = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex
        }
    },
    (void *)&afw_function_definition_nex
};

static const afw_value_function_parameter_t
impl_nex_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_nex_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_parameters[] = {
    &impl_nex_parameter_1,
    &impl_nex_parameter_2,
    NULL
};

static const afw_utf8_t
impl_nex_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("function"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("afwNex"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for <dataType> arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex `<dataType>`(\n    arg1: dataType,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_parameters[0],
    2,
    &impl_nex_returns,
    &impl_nex_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    true,
    true,
    false,
    true,
    false
};

/* ---------- normalize_space ---------- */

static const afw_utf8_t
impl_object_path__normalize_space =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/normalize_space");

static const afw_runtime_object_indirect_t
impl_object__normalize_space = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_normalize_space,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__normalize_space
        }
    },
    (void *)&afw_function_definition_normalize_space
};

static const afw_value_function_parameter_t
impl_normalize_space_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_normalize_space_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_normalize_space_parameters[] = {
    &impl_normalize_space_parameter_1,
    NULL
};

static const afw_utf8_t
impl_normalize_space_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_space = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__normalize_space,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("normalize_space"),
    AFW_UTF8_LITERAL("normalize_space"),
    AFW_UTF8_LITERAL("normalize_space"),
    AFW_UTF8_LITERAL("normalizeSpace"),
    AFW_UTF8_LITERAL("afwNormalizeSpace"),
    AFW_UTF8_LITERAL("Trims whitespace from beginning and end"),
    AFW_UTF8_LITERAL("Remove whitespace from the beginning and end of a <dataType> value."),
    AFW_UTF8_LITERAL("`<dataType>`(string: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Trims whitespace from beginning and end */\nfunction normalize_space `<dataType>`(\n    string: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_normalize_space_parameters[0],
    1,
    &impl_normalize_space_returns,
    &impl_normalize_space_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_normalize_space,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- normalize_to_lower_case ---------- */

static const afw_utf8_t
impl_object_path__normalize_to_lower_case =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/normalize_to_lower_case");

static const afw_runtime_object_indirect_t
impl_object__normalize_to_lower_case = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_normalize_to_lower_case,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__normalize_to_lower_case
        }
    },
    (void *)&afw_function_definition_normalize_to_lower_case
};

static const afw_value_function_parameter_t
impl_normalize_to_lower_case_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_normalize_to_lower_case_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_normalize_to_lower_case_parameters[] = {
    &impl_normalize_to_lower_case_parameter_1,
    NULL
};

static const afw_utf8_t
impl_normalize_to_lower_case_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_to_lower_case = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__normalize_to_lower_case,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("normalize_to_lower_case"),
    AFW_UTF8_LITERAL("normalize_to_lower_case"),
    AFW_UTF8_LITERAL("normalize_to_lower_case"),
    AFW_UTF8_LITERAL("normalizeToLowerCase"),
    AFW_UTF8_LITERAL("afwNormalizeToLowerCase"),
    AFW_UTF8_LITERAL("Converts to lower case"),
    AFW_UTF8_LITERAL("Normalize <dataType> value to lower case and returns <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(string: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Converts to lower case */\nfunction normalize_to_lower_case `<dataType>`(\n    string: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_normalize_to_lower_case_parameters[0],
    1,
    &impl_normalize_to_lower_case_returns,
    &impl_normalize_to_lower_case_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_normalize_to_lower_case,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only ---------- */

static const afw_utf8_t
impl_object_path__one_and_only =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only");

static const afw_runtime_object_indirect_t
impl_object__one_and_only = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only
        }
    },
    (void *)&afw_function_definition_one_and_only
};

static const afw_value_function_parameter_t
impl_one_and_only_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_parameters[] = {
    &impl_one_and_only_parameter_1,
    NULL
};

static const afw_utf8_t
impl_one_and_only_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

static const afw_utf8_z_t *
impl_one_and_only_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("oneAndOnly"),
    AFW_UTF8_LITERAL("afwOneAndOnly"),
    AFW_UTF8_LITERAL("Converts a one value list to a <dataType> value"),
    AFW_UTF8_LITERAL("This converts a list of <dataType> values that contains one value to a single <dataType> value."),
    AFW_UTF8_LITERAL("`<dataType>`(list: (list list)): dataType"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a <dataType> value */\nfunction one_and_only `<dataType>`(\n    list: (list list)\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_one_and_only_parameters[0],
    1,
    &impl_one_and_only_returns,
    &impl_one_and_only_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_one_and_only_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- pow ---------- */

static const afw_utf8_t
impl_object_path__pow =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/pow");

static const afw_runtime_object_indirect_t
impl_object__pow = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_pow,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__pow
        }
    },
    (void *)&afw_function_definition_pow
};

static const afw_value_function_parameter_t
impl_pow_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Base raised to the power."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_pow_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("base"),
    AFW_UTF8_LITERAL("Base value"),
    AFW_UTF8_LITERAL("Base value."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_pow_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("exponent"),
    AFW_UTF8_LITERAL("Exponent value"),
    AFW_UTF8_LITERAL("Exponent value."),
    1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_pow_parameters[] = {
    &impl_pow_parameter_1,
    &impl_pow_parameter_2,
    NULL
};

static const afw_utf8_t
impl_pow_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_pow = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__pow,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("pow"),
    AFW_UTF8_LITERAL("pow"),
    AFW_UTF8_LITERAL("pow"),
    AFW_UTF8_LITERAL("pow"),
    AFW_UTF8_LITERAL("afwPow"),
    AFW_UTF8_LITERAL("Base raised to a power"),
    AFW_UTF8_LITERAL("This returns the value of base raised to a power. Multiple exponents can be specified to raise the previous exponent to the power of the latter exponent."),
    AFW_UTF8_LITERAL("`<dataType>`(base: dataType, exponent_1: dataType, ...exponent_rest: (list of dataType)): dataType"),
    AFW_UTF8_LITERAL("/* Base raised to a power */\nfunction pow `<dataType>`(\n    base: dataType     /* Base value */,\n    exponent_1: dataType,\n    ...exponent_rest: (list of dataType) /* Exponent value */\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    -1,
    &impl_pow_parameters[0],
    2,
    &impl_pow_returns,
    &impl_pow_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_pow,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- regexp_index_of ---------- */

static const afw_utf8_t
impl_object_path__regexp_index_of =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_index_of");

static const afw_runtime_object_indirect_t
impl_object__regexp_index_of = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_index_of,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_index_of
        }
    },
    (void *)&afw_function_definition_regexp_index_of
};

static const afw_value_function_parameter_t
impl_regexp_index_of_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_index_of_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to search."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_index_of_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A regular expression to use for search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_index_of_parameters[] = {
    &impl_regexp_index_of_parameter_1,
    &impl_regexp_index_of_parameter_2,
    NULL
};

static const afw_utf8_t
impl_regexp_index_of_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_index_of = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_index_of,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("regexp_index_of"),
    AFW_UTF8_LITERAL("regexp_index_of"),
    AFW_UTF8_LITERAL("regexp_index_of"),
    AFW_UTF8_LITERAL("regexpIndexOf"),
    AFW_UTF8_LITERAL("afwRegexpIndexOf"),
    AFW_UTF8_LITERAL("Returns index of first match of regular expression"),
    AFW_UTF8_LITERAL("Search <dataType> value for a regular expression and return index. If not found, -1 is returned."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, regexp: string): integer"),
    AFW_UTF8_LITERAL("/* Returns index of first match of regular expression */\nfunction regexp_index_of `<dataType>`(\n    value: dataType,\n    regexp: string\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_regexp_index_of_parameters[0],
    2,
    &impl_regexp_index_of_returns,
    &impl_regexp_index_of_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_index_of,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- regexp_match ---------- */

static const afw_utf8_t
impl_object_path__regexp_match =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_match");

static const afw_runtime_object_indirect_t
impl_object__regexp_match = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_match,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_match
        }
    },
    (void *)&afw_function_definition_regexp_match
};

static const afw_value_function_parameter_t
impl_regexp_match_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_match_parameters[] = {
    &impl_regexp_match_parameter_1,
    &impl_regexp_match_parameter_2,
    NULL
};

static const afw_utf8_t
impl_regexp_match_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("x500Name"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_match,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexpMatch"),
    AFW_UTF8_LITERAL("afwRegexpMatch"),
    AFW_UTF8_LITERAL("Search for a match using a regular expression"),
    AFW_UTF8_LITERAL("Checks whether <dataType> value matches the regular expression regexp and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, regexp: string): boolean"),
    AFW_UTF8_LITERAL("/* Search for a match using a regular expression */\nfunction regexp_match `<dataType>`(\n    value: dataType,\n    regexp: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_regexp_match_parameters[0],
    2,
    &impl_regexp_match_returns,
    &impl_regexp_match_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_match,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- regexp_replace ---------- */

static const afw_utf8_t
impl_object_path__regexp_replace =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_replace");

static const afw_runtime_object_indirect_t
impl_object__regexp_replace = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_replace,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_replace
        }
    },
    (void *)&afw_function_definition_regexp_replace
};

static const afw_value_function_parameter_t
impl_regexp_replace_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A <dataType> value with the matched string(s) replaced."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The original <dataType> value."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A regular expression to use for search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("replacement"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The replacement string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_replace_parameters[] = {
    &impl_regexp_replace_parameter_1,
    &impl_regexp_replace_parameter_2,
    &impl_regexp_replace_parameter_3,
    &impl_regexp_replace_parameter_4,
    NULL
};

static const afw_utf8_t
impl_regexp_replace_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_replace = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_replace,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("regexp_replace"),
    AFW_UTF8_LITERAL("regexp_replace"),
    AFW_UTF8_LITERAL("regexp_replace"),
    AFW_UTF8_LITERAL("regexpReplace"),
    AFW_UTF8_LITERAL("afwRegexpReplace"),
    AFW_UTF8_LITERAL("Replace strings matching a regular expression"),
    AFW_UTF8_LITERAL("Replace matched values for a regular expression in a <dataType> value."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, regexp: string, replacement: string, limit?: integer): dataType"),
    AFW_UTF8_LITERAL("/* Replace strings matching a regular expression */\nfunction regexp_replace `<dataType>`(\n    value: dataType,\n    regexp: string,\n    replacement: string,\n    limit?: integer\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    3,
    4,
    &impl_regexp_replace_parameters[0],
    4,
    &impl_regexp_replace_returns,
    &impl_regexp_replace_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_replace,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- repeat ---------- */

static const afw_utf8_t
impl_object_path__repeat =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/repeat");

static const afw_runtime_object_indirect_t
impl_object__repeat = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_repeat,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__repeat
        }
    },
    (void *)&afw_function_definition_repeat
};

static const afw_value_function_parameter_t
impl_repeat_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The repeated <dataType> value."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_repeat_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to repeat."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_repeat_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("times"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The number of times to repeat the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_repeat_parameters[] = {
    &impl_repeat_parameter_1,
    &impl_repeat_parameter_2,
    NULL
};

static const afw_utf8_t
impl_repeat_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_repeat = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__repeat,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("repeat"),
    AFW_UTF8_LITERAL("repeat"),
    AFW_UTF8_LITERAL("repeat"),
    AFW_UTF8_LITERAL("repeat"),
    AFW_UTF8_LITERAL("afwRepeat"),
    AFW_UTF8_LITERAL("Returns a repeated value"),
    AFW_UTF8_LITERAL("Repeat a <dataType> value a specified number of times."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, times: integer): dataType"),
    AFW_UTF8_LITERAL("/* Returns a repeated value */\nfunction repeat `<dataType>`(\n    value: dataType,\n    times: integer\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_repeat_parameters[0],
    2,
    &impl_repeat_returns,
    &impl_repeat_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_repeat,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- replace ---------- */

static const afw_utf8_t
impl_object_path__replace =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/replace");

static const afw_runtime_object_indirect_t
impl_object__replace = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_replace,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__replace
        }
    },
    (void *)&afw_function_definition_replace
};

static const afw_value_function_parameter_t
impl_replace_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A <dataType> value with the matched string(s) replaced."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_replace_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The original <dataType> value."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_replace_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string to replace."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("replacement"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The replacement string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_replace_parameters[] = {
    &impl_replace_parameter_1,
    &impl_replace_parameter_2,
    &impl_replace_parameter_3,
    &impl_replace_parameter_4,
    NULL
};

static const afw_utf8_t
impl_replace_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__replace,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("replace"),
    AFW_UTF8_LITERAL("replace"),
    AFW_UTF8_LITERAL("replace"),
    AFW_UTF8_LITERAL("replace"),
    AFW_UTF8_LITERAL("afwReplace"),
    AFW_UTF8_LITERAL("Replace strings"),
    AFW_UTF8_LITERAL("Replace string(s) in a <dataType> value."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, match: string, replacement: string, limit?: integer): dataType"),
    AFW_UTF8_LITERAL("/* Replace strings */\nfunction replace `<dataType>`(\n    value: dataType,\n    match: string,\n    replacement: string,\n    limit?: integer\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    3,
    4,
    &impl_replace_parameters[0],
    4,
    &impl_replace_returns,
    &impl_replace_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_replace,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- round ---------- */

static const afw_utf8_t
impl_object_path__round =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/round");

static const afw_runtime_object_indirect_t
impl_object__round = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_round,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__round
        }
    },
    (void *)&afw_function_definition_round
};

static const afw_value_function_parameter_t
impl_round_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_round_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("number"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_round_parameters[] = {
    &impl_round_parameter_1,
    NULL
};

static const afw_utf8_t
impl_round_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_round = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__round,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("round"),
    AFW_UTF8_LITERAL("round"),
    AFW_UTF8_LITERAL("round"),
    AFW_UTF8_LITERAL("round"),
    AFW_UTF8_LITERAL("afwRound"),
    AFW_UTF8_LITERAL("Round to nearest integer"),
    AFW_UTF8_LITERAL("Determine the integer closest to <dataType> value and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(number: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Round to nearest integer */\nfunction round `<dataType>`(\n    number: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_round_parameters[0],
    1,
    &impl_round_returns,
    &impl_round_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_round,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- set_equals ---------- */

static const afw_utf8_t
impl_object_path__set_equals =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals");

static const afw_runtime_object_indirect_t
impl_object__set_equals = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals
        }
    },
    (void *)&afw_function_definition_set_equals
};

static const afw_value_function_parameter_t
impl_set_equals_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t
impl_set_equals_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_set_equals_parameters[] = {
    &impl_set_equals_parameter_1,
    &impl_set_equals_parameter_2,
    NULL
};

static const afw_utf8_t
impl_set_equals_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("setEquals"),
    AFW_UTF8_LITERAL("afwSetEquals"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if <dataType> list1 and <dataType> list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(list1: list, list2: list): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals `<dataType>`(\n    list1: list,\n    list2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_set_equals_parameters[0],
    2,
    &impl_set_equals_returns,
    &impl_set_equals_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- split ---------- */

static const afw_utf8_t
impl_object_path__split =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/split");

static const afw_runtime_object_indirect_t
impl_object__split = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_split,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__split
        }
    },
    (void *)&afw_function_definition_split
};

static const afw_value_function_parameter_t
impl_split_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An list of strings."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The <dataType> value to split."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_split_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("separator"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The separator to use. If this is an empty string or separator is not specified, the value is split between characters."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum number of splits. Any remaining part of value is ignored."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_split_parameters[] = {
    &impl_split_parameter_1,
    &impl_split_parameter_2,
    &impl_split_parameter_3,
    NULL
};

static const afw_utf8_t
impl_split_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_split = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__split,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("split"),
    AFW_UTF8_LITERAL("split"),
    AFW_UTF8_LITERAL("split"),
    AFW_UTF8_LITERAL("split"),
    AFW_UTF8_LITERAL("afwSplit"),
    AFW_UTF8_LITERAL("Split at a separator"),
    AFW_UTF8_LITERAL("Split <dataType> value into an list of strings using a separator."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, separator?: string, limit?: integer): list"),
    AFW_UTF8_LITERAL("/* Split at a separator */\nfunction split `<dataType>`(\n    value: dataType,\n    separator?: string,\n    limit?: integer\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    3,
    &impl_split_parameters[0],
    3,
    &impl_split_returns,
    &impl_split_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_split,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- starts_with ---------- */

static const afw_utf8_t
impl_object_path__starts_with =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/starts_with");

static const afw_runtime_object_indirect_t
impl_object__starts_with = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_starts_with,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__starts_with
        }
    },
    (void *)&afw_function_definition_starts_with
};

static const afw_value_function_parameter_t
impl_starts_with_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_starts_with_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_starts_with_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_starts_with_parameters[] = {
    &impl_starts_with_parameter_1,
    &impl_starts_with_parameter_2,
    NULL
};

static const afw_utf8_t
impl_starts_with_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_starts_with = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__starts_with,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("starts_with"),
    AFW_UTF8_LITERAL("starts_with"),
    AFW_UTF8_LITERAL("starts_with"),
    AFW_UTF8_LITERAL("startsWith"),
    AFW_UTF8_LITERAL("afwStartsWith"),
    AFW_UTF8_LITERAL("Checks whether value starts with a string"),
    AFW_UTF8_LITERAL("Checks whether <dataType> value starts with a subString and return the boolean result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType, subString: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value starts with a string */\nfunction starts_with `<dataType>`(\n    value: dataType,\n    subString: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_starts_with_parameters[0],
    2,
    &impl_starts_with_returns,
    &impl_starts_with_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_starts_with,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- subset ---------- */

static const afw_utf8_t
impl_object_path__subset =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset");

static const afw_runtime_object_indirect_t
impl_object__subset = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset
        }
    },
    (void *)&afw_function_definition_subset
};

static const afw_value_function_parameter_t
impl_subset_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t
impl_subset_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_subset_parameters[] = {
    &impl_subset_parameter_1,
    &impl_subset_parameter_2,
    NULL
};

static const afw_utf8_t
impl_subset_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("afwSubset"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in <dataType> list1 are all in <dataType> list2."),
    AFW_UTF8_LITERAL("`<dataType>`(list1: list, list2: list): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset `<dataType>`(\n    list1: list,\n    list2: list\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_subset_parameters[0],
    2,
    &impl_subset_returns,
    &impl_subset_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- substring ---------- */

static const afw_utf8_t
impl_object_path__substring =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/substring");

static const afw_runtime_object_indirect_t
impl_object__substring = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_substring,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__substring
        }
    },
    (void *)&afw_function_definition_substring
};

static const afw_value_function_parameter_t
impl_substring_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_substring_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_substring_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_substring_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("endIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_substring_parameters[] = {
    &impl_substring_parameter_1,
    &impl_substring_parameter_2,
    &impl_substring_parameter_3,
    NULL
};

static const afw_utf8_t
impl_substring_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_substring_errorsThrown[] = {
    "error", "arg_error",
    "reason", "startIndex or endIndex is out of range",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_substring = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__substring,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("substring"),
    AFW_UTF8_LITERAL("substring"),
    AFW_UTF8_LITERAL("substring"),
    AFW_UTF8_LITERAL("substring"),
    AFW_UTF8_LITERAL("afwSubstring"),
    AFW_UTF8_LITERAL("Extract a substring"),
    AFW_UTF8_LITERAL("Returns the <dataType> substring of value beginning at zero-based position integer startIndex and ending at the position before integer endIndex. Specify -1 or omitting endIndex to return up to end of <dataType>."),
    AFW_UTF8_LITERAL("`<dataType>`(string: dataType, startIndex: integer, endIndex?: integer): dataType"),
    AFW_UTF8_LITERAL("/* Extract a substring */\nfunction substring `<dataType>`(\n    string: dataType,\n    startIndex: integer,\n    endIndex?: integer\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    3,
    &impl_substring_parameters[0],
    3,
    &impl_substring_returns,
    &impl_substring_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_substring_errorsThrown[0],
    NULL,
    afw_data_type_method_number_substring,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- subtract ---------- */

static const afw_utf8_t
impl_object_path__subtract =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract");

static const afw_runtime_object_indirect_t
impl_object__subtract = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract
        }
    },
    (void *)&afw_function_definition_subtract
};

static const afw_value_function_parameter_t
impl_subtract_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_parameters[] = {
    &impl_subtract_parameter_1,
    &impl_subtract_parameter_2,
    NULL
};

static const afw_utf8_t
impl_subtract_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("integer"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("subtract"),
    AFW_UTF8_LITERAL("subtract"),
    AFW_UTF8_LITERAL("subtract"),
    AFW_UTF8_LITERAL("subtract"),
    AFW_UTF8_LITERAL("afwSubtract"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract <dataType> arg2 from <dataType> arg1 and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: dataType): dataType"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract `<dataType>`(\n    arg1: dataType,\n    arg2: dataType\n): dataType;\n"),
    AFW_UTF8_LITERAL("-"),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_subtract_parameters[0],
    2,
    &impl_subtract_returns,
    &impl_subtract_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_subtract,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- subtract_dayTimeDuration ---------- */

static const afw_utf8_t
impl_object_path__subtract_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__subtract_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_subtract_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_subtract_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_dayTimeDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_dayTimeDuration_parameters[] = {
    &impl_subtract_dayTimeDuration_parameter_1,
    &impl_subtract_dayTimeDuration_parameter_2,
    NULL
};

static const afw_utf8_t
impl_subtract_dayTimeDuration_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("dateTime"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract_dayTimeDuration,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("subtract_dayTimeDuration"),
    AFW_UTF8_LITERAL("subtract_dayTimeDuration"),
    AFW_UTF8_LITERAL("subtract_dayTimeDuration"),
    AFW_UTF8_LITERAL("subtractDayTimeDuration"),
    AFW_UTF8_LITERAL("afwSubtractDayTimeDuration"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract dayTimeDuration arg2 from <dataType> arg1 and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: dayTimeDuration): dataType"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract_dayTimeDuration `<dataType>`(\n    arg1: dataType,\n    arg2: dayTimeDuration\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_subtract_dayTimeDuration_parameters[0],
    2,
    &impl_subtract_dayTimeDuration_returns,
    &impl_subtract_dayTimeDuration_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_subtract_dayTimeDuration,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- subtract_yearMonthDuration ---------- */

static const afw_utf8_t
impl_object_path__subtract_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subtract_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__subtract_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subtract_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subtract_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_subtract_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t
impl_subtract_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subtract_yearMonthDuration_parameters[] = {
    &impl_subtract_yearMonthDuration_parameter_1,
    &impl_subtract_yearMonthDuration_parameter_2,
    NULL
};

static const afw_utf8_t
impl_subtract_yearMonthDuration_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subtract_yearMonthDuration,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration"),
    AFW_UTF8_LITERAL("subtract_yearMonthDuration"),
    AFW_UTF8_LITERAL("subtractYearMonthDuration"),
    AFW_UTF8_LITERAL("afwSubtractYearMonthDuration"),
    AFW_UTF8_LITERAL("Subtract numbers"),
    AFW_UTF8_LITERAL("Subtract yearMonthDuration arg2 from <dataType> arg1 and return the <dataType> result."),
    AFW_UTF8_LITERAL("`<dataType>`(arg1: dataType, arg2: yearMonthDuration): dataType"),
    AFW_UTF8_LITERAL("/* Subtract numbers */\nfunction subtract_yearMonthDuration `<dataType>`(\n    arg1: dataType,\n    arg2: yearMonthDuration\n): dataType;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    2,
    &impl_subtract_yearMonthDuration_parameters[0],
    2,
    &impl_subtract_yearMonthDuration_returns,
    &impl_subtract_yearMonthDuration_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_subtract_yearMonthDuration,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_anyURI ---------- */

static const afw_utf8_t
impl_object_path__to_anyURI =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_anyURI");

static const afw_runtime_object_indirect_t
impl_object__to_anyURI = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_anyURI,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_anyURI
        }
    },
    (void *)&afw_function_definition_to_anyURI
};

static const afw_value_function_parameter_t
impl_to_anyURI_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_anyURI_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_anyURI_parameters[] = {
    &impl_to_anyURI_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_anyURI_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_anyURI_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_anyURI = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_anyURI,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_anyURI"),
    AFW_UTF8_LITERAL("to_anyURI"),
    AFW_UTF8_LITERAL("to_anyURI"),
    AFW_UTF8_LITERAL("toAnyURI"),
    AFW_UTF8_LITERAL("afwToAnyURI"),
    AFW_UTF8_LITERAL("Converts string to anyURI"),
    AFW_UTF8_LITERAL("Converts <dataType> value to anyURI."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): anyURI"),
    AFW_UTF8_LITERAL("/* Converts string to anyURI */\nfunction to_anyURI `<dataType>`(\n    value: dataType\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_anyURI_parameters[0],
    1,
    &impl_to_anyURI_returns,
    &impl_to_anyURI_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_anyURI_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_anyURI,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_boolean ---------- */

static const afw_utf8_t
impl_object_path__to_boolean =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_boolean");

static const afw_runtime_object_indirect_t
impl_object__to_boolean = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_boolean,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_boolean
        }
    },
    (void *)&afw_function_definition_to_boolean
};

static const afw_value_function_parameter_t
impl_to_boolean_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_boolean_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_boolean_parameters[] = {
    &impl_to_boolean_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_boolean_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_boolean_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_boolean = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_boolean,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_boolean"),
    AFW_UTF8_LITERAL("to_boolean"),
    AFW_UTF8_LITERAL("to_boolean"),
    AFW_UTF8_LITERAL("toBoolean"),
    AFW_UTF8_LITERAL("afwToBoolean"),
    AFW_UTF8_LITERAL("Converts string to boolean"),
    AFW_UTF8_LITERAL("Converts <dataType> value to boolean."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): boolean"),
    AFW_UTF8_LITERAL("/* Converts string to boolean */\nfunction to_boolean `<dataType>`(\n    value: dataType\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_boolean_parameters[0],
    1,
    &impl_to_boolean_returns,
    &impl_to_boolean_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_boolean_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_boolean,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_date ---------- */

static const afw_utf8_t
impl_object_path__to_date =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_date");

static const afw_runtime_object_indirect_t
impl_object__to_date = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_date,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_date
        }
    },
    (void *)&afw_function_definition_to_date
};

static const afw_value_function_parameter_t
impl_to_date_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_date_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_date_parameters[] = {
    &impl_to_date_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_date_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_date_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_date = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_date,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_date"),
    AFW_UTF8_LITERAL("to_date"),
    AFW_UTF8_LITERAL("to_date"),
    AFW_UTF8_LITERAL("toDate"),
    AFW_UTF8_LITERAL("afwToDate"),
    AFW_UTF8_LITERAL("Converts string to date"),
    AFW_UTF8_LITERAL("Converts <dataType> value to date."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): date"),
    AFW_UTF8_LITERAL("/* Converts string to date */\nfunction to_date `<dataType>`(\n    value: dataType\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_date_parameters[0],
    1,
    &impl_to_date_returns,
    &impl_to_date_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_date_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_date,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_dateTime ---------- */

static const afw_utf8_t
impl_object_path__to_dateTime =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_dateTime");

static const afw_runtime_object_indirect_t
impl_object__to_dateTime = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_dateTime,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_dateTime
        }
    },
    (void *)&afw_function_definition_to_dateTime
};

static const afw_value_function_parameter_t
impl_to_dateTime_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_dateTime_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_dateTime_parameters[] = {
    &impl_to_dateTime_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_dateTime_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_dateTime_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dateTime = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_dateTime,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_dateTime"),
    AFW_UTF8_LITERAL("to_dateTime"),
    AFW_UTF8_LITERAL("to_dateTime"),
    AFW_UTF8_LITERAL("toDateTime"),
    AFW_UTF8_LITERAL("afwToDateTime"),
    AFW_UTF8_LITERAL("Converts string to dateTime"),
    AFW_UTF8_LITERAL("Converts <dataType> value to dateTime."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): dateTime"),
    AFW_UTF8_LITERAL("/* Converts string to dateTime */\nfunction to_dateTime `<dataType>`(\n    value: dataType\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_dateTime_parameters[0],
    1,
    &impl_to_dateTime_returns,
    &impl_to_dateTime_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_dateTime_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_dateTime,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_dayTimeDuration ---------- */

static const afw_utf8_t
impl_object_path__to_dayTimeDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_dayTimeDuration");

static const afw_runtime_object_indirect_t
impl_object__to_dayTimeDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_dayTimeDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_dayTimeDuration
        }
    },
    (void *)&afw_function_definition_to_dayTimeDuration
};

static const afw_value_function_parameter_t
impl_to_dayTimeDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_dayTimeDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_dayTimeDuration_parameters[] = {
    &impl_to_dayTimeDuration_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_dayTimeDuration_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_dayTimeDuration_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dayTimeDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_dayTimeDuration,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_dayTimeDuration"),
    AFW_UTF8_LITERAL("to_dayTimeDuration"),
    AFW_UTF8_LITERAL("to_dayTimeDuration"),
    AFW_UTF8_LITERAL("toDayTimeDuration"),
    AFW_UTF8_LITERAL("afwToDayTimeDuration"),
    AFW_UTF8_LITERAL("Converts string to dayTimeDuration"),
    AFW_UTF8_LITERAL("Converts <dataType> value to dayTimeDuration."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): dayTimeDuration"),
    AFW_UTF8_LITERAL("/* Converts string to dayTimeDuration */\nfunction to_dayTimeDuration `<dataType>`(\n    value: dataType\n): dayTimeDuration;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_dayTimeDuration_parameters[0],
    1,
    &impl_to_dayTimeDuration_returns,
    &impl_to_dayTimeDuration_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_dayTimeDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_dayTimeDuration,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_dnsName ---------- */

static const afw_utf8_t
impl_object_path__to_dnsName =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_dnsName");

static const afw_runtime_object_indirect_t
impl_object__to_dnsName = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_dnsName,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_dnsName
        }
    },
    (void *)&afw_function_definition_to_dnsName
};

static const afw_value_function_parameter_t
impl_to_dnsName_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_dnsName_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_dnsName_parameters[] = {
    &impl_to_dnsName_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_dnsName_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_dnsName_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dnsName = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_dnsName,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_dnsName"),
    AFW_UTF8_LITERAL("to_dnsName"),
    AFW_UTF8_LITERAL("to_dnsName"),
    AFW_UTF8_LITERAL("toDnsName"),
    AFW_UTF8_LITERAL("afwToDnsName"),
    AFW_UTF8_LITERAL("Converts string to dnsName"),
    AFW_UTF8_LITERAL("Converts <dataType> value to dnsName."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): dnsName"),
    AFW_UTF8_LITERAL("/* Converts string to dnsName */\nfunction to_dnsName `<dataType>`(\n    value: dataType\n): dnsName;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_dnsName_parameters[0],
    1,
    &impl_to_dnsName_returns,
    &impl_to_dnsName_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_dnsName_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_dnsName,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_double ---------- */

static const afw_utf8_t
impl_object_path__to_double =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_double");

static const afw_runtime_object_indirect_t
impl_object__to_double = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_double,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_double
        }
    },
    (void *)&afw_function_definition_to_double
};

static const afw_value_function_parameter_t
impl_to_double_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_double_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_double_parameters[] = {
    &impl_to_double_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_double_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_double_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_double = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_double,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_double"),
    AFW_UTF8_LITERAL("to_double"),
    AFW_UTF8_LITERAL("to_double"),
    AFW_UTF8_LITERAL("toDouble"),
    AFW_UTF8_LITERAL("afwToDouble"),
    AFW_UTF8_LITERAL("Converts to double"),
    AFW_UTF8_LITERAL("Converts <dataType> value to double and returns double result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): double"),
    AFW_UTF8_LITERAL("/* Converts to double */\nfunction to_double `<dataType>`(\n    value: dataType\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_double_parameters[0],
    1,
    &impl_to_double_returns,
    &impl_to_double_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_double_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_double,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_integer ---------- */

static const afw_utf8_t
impl_object_path__to_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_integer");

static const afw_runtime_object_indirect_t
impl_object__to_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_integer
        }
    },
    (void *)&afw_function_definition_to_integer
};

static const afw_value_function_parameter_t
impl_to_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_integer_parameters[] = {
    &impl_to_integer_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_integer_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_integer,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_integer"),
    AFW_UTF8_LITERAL("to_integer"),
    AFW_UTF8_LITERAL("to_integer"),
    AFW_UTF8_LITERAL("toInteger"),
    AFW_UTF8_LITERAL("afwToInteger"),
    AFW_UTF8_LITERAL("Converts to integer"),
    AFW_UTF8_LITERAL("Truncate <dataType> value to a whole number and returns integer result."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): integer"),
    AFW_UTF8_LITERAL("/* Converts to integer */\nfunction to_integer `<dataType>`(\n    value: dataType\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_integer_parameters[0],
    1,
    &impl_to_integer_returns,
    &impl_to_integer_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_to_integer,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_ipAddress ---------- */

static const afw_utf8_t
impl_object_path__to_ipAddress =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_ipAddress");

static const afw_runtime_object_indirect_t
impl_object__to_ipAddress = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_ipAddress,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_ipAddress
        }
    },
    (void *)&afw_function_definition_to_ipAddress
};

static const afw_value_function_parameter_t
impl_to_ipAddress_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_ipAddress_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_ipAddress_parameters[] = {
    &impl_to_ipAddress_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_ipAddress_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_ipAddress_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_ipAddress = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_ipAddress,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_ipAddress"),
    AFW_UTF8_LITERAL("to_ipAddress"),
    AFW_UTF8_LITERAL("to_ipAddress"),
    AFW_UTF8_LITERAL("toIpAddress"),
    AFW_UTF8_LITERAL("afwToIpAddress"),
    AFW_UTF8_LITERAL("Converts string to ipAddress"),
    AFW_UTF8_LITERAL("Converts <dataType> value to ipAddress."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): ipAddress"),
    AFW_UTF8_LITERAL("/* Converts string to ipAddress */\nfunction to_ipAddress `<dataType>`(\n    value: dataType\n): ipAddress;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_ipAddress_parameters[0],
    1,
    &impl_to_ipAddress_returns,
    &impl_to_ipAddress_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_ipAddress_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_ipAddress,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_rfc822Name ---------- */

static const afw_utf8_t
impl_object_path__to_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__to_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_rfc822Name
        }
    },
    (void *)&afw_function_definition_to_rfc822Name
};

static const afw_value_function_parameter_t
impl_to_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_rfc822Name_parameters[] = {
    &impl_to_rfc822Name_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_rfc822Name_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_rfc822Name_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_rfc822Name,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_rfc822Name"),
    AFW_UTF8_LITERAL("to_rfc822Name"),
    AFW_UTF8_LITERAL("to_rfc822Name"),
    AFW_UTF8_LITERAL("toRfc822Name"),
    AFW_UTF8_LITERAL("afwToRfc822Name"),
    AFW_UTF8_LITERAL("Converts string to rfc822Name"),
    AFW_UTF8_LITERAL("Converts <dataType> value to rfc822Name."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): rfc822Name"),
    AFW_UTF8_LITERAL("/* Converts string to rfc822Name */\nfunction to_rfc822Name `<dataType>`(\n    value: dataType\n): rfc822Name;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_rfc822Name_parameters[0],
    1,
    &impl_to_rfc822Name_returns,
    &impl_to_rfc822Name_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_rfc822Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_rfc822Name,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_string ---------- */

static const afw_utf8_t
impl_object_path__to_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string");

static const afw_runtime_object_indirect_t
impl_object__to_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string
        }
    },
    (void *)&afw_function_definition_to_string
};

static const afw_value_function_parameter_t
impl_to_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A <dataType> value."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_parameters[] = {
    &impl_to_string_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_string_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("expression"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("hybrid"),
    AFW_UTF8_LITERAL("ia5String"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("objectId"),
    AFW_UTF8_LITERAL("objectPath"),
    AFW_UTF8_LITERAL("password"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("toString"),
    AFW_UTF8_LITERAL("afwToString"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts <dataType> value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string `<dataType>`(\n    value: dataType\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_string_parameters[0],
    1,
    &impl_to_string_returns,
    &impl_to_string_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_time ---------- */

static const afw_utf8_t
impl_object_path__to_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_time");

static const afw_runtime_object_indirect_t
impl_object__to_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_time
        }
    },
    (void *)&afw_function_definition_to_time
};

static const afw_value_function_parameter_t
impl_to_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_time_parameters[] = {
    &impl_to_time_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_time_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_time_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_time,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_time"),
    AFW_UTF8_LITERAL("to_time"),
    AFW_UTF8_LITERAL("to_time"),
    AFW_UTF8_LITERAL("toTime"),
    AFW_UTF8_LITERAL("afwToTime"),
    AFW_UTF8_LITERAL("Converts string to time"),
    AFW_UTF8_LITERAL("Converts <dataType> value to time."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): time"),
    AFW_UTF8_LITERAL("/* Converts string to time */\nfunction to_time `<dataType>`(\n    value: dataType\n): time;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_time_parameters[0],
    1,
    &impl_to_time_returns,
    &impl_to_time_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_time_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_time,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_x500Name ---------- */

static const afw_utf8_t
impl_object_path__to_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_x500Name");

static const afw_runtime_object_indirect_t
impl_object__to_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_x500Name
        }
    },
    (void *)&afw_function_definition_to_x500Name
};

static const afw_value_function_parameter_t
impl_to_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_x500Name_parameters[] = {
    &impl_to_x500Name_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_x500Name_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_x500Name_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_x500Name,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_x500Name"),
    AFW_UTF8_LITERAL("to_x500Name"),
    AFW_UTF8_LITERAL("to_x500Name"),
    AFW_UTF8_LITERAL("toX500Name"),
    AFW_UTF8_LITERAL("afwToX500Name"),
    AFW_UTF8_LITERAL("Converts string to x500Name"),
    AFW_UTF8_LITERAL("Converts <dataType> value to x500Name."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): x500Name"),
    AFW_UTF8_LITERAL("/* Converts string to x500Name */\nfunction to_x500Name `<dataType>`(\n    value: dataType\n): x500Name;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_x500Name_parameters[0],
    1,
    &impl_to_x500Name_returns,
    &impl_to_x500Name_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_x500Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_x500Name,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- to_yearMonthDuration ---------- */

static const afw_utf8_t
impl_object_path__to_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__to_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_to_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_to_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_to_yearMonthDuration_parameters[] = {
    &impl_to_yearMonthDuration_parameter_1,
    NULL
};

static const afw_utf8_t
impl_to_yearMonthDuration_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    { NULL }
};

static const afw_utf8_z_t *
impl_to_yearMonthDuration_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_yearMonthDuration,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("to_yearMonthDuration"),
    AFW_UTF8_LITERAL("to_yearMonthDuration"),
    AFW_UTF8_LITERAL("to_yearMonthDuration"),
    AFW_UTF8_LITERAL("toYearMonthDuration"),
    AFW_UTF8_LITERAL("afwToYearMonthDuration"),
    AFW_UTF8_LITERAL("Converts string to yearMonthDuration"),
    AFW_UTF8_LITERAL("Converts <dataType> value to yearMonthDuration."),
    AFW_UTF8_LITERAL("`<dataType>`(value: dataType): yearMonthDuration"),
    AFW_UTF8_LITERAL("/* Converts string to yearMonthDuration */\nfunction to_yearMonthDuration `<dataType>`(\n    value: dataType\n): yearMonthDuration;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_to_yearMonthDuration_parameters[0],
    1,
    &impl_to_yearMonthDuration_returns,
    &impl_to_yearMonthDuration_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_to_yearMonthDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_yearMonthDuration,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- union ---------- */

static const afw_utf8_t
impl_object_path__union =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union");

static const afw_runtime_object_indirect_t
impl_object__union = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union
        }
    },
    (void *)&afw_function_definition_union
};

static const afw_value_function_parameter_t
impl_union_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t
impl_union_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    true,
};

static const afw_value_function_parameter_t *
impl_union_parameters[] = {
    &impl_union_parameter_1,
    NULL
};

static const afw_utf8_t
impl_union_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("afwUnion"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of <dataType> contains all of the unique values in two or more list of <dataType> values."),
    AFW_UTF8_LITERAL("`<dataType>`(lists_1: list, lists_2: list, ...lists_rest: (list of list)): list"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union `<dataType>`(\n    lists_1: list,\n    lists_2: list,\n    ...lists_rest: (list of list)\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    2,
    -1,
    &impl_union_parameters[0],
    1,
    &impl_union_returns,
    &impl_union_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- url_encode ---------- */

static const afw_utf8_t
impl_object_path__url_encode =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/url_encode");

static const afw_runtime_object_indirect_t
impl_object__url_encode = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_url_encode,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__url_encode
        }
    },
    (void *)&afw_function_definition_url_encode
};

static const afw_value_function_parameter_t
impl_url_encode_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI encoded string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_url_encode_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("unencoded"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URL encode a single value. See the url_encode method for the data type of more details."),
    -1,
    false,
    false,
    true,
    false,
};

static const afw_value_function_parameter_t *
impl_url_encode_parameters[] = {
    &impl_url_encode_parameter_1,
    NULL
};

static const afw_utf8_t
impl_url_encode_polymorphicDataTypes[] = {
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("anyURI"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_encode = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__url_encode,
    AFW_UTF8_LITERAL("polymorphic"),
    AFW_UTF8_LITERAL("url_encode"),
    AFW_UTF8_LITERAL("url_encode"),
    AFW_UTF8_LITERAL("url_encode"),
    AFW_UTF8_LITERAL("urlEncode"),
    AFW_UTF8_LITERAL("afwUrlEncode"),
    AFW_UTF8_LITERAL("URI encode"),
    AFW_UTF8_LITERAL("URL encode a value or bag of values."),
    AFW_UTF8_LITERAL("`<dataType>`(unencoded: dataType): string"),
    AFW_UTF8_LITERAL("/* URI encode */\nfunction url_encode `<dataType>`(\n    unencoded: dataType\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING,
    NULL,
    1,
    1,
    &impl_url_encode_parameters[0],
    1,
    &impl_url_encode_returns,
    &impl_url_encode_polymorphicDataTypes[0],
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    afw_data_type_method_number_url_encode,
    0,
    true,
    false,
    false,
    true,
    false
};

/* ---------- random_base64Binary ---------- */

static const afw_utf8_t
impl_object_path__random_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/random_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__random_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_random_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__random_base64Binary
        }
    },
    (void *)&afw_function_definition_random_base64Binary
};

static const afw_value_function_parameter_t
impl_random_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_random_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("numberOfOctets"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The number of random octets to generate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_random_base64Binary_parameters[] = {
    &impl_random_base64Binary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__random_base64Binary,
    AFW_UTF8_LITERAL("random"),
    AFW_UTF8_LITERAL("random_base64Binary"),
    AFW_UTF8_LITERAL("random_base64Binary"),
    AFW_UTF8_LITERAL("random_base64Binary"),
    AFW_UTF8_LITERAL("randomBase64Binary"),
    AFW_UTF8_LITERAL("afwRandomBase64Binary"),
    AFW_UTF8_LITERAL("Generate random octets (base64Binary)"),
    AFW_UTF8_LITERAL("This returns a specified number of random octets as dataType base64Binary."),
    AFW_UTF8_LITERAL("(numberOfOctets: integer): base64Binary"),
    AFW_UTF8_LITERAL("/* Generate random octets (base64Binary) */\nfunction random_base64Binary (\n    numberOfOctets: integer\n): base64Binary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_random_base64Binary,
    NULL,
    1,
    1,
    &impl_random_base64Binary_parameters[0],
    1,
    &impl_random_base64Binary_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- random_digits ---------- */

static const afw_utf8_t
impl_object_path__random_digits =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/random_digits");

static const afw_runtime_object_indirect_t
impl_object__random_digits = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_random_digits,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__random_digits
        }
    },
    (void *)&afw_function_definition_random_digits
};

static const afw_value_function_parameter_t
impl_random_digits_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_random_digits_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("numberOfDigits"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The number (1-18) of digits to generate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_random_digits_parameters[] = {
    &impl_random_digits_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_digits = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__random_digits,
    AFW_UTF8_LITERAL("random"),
    AFW_UTF8_LITERAL("random_digits"),
    AFW_UTF8_LITERAL("random_digits"),
    AFW_UTF8_LITERAL("random_digits"),
    AFW_UTF8_LITERAL("randomDigits"),
    AFW_UTF8_LITERAL("afwRandomDigits"),
    AFW_UTF8_LITERAL("Generate random decimal digits"),
    AFW_UTF8_LITERAL("Generate a string containing a specified number of random decimal digits."),
    AFW_UTF8_LITERAL("(numberOfDigits: integer): string"),
    AFW_UTF8_LITERAL("/* Generate random decimal digits */\nfunction random_digits (\n    numberOfDigits: integer\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_random_digits,
    NULL,
    1,
    1,
    &impl_random_digits_parameters[0],
    1,
    &impl_random_digits_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- random_hexBinary ---------- */

static const afw_utf8_t
impl_object_path__random_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/random_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__random_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_random_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__random_hexBinary
        }
    },
    (void *)&afw_function_definition_random_hexBinary
};

static const afw_value_function_parameter_t
impl_random_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_random_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("numberOfOctets"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The number of random octets to generate."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_random_hexBinary_parameters[] = {
    &impl_random_hexBinary_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__random_hexBinary,
    AFW_UTF8_LITERAL("random"),
    AFW_UTF8_LITERAL("random_hexBinary"),
    AFW_UTF8_LITERAL("random_hexBinary"),
    AFW_UTF8_LITERAL("random_hexBinary"),
    AFW_UTF8_LITERAL("randomHexBinary"),
    AFW_UTF8_LITERAL("afwRandomHexBinary"),
    AFW_UTF8_LITERAL("Generate random octets (hexBinary)"),
    AFW_UTF8_LITERAL("This returns a specified number of random octets as dataType hexBinary."),
    AFW_UTF8_LITERAL("(numberOfOctets: integer): hexBinary"),
    AFW_UTF8_LITERAL("/* Generate random octets (hexBinary) */\nfunction random_hexBinary (\n    numberOfOctets: integer\n): hexBinary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_random_hexBinary,
    NULL,
    1,
    1,
    &impl_random_hexBinary_parameters[0],
    1,
    &impl_random_hexBinary_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- random_integer ---------- */

static const afw_utf8_t
impl_object_path__random_integer =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/random_integer");

static const afw_runtime_object_indirect_t
impl_object__random_integer = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_random_integer,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__random_integer
        }
    },
    (void *)&afw_function_definition_random_integer
};

static const afw_value_function_parameter_t
impl_random_integer_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A random integer."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_random_integer_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Minimum integer inclusive."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_random_integer_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Maximum integer inclusive."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_random_integer_parameters[] = {
    &impl_random_integer_parameter_1,
    &impl_random_integer_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_integer = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__random_integer,
    AFW_UTF8_LITERAL("random"),
    AFW_UTF8_LITERAL("random_integer"),
    AFW_UTF8_LITERAL("random_integer"),
    AFW_UTF8_LITERAL("random_integer"),
    AFW_UTF8_LITERAL("randomInteger"),
    AFW_UTF8_LITERAL("afwRandomInteger"),
    AFW_UTF8_LITERAL("Generate a random integer between specified values"),
    AFW_UTF8_LITERAL("This returns a random integer between specified values inclusive."),
    AFW_UTF8_LITERAL("(min: integer, max: integer): integer"),
    AFW_UTF8_LITERAL("/* Generate a random integer between specified values */\nfunction random_integer (\n    min: integer,\n    max: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_random_integer,
    NULL,
    2,
    2,
    &impl_random_integer_parameters[0],
    2,
    &impl_random_integer_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- random_number ---------- */

static const afw_utf8_t
impl_object_path__random_number =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/random_number");

static const afw_runtime_object_indirect_t
impl_object__random_number = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_random_number,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__random_number
        }
    },
    (void *)&afw_function_definition_random_number
};

static const afw_value_function_parameter_t
impl_random_number_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_random_number_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Minimum double inclusive. The default is 0.0."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_random_number_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Maximum double exclusive. The default is 1.0."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_random_number_parameters[] = {
    &impl_random_number_parameter_1,
    &impl_random_number_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_number = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__random_number,
    AFW_UTF8_LITERAL("random"),
    AFW_UTF8_LITERAL("random_number"),
    AFW_UTF8_LITERAL("random_number"),
    AFW_UTF8_LITERAL("random_number"),
    AFW_UTF8_LITERAL("randomNumber"),
    AFW_UTF8_LITERAL("afwRandomNumber"),
    AFW_UTF8_LITERAL("Generate a random number between specified values"),
    AFW_UTF8_LITERAL("This returns a random double between specified values"),
    AFW_UTF8_LITERAL("(min?: double, max?: double): double"),
    AFW_UTF8_LITERAL("/* Generate a random number between specified values */\nfunction random_number (\n    min?: double,\n    max?: double\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_random_number,
    NULL,
    0,
    2,
    &impl_random_number_parameters[0],
    2,
    &impl_random_number_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- compile<regexp> ---------- */

static const afw_utf8_t
impl_object_path__compile_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_regexp");

static const afw_runtime_object_indirect_t
impl_object__compile_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_regexp
        }
    },
    (void *)&afw_function_definition_compile_regexp
};

static const afw_value_function_parameter_t
impl_compile_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to compile"),
    AFW_UTF8_LITERAL("regexp string to compile"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL("Listing option"),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_regexp_parameters[] = {
    &impl_compile_regexp_parameter_1,
    &impl_compile_regexp_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("compile<regexp>"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile_regexp"),
    AFW_UTF8_LITERAL("compileRegexp"),
    AFW_UTF8_LITERAL("afwCompileRegexp"),
    AFW_UTF8_LITERAL("Compile regexp value"),
    AFW_UTF8_LITERAL("Compile regexp value and return either an unevaluated adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(source: regexp, listing?: any): unevaluated"),
    AFW_UTF8_LITERAL("/* Compile regexp value */\nfunction compile<regexp> (\n    source: regexp /* Source to compile */,\n    listing?: any  /* Listing option */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_regexp,
    NULL,
    1,
    2,
    &impl_compile_regexp_parameters[0],
    2,
    &impl_compile_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    NULL,
    NULL,
    afw_data_type_method_number_compile,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<regexp> ---------- */

static const afw_utf8_t
impl_object_path__eq_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_regexp");

static const afw_runtime_object_indirect_t
impl_object__eq_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_regexp
        }
    },
    (void *)&afw_function_definition_eq_regexp
};

static const afw_value_function_parameter_t
impl_eq_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_regexp_parameters[] = {
    &impl_eq_regexp_parameter_1,
    &impl_eq_regexp_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_regexp_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("eq<regexp>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_regexp"),
    AFW_UTF8_LITERAL("eqRegexp"),
    AFW_UTF8_LITERAL("afwEqRegexp"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if regexp arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<regexp> (\n    arg1: regexp,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_regexp_parameters[0],
    2,
    &impl_eq_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    &impl_eq_regexp_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<regexp> ---------- */

static const afw_utf8_t
impl_object_path__eqx_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_regexp");

static const afw_runtime_object_indirect_t
impl_object__eqx_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_regexp
        }
    },
    (void *)&afw_function_definition_eqx_regexp
};

static const afw_value_function_parameter_t
impl_eqx_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_regexp_parameters[] = {
    &impl_eqx_regexp_parameter_1,
    &impl_eqx_regexp_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("eqx<regexp>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_regexp"),
    AFW_UTF8_LITERAL("eqxRegexp"),
    AFW_UTF8_LITERAL("afwEqxRegexp"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for regexp arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<regexp> (\n    arg1: regexp,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_regexp_parameters[0],
    2,
    &impl_eqx_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<regexp> ---------- */

static const afw_utf8_t
impl_object_path__ge_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_regexp");

static const afw_runtime_object_indirect_t
impl_object__ge_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_regexp
        }
    },
    (void *)&afw_function_definition_ge_regexp
};

static const afw_value_function_parameter_t
impl_ge_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_regexp_parameters[] = {
    &impl_ge_regexp_parameter_1,
    &impl_ge_regexp_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("ge<regexp>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_regexp"),
    AFW_UTF8_LITERAL("geRegexp"),
    AFW_UTF8_LITERAL("afwGeRegexp"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for regexp arg1 is greater than or equal to regexp arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: regexp): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<regexp> (\n    arg1: regexp,\n    arg2: regexp\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_regexp_parameters[0],
    2,
    &impl_ge_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<regexp> ---------- */

static const afw_utf8_t
impl_object_path__gt_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_regexp");

static const afw_runtime_object_indirect_t
impl_object__gt_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_regexp
        }
    },
    (void *)&afw_function_definition_gt_regexp
};

static const afw_value_function_parameter_t
impl_gt_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_regexp_parameters[] = {
    &impl_gt_regexp_parameter_1,
    &impl_gt_regexp_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("gt<regexp>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_regexp"),
    AFW_UTF8_LITERAL("gtRegexp"),
    AFW_UTF8_LITERAL("afwGtRegexp"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for regexp arg1 is greater than regexp arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: regexp): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<regexp> (\n    arg1: regexp,\n    arg2: regexp\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_regexp_parameters[0],
    2,
    &impl_gt_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<regexp> ---------- */

static const afw_utf8_t
impl_object_path__le_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_regexp");

static const afw_runtime_object_indirect_t
impl_object__le_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_regexp
        }
    },
    (void *)&afw_function_definition_le_regexp
};

static const afw_value_function_parameter_t
impl_le_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_regexp_parameters[] = {
    &impl_le_regexp_parameter_1,
    &impl_le_regexp_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("le<regexp>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_regexp"),
    AFW_UTF8_LITERAL("leRegexp"),
    AFW_UTF8_LITERAL("afwLeRegexp"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for regexp arg1 is less than or equal to regexp arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<regexp> (\n    arg1: regexp,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_regexp_parameters[0],
    2,
    &impl_le_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<regexp> ---------- */

static const afw_utf8_t
impl_object_path__lt_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_regexp");

static const afw_runtime_object_indirect_t
impl_object__lt_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_regexp
        }
    },
    (void *)&afw_function_definition_lt_regexp
};

static const afw_value_function_parameter_t
impl_lt_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_regexp_parameters[] = {
    &impl_lt_regexp_parameter_1,
    &impl_lt_regexp_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("lt<regexp>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_regexp"),
    AFW_UTF8_LITERAL("ltRegexp"),
    AFW_UTF8_LITERAL("afwLtRegexp"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for regexp arg1 is less that regexp arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: regexp): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<regexp> (\n    arg1: regexp,\n    arg2: regexp\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_regexp_parameters[0],
    2,
    &impl_lt_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<regexp> ---------- */

static const afw_utf8_t
impl_object_path__ne_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_regexp");

static const afw_runtime_object_indirect_t
impl_object__ne_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_regexp
        }
    },
    (void *)&afw_function_definition_ne_regexp
};

static const afw_value_function_parameter_t
impl_ne_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_regexp_parameters[] = {
    &impl_ne_regexp_parameter_1,
    &impl_ne_regexp_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_regexp_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("ne<regexp>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_regexp"),
    AFW_UTF8_LITERAL("neRegexp"),
    AFW_UTF8_LITERAL("afwNeRegexp"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if regexp arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<regexp> (\n    arg1: regexp,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_regexp_parameters[0],
    2,
    &impl_ne_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    &impl_ne_regexp_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<regexp> ---------- */

static const afw_utf8_t
impl_object_path__nex_regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_regexp");

static const afw_runtime_object_indirect_t
impl_object__nex_regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_regexp
        }
    },
    (void *)&afw_function_definition_nex_regexp
};

static const afw_value_function_parameter_t
impl_nex_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_regexp_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_regexp_parameters[] = {
    &impl_nex_regexp_parameter_1,
    &impl_nex_regexp_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("nex<regexp>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_regexp"),
    AFW_UTF8_LITERAL("nexRegexp"),
    AFW_UTF8_LITERAL("afwNexRegexp"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for regexp arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: regexp, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<regexp> (\n    arg1: regexp,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_regexp_parameters[0],
    2,
    &impl_nex_regexp_returns,
    NULL,
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp ---------- */

static const afw_utf8_t
impl_object_path__regexp =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp");

static const afw_runtime_object_indirect_t
impl_object__regexp = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp
        }
    },
    (void *)&afw_function_definition_regexp
};

static const afw_value_function_parameter_t
impl_regexp_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_regexp_direct,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_parameters[] = {
    &impl_regexp_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_regexp_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp,
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL("afwRegexp"),
    AFW_UTF8_LITERAL("Convert to data type regexp"),
    AFW_UTF8_LITERAL("Converts value to data type regexp returning regexp result."),
    AFW_UTF8_LITERAL("(value: any): regexp"),
    AFW_UTF8_LITERAL("/* Convert to data type regexp */\nfunction regexp (\n    value: any\n): regexp;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_regexp_parameters[0],
    1,
    &impl_regexp_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_regexp_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_rfc822Name
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_rfc822Name
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_rfc822Name_parameters[] = {
    &impl_at_least_one_member_of_rfc822Name_parameter_1,
    &impl_at_least_one_member_of_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("at_least_one_member_of<rfc822Name>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_rfc822Name"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfRfc822Name"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfRfc822Name"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in rfc822Name list1 is in rfc822Name list2."),
    AFW_UTF8_LITERAL("(list1: (list rfc822Name), list2: (list rfc822Name)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<rfc822Name> (\n    list1: (list rfc822Name),\n    list2: (list rfc822Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_rfc822Name_parameters[0],
    2,
    &impl_at_least_one_member_of_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__bag_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__bag_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_rfc822Name
        }
    },
    (void *)&afw_function_definition_bag_rfc822Name
};

static const afw_value_function_parameter_t
impl_bag_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_rfc822Name_parameters[] = {
    &impl_bag_rfc822Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("bag<rfc822Name>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_rfc822Name"),
    AFW_UTF8_LITERAL("bagRfc822Name"),
    AFW_UTF8_LITERAL("afwBagRfc822Name"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of rfc822Name values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list rfc822Name))): (list rfc822Name)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<rfc822Name> (\n    ...values: (list of (list rfc822Name))\n): (list rfc822Name);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_rfc822Name_parameters[0],
    1,
    &impl_bag_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__bag_size_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_rfc822Name
        }
    },
    (void *)&afw_function_definition_bag_size_rfc822Name
};

static const afw_value_function_parameter_t
impl_bag_size_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_rfc822Name_parameters[] = {
    &impl_bag_size_rfc822Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("bag_size<rfc822Name>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_rfc822Name"),
    AFW_UTF8_LITERAL("bagSizeRfc822Name"),
    AFW_UTF8_LITERAL("afwBagSizeRfc822Name"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list rfc822Name)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<rfc822Name> (\n    value: (list rfc822Name)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_rfc822Name_parameters[0],
    1,
    &impl_bag_size_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__eq_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__eq_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_rfc822Name
        }
    },
    (void *)&afw_function_definition_eq_rfc822Name
};

static const afw_value_function_parameter_t
impl_eq_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_rfc822Name_parameters[] = {
    &impl_eq_rfc822Name_parameter_1,
    &impl_eq_rfc822Name_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_rfc822Name_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("eq<rfc822Name>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_rfc822Name"),
    AFW_UTF8_LITERAL("eqRfc822Name"),
    AFW_UTF8_LITERAL("afwEqRfc822Name"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if rfc822Name arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_rfc822Name_parameters[0],
    2,
    &impl_eq_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    &impl_eq_rfc822Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__eqx_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__eqx_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_rfc822Name
        }
    },
    (void *)&afw_function_definition_eqx_rfc822Name
};

static const afw_value_function_parameter_t
impl_eqx_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_rfc822Name_parameters[] = {
    &impl_eqx_rfc822Name_parameter_1,
    &impl_eqx_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("eqx<rfc822Name>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_rfc822Name"),
    AFW_UTF8_LITERAL("eqxRfc822Name"),
    AFW_UTF8_LITERAL("afwEqxRfc822Name"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for rfc822Name arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_rfc822Name_parameters[0],
    2,
    &impl_eqx_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__ge_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__ge_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_rfc822Name
        }
    },
    (void *)&afw_function_definition_ge_rfc822Name
};

static const afw_value_function_parameter_t
impl_ge_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_rfc822Name_parameters[] = {
    &impl_ge_rfc822Name_parameter_1,
    &impl_ge_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("ge<rfc822Name>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_rfc822Name"),
    AFW_UTF8_LITERAL("geRfc822Name"),
    AFW_UTF8_LITERAL("afwGeRfc822Name"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for rfc822Name arg1 is greater than or equal to rfc822Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: rfc822Name): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: rfc822Name\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_rfc822Name_parameters[0],
    2,
    &impl_ge_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__gt_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__gt_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_rfc822Name
        }
    },
    (void *)&afw_function_definition_gt_rfc822Name
};

static const afw_value_function_parameter_t
impl_gt_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_rfc822Name_parameters[] = {
    &impl_gt_rfc822Name_parameter_1,
    &impl_gt_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("gt<rfc822Name>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_rfc822Name"),
    AFW_UTF8_LITERAL("gtRfc822Name"),
    AFW_UTF8_LITERAL("afwGtRfc822Name"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for rfc822Name arg1 is greater than rfc822Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: rfc822Name): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: rfc822Name\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_rfc822Name_parameters[0],
    2,
    &impl_gt_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__intersection_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__intersection_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_rfc822Name
        }
    },
    (void *)&afw_function_definition_intersection_rfc822Name
};

static const afw_value_function_parameter_t
impl_intersection_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_rfc822Name_parameters[] = {
    &impl_intersection_rfc822Name_parameter_1,
    &impl_intersection_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("intersection<rfc822Name>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_rfc822Name"),
    AFW_UTF8_LITERAL("intersectionRfc822Name"),
    AFW_UTF8_LITERAL("afwIntersectionRfc822Name"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of rfc822Name with the values that are common to both list of rfc822Name list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list rfc822Name), list2: (list rfc822Name)): (list rfc822Name)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<rfc822Name> (\n    list1: (list rfc822Name),\n    list2: (list rfc822Name)\n): (list rfc822Name);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_rfc822Name_parameters[0],
    2,
    &impl_intersection_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__is_in_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__is_in_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_rfc822Name
        }
    },
    (void *)&afw_function_definition_is_in_rfc822Name
};

static const afw_value_function_parameter_t
impl_is_in_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_rfc822Name_parameters[] = {
    &impl_is_in_rfc822Name_parameter_1,
    &impl_is_in_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("is_in<rfc822Name>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_rfc822Name"),
    AFW_UTF8_LITERAL("isInRfc822Name"),
    AFW_UTF8_LITERAL("afwIsInRfc822Name"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether rfc822Name value is in list of rfc822Name list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: rfc822Name, list: (list rfc822Name)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<rfc822Name> (\n    value: rfc822Name,\n    list: (list rfc822Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_rfc822Name_parameters[0],
    2,
    &impl_is_in_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__is_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__is_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_rfc822Name
        }
    },
    (void *)&afw_function_definition_is_rfc822Name
};

static const afw_value_function_parameter_t
impl_is_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_rfc822Name_parameters[] = {
    &impl_is_rfc822Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("is<rfc822Name>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_rfc822Name"),
    AFW_UTF8_LITERAL("isRfc822Name"),
    AFW_UTF8_LITERAL("afwIsRfc822Name"),
    AFW_UTF8_LITERAL("Checks whether value is dataType rfc822Name"),
    AFW_UTF8_LITERAL("Checks whether value is dataType rfc822Name and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType rfc822Name */\nfunction is<rfc822Name> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_rfc822Name_parameters[0],
    1,
    &impl_is_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__le_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__le_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_rfc822Name
        }
    },
    (void *)&afw_function_definition_le_rfc822Name
};

static const afw_value_function_parameter_t
impl_le_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_rfc822Name_parameters[] = {
    &impl_le_rfc822Name_parameter_1,
    &impl_le_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("le<rfc822Name>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_rfc822Name"),
    AFW_UTF8_LITERAL("leRfc822Name"),
    AFW_UTF8_LITERAL("afwLeRfc822Name"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for rfc822Name arg1 is less than or equal to rfc822Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_rfc822Name_parameters[0],
    2,
    &impl_le_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__lt_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__lt_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_rfc822Name
        }
    },
    (void *)&afw_function_definition_lt_rfc822Name
};

static const afw_value_function_parameter_t
impl_lt_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_rfc822Name_parameters[] = {
    &impl_lt_rfc822Name_parameter_1,
    &impl_lt_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("lt<rfc822Name>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_rfc822Name"),
    AFW_UTF8_LITERAL("ltRfc822Name"),
    AFW_UTF8_LITERAL("afwLtRfc822Name"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for rfc822Name arg1 is less that rfc822Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: rfc822Name): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: rfc822Name\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_rfc822Name_parameters[0],
    2,
    &impl_lt_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- match<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__match_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/match_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__match_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_match_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__match_rfc822Name
        }
    },
    (void *)&afw_function_definition_match_rfc822Name
};

static const afw_value_function_parameter_t
impl_match_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_match_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_match_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_match_rfc822Name_parameters[] = {
    &impl_match_rfc822Name_parameter_1,
    &impl_match_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_match_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__match_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("match<rfc822Name>"),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL("match_rfc822Name"),
    AFW_UTF8_LITERAL("matchRfc822Name"),
    AFW_UTF8_LITERAL("afwMatchRfc822Name"),
    AFW_UTF8_LITERAL("Checks if x500Name matches"),
    AFW_UTF8_LITERAL("Returns true if arg1 matches some terminal sequence of RDNs from arg2 when compared using equal_rfc822Name."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks if x500Name matches */\nfunction match<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_match_rfc822Name,
    NULL,
    2,
    2,
    &impl_match_rfc822Name_parameters[0],
    2,
    &impl_match_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__ne_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__ne_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_rfc822Name
        }
    },
    (void *)&afw_function_definition_ne_rfc822Name
};

static const afw_value_function_parameter_t
impl_ne_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_rfc822Name_parameters[] = {
    &impl_ne_rfc822Name_parameter_1,
    &impl_ne_rfc822Name_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_rfc822Name_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("ne<rfc822Name>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_rfc822Name"),
    AFW_UTF8_LITERAL("neRfc822Name"),
    AFW_UTF8_LITERAL("afwNeRfc822Name"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if rfc822Name arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_rfc822Name_parameters[0],
    2,
    &impl_ne_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    &impl_ne_rfc822Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__nex_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__nex_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_rfc822Name
        }
    },
    (void *)&afw_function_definition_nex_rfc822Name
};

static const afw_value_function_parameter_t
impl_nex_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_rfc822Name_parameters[] = {
    &impl_nex_rfc822Name_parameter_1,
    &impl_nex_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("nex<rfc822Name>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_rfc822Name"),
    AFW_UTF8_LITERAL("nexRfc822Name"),
    AFW_UTF8_LITERAL("afwNexRfc822Name"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for rfc822Name arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: rfc822Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<rfc822Name> (\n    arg1: rfc822Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_rfc822Name_parameters[0],
    2,
    &impl_nex_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_rfc822Name
        }
    },
    (void *)&afw_function_definition_one_and_only_rfc822Name
};

static const afw_value_function_parameter_t
impl_one_and_only_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_rfc822Name_parameters[] = {
    &impl_one_and_only_rfc822Name_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_rfc822Name_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("one_and_only<rfc822Name>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_rfc822Name"),
    AFW_UTF8_LITERAL("oneAndOnlyRfc822Name"),
    AFW_UTF8_LITERAL("afwOneAndOnlyRfc822Name"),
    AFW_UTF8_LITERAL("Converts a one value list to a rfc822Name value"),
    AFW_UTF8_LITERAL("This converts a list of rfc822Name values that contains one value to a single rfc822Name value."),
    AFW_UTF8_LITERAL("(list: (list list)): rfc822Name"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a rfc822Name value */\nfunction one_and_only<rfc822Name> (\n    list: (list list)\n): rfc822Name;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_rfc822Name_parameters[0],
    1,
    &impl_one_and_only_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    &impl_one_and_only_rfc822Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_match<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__regexp_match_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_match_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__regexp_match_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_match_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_match_rfc822Name
        }
    },
    (void *)&afw_function_definition_regexp_match_rfc822Name
};

static const afw_value_function_parameter_t
impl_regexp_match_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_match_rfc822Name_parameters[] = {
    &impl_regexp_match_rfc822Name_parameter_1,
    &impl_regexp_match_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_match_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("regexp_match<rfc822Name>"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match_rfc822Name"),
    AFW_UTF8_LITERAL("regexpMatchRfc822Name"),
    AFW_UTF8_LITERAL("afwRegexpMatchRfc822Name"),
    AFW_UTF8_LITERAL("Search for a match using a regular expression"),
    AFW_UTF8_LITERAL("Checks whether rfc822Name value matches the regular expression regexp and return the boolean result."),
    AFW_UTF8_LITERAL("(value: rfc822Name, regexp: string): boolean"),
    AFW_UTF8_LITERAL("/* Search for a match using a regular expression */\nfunction regexp_match<rfc822Name> (\n    value: rfc822Name,\n    regexp: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_match,
    NULL,
    2,
    2,
    &impl_regexp_match_rfc822Name_parameters[0],
    2,
    &impl_regexp_match_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- rfc822Name ---------- */

static const afw_utf8_t
impl_object_path__rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__rfc822Name
        }
    },
    (void *)&afw_function_definition_rfc822Name
};

static const afw_value_function_parameter_t
impl_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_rfc822Name_parameters[] = {
    &impl_rfc822Name_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_rfc822Name_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("afwRfc822Name"),
    AFW_UTF8_LITERAL("Convert to data type rfc822Name"),
    AFW_UTF8_LITERAL("Converts value to data type rfc822Name returning rfc822Name result."),
    AFW_UTF8_LITERAL("(value: any): rfc822Name"),
    AFW_UTF8_LITERAL("/* Convert to data type rfc822Name */\nfunction rfc822Name (\n    value: any\n): rfc822Name;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_rfc822Name_parameters[0],
    1,
    &impl_rfc822Name_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_rfc822Name_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__set_equals_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_rfc822Name
        }
    },
    (void *)&afw_function_definition_set_equals_rfc822Name
};

static const afw_value_function_parameter_t
impl_set_equals_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_rfc822Name_parameters[] = {
    &impl_set_equals_rfc822Name_parameter_1,
    &impl_set_equals_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("set_equals<rfc822Name>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_rfc822Name"),
    AFW_UTF8_LITERAL("setEqualsRfc822Name"),
    AFW_UTF8_LITERAL("afwSetEqualsRfc822Name"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if rfc822Name list1 and rfc822Name list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list rfc822Name), list2: (list rfc822Name)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<rfc822Name> (\n    list1: (list rfc822Name),\n    list2: (list rfc822Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_rfc822Name_parameters[0],
    2,
    &impl_set_equals_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__subset_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__subset_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_rfc822Name
        }
    },
    (void *)&afw_function_definition_subset_rfc822Name
};

static const afw_value_function_parameter_t
impl_subset_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_rfc822Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_rfc822Name_parameters[] = {
    &impl_subset_rfc822Name_parameter_1,
    &impl_subset_rfc822Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("subset<rfc822Name>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_rfc822Name"),
    AFW_UTF8_LITERAL("subsetRfc822Name"),
    AFW_UTF8_LITERAL("afwSubsetRfc822Name"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in rfc822Name list1 are all in rfc822Name list2."),
    AFW_UTF8_LITERAL("(list1: (list rfc822Name), list2: (list rfc822Name)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<rfc822Name> (\n    list1: (list rfc822Name),\n    list2: (list rfc822Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_rfc822Name_parameters[0],
    2,
    &impl_subset_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__to_string_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__to_string_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_rfc822Name
        }
    },
    (void *)&afw_function_definition_to_string_rfc822Name
};

static const afw_value_function_parameter_t
impl_to_string_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A rfc822Name value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_rfc822Name_parameters[] = {
    &impl_to_string_rfc822Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("to_string<rfc822Name>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_rfc822Name"),
    AFW_UTF8_LITERAL("toStringRfc822Name"),
    AFW_UTF8_LITERAL("afwToStringRfc822Name"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts rfc822Name value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: rfc822Name): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<rfc822Name> (\n    value: rfc822Name\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_rfc822Name_parameters[0],
    1,
    &impl_to_string_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<rfc822Name> ---------- */

static const afw_utf8_t
impl_object_path__union_rfc822Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_rfc822Name");

static const afw_runtime_object_indirect_t
impl_object__union_rfc822Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_rfc822Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_rfc822Name
        }
    },
    (void *)&afw_function_definition_union_rfc822Name
};

static const afw_value_function_parameter_t
impl_union_rfc822Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_rfc822Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_rfc822Name_parameters[] = {
    &impl_union_rfc822Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_rfc822Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_rfc822Name,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL("union<rfc822Name>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_rfc822Name"),
    AFW_UTF8_LITERAL("unionRfc822Name"),
    AFW_UTF8_LITERAL("afwUnionRfc822Name"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of rfc822Name contains all of the unique values in two or more list of rfc822Name values."),
    AFW_UTF8_LITERAL("(lists_1: (list rfc822Name), lists_2: (list rfc822Name), ...lists_rest: (list of (list rfc822Name))): (list rfc822Name)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<rfc822Name> (\n    lists_1: (list rfc822Name),\n    lists_2: (list rfc822Name),\n    ...lists_rest: (list of (list rfc822Name))\n): (list rfc822Name);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_rfc822Name_parameters[0],
    1,
    &impl_union_rfc822Name_returns,
    NULL,
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- assign ---------- */

static const afw_utf8_t
impl_object_path__assign =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/assign");

static const afw_runtime_object_indirect_t
impl_object__assign = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_assign,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__assign
        }
    },
    (void *)&afw_function_definition_assign
};

static const afw_value_function_parameter_t
impl_assign_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The value assigned."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_assign_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Variable name"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_assign_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the value to assign to the variable."),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_assign_parameters[] = {
    &impl_assign_parameter_1,
    &impl_assign_parameter_2,
    NULL
};

static const afw_utf8_t
impl_assign_sideEffects[] = {
    AFW_UTF8_LITERAL("Value assigned"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_assign = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__assign,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("assign"),
    AFW_UTF8_LITERAL("assign"),
    AFW_UTF8_LITERAL("assign"),
    AFW_UTF8_LITERAL("assign"),
    AFW_UTF8_LITERAL("afwAssign"),
    AFW_UTF8_LITERAL("Assign a value to a defined variable"),
    AFW_UTF8_LITERAL("Assign a value to the innermost structured block definition of a variable. If the variable is not defined, the variable is defined in the innermost structured block. An error is thrown if not called from a list of values in a structured function."),
    AFW_UTF8_LITERAL("(name: string, value: any): any"),
    AFW_UTF8_LITERAL("/* Assign a value to a defined variable */\nfunction assign (\n    name: string,\n    value: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_assign,
    NULL,
    2,
    2,
    &impl_assign_parameters[0],
    2,
    &impl_assign_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_assign_sideEffects[0],
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_ASSIGN,
    false,
    false,
    false,
    false,
    false
};

/* ---------- bag<script> ---------- */

static const afw_utf8_t
impl_object_path__bag_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_script");

static const afw_runtime_object_indirect_t
impl_object__bag_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_script
        }
    },
    (void *)&afw_function_definition_bag_script
};

static const afw_value_function_parameter_t
impl_bag_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_script_parameters[] = {
    &impl_bag_script_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("bag<script>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_script"),
    AFW_UTF8_LITERAL("bagScript"),
    AFW_UTF8_LITERAL("afwBagScript"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of script values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list script))): (list script)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<script> (\n    ...values: (list of (list script))\n): (list script);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_script_parameters[0],
    1,
    &impl_bag_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<script> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_script");

static const afw_runtime_object_indirect_t
impl_object__bag_size_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_script
        }
    },
    (void *)&afw_function_definition_bag_size_script
};

static const afw_value_function_parameter_t
impl_bag_size_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_script_parameters[] = {
    &impl_bag_size_script_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("bag_size<script>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_script"),
    AFW_UTF8_LITERAL("bagSizeScript"),
    AFW_UTF8_LITERAL("afwBagSizeScript"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list script)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<script> (\n    value: (list script)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_script_parameters[0],
    1,
    &impl_bag_size_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- break ---------- */

static const afw_utf8_t
impl_object_path__break =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/break");

static const afw_runtime_object_indirect_t
impl_object__break = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_break,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__break
        }
    },
    (void *)&afw_function_definition_break
};

static const afw_value_function_parameter_t
impl_break_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This function returns from the body of a loop with the last evaluated value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_break_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The value to evaluate that the enclosing loop will return. If not specified, the last evaluated value or a null value will be returned."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_break_parameters[] = {
    &impl_break_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_break = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__break,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("break"),
    AFW_UTF8_LITERAL("break"),
    AFW_UTF8_LITERAL("break"),
    AFW_UTF8_LITERAL("break"),
    AFW_UTF8_LITERAL("afwBreak"),
    AFW_UTF8_LITERAL("Break out of a block"),
    AFW_UTF8_LITERAL("This is a special function that can be called to break out of the body of a loop. If called outside of a loop body, an error is thrown."),
    AFW_UTF8_LITERAL("(value?: any): any"),
    AFW_UTF8_LITERAL("/* Break out of a block */\nfunction break (\n    value?: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_break,
    NULL,
    0,
    1,
    &impl_break_parameters[0],
    1,
    &impl_break_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_BREAK,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compile<script> ---------- */

static const afw_utf8_t
impl_object_path__compile_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_script");

static const afw_runtime_object_indirect_t
impl_object__compile_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_script
        }
    },
    (void *)&afw_function_definition_compile_script
};

static const afw_value_function_parameter_t
impl_compile_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to compile"),
    AFW_UTF8_LITERAL("script string to compile"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL("Listing option"),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_script_parameters[] = {
    &impl_compile_script_parameter_1,
    &impl_compile_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("compile<script>"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile_script"),
    AFW_UTF8_LITERAL("compileScript"),
    AFW_UTF8_LITERAL("afwCompileScript"),
    AFW_UTF8_LITERAL("Compile script value"),
    AFW_UTF8_LITERAL("Compile script value and return either an unevaluated adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(source: script, listing?: any): unevaluated"),
    AFW_UTF8_LITERAL("/* Compile script value */\nfunction compile<script> (\n    source: script /* Source to compile */,\n    listing?: any  /* Listing option */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_script,
    NULL,
    1,
    2,
    &impl_compile_script_parameters[0],
    2,
    &impl_compile_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_compile,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- const ---------- */

static const afw_utf8_t
impl_object_path__const =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/const");

static const afw_runtime_object_indirect_t
impl_object__const = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_const,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__const
        }
    },
    (void *)&afw_function_definition_const
};

static const afw_value_function_parameter_t
impl_const_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The value assigned."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_const_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The name of one or more constants to defined in the current block."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_const_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the value of the constant(s)."),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_const_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveValueMeta_"),
    AFW_UTF8_LITERAL("type"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The type of the constant(s)."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_const_parameters[] = {
    &impl_const_parameter_1,
    &impl_const_parameter_2,
    &impl_const_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_const = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__const,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("const"),
    AFW_UTF8_LITERAL("const"),
    AFW_UTF8_LITERAL("const"),
    AFW_UTF8_LITERAL("const"),
    AFW_UTF8_LITERAL("afwConst"),
    AFW_UTF8_LITERAL("Define one or more constants in the current block"),
    AFW_UTF8_LITERAL("Define one or more statically scoped constants local to the current script block with a permanent value. These constants can be accessed from the current block and inner blocks, but can not be assigned a different value."),
    AFW_UTF8_LITERAL("(name: (list string), value: any, type?: (object _AdaptiveValueMeta_)): any"),
    AFW_UTF8_LITERAL("/* Define one or more constants in the current block */\nfunction const (\n    name: (list string),\n    value: any,\n    type?: (object _AdaptiveValueMeta_)\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_const,
    NULL,
    2,
    3,
    &impl_const_parameters[0],
    3,
    &impl_const_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_CONST,
    false,
    false,
    false,
    true,
    false
};

/* ---------- continue ---------- */

static const afw_utf8_t
impl_object_path__continue =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/continue");

static const afw_runtime_object_indirect_t
impl_object__continue = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_continue,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__continue
        }
    },
    (void *)&afw_function_definition_continue
};

static const afw_value_function_parameter_t
impl_continue_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This function does not return."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_continue_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_continue = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__continue,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("continue"),
    AFW_UTF8_LITERAL("continue"),
    AFW_UTF8_LITERAL("continue"),
    AFW_UTF8_LITERAL("continue"),
    AFW_UTF8_LITERAL("afwContinue"),
    AFW_UTF8_LITERAL("Continue at beginning of a loop"),
    AFW_UTF8_LITERAL("This is a special function that can be called in the body of a loop function to test the condition and, if true, start evaluating the body again. If called outside of a loop body, an error is thrown."),
    AFW_UTF8_LITERAL("(): any"),
    AFW_UTF8_LITERAL("/* Continue at beginning of a loop */\nfunction continue (\n\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_continue,
    NULL,
    0,
    0,
    &impl_continue_parameters[0],
    0,
    &impl_continue_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_CONTINUE,
    false,
    false,
    false,
    true,
    false
};

/* ---------- do_while ---------- */

static const afw_utf8_t
impl_object_path__do_while =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/do_while");

static const afw_runtime_object_indirect_t
impl_object__do_while = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_do_while,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__do_while
        }
    },
    (void *)&afw_function_definition_do_while
};

static const afw_value_function_parameter_t
impl_do_while_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The last value evaluated in body or null if the body is empty."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_do_while_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("condition"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("While this condition is true, the loop will continue. This is evaluated in the loop's scope."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_do_while_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("body"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a \"break\", \"continue\" or \"return\" function is encountered."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_do_while_parameters[] = {
    &impl_do_while_parameter_1,
    &impl_do_while_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_do_while = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__do_while,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("do_while"),
    AFW_UTF8_LITERAL("do_while"),
    AFW_UTF8_LITERAL("do_while"),
    AFW_UTF8_LITERAL("doWhile"),
    AFW_UTF8_LITERAL("afwDoWhile"),
    AFW_UTF8_LITERAL("Evaluate a list of values at least once while a condition is true"),
    AFW_UTF8_LITERAL("This creates a new structured block with a new nested variable scope.\n\nThis function will evaluate a list of values at least once while a condition is true. See the related functions \"break\", \"continue\", and \"return\"."),
    AFW_UTF8_LITERAL("(condition: boolean, body: list): any"),
    AFW_UTF8_LITERAL("/* Evaluate a list of values at least once while a condition is true */\nfunction do_while (\n    condition: boolean,\n    body: list\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_do_while,
    NULL,
    2,
    2,
    &impl_do_while_parameters[0],
    2,
    &impl_do_while_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_DO_WHILE,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<script> ---------- */

static const afw_utf8_t
impl_object_path__eq_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_script");

static const afw_runtime_object_indirect_t
impl_object__eq_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_script
        }
    },
    (void *)&afw_function_definition_eq_script
};

static const afw_value_function_parameter_t
impl_eq_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_script_parameters[] = {
    &impl_eq_script_parameter_1,
    &impl_eq_script_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_script_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("eq<script>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_script"),
    AFW_UTF8_LITERAL("eqScript"),
    AFW_UTF8_LITERAL("afwEqScript"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if script arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<script> (\n    arg1: script,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_script_parameters[0],
    2,
    &impl_eq_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    &impl_eq_script_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<script> ---------- */

static const afw_utf8_t
impl_object_path__eqx_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_script");

static const afw_runtime_object_indirect_t
impl_object__eqx_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_script
        }
    },
    (void *)&afw_function_definition_eqx_script
};

static const afw_value_function_parameter_t
impl_eqx_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_script_parameters[] = {
    &impl_eqx_script_parameter_1,
    &impl_eqx_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("eqx<script>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_script"),
    AFW_UTF8_LITERAL("eqxScript"),
    AFW_UTF8_LITERAL("afwEqxScript"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for script arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<script> (\n    arg1: script,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_script_parameters[0],
    2,
    &impl_eqx_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- evaluate<script> ---------- */

static const afw_utf8_t
impl_object_path__evaluate_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_script");

static const afw_runtime_object_indirect_t
impl_object__evaluate_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_script
        }
    },
    (void *)&afw_function_definition_evaluate_script
};

static const afw_value_function_parameter_t
impl_evaluate_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to evaluate"),
    AFW_UTF8_LITERAL("script string to compile and evaluate"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_script_parameters[] = {
    &impl_evaluate_script_parameter_1,
    &impl_evaluate_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("evaluate<script>"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate_script"),
    AFW_UTF8_LITERAL("evaluateScript"),
    AFW_UTF8_LITERAL("afwEvaluateScript"),
    AFW_UTF8_LITERAL("Evaluate script value"),
    AFW_UTF8_LITERAL("Compile and evaluate script value."),
    AFW_UTF8_LITERAL("(source: script, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): unevaluated"),
    AFW_UTF8_LITERAL("/* Evaluate script value */\nfunction evaluate<script> (\n    source: script                                                                     /* Source to evaluate */,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_script,
    NULL,
    1,
    2,
    &impl_evaluate_script_parameters[0],
    2,
    &impl_evaluate_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_evaluate,
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- for ---------- */

static const afw_utf8_t
impl_object_path__for =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/for");

static const afw_runtime_object_indirect_t
impl_object__for = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_for,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__for
        }
    },
    (void *)&afw_function_definition_for
};

static const afw_value_function_parameter_t
impl_for_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The last value evaluated in body or null if condition evaluates to false the first time."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_for_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("initial"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of values to evaluate before the loop starts. The values will normally be a call to the \"assign\" function."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_for_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("condition"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("While this condition is true, the loop will continue."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_for_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("increment"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of values to evaluate after each iteration of the loop. The values will normally be a call to the \"assign\" function."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_for_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("body"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a \"break\", \"continue\" or \"return\" function is encountered."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_for_parameters[] = {
    &impl_for_parameter_1,
    &impl_for_parameter_2,
    &impl_for_parameter_3,
    &impl_for_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_for = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__for,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("for"),
    AFW_UTF8_LITERAL("for"),
    AFW_UTF8_LITERAL("for"),
    AFW_UTF8_LITERAL("for"),
    AFW_UTF8_LITERAL("afwFor"),
    AFW_UTF8_LITERAL("Evaluate a list of values while a condition is true with a list of initial and increment values"),
    AFW_UTF8_LITERAL("This creates a new structured block with a new nested variable scope.\n\nThis function loops while condition is true. If the condition is false for the first iteration, the loop returns a null value."),
    AFW_UTF8_LITERAL("(initial?: list, condition?: boolean, increment?: list, body?: list): any"),
    AFW_UTF8_LITERAL("/* Evaluate a list of values while a condition is true with a list of initial and increment values */\nfunction for (\n    initial?: list,\n    condition?: boolean,\n    increment?: list,\n    body?: list\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_for,
    NULL,
    0,
    4,
    &impl_for_parameters[0],
    4,
    &impl_for_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_FOR,
    false,
    false,
    false,
    true,
    false
};

/* ---------- foreach ---------- */

static const afw_utf8_t
impl_object_path__foreach =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/foreach");

static const afw_runtime_object_indirect_t
impl_object__foreach = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_foreach,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__foreach
        }
    },
    (void *)&afw_function_definition_foreach
};

static const afw_value_function_parameter_t
impl_foreach_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The last value evaluated in body or null if condition evaluates to false the first time."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_foreach_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Variable name(s)."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_foreach_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Any list, object or single value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_foreach_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("body"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a \"break\", \"continue\" or \"return\" function is encountered."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_foreach_parameters[] = {
    &impl_foreach_parameter_1,
    &impl_foreach_parameter_2,
    &impl_foreach_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_foreach = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__foreach,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("foreach"),
    AFW_UTF8_LITERAL("foreach"),
    AFW_UTF8_LITERAL("foreach"),
    AFW_UTF8_LITERAL("foreach"),
    AFW_UTF8_LITERAL("afwForeach"),
    AFW_UTF8_LITERAL("Evaluate a list of values while a condition is true with a list of initial and increment values"),
    AFW_UTF8_LITERAL("This creates a new structured block with a new nested variable scope.\n\nThis function will evaluate a list of values while a condition is true with initial and increment values. The condition is tested at the beginning of the loop. If the condition is false for the first iteration, the loop returns a null value."),
    AFW_UTF8_LITERAL("(name: (list string), value: any, body?: list): any"),
    AFW_UTF8_LITERAL("/* Evaluate a list of values while a condition is true with a list of initial and increment values */\nfunction foreach (\n    name: (list string),\n    value: any,\n    body?: list\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_foreach,
    NULL,
    2,
    3,
    &impl_foreach_parameters[0],
    3,
    &impl_foreach_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_FOREACH,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<script> ---------- */

static const afw_utf8_t
impl_object_path__ge_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_script");

static const afw_runtime_object_indirect_t
impl_object__ge_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_script
        }
    },
    (void *)&afw_function_definition_ge_script
};

static const afw_value_function_parameter_t
impl_ge_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_script_parameters[] = {
    &impl_ge_script_parameter_1,
    &impl_ge_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("ge<script>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_script"),
    AFW_UTF8_LITERAL("geScript"),
    AFW_UTF8_LITERAL("afwGeScript"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for script arg1 is greater than or equal to script arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: script): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<script> (\n    arg1: script,\n    arg2: script\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_script_parameters[0],
    2,
    &impl_ge_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<script> ---------- */

static const afw_utf8_t
impl_object_path__gt_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_script");

static const afw_runtime_object_indirect_t
impl_object__gt_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_script
        }
    },
    (void *)&afw_function_definition_gt_script
};

static const afw_value_function_parameter_t
impl_gt_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_script_parameters[] = {
    &impl_gt_script_parameter_1,
    &impl_gt_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("gt<script>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_script"),
    AFW_UTF8_LITERAL("gtScript"),
    AFW_UTF8_LITERAL("afwGtScript"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for script arg1 is greater than script arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: script): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<script> (\n    arg1: script,\n    arg2: script\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_script_parameters[0],
    2,
    &impl_gt_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- if ---------- */

static const afw_utf8_t
impl_object_path__if =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/if");

static const afw_runtime_object_indirect_t
impl_object__if = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_if,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__if
        }
    },
    (void *)&afw_function_definition_if
};

static const afw_value_function_parameter_t
impl_if_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The result of evaluating \"then\" or \"else\""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_if_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("condition"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("If true, parameter \"then\" is evaluated for result. If false, parameter \"else\" is evaluated."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_if_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("then"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the body of a structured block that is evaluated if \"condition\" is true. See the \"body\" parameter of the \"block\" function for information on how the body is processed."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_if_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("else"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the body of a structured block that is evaluated if \"condition\" is false. If not specified and condition is false, a null value is returned. See the \"body\" parameter of the \"block\" function for information on how the body is processed."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_if_parameters[] = {
    &impl_if_parameter_1,
    &impl_if_parameter_2,
    &impl_if_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_if = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__if,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("if"),
    AFW_UTF8_LITERAL("if"),
    AFW_UTF8_LITERAL("if"),
    AFW_UTF8_LITERAL("if"),
    AFW_UTF8_LITERAL("afwIf"),
    AFW_UTF8_LITERAL("If/then/else function"),
    AFW_UTF8_LITERAL("Evaluate one of two different values depending on test condition."),
    AFW_UTF8_LITERAL("(condition: boolean, then: list, else?: list): any"),
    AFW_UTF8_LITERAL("/* If/then/else function */\nfunction if (\n    condition: boolean,\n    then: list,\n    else?: list\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_if,
    NULL,
    2,
    3,
    &impl_if_parameters[0],
    3,
    &impl_if_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_IF,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<script> ---------- */

static const afw_utf8_t
impl_object_path__is_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_script");

static const afw_runtime_object_indirect_t
impl_object__is_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_script
        }
    },
    (void *)&afw_function_definition_is_script
};

static const afw_value_function_parameter_t
impl_is_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_script_parameters[] = {
    &impl_is_script_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("is<script>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_script"),
    AFW_UTF8_LITERAL("isScript"),
    AFW_UTF8_LITERAL("afwIsScript"),
    AFW_UTF8_LITERAL("Checks whether value is dataType script"),
    AFW_UTF8_LITERAL("Checks whether value is dataType script and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType script */\nfunction is<script> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_script_parameters[0],
    1,
    &impl_is_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<script> ---------- */

static const afw_utf8_t
impl_object_path__le_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_script");

static const afw_runtime_object_indirect_t
impl_object__le_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_script
        }
    },
    (void *)&afw_function_definition_le_script
};

static const afw_value_function_parameter_t
impl_le_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_script_parameters[] = {
    &impl_le_script_parameter_1,
    &impl_le_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("le<script>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_script"),
    AFW_UTF8_LITERAL("leScript"),
    AFW_UTF8_LITERAL("afwLeScript"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for script arg1 is less than or equal to script arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<script> (\n    arg1: script,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_script_parameters[0],
    2,
    &impl_le_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- loc ---------- */

static const afw_utf8_t
impl_object_path__loc =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/loc");

static const afw_runtime_object_indirect_t
impl_object__loc = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_loc,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__loc
        }
    },
    (void *)&afw_function_definition_loc
};

static const afw_value_function_parameter_t
impl_loc_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The value assigned."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_loc_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The name of one or more variables to declared in the current block."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_loc_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the initial value of the variable(s). If not specified, the variable will have a value of undefined."),
    -1,
    true,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_loc_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveValueMeta_"),
    AFW_UTF8_LITERAL("type"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The type of the variable(s)."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_loc_parameters[] = {
    &impl_loc_parameter_1,
    &impl_loc_parameter_2,
    &impl_loc_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_loc = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__loc,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("loc"),
    AFW_UTF8_LITERAL("loc"),
    AFW_UTF8_LITERAL("loc"),
    AFW_UTF8_LITERAL("loc"),
    AFW_UTF8_LITERAL("afwLoc"),
    AFW_UTF8_LITERAL("Declare one or more variables in the current block"),
    AFW_UTF8_LITERAL("Declare one or more statically scoped variable locations local to the current script block and optionally assign them an initial value. These variables can be accessed and assigned different values from the current block and inner blocks."),
    AFW_UTF8_LITERAL("(name: (list string), value?: any, type?: (object _AdaptiveValueMeta_)): any"),
    AFW_UTF8_LITERAL("/* Declare one or more variables in the current block */\nfunction loc (\n    name: (list string),\n    value?: any,\n    type?: (object _AdaptiveValueMeta_)\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_loc,
    NULL,
    1,
    3,
    &impl_loc_parameters[0],
    3,
    &impl_loc_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_LOC,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<script> ---------- */

static const afw_utf8_t
impl_object_path__lt_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_script");

static const afw_runtime_object_indirect_t
impl_object__lt_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_script
        }
    },
    (void *)&afw_function_definition_lt_script
};

static const afw_value_function_parameter_t
impl_lt_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_script_parameters[] = {
    &impl_lt_script_parameter_1,
    &impl_lt_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("lt<script>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_script"),
    AFW_UTF8_LITERAL("ltScript"),
    AFW_UTF8_LITERAL("afwLtScript"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for script arg1 is less that script arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: script): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<script> (\n    arg1: script,\n    arg2: script\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_script_parameters[0],
    2,
    &impl_lt_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<script> ---------- */

static const afw_utf8_t
impl_object_path__ne_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_script");

static const afw_runtime_object_indirect_t
impl_object__ne_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_script
        }
    },
    (void *)&afw_function_definition_ne_script
};

static const afw_value_function_parameter_t
impl_ne_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_script_parameters[] = {
    &impl_ne_script_parameter_1,
    &impl_ne_script_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_script_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("ne<script>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_script"),
    AFW_UTF8_LITERAL("neScript"),
    AFW_UTF8_LITERAL("afwNeScript"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if script arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<script> (\n    arg1: script,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_script_parameters[0],
    2,
    &impl_ne_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    &impl_ne_script_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<script> ---------- */

static const afw_utf8_t
impl_object_path__nex_script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_script");

static const afw_runtime_object_indirect_t
impl_object__nex_script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_script
        }
    },
    (void *)&afw_function_definition_nex_script
};

static const afw_value_function_parameter_t
impl_nex_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_script_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_script_parameters[] = {
    &impl_nex_script_parameter_1,
    &impl_nex_script_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("nex<script>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_script"),
    AFW_UTF8_LITERAL("nexScript"),
    AFW_UTF8_LITERAL("afwNexScript"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for script arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: script, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<script> (\n    arg1: script,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_script_parameters[0],
    2,
    &impl_nex_script_returns,
    NULL,
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- return ---------- */

static const afw_utf8_t
impl_object_path__return =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/return");

static const afw_runtime_object_indirect_t
impl_object__return = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_return,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__return
        }
    },
    (void *)&afw_function_definition_return
};

static const afw_value_function_parameter_t
impl_return_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This function returns from the outermost structured block with the last evaluated value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_return_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The value to evaluate that the outermost block will return. If not specified, the last evaluated value or a null value will be returned."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_return_parameters[] = {
    &impl_return_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_return = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__return,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("return"),
    AFW_UTF8_LITERAL("return"),
    AFW_UTF8_LITERAL("return"),
    AFW_UTF8_LITERAL("return"),
    AFW_UTF8_LITERAL("afwReturn"),
    AFW_UTF8_LITERAL("Return from the outermost structured block"),
    AFW_UTF8_LITERAL("Return from the outermost structured block. If the expression of a lambda function is a block function, this will effectively return from the lambda function. If called outside of a structured block, an error is thrown."),
    AFW_UTF8_LITERAL("(value?: any): any"),
    AFW_UTF8_LITERAL("/* Return from the outermost structured block */\nfunction return (\n    value?: any\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_return,
    NULL,
    0,
    1,
    &impl_return_parameters[0],
    1,
    &impl_return_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_RETURN,
    false,
    false,
    false,
    true,
    false
};

/* ---------- script ---------- */

static const afw_utf8_t
impl_object_path__script =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/script");

static const afw_runtime_object_indirect_t
impl_object__script = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_script,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__script
        }
    },
    (void *)&afw_function_definition_script
};

static const afw_value_function_parameter_t
impl_script_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_script_direct,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_script_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_script_parameters[] = {
    &impl_script_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_script_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_script = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__script,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("afwScript"),
    AFW_UTF8_LITERAL("Convert to data type script"),
    AFW_UTF8_LITERAL("Converts value to data type script returning script result."),
    AFW_UTF8_LITERAL("(value: any): script"),
    AFW_UTF8_LITERAL("/* Convert to data type script */\nfunction script (\n    value: any\n): script;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_script_parameters[0],
    1,
    &impl_script_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_script_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- while ---------- */

static const afw_utf8_t
impl_object_path__while =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/while");

static const afw_runtime_object_indirect_t
impl_object__while = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_while,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__while
        }
    },
    (void *)&afw_function_definition_while
};

static const afw_value_function_parameter_t
impl_while_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The last value evaluated in body or null if condition evaluates to false the first time."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_while_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("condition"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("While this condition is true, the loop will continue. This is evaluated in the loop's scope."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_while_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("body"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a \"break\", \"continue\" or \"return\" function is encountered."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_while_parameters[] = {
    &impl_while_parameter_1,
    &impl_while_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_while = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__while,
    AFW_UTF8_LITERAL("script"),
    AFW_UTF8_LITERAL("while"),
    AFW_UTF8_LITERAL("while"),
    AFW_UTF8_LITERAL("while"),
    AFW_UTF8_LITERAL("while"),
    AFW_UTF8_LITERAL("afwWhile"),
    AFW_UTF8_LITERAL("Evaluate a list of values while a condition is true"),
    AFW_UTF8_LITERAL("This creates a new structured block with a new nested variable scope.\n\nThis function will evaluate a list of values while a condition is true. The condition is tested at the beginning of the loop. If the condition is false for the first iteration, the loop returns a null value. See the related functions \"break\", \"continue\", and \"return\"."),
    AFW_UTF8_LITERAL("(condition: boolean, body: list): any"),
    AFW_UTF8_LITERAL("/* Evaluate a list of values while a condition is true */\nfunction while (\n    condition: boolean,\n    body: list\n): any;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_while,
    NULL,
    2,
    2,
    &impl_while_parameters[0],
    2,
    &impl_while_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    AFW_VALUE_SCRIPT_SUPPORT_NUMBER_WHILE,
    false,
    false,
    false,
    true,
    false
};

/* ---------- close ---------- */

static const afw_utf8_t
impl_object_path__close =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/close");

static const afw_runtime_object_indirect_t
impl_object__close = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_close,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__close
        }
    },
    (void *)&afw_function_definition_close
};

static const afw_value_function_parameter_t
impl_close_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_close_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream Number"),
    AFW_UTF8_LITERAL("The streamNumber for the stream to close."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_close_parameters[] = {
    &impl_close_parameter_1,
    NULL
};

static const afw_utf8_t
impl_close_sideEffects[] = {
    AFW_UTF8_LITERAL("Buffers written and stream closed"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_close = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__close,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("close"),
    AFW_UTF8_LITERAL("close"),
    AFW_UTF8_LITERAL("close"),
    AFW_UTF8_LITERAL("close"),
    AFW_UTF8_LITERAL("afwClose"),
    AFW_UTF8_LITERAL("Close a stream"),
    AFW_UTF8_LITERAL("This will close an open stream"),
    AFW_UTF8_LITERAL("(streamNumber: integer): null"),
    AFW_UTF8_LITERAL("/* Close a stream */\nfunction close (\n    streamNumber: integer /* Stream Number */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_close,
    NULL,
    1,
    1,
    &impl_close_parameters[0],
    1,
    &impl_close_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_close_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- flush ---------- */

static const afw_utf8_t
impl_object_path__flush =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/flush");

static const afw_runtime_object_indirect_t
impl_object__flush = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_flush,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__flush
        }
    },
    (void *)&afw_function_definition_flush
};

static const afw_value_function_parameter_t
impl_flush_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_flush_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("The streamNumber for the stream to flush."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_flush_parameters[] = {
    &impl_flush_parameter_1,
    NULL
};

static const afw_utf8_t
impl_flush_sideEffects[] = {
    AFW_UTF8_LITERAL("Buffers written"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flush = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__flush,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("flush"),
    AFW_UTF8_LITERAL("flush"),
    AFW_UTF8_LITERAL("flush"),
    AFW_UTF8_LITERAL("flush"),
    AFW_UTF8_LITERAL("afwFlush"),
    AFW_UTF8_LITERAL("Flush stream buffer"),
    AFW_UTF8_LITERAL("Write the content of the stream's buffers to its destination."),
    AFW_UTF8_LITERAL("(streamNumber: integer): null"),
    AFW_UTF8_LITERAL("/* Flush stream buffer */\nfunction flush (\n    streamNumber: integer /* Stream number */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_flush,
    NULL,
    1,
    1,
    &impl_flush_parameters[0],
    1,
    &impl_flush_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_flush_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- get_stream_error ---------- */

static const afw_utf8_t
impl_object_path__get_stream_error =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/get_stream_error");

static const afw_runtime_object_indirect_t
impl_object__get_stream_error = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_get_stream_error,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__get_stream_error
        }
    },
    (void *)&afw_function_definition_get_stream_error
};

static const afw_value_function_parameter_t
impl_get_stream_error_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Stream error"),
    AFW_UTF8_LITERAL("The most recent stream error."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_get_stream_error_parameters[] = {
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_get_stream_error = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__get_stream_error,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("get_stream_error"),
    AFW_UTF8_LITERAL("get_stream_error"),
    AFW_UTF8_LITERAL("get_stream_error"),
    AFW_UTF8_LITERAL("getStreamError"),
    AFW_UTF8_LITERAL("afwGetStreamError"),
    AFW_UTF8_LITERAL("Get stream error"),
    AFW_UTF8_LITERAL("Get the most recent stream error."),
    AFW_UTF8_LITERAL("(): string"),
    AFW_UTF8_LITERAL("/* Get stream error */\nfunction get_stream_error (\n\n): string; /* Stream error */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_get_stream_error,
    NULL,
    0,
    0,
    &impl_get_stream_error_parameters[0],
    0,
    &impl_get_stream_error_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- open_file ---------- */

static const afw_utf8_t
impl_object_path__open_file =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/open_file");

static const afw_runtime_object_indirect_t
impl_object__open_file = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_open_file,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__open_file
        }
    },
    (void *)&afw_function_definition_open_file
};

static const afw_value_function_parameter_t
impl_open_file_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_file_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamId"),
    AFW_UTF8_LITERAL("Stream id"),
    AFW_UTF8_LITERAL("This is the streamId that will be associated with this open file stream."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_file_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("path"),
    AFW_UTF8_LITERAL("File path"),
    AFW_UTF8_LITERAL("This is the path to the file to open. The rootDirectory of the path is defined in the application object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_file_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("mode"),
    AFW_UTF8_LITERAL("Mode"),
    AFW_UTF8_LITERAL("This is the access mode string. Values can be:\n  r - Open an existing file text file for read.\n  w - Open a text file for writing. If the file does not exist, it will be created.\n  a - Open a text file for writing additional data to the end. If the file does not exist, it will be created.\n  r+ - Open a text file for both reading and writing.\n  w+ - Open a text file for both reading and writing. If the file exists, it will be overwritten. If the file does not exist, it will be created.\n  a+ - Open a text file for both reading and writing. Reading will begin at the start of the file while writing will be appended to the end.\n\nAll of these modes expect data type string. If you are using data type base64Binary or hexBinary you can use corresponding binary modes, \"rb\", \"wb\", \"ab\", \"rb+\", \"r+b\", \"wb+\", \"w+b\", \"ab+\", and \"a+b\"."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_file_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("autoFlush"),
    AFW_UTF8_LITERAL("Auto flush"),
    AFW_UTF8_LITERAL("If specified and true, this will automatically flush the stream's buffers after every write."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_open_file_parameters[] = {
    &impl_open_file_parameter_1,
    &impl_open_file_parameter_2,
    &impl_open_file_parameter_3,
    &impl_open_file_parameter_4,
    NULL
};

static const afw_utf8_t
impl_open_file_sideEffects[] = {
    AFW_UTF8_LITERAL("Stream is opened"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_open_file = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__open_file,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("open_file"),
    AFW_UTF8_LITERAL("open_file"),
    AFW_UTF8_LITERAL("open_file"),
    AFW_UTF8_LITERAL("openFile"),
    AFW_UTF8_LITERAL("afwOpenFile"),
    AFW_UTF8_LITERAL("Open a file stream"),
    AFW_UTF8_LITERAL("This will open a file stream."),
    AFW_UTF8_LITERAL("(streamId: string, path: string, mode: string, autoFlush?: boolean): integer"),
    AFW_UTF8_LITERAL("/* Open a file stream */\nfunction open_file (\n    streamId: string    /* Stream id */,\n    path: string        /* File path */,\n    mode: string        /* Mode */,\n    autoFlush?: boolean /* Auto flush */\n): integer; /* streamNumber */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_open_file,
    NULL,
    3,
    4,
    &impl_open_file_parameters[0],
    4,
    &impl_open_file_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_open_file_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- open_response ---------- */

static const afw_utf8_t
impl_object_path__open_response =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/open_response");

static const afw_runtime_object_indirect_t
impl_object__open_response = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_open_response,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__open_response
        }
    },
    (void *)&afw_function_definition_open_response
};

static const afw_value_function_parameter_t
impl_open_response_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_response_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamId"),
    AFW_UTF8_LITERAL("Stream id"),
    AFW_UTF8_LITERAL("This is the streamId that will be associated with this open response stream."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_response_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("autoFlush"),
    AFW_UTF8_LITERAL("Auto flush"),
    AFW_UTF8_LITERAL("If specified and true, this will automatically flush the stream's buffers after every write."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_open_response_parameters[] = {
    &impl_open_response_parameter_1,
    &impl_open_response_parameter_2,
    NULL
};

static const afw_utf8_t
impl_open_response_sideEffects[] = {
    AFW_UTF8_LITERAL("Stream is opened"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_open_response = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__open_response,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("open_response"),
    AFW_UTF8_LITERAL("open_response"),
    AFW_UTF8_LITERAL("open_response"),
    AFW_UTF8_LITERAL("openResponse"),
    AFW_UTF8_LITERAL("afwOpenResponse"),
    AFW_UTF8_LITERAL("Open a response stream"),
    AFW_UTF8_LITERAL("This will open a response text write-only stream that will be written to the http response."),
    AFW_UTF8_LITERAL("(streamId: string, autoFlush?: boolean): integer"),
    AFW_UTF8_LITERAL("/* Open a response stream */\nfunction open_response (\n    streamId: string    /* Stream id */,\n    autoFlush?: boolean /* Auto flush */\n): integer; /* streamNumber */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_open_response,
    NULL,
    1,
    2,
    &impl_open_response_parameters[0],
    2,
    &impl_open_response_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_open_response_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- open_uri ---------- */

static const afw_utf8_t
impl_object_path__open_uri =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/open_uri");

static const afw_runtime_object_indirect_t
impl_object__open_uri = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_open_uri,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__open_uri
        }
    },
    (void *)&afw_function_definition_open_uri
};

static const afw_value_function_parameter_t
impl_open_uri_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_uri_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamId"),
    AFW_UTF8_LITERAL("Stream id"),
    AFW_UTF8_LITERAL("This is the streamId that will be associated with this open URI stream."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_uri_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("uri"),
    AFW_UTF8_LITERAL("URI"),
    AFW_UTF8_LITERAL("This is the URI of the stream to open."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_uri_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("mode"),
    AFW_UTF8_LITERAL("Mode"),
    AFW_UTF8_LITERAL("This is the access mode string. Values can be \"r\" for read or \"w\" for write."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_open_uri_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("autoFlush"),
    AFW_UTF8_LITERAL("Auto flush"),
    AFW_UTF8_LITERAL("If specified and true, this will automatically flush the stream's buffers after every write."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_open_uri_parameters[] = {
    &impl_open_uri_parameter_1,
    &impl_open_uri_parameter_2,
    &impl_open_uri_parameter_3,
    &impl_open_uri_parameter_4,
    NULL
};

static const afw_utf8_t
impl_open_uri_sideEffects[] = {
    AFW_UTF8_LITERAL("Stream is opened"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_open_uri = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__open_uri,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("open_uri"),
    AFW_UTF8_LITERAL("open_uri"),
    AFW_UTF8_LITERAL("open_uri"),
    AFW_UTF8_LITERAL("openUri"),
    AFW_UTF8_LITERAL("afwOpenUri"),
    AFW_UTF8_LITERAL("Open a URI"),
    AFW_UTF8_LITERAL("This will open a read or write stream for a URI."),
    AFW_UTF8_LITERAL("(streamId: string, uri: string, mode: string, autoFlush?: boolean): integer"),
    AFW_UTF8_LITERAL("/* Open a URI */\nfunction open_uri (\n    streamId: string    /* Stream id */,\n    uri: string         /* URI */,\n    mode: string        /* Mode */,\n    autoFlush?: boolean /* Auto flush */\n): integer; /* streamNumber */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_open_uri,
    NULL,
    3,
    4,
    &impl_open_uri_parameters[0],
    4,
    &impl_open_uri_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_open_uri_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- print ---------- */

static const afw_utf8_t
impl_object_path__print =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/print");

static const afw_runtime_object_indirect_t
impl_object__print = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_print,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__print
        }
    },
    (void *)&afw_function_definition_print
};

static const afw_value_function_parameter_t
impl_print_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_print_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Values to print."),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_print_parameters[] = {
    &impl_print_parameter_1,
    NULL
};

static const afw_utf8_t
impl_print_sideEffects[] = {
    AFW_UTF8_LITERAL("Values written"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_print = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__print,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("print"),
    AFW_UTF8_LITERAL("print"),
    AFW_UTF8_LITERAL("print"),
    AFW_UTF8_LITERAL("print"),
    AFW_UTF8_LITERAL("afwPrint"),
    AFW_UTF8_LITERAL("Print value"),
    AFW_UTF8_LITERAL("Evaluate and convert 0 or more values to its string value, then write them to stdout. An undefined value is represented by '<undefined>'."),
    AFW_UTF8_LITERAL("(...values: (list of any)): null"),
    AFW_UTF8_LITERAL("/* Print value */\nfunction print (\n    ...values: (list of any)\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_print,
    NULL,
    0,
    -1,
    &impl_print_parameters[0],
    1,
    &impl_print_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_print_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- println ---------- */

static const afw_utf8_t
impl_object_path__println =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/println");

static const afw_runtime_object_indirect_t
impl_object__println = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_println,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__println
        }
    },
    (void *)&afw_function_definition_println
};

static const afw_value_function_parameter_t
impl_println_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_println_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Values to print."),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_println_parameters[] = {
    &impl_println_parameter_1,
    NULL
};

static const afw_utf8_t
impl_println_sideEffects[] = {
    AFW_UTF8_LITERAL("Values written"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_println = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__println,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("println"),
    AFW_UTF8_LITERAL("println"),
    AFW_UTF8_LITERAL("println"),
    AFW_UTF8_LITERAL("println"),
    AFW_UTF8_LITERAL("afwPrintln"),
    AFW_UTF8_LITERAL("Print value followed by '\\n'"),
    AFW_UTF8_LITERAL("Evaluate and convert 0 or more values to their string value, then write them to stdout. A newline character ('\\n') is written after the last value. An undefined value is represented by '<undefined>'."),
    AFW_UTF8_LITERAL("(...value: (list of any)): null"),
    AFW_UTF8_LITERAL("/* Print value followed by '\\n' */\nfunction println (\n    ...value: (list of any)\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_println,
    NULL,
    0,
    -1,
    &impl_println_parameters[0],
    1,
    &impl_println_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_println_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- read ---------- */

static const afw_utf8_t
impl_object_path__read =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/read");

static const afw_runtime_object_indirect_t
impl_object__read = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_read,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__read
        }
    },
    (void *)&afw_function_definition_read
};

static const afw_value_function_parameter_t
impl_read_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string read"),
    AFW_UTF8_LITERAL("The UTF-8 string read. Check the size of this value to determine the actual number of octets read."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_read_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("Stream number"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_read_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("n"),
    AFW_UTF8_LITERAL("Number of octets"),
    AFW_UTF8_LITERAL("The maximum number of octets to read."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_read_parameters[] = {
    &impl_read_parameter_1,
    &impl_read_parameter_2,
    NULL
};

static const afw_utf8_t
impl_read_sideEffects[] = {
    AFW_UTF8_LITERAL("Stream modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_read = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__read,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("read"),
    AFW_UTF8_LITERAL("read"),
    AFW_UTF8_LITERAL("read"),
    AFW_UTF8_LITERAL("read"),
    AFW_UTF8_LITERAL("afwRead"),
    AFW_UTF8_LITERAL("Read from a UTF-8 text stream"),
    AFW_UTF8_LITERAL("Read a UTF-8 text stream up to a specified number of octets. The stream must contain valid UTF-8 or an error is thrown."),
    AFW_UTF8_LITERAL("(streamNumber: integer, n: any): string"),
    AFW_UTF8_LITERAL("/* Read from a UTF-8 text stream */\nfunction read (\n    streamNumber: integer /* Stream number */,\n    n: any                /* Number of octets */\n): string; /* The string read */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_read,
    NULL,
    2,
    2,
    &impl_read_parameters[0],
    2,
    &impl_read_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_read_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- read_to_base64Binary ---------- */

static const afw_utf8_t
impl_object_path__read_to_base64Binary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/read_to_base64Binary");

static const afw_runtime_object_indirect_t
impl_object__read_to_base64Binary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_read_to_base64Binary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__read_to_base64Binary
        }
    },
    (void *)&afw_function_definition_read_to_base64Binary
};

static const afw_value_function_parameter_t
impl_read_to_base64Binary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The base64Binary read"),
    AFW_UTF8_LITERAL("The base64Binary value read. Check the size of this value to determine the actual number of octets read."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_read_to_base64Binary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("Stream number"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_read_to_base64Binary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("n"),
    AFW_UTF8_LITERAL("Number of octets"),
    AFW_UTF8_LITERAL("The maximum number of octets to read."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_read_to_base64Binary_parameters[] = {
    &impl_read_to_base64Binary_parameter_1,
    &impl_read_to_base64Binary_parameter_2,
    NULL
};

static const afw_utf8_t
impl_read_to_base64Binary_sideEffects[] = {
    AFW_UTF8_LITERAL("Stream modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_read_to_base64Binary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__read_to_base64Binary,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("read_to_base64Binary"),
    AFW_UTF8_LITERAL("read_to_base64Binary"),
    AFW_UTF8_LITERAL("read_to_base64Binary"),
    AFW_UTF8_LITERAL("readToBase64Binary"),
    AFW_UTF8_LITERAL("afwReadToBase64Binary"),
    AFW_UTF8_LITERAL("Read from a stream to base64Binary"),
    AFW_UTF8_LITERAL("Read a stream up to a specified number of octets. The result will be the internal memory of a base64Binary value."),
    AFW_UTF8_LITERAL("(streamNumber: integer, n: any): base64Binary"),
    AFW_UTF8_LITERAL("/* Read from a stream to base64Binary */\nfunction read_to_base64Binary (\n    streamNumber: integer /* Stream number */,\n    n: any                /* Number of octets */\n): base64Binary; /* The base64Binary read */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_read_to_base64Binary,
    NULL,
    2,
    2,
    &impl_read_to_base64Binary_parameters[0],
    2,
    &impl_read_to_base64Binary_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_read_to_base64Binary_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- read_to_hexBinary ---------- */

static const afw_utf8_t
impl_object_path__read_to_hexBinary =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/read_to_hexBinary");

static const afw_runtime_object_indirect_t
impl_object__read_to_hexBinary = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_read_to_hexBinary,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__read_to_hexBinary
        }
    },
    (void *)&afw_function_definition_read_to_hexBinary
};

static const afw_value_function_parameter_t
impl_read_to_hexBinary_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The hexBinary read"),
    AFW_UTF8_LITERAL("The hexBinary value read. Check the size of this value to determine the actual number of octets read."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_read_to_hexBinary_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("Stream number"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_read_to_hexBinary_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("n"),
    AFW_UTF8_LITERAL("Number of octets"),
    AFW_UTF8_LITERAL("The maximum number of octets to read."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_read_to_hexBinary_parameters[] = {
    &impl_read_to_hexBinary_parameter_1,
    &impl_read_to_hexBinary_parameter_2,
    NULL
};

static const afw_utf8_t
impl_read_to_hexBinary_sideEffects[] = {
    AFW_UTF8_LITERAL("Stream modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_read_to_hexBinary = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__read_to_hexBinary,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("read_to_hexBinary"),
    AFW_UTF8_LITERAL("read_to_hexBinary"),
    AFW_UTF8_LITERAL("read_to_hexBinary"),
    AFW_UTF8_LITERAL("readToHexBinary"),
    AFW_UTF8_LITERAL("afwReadToHexBinary"),
    AFW_UTF8_LITERAL("Read from a stream to hexBinary"),
    AFW_UTF8_LITERAL("Read a stream up to a specified number of octets. The result will be the internal memory of a hexBinary value."),
    AFW_UTF8_LITERAL("(streamNumber: integer, n: any): hexBinary"),
    AFW_UTF8_LITERAL("/* Read from a stream to hexBinary */\nfunction read_to_hexBinary (\n    streamNumber: integer /* Stream number */,\n    n: any                /* Number of octets */\n): hexBinary; /* The hexBinary read */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_read_to_hexBinary,
    NULL,
    2,
    2,
    &impl_read_to_hexBinary_parameters[0],
    2,
    &impl_read_to_hexBinary_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_read_to_hexBinary_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- readln ---------- */

static const afw_utf8_t
impl_object_path__readln =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/readln");

static const afw_runtime_object_indirect_t
impl_object__readln = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_readln,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__readln
        }
    },
    (void *)&afw_function_definition_readln
};

static const afw_value_function_parameter_t
impl_readln_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string read"),
    AFW_UTF8_LITERAL("The UTF-8 string read."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_readln_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("Stream number"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_readln_parameters[] = {
    &impl_readln_parameter_1,
    NULL
};

static const afw_utf8_t
impl_readln_sideEffects[] = {
    AFW_UTF8_LITERAL("Stream modified"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_readln = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__readln,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("readln"),
    AFW_UTF8_LITERAL("readln"),
    AFW_UTF8_LITERAL("readln"),
    AFW_UTF8_LITERAL("readln"),
    AFW_UTF8_LITERAL("afwReadln"),
    AFW_UTF8_LITERAL("Read from a UTF-8 text stream line"),
    AFW_UTF8_LITERAL("Read a UTF-8 text stream line. The stream must contain valid UTF-8 or an error is thrown."),
    AFW_UTF8_LITERAL("(streamNumber: integer): string"),
    AFW_UTF8_LITERAL("/* Read from a UTF-8 text stream line */\nfunction readln (\n    streamNumber: integer /* Stream number */\n): string; /* The string read */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_readln,
    NULL,
    1,
    1,
    &impl_readln_parameters[0],
    1,
    &impl_readln_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_readln_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- stream ---------- */

static const afw_utf8_t
impl_object_path__stream =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/stream");

static const afw_runtime_object_indirect_t
impl_object__stream = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_stream,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__stream
        }
    },
    (void *)&afw_function_definition_stream
};

static const afw_value_function_parameter_t
impl_stream_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_stream_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamId"),
    AFW_UTF8_LITERAL("Stream Id"),
    AFW_UTF8_LITERAL("The id of a stream."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_stream_parameters[] = {
    &impl_stream_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_stream = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__stream,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("afwStream"),
    AFW_UTF8_LITERAL("Get streamNumber for a streamId"),
    AFW_UTF8_LITERAL("This will return the streamNumber for a streamId. This function useful to obtain the number of the automatically opened standard streams \"console\", \"stderr\" and \"stdout\" as well and any other open stream."),
    AFW_UTF8_LITERAL("(streamId: string): integer"),
    AFW_UTF8_LITERAL("/* Get streamNumber for a streamId */\nfunction stream (\n    streamId: string /* Stream Id */\n): integer; /* streamNumber */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_stream,
    NULL,
    1,
    1,
    &impl_stream_parameters[0],
    1,
    &impl_stream_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- write ---------- */

static const afw_utf8_t
impl_object_path__write =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/write");

static const afw_runtime_object_indirect_t
impl_object__write = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_write,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__write
        }
    },
    (void *)&afw_function_definition_write
};

static const afw_value_function_parameter_t
impl_write_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_write_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("The streamNumber for the stream to write."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_write_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_any_direct,
    AFW_UTF8_LITERAL("any"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Values to write as their string value."),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_write_parameters[] = {
    &impl_write_parameter_1,
    &impl_write_parameter_2,
    NULL
};

static const afw_utf8_t
impl_write_sideEffects[] = {
    AFW_UTF8_LITERAL("Values written"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_write = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__write,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("write"),
    AFW_UTF8_LITERAL("write"),
    AFW_UTF8_LITERAL("write"),
    AFW_UTF8_LITERAL("write"),
    AFW_UTF8_LITERAL("afwWrite"),
    AFW_UTF8_LITERAL("Write values to stream as sting"),
    AFW_UTF8_LITERAL("Evaluate and convert 0 or more values to its string value, then write them to stream. An value with an undefined value is represented by '<undefined>'."),
    AFW_UTF8_LITERAL("(streamNumber: integer, ...value: (list of any)): null"),
    AFW_UTF8_LITERAL("/* Write values to stream as sting */\nfunction write (\n    streamNumber: integer /* Stream number */,\n    ...value: (list of any)\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_write,
    NULL,
    1,
    -1,
    &impl_write_parameters[0],
    2,
    &impl_write_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_write_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- write_internal ---------- */

static const afw_utf8_t
impl_object_path__write_internal =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/write_internal");

static const afw_runtime_object_indirect_t
impl_object__write_internal = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_write_internal,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__write_internal
        }
    },
    (void *)&afw_function_definition_write_internal
};

static const afw_value_function_parameter_t
impl_write_internal_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_write_internal_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("The streamNumber for the stream to write."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_write_internal_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_any_direct,
    AFW_UTF8_LITERAL("any"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL("Internal value to write"),
    AFW_UTF8_LITERAL("The internal memory of this value is written."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_write_internal_parameters[] = {
    &impl_write_internal_parameter_1,
    &impl_write_internal_parameter_2,
    NULL
};

static const afw_utf8_t
impl_write_internal_sideEffects[] = {
    AFW_UTF8_LITERAL("Values written"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_write_internal = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__write_internal,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("write_internal"),
    AFW_UTF8_LITERAL("write_internal"),
    AFW_UTF8_LITERAL("write_internal"),
    AFW_UTF8_LITERAL("writeInternal"),
    AFW_UTF8_LITERAL("afwWriteInternal"),
    AFW_UTF8_LITERAL("Write internal"),
    AFW_UTF8_LITERAL("Write a value's internal memory. This is especially useful for writing data type base64Binary and hexBinary."),
    AFW_UTF8_LITERAL("(streamNumber: integer, value: any): null"),
    AFW_UTF8_LITERAL("/* Write internal */\nfunction write_internal (\n    streamNumber: integer /* Stream number */,\n    value: any            /* Internal value to write */\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_write_internal,
    NULL,
    2,
    2,
    &impl_write_internal_parameters[0],
    2,
    &impl_write_internal_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_write_internal_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- writeln ---------- */

static const afw_utf8_t
impl_object_path__writeln =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/writeln");

static const afw_runtime_object_indirect_t
impl_object__writeln = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_writeln,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__writeln
        }
    },
    (void *)&afw_function_definition_writeln
};

static const afw_value_function_parameter_t
impl_writeln_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_null_direct,
    AFW_UTF8_LITERAL("null"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_writeln_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("streamNumber"),
    AFW_UTF8_LITERAL("Stream number"),
    AFW_UTF8_LITERAL("The streamNumber for the stream to write."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_writeln_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Values to write."),
    0,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_writeln_parameters[] = {
    &impl_writeln_parameter_1,
    &impl_writeln_parameter_2,
    NULL
};

static const afw_utf8_t
impl_writeln_sideEffects[] = {
    AFW_UTF8_LITERAL("Values written"),
    { NULL }
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_writeln = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__writeln,
    AFW_UTF8_LITERAL("stream"),
    AFW_UTF8_LITERAL("writeln"),
    AFW_UTF8_LITERAL("writeln"),
    AFW_UTF8_LITERAL("writeln"),
    AFW_UTF8_LITERAL("writeln"),
    AFW_UTF8_LITERAL("afwWriteln"),
    AFW_UTF8_LITERAL("Write values to stream as string followed by '\\n'"),
    AFW_UTF8_LITERAL("Evaluate and convert 0 or more values to its string value, then write them to stream. A newline character ('\\n') is written after the last value. An undefined value is represented by '<undefined>'."),
    AFW_UTF8_LITERAL("(streamNumber: integer, ...value: (list of any)): null"),
    AFW_UTF8_LITERAL("/* Write values to stream as string followed by '\\n' */\nfunction writeln (\n    streamNumber: integer /* Stream number */,\n    ...value: (list of any)\n): null;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_writeln,
    NULL,
    1,
    -1,
    &impl_writeln_parameters[0],
    2,
    &impl_writeln_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    &impl_writeln_sideEffects[0],
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- add<string> ---------- */

static const afw_utf8_t
impl_object_path__add_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/add_string");

static const afw_runtime_object_indirect_t
impl_object__add_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_add_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__add_string
        }
    },
    (void *)&afw_function_definition_add_string
};

static const afw_value_function_parameter_t
impl_add_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_add_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_add_string_parameters[] = {
    &impl_add_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__add_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("add<string>"),
    AFW_UTF8_LITERAL("add"),
    AFW_UTF8_LITERAL("add_string"),
    AFW_UTF8_LITERAL("addString"),
    AFW_UTF8_LITERAL("afwAddString"),
    AFW_UTF8_LITERAL("Add (concatenate) strings"),
    AFW_UTF8_LITERAL("Add (concatenate) 2 or more string values and return the string result."),
    AFW_UTF8_LITERAL("(values_1: string, values_2: string, ...values_rest: (list of string)): string"),
    AFW_UTF8_LITERAL("/* Add (concatenate) strings */\nfunction add<string> (\n    values_1: string,\n    values_2: string,\n    ...values_rest: (list of string)\n): string;\n"),
    AFW_UTF8_LITERAL("+"),
    afw_function_execute_add_string,
    NULL,
    2,
    -1,
    &impl_add_string_parameters[0],
    1,
    &impl_add_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_add,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<string> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_string");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_string
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_string
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_string_parameters[] = {
    &impl_at_least_one_member_of_string_parameter_1,
    &impl_at_least_one_member_of_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("at_least_one_member_of<string>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_string"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfString"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfString"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in string list1 is in string list2."),
    AFW_UTF8_LITERAL("(list1: (list string), list2: (list string)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<string> (\n    list1: (list string),\n    list2: (list string)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_string_parameters[0],
    2,
    &impl_at_least_one_member_of_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<string> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_string");

static const afw_runtime_object_indirect_t
impl_object__bag_size_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_string
        }
    },
    (void *)&afw_function_definition_bag_size_string
};

static const afw_value_function_parameter_t
impl_bag_size_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_string_parameters[] = {
    &impl_bag_size_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("bag_size<string>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_string"),
    AFW_UTF8_LITERAL("bagSizeString"),
    AFW_UTF8_LITERAL("afwBagSizeString"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list string)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<string> (\n    value: (list string)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_string_parameters[0],
    1,
    &impl_bag_size_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<string> ---------- */

static const afw_utf8_t
impl_object_path__bag_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_string");

static const afw_runtime_object_indirect_t
impl_object__bag_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_string
        }
    },
    (void *)&afw_function_definition_bag_string
};

static const afw_value_function_parameter_t
impl_bag_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_string_parameters[] = {
    &impl_bag_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("bag<string>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_string"),
    AFW_UTF8_LITERAL("bagString"),
    AFW_UTF8_LITERAL("afwBagString"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of string values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list string))): (list string)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<string> (\n    ...values: (list of (list string))\n): (list string);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_string_parameters[0],
    1,
    &impl_bag_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- concat ---------- */

static const afw_utf8_t
impl_object_path__concat =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/concat");

static const afw_runtime_object_indirect_t
impl_object__concat = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_concat,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__concat
        }
    },
    (void *)&afw_function_definition_concat
};

static const afw_value_function_parameter_t
impl_concat_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Concatenated value"),
    AFW_UTF8_LITERAL("The concatenated string values."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_concat_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_concat_parameters[] = {
    &impl_concat_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_concat_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_concat = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__concat,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("concat"),
    AFW_UTF8_LITERAL("concat"),
    AFW_UTF8_LITERAL("concat"),
    AFW_UTF8_LITERAL("concat"),
    AFW_UTF8_LITERAL("afwConcat"),
    AFW_UTF8_LITERAL("Convert two or more values to string and concatenate"),
    AFW_UTF8_LITERAL("Convert two or more values of any data type to string and return the concatenated result. A value with an undefined value is represented by '<undefined>'."),
    AFW_UTF8_LITERAL("(values_1: any, ...values_rest: (list of any)): string"),
    AFW_UTF8_LITERAL("/* Convert two or more values to string and concatenate */\nfunction concat (\n    values_1: any,\n    ...values_rest: (list of any)\n): string; /* Concatenated value */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_concat,
    NULL,
    1,
    -1,
    &impl_concat_parameters[0],
    1,
    &impl_concat_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_concat_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- encode_as_base64Binary<string> ---------- */

static const afw_utf8_t
impl_object_path__encode_as_base64Binary_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/encode_as_base64Binary_string");

static const afw_runtime_object_indirect_t
impl_object__encode_as_base64Binary_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_encode_as_base64Binary_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__encode_as_base64Binary_string
        }
    },
    (void *)&afw_function_definition_encode_as_base64Binary_string
};

static const afw_value_function_parameter_t
impl_encode_as_base64Binary_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_base64Binary_direct,
    AFW_UTF8_LITERAL("base64Binary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A base64Binary value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_encode_as_base64Binary_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string value to encode."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_encode_as_base64Binary_string_parameters[] = {
    &impl_encode_as_base64Binary_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_base64Binary_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__encode_as_base64Binary_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("encode_as_base64Binary<string>"),
    AFW_UTF8_LITERAL("encode_as_base64Binary"),
    AFW_UTF8_LITERAL("encode_as_base64Binary_string"),
    AFW_UTF8_LITERAL("encodeAsBase64BinaryString"),
    AFW_UTF8_LITERAL("afwEncodeAsBase64BinaryString"),
    AFW_UTF8_LITERAL("Encode to a base64Binary value"),
    AFW_UTF8_LITERAL("Encode a value as a base64Binary. The effect is to create a base64Binary value with an internal value of the value passed."),
    AFW_UTF8_LITERAL("(value: string): base64Binary"),
    AFW_UTF8_LITERAL("/* Encode to a base64Binary value */\nfunction encode_as_base64Binary<string> (\n    value: string\n): base64Binary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_encode_as_base64Binary,
    NULL,
    1,
    1,
    &impl_encode_as_base64Binary_string_parameters[0],
    1,
    &impl_encode_as_base64Binary_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_encode_as_base64Binary,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- encode_as_hexBinary<string> ---------- */

static const afw_utf8_t
impl_object_path__encode_as_hexBinary_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/encode_as_hexBinary_string");

static const afw_runtime_object_indirect_t
impl_object__encode_as_hexBinary_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_encode_as_hexBinary_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__encode_as_hexBinary_string
        }
    },
    (void *)&afw_function_definition_encode_as_hexBinary_string
};

static const afw_value_function_parameter_t
impl_encode_as_hexBinary_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_hexBinary_direct,
    AFW_UTF8_LITERAL("hexBinary"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A hexBinary value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_encode_as_hexBinary_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string value to encode."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_encode_as_hexBinary_string_parameters[] = {
    &impl_encode_as_hexBinary_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_hexBinary_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__encode_as_hexBinary_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("encode_as_hexBinary<string>"),
    AFW_UTF8_LITERAL("encode_as_hexBinary"),
    AFW_UTF8_LITERAL("encode_as_hexBinary_string"),
    AFW_UTF8_LITERAL("encodeAsHexBinaryString"),
    AFW_UTF8_LITERAL("afwEncodeAsHexBinaryString"),
    AFW_UTF8_LITERAL("Encode to a hexBinary value"),
    AFW_UTF8_LITERAL("Encode a value as a hexBinary. The effect is to create a hexBinary value with an internal value of the value passed."),
    AFW_UTF8_LITERAL("(value: string): hexBinary"),
    AFW_UTF8_LITERAL("/* Encode to a hexBinary value */\nfunction encode_as_hexBinary<string> (\n    value: string\n): hexBinary;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_encode_as_hexBinary,
    NULL,
    1,
    1,
    &impl_encode_as_hexBinary_string_parameters[0],
    1,
    &impl_encode_as_hexBinary_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_encode_as_hexBinary,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ends_with<string> ---------- */

static const afw_utf8_t
impl_object_path__ends_with_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ends_with_string");

static const afw_runtime_object_indirect_t
impl_object__ends_with_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ends_with_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ends_with_string
        }
    },
    (void *)&afw_function_definition_ends_with_string
};

static const afw_value_function_parameter_t
impl_ends_with_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ends_with_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ends_with_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ends_with_string_parameters[] = {
    &impl_ends_with_string_parameter_1,
    &impl_ends_with_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ends_with_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ends_with_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("ends_with<string>"),
    AFW_UTF8_LITERAL("ends_with"),
    AFW_UTF8_LITERAL("ends_with_string"),
    AFW_UTF8_LITERAL("endsWithString"),
    AFW_UTF8_LITERAL("afwEndsWithString"),
    AFW_UTF8_LITERAL("Checks whether value ends with a string"),
    AFW_UTF8_LITERAL("Checks whether string value ends with a string and return the boolean result."),
    AFW_UTF8_LITERAL("(value: string, subString: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value ends with a string */\nfunction ends_with<string> (\n    value: string,\n    subString: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_ends_with,
    NULL,
    2,
    2,
    &impl_ends_with_string_parameters[0],
    2,
    &impl_ends_with_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_ends_with,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq_ignore_case<string> ---------- */

static const afw_utf8_t
impl_object_path__eq_ignore_case_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_ignore_case_string");

static const afw_runtime_object_indirect_t
impl_object__eq_ignore_case_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_ignore_case_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_ignore_case_string
        }
    },
    (void *)&afw_function_definition_eq_ignore_case_string
};

static const afw_value_function_parameter_t
impl_eq_ignore_case_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ignore_case_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_ignore_case_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_ignore_case_string_parameters[] = {
    &impl_eq_ignore_case_string_parameter_1,
    &impl_eq_ignore_case_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ignore_case_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_ignore_case_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("eq_ignore_case<string>"),
    AFW_UTF8_LITERAL("eq_ignore_case"),
    AFW_UTF8_LITERAL("eq_ignore_case_string"),
    AFW_UTF8_LITERAL("eqIgnoreCaseString"),
    AFW_UTF8_LITERAL("afwEqIgnoreCaseString"),
    AFW_UTF8_LITERAL("Checks for equal ignoring case"),
    AFW_UTF8_LITERAL("Checks for string arg1 is equal to string arg2 ignoring case and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal ignoring case */\nfunction eq_ignore_case<string> (\n    arg1: string,\n    arg2: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_eq_ignore_case_string,
    NULL,
    2,
    2,
    &impl_eq_ignore_case_string_parameters[0],
    2,
    &impl_eq_ignore_case_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_eq_ignore_case,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<string> ---------- */

static const afw_utf8_t
impl_object_path__eq_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_string");

static const afw_runtime_object_indirect_t
impl_object__eq_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_string
        }
    },
    (void *)&afw_function_definition_eq_string
};

static const afw_value_function_parameter_t
impl_eq_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_string_parameters[] = {
    &impl_eq_string_parameter_1,
    &impl_eq_string_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_string_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("eq<string>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_string"),
    AFW_UTF8_LITERAL("eqString"),
    AFW_UTF8_LITERAL("afwEqString"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if string arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<string> (\n    arg1: string,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_string_parameters[0],
    2,
    &impl_eq_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_eq_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<string> ---------- */

static const afw_utf8_t
impl_object_path__eqx_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_string");

static const afw_runtime_object_indirect_t
impl_object__eqx_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_string
        }
    },
    (void *)&afw_function_definition_eqx_string
};

static const afw_value_function_parameter_t
impl_eqx_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_string_parameters[] = {
    &impl_eqx_string_parameter_1,
    &impl_eqx_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("eqx<string>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_string"),
    AFW_UTF8_LITERAL("eqxString"),
    AFW_UTF8_LITERAL("afwEqxString"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for string arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<string> (\n    arg1: string,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_string_parameters[0],
    2,
    &impl_eqx_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<string> ---------- */

static const afw_utf8_t
impl_object_path__ge_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_string");

static const afw_runtime_object_indirect_t
impl_object__ge_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_string
        }
    },
    (void *)&afw_function_definition_ge_string
};

static const afw_value_function_parameter_t
impl_ge_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_string_parameters[] = {
    &impl_ge_string_parameter_1,
    &impl_ge_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("ge<string>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_string"),
    AFW_UTF8_LITERAL("geString"),
    AFW_UTF8_LITERAL("afwGeString"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for string arg1 is greater than or equal to string arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<string> (\n    arg1: string,\n    arg2: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_string_parameters[0],
    2,
    &impl_ge_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<string> ---------- */

static const afw_utf8_t
impl_object_path__gt_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_string");

static const afw_runtime_object_indirect_t
impl_object__gt_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_string
        }
    },
    (void *)&afw_function_definition_gt_string
};

static const afw_value_function_parameter_t
impl_gt_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_string_parameters[] = {
    &impl_gt_string_parameter_1,
    &impl_gt_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("gt<string>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_string"),
    AFW_UTF8_LITERAL("gtString"),
    AFW_UTF8_LITERAL("afwGtString"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for string arg1 is greater than string arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<string> (\n    arg1: string,\n    arg2: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_string_parameters[0],
    2,
    &impl_gt_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- includes<string> ---------- */

static const afw_utf8_t
impl_object_path__includes_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/includes_string");

static const afw_runtime_object_indirect_t
impl_object__includes_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_includes_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__includes_string
        }
    },
    (void *)&afw_function_definition_includes_string
};

static const afw_value_function_parameter_t
impl_includes_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Indicates if the substring is found"),
    AFW_UTF8_LITERAL("Indicates if the substring is contained in the search string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("searchString"),
    AFW_UTF8_LITERAL("The string to search"),
    AFW_UTF8_LITERAL("The string to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL("Substring to find"),
    AFW_UTF8_LITERAL("Substring to find."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_includes_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("position"),
    AFW_UTF8_LITERAL("Zero-based position in the search string to start search"),
    AFW_UTF8_LITERAL("Zero-based position in the search string to start search."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_includes_string_parameters[] = {
    &impl_includes_string_parameter_1,
    &impl_includes_string_parameter_2,
    &impl_includes_string_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__includes_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("includes<string>"),
    AFW_UTF8_LITERAL("includes"),
    AFW_UTF8_LITERAL("includes_string"),
    AFW_UTF8_LITERAL("includesString"),
    AFW_UTF8_LITERAL("afwIncludesString"),
    AFW_UTF8_LITERAL("Checks whether the string value includes a string"),
    AFW_UTF8_LITERAL("Checks whether the string value includes a string and return the boolean result."),
    AFW_UTF8_LITERAL("(searchString: string, subString: string, position?: integer): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether the string value includes a string */\nfunction includes<string> (\n    searchString: string /* The string to search */,\n    subString: string    /* Substring to find */,\n    position?: integer   /* Zero-based position in the search string to start search */\n): boolean; /* Indicates if the substring is found */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_includes,
    NULL,
    2,
    3,
    &impl_includes_string_parameters[0],
    3,
    &impl_includes_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_includes,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- index_of<string> ---------- */

static const afw_utf8_t
impl_object_path__index_of_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/index_of_string");

static const afw_runtime_object_indirect_t
impl_object__index_of_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_index_of_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__index_of_string
        }
    },
    (void *)&afw_function_definition_index_of_string
};

static const afw_value_function_parameter_t
impl_index_of_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string value to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Substring to search for."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_index_of_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional start index for search if different than start of string."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_index_of_string_parameters[] = {
    &impl_index_of_string_parameter_1,
    &impl_index_of_string_parameter_2,
    &impl_index_of_string_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_of_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__index_of_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("index_of<string>"),
    AFW_UTF8_LITERAL("index_of"),
    AFW_UTF8_LITERAL("index_of_string"),
    AFW_UTF8_LITERAL("indexOfString"),
    AFW_UTF8_LITERAL("afwIndexOfString"),
    AFW_UTF8_LITERAL("Returns index of first occurrence"),
    AFW_UTF8_LITERAL("Returns the zero-based index into string value of subString. If subString is not found, -1 is returned."),
    AFW_UTF8_LITERAL("(value: string, subString: string, startIndex?: integer): integer"),
    AFW_UTF8_LITERAL("/* Returns index of first occurrence */\nfunction index_of<string> (\n    value: string,\n    subString: string,\n    startIndex?: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_index_of,
    NULL,
    2,
    3,
    &impl_index_of_string_parameters[0],
    3,
    &impl_index_of_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_index_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<string> ---------- */

static const afw_utf8_t
impl_object_path__intersection_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_string");

static const afw_runtime_object_indirect_t
impl_object__intersection_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_string
        }
    },
    (void *)&afw_function_definition_intersection_string
};

static const afw_value_function_parameter_t
impl_intersection_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_string_parameters[] = {
    &impl_intersection_string_parameter_1,
    &impl_intersection_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("intersection<string>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_string"),
    AFW_UTF8_LITERAL("intersectionString"),
    AFW_UTF8_LITERAL("afwIntersectionString"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of string with the values that are common to both list of string list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list string), list2: (list string)): (list string)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<string> (\n    list1: (list string),\n    list2: (list string)\n): (list string);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_string_parameters[0],
    2,
    &impl_intersection_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<string> ---------- */

static const afw_utf8_t
impl_object_path__is_in_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_string");

static const afw_runtime_object_indirect_t
impl_object__is_in_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_string
        }
    },
    (void *)&afw_function_definition_is_in_string
};

static const afw_value_function_parameter_t
impl_is_in_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_string_parameters[] = {
    &impl_is_in_string_parameter_1,
    &impl_is_in_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("is_in<string>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_string"),
    AFW_UTF8_LITERAL("isInString"),
    AFW_UTF8_LITERAL("afwIsInString"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether string value is in list of string list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: string, list: (list string)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<string> (\n    value: string,\n    list: (list string)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_string_parameters[0],
    2,
    &impl_is_in_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<string> ---------- */

static const afw_utf8_t
impl_object_path__is_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_string");

static const afw_runtime_object_indirect_t
impl_object__is_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_string
        }
    },
    (void *)&afw_function_definition_is_string
};

static const afw_value_function_parameter_t
impl_is_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_string_parameters[] = {
    &impl_is_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("is<string>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_string"),
    AFW_UTF8_LITERAL("isString"),
    AFW_UTF8_LITERAL("afwIsString"),
    AFW_UTF8_LITERAL("Checks whether value is dataType string"),
    AFW_UTF8_LITERAL("Checks whether value is dataType string and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType string */\nfunction is<string> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_string_parameters[0],
    1,
    &impl_is_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- last_index_of<string> ---------- */

static const afw_utf8_t
impl_object_path__last_index_of_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/last_index_of_string");

static const afw_runtime_object_indirect_t
impl_object__last_index_of_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_last_index_of_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__last_index_of_string
        }
    },
    (void *)&afw_function_definition_last_index_of_string
};

static const afw_value_function_parameter_t
impl_last_index_of_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string value to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Substring to search for."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_last_index_of_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Optional start index for search if different than start of string."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_last_index_of_string_parameters[] = {
    &impl_last_index_of_string_parameter_1,
    &impl_last_index_of_string_parameter_2,
    &impl_last_index_of_string_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_last_index_of_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__last_index_of_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("last_index_of<string>"),
    AFW_UTF8_LITERAL("last_index_of"),
    AFW_UTF8_LITERAL("last_index_of_string"),
    AFW_UTF8_LITERAL("lastIndexOfString"),
    AFW_UTF8_LITERAL("afwLastIndexOfString"),
    AFW_UTF8_LITERAL("Returns index of last occurrence"),
    AFW_UTF8_LITERAL("Returns the zero-based index into string value of the last occurrence of a subString. If subString is not found, -1 is returned."),
    AFW_UTF8_LITERAL("(value: string, subString: string, startIndex?: integer): integer"),
    AFW_UTF8_LITERAL("/* Returns index of last occurrence */\nfunction last_index_of<string> (\n    value: string,\n    subString: string,\n    startIndex?: integer\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_last_index_of,
    NULL,
    2,
    3,
    &impl_last_index_of_string_parameters[0],
    3,
    &impl_last_index_of_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_last_index_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<string> ---------- */

static const afw_utf8_t
impl_object_path__le_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_string");

static const afw_runtime_object_indirect_t
impl_object__le_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_string
        }
    },
    (void *)&afw_function_definition_le_string
};

static const afw_value_function_parameter_t
impl_le_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_string_parameters[] = {
    &impl_le_string_parameter_1,
    &impl_le_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("le<string>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_string"),
    AFW_UTF8_LITERAL("leString"),
    AFW_UTF8_LITERAL("afwLeString"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for string arg1 is less than or equal to string arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<string> (\n    arg1: string,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_string_parameters[0],
    2,
    &impl_le_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- length<string> ---------- */

static const afw_utf8_t
impl_object_path__length_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/length_string");

static const afw_runtime_object_indirect_t
impl_object__length_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_length_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__length_string
        }
    },
    (void *)&afw_function_definition_length_string
};

static const afw_value_function_parameter_t
impl_length_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_length_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Returns the number of entries in a list or code points in others."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_length_string_parameters[] = {
    &impl_length_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__length_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("length<string>"),
    AFW_UTF8_LITERAL("length"),
    AFW_UTF8_LITERAL("length_string"),
    AFW_UTF8_LITERAL("lengthString"),
    AFW_UTF8_LITERAL("afwLengthString"),
    AFW_UTF8_LITERAL("Returns number of codepoints or entries in value"),
    AFW_UTF8_LITERAL("This is a polymorphic function where string can be any of the supported data types. Return the integer number of entries in datatype list or codepoints in others."),
    AFW_UTF8_LITERAL("(value: string): integer"),
    AFW_UTF8_LITERAL("/* Returns number of codepoints or entries in value */\nfunction length<string> (\n    value: string\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_length,
    NULL,
    1,
    1,
    &impl_length_string_parameters[0],
    1,
    &impl_length_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_length,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<string> ---------- */

static const afw_utf8_t
impl_object_path__lt_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_string");

static const afw_runtime_object_indirect_t
impl_object__lt_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_string
        }
    },
    (void *)&afw_function_definition_lt_string
};

static const afw_value_function_parameter_t
impl_lt_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_string_parameters[] = {
    &impl_lt_string_parameter_1,
    &impl_lt_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("lt<string>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_string"),
    AFW_UTF8_LITERAL("ltString"),
    AFW_UTF8_LITERAL("afwLtString"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for string arg1 is less that string arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<string> (\n    arg1: string,\n    arg2: string\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_string_parameters[0],
    2,
    &impl_lt_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- max<string> ---------- */

static const afw_utf8_t
impl_object_path__max_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/max_string");

static const afw_runtime_object_indirect_t
impl_object__max_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_max_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__max_string
        }
    },
    (void *)&afw_function_definition_max_string
};

static const afw_value_function_parameter_t
impl_max_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_max_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_max_string_parameters[] = {
    &impl_max_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__max_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("max<string>"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max_string"),
    AFW_UTF8_LITERAL("maxString"),
    AFW_UTF8_LITERAL("afwMaxString"),
    AFW_UTF8_LITERAL("Maximum value"),
    AFW_UTF8_LITERAL("Return the string value that is greater than or equal to the others."),
    AFW_UTF8_LITERAL("(values_1: string, ...values_rest: (list of string)): string"),
    AFW_UTF8_LITERAL("/* Maximum value */\nfunction max<string> (\n    values_1: string,\n    ...values_rest: (list of string)\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_max,
    NULL,
    1,
    -1,
    &impl_max_string_parameters[0],
    1,
    &impl_max_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_max,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- min<string> ---------- */

static const afw_utf8_t
impl_object_path__min_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/min_string");

static const afw_runtime_object_indirect_t
impl_object__min_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_min_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__min_string
        }
    },
    (void *)&afw_function_definition_min_string
};

static const afw_value_function_parameter_t
impl_min_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_min_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_min_string_parameters[] = {
    &impl_min_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__min_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("min<string>"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min_string"),
    AFW_UTF8_LITERAL("minString"),
    AFW_UTF8_LITERAL("afwMinString"),
    AFW_UTF8_LITERAL("Minimum value"),
    AFW_UTF8_LITERAL("Return the string value that is less than or equal to the others."),
    AFW_UTF8_LITERAL("(values_1: string, ...values_rest: (list of string)): string"),
    AFW_UTF8_LITERAL("/* Minimum value */\nfunction min<string> (\n    values_1: string,\n    ...values_rest: (list of string)\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_min,
    NULL,
    1,
    -1,
    &impl_min_string_parameters[0],
    1,
    &impl_min_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_min,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<string> ---------- */

static const afw_utf8_t
impl_object_path__ne_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_string");

static const afw_runtime_object_indirect_t
impl_object__ne_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_string
        }
    },
    (void *)&afw_function_definition_ne_string
};

static const afw_value_function_parameter_t
impl_ne_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_string_parameters[] = {
    &impl_ne_string_parameter_1,
    &impl_ne_string_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_string_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("ne<string>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_string"),
    AFW_UTF8_LITERAL("neString"),
    AFW_UTF8_LITERAL("afwNeString"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if string arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<string> (\n    arg1: string,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_string_parameters[0],
    2,
    &impl_ne_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_ne_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<string> ---------- */

static const afw_utf8_t
impl_object_path__nex_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_string");

static const afw_runtime_object_indirect_t
impl_object__nex_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_string
        }
    },
    (void *)&afw_function_definition_nex_string
};

static const afw_value_function_parameter_t
impl_nex_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_string_parameters[] = {
    &impl_nex_string_parameter_1,
    &impl_nex_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("nex<string>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_string"),
    AFW_UTF8_LITERAL("nexString"),
    AFW_UTF8_LITERAL("afwNexString"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for string arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: string, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<string> (\n    arg1: string,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_string_parameters[0],
    2,
    &impl_nex_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- normalize_space<string> ---------- */

static const afw_utf8_t
impl_object_path__normalize_space_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/normalize_space_string");

static const afw_runtime_object_indirect_t
impl_object__normalize_space_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_normalize_space_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__normalize_space_string
        }
    },
    (void *)&afw_function_definition_normalize_space_string
};

static const afw_value_function_parameter_t
impl_normalize_space_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_normalize_space_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_normalize_space_string_parameters[] = {
    &impl_normalize_space_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_space_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__normalize_space_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("normalize_space<string>"),
    AFW_UTF8_LITERAL("normalize_space"),
    AFW_UTF8_LITERAL("normalize_space_string"),
    AFW_UTF8_LITERAL("normalizeSpaceString"),
    AFW_UTF8_LITERAL("afwNormalizeSpaceString"),
    AFW_UTF8_LITERAL("Trims whitespace from beginning and end"),
    AFW_UTF8_LITERAL("Remove whitespace from the beginning and end of a string value."),
    AFW_UTF8_LITERAL("(string: string): string"),
    AFW_UTF8_LITERAL("/* Trims whitespace from beginning and end */\nfunction normalize_space<string> (\n    string: string\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_normalize_space_string,
    NULL,
    1,
    1,
    &impl_normalize_space_string_parameters[0],
    1,
    &impl_normalize_space_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_normalize_space,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- normalize_to_lower_case<string> ---------- */

static const afw_utf8_t
impl_object_path__normalize_to_lower_case_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/normalize_to_lower_case_string");

static const afw_runtime_object_indirect_t
impl_object__normalize_to_lower_case_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_normalize_to_lower_case_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__normalize_to_lower_case_string
        }
    },
    (void *)&afw_function_definition_normalize_to_lower_case_string
};

static const afw_value_function_parameter_t
impl_normalize_to_lower_case_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_normalize_to_lower_case_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_normalize_to_lower_case_string_parameters[] = {
    &impl_normalize_to_lower_case_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_to_lower_case_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__normalize_to_lower_case_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("normalize_to_lower_case<string>"),
    AFW_UTF8_LITERAL("normalize_to_lower_case"),
    AFW_UTF8_LITERAL("normalize_to_lower_case_string"),
    AFW_UTF8_LITERAL("normalizeToLowerCaseString"),
    AFW_UTF8_LITERAL("afwNormalizeToLowerCaseString"),
    AFW_UTF8_LITERAL("Converts to lower case"),
    AFW_UTF8_LITERAL("Normalize string value to lower case and returns string result."),
    AFW_UTF8_LITERAL("(string: string): string"),
    AFW_UTF8_LITERAL("/* Converts to lower case */\nfunction normalize_to_lower_case<string> (\n    string: string\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_normalize_to_lower_case_string,
    NULL,
    1,
    1,
    &impl_normalize_to_lower_case_string_parameters[0],
    1,
    &impl_normalize_to_lower_case_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_normalize_to_lower_case,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<string> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_string");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_string
        }
    },
    (void *)&afw_function_definition_one_and_only_string
};

static const afw_value_function_parameter_t
impl_one_and_only_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_string_parameters[] = {
    &impl_one_and_only_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_string_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("one_and_only<string>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_string"),
    AFW_UTF8_LITERAL("oneAndOnlyString"),
    AFW_UTF8_LITERAL("afwOneAndOnlyString"),
    AFW_UTF8_LITERAL("Converts a one value list to a string value"),
    AFW_UTF8_LITERAL("This converts a list of string values that contains one value to a single string value."),
    AFW_UTF8_LITERAL("(list: (list list)): string"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a string value */\nfunction one_and_only<string> (\n    list: (list list)\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_string_parameters[0],
    1,
    &impl_one_and_only_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_one_and_only_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_index_of<string> ---------- */

static const afw_utf8_t
impl_object_path__regexp_index_of_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_index_of_string");

static const afw_runtime_object_indirect_t
impl_object__regexp_index_of_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_index_of_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_index_of_string
        }
    },
    (void *)&afw_function_definition_regexp_index_of_string
};

static const afw_value_function_parameter_t
impl_regexp_index_of_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Zero-based index of subString or -1 if not found."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_index_of_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string value to search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_index_of_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A regular expression to use for search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_index_of_string_parameters[] = {
    &impl_regexp_index_of_string_parameter_1,
    &impl_regexp_index_of_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_index_of_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_index_of_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("regexp_index_of<string>"),
    AFW_UTF8_LITERAL("regexp_index_of"),
    AFW_UTF8_LITERAL("regexp_index_of_string"),
    AFW_UTF8_LITERAL("regexpIndexOfString"),
    AFW_UTF8_LITERAL("afwRegexpIndexOfString"),
    AFW_UTF8_LITERAL("Returns index of first match of regular expression"),
    AFW_UTF8_LITERAL("Search string value for a regular expression and return index. If not found, -1 is returned."),
    AFW_UTF8_LITERAL("(value: string, regexp: string): integer"),
    AFW_UTF8_LITERAL("/* Returns index of first match of regular expression */\nfunction regexp_index_of<string> (\n    value: string,\n    regexp: string\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_index_of,
    NULL,
    2,
    2,
    &impl_regexp_index_of_string_parameters[0],
    2,
    &impl_regexp_index_of_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_index_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_match<string> ---------- */

static const afw_utf8_t
impl_object_path__regexp_match_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_match_string");

static const afw_runtime_object_indirect_t
impl_object__regexp_match_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_match_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_match_string
        }
    },
    (void *)&afw_function_definition_regexp_match_string
};

static const afw_value_function_parameter_t
impl_regexp_match_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_match_string_parameters[] = {
    &impl_regexp_match_string_parameter_1,
    &impl_regexp_match_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_match_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("regexp_match<string>"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match_string"),
    AFW_UTF8_LITERAL("regexpMatchString"),
    AFW_UTF8_LITERAL("afwRegexpMatchString"),
    AFW_UTF8_LITERAL("Search for a match using a regular expression"),
    AFW_UTF8_LITERAL("Checks whether string value matches the regular expression regexp and return the boolean result."),
    AFW_UTF8_LITERAL("(value: string, regexp: string): boolean"),
    AFW_UTF8_LITERAL("/* Search for a match using a regular expression */\nfunction regexp_match<string> (\n    value: string,\n    regexp: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_match,
    NULL,
    2,
    2,
    &impl_regexp_match_string_parameters[0],
    2,
    &impl_regexp_match_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_replace<string> ---------- */

static const afw_utf8_t
impl_object_path__regexp_replace_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_replace_string");

static const afw_runtime_object_indirect_t
impl_object__regexp_replace_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_replace_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_replace_string
        }
    },
    (void *)&afw_function_definition_regexp_replace_string
};

static const afw_value_function_parameter_t
impl_regexp_replace_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A string value with the matched string(s) replaced."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The original string value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A regular expression to use for search."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("replacement"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The replacement string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_replace_string_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_replace_string_parameters[] = {
    &impl_regexp_replace_string_parameter_1,
    &impl_regexp_replace_string_parameter_2,
    &impl_regexp_replace_string_parameter_3,
    &impl_regexp_replace_string_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_replace_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_replace_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("regexp_replace<string>"),
    AFW_UTF8_LITERAL("regexp_replace"),
    AFW_UTF8_LITERAL("regexp_replace_string"),
    AFW_UTF8_LITERAL("regexpReplaceString"),
    AFW_UTF8_LITERAL("afwRegexpReplaceString"),
    AFW_UTF8_LITERAL("Replace strings matching a regular expression"),
    AFW_UTF8_LITERAL("Replace matched values for a regular expression in a string value."),
    AFW_UTF8_LITERAL("(value: string, regexp: string, replacement: string, limit?: integer): string"),
    AFW_UTF8_LITERAL("/* Replace strings matching a regular expression */\nfunction regexp_replace<string> (\n    value: string,\n    regexp: string,\n    replacement: string,\n    limit?: integer\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_replace,
    NULL,
    3,
    4,
    &impl_regexp_replace_string_parameters[0],
    4,
    &impl_regexp_replace_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_replace,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- repeat<string> ---------- */

static const afw_utf8_t
impl_object_path__repeat_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/repeat_string");

static const afw_runtime_object_indirect_t
impl_object__repeat_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_repeat_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__repeat_string
        }
    },
    (void *)&afw_function_definition_repeat_string
};

static const afw_value_function_parameter_t
impl_repeat_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The repeated string value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_repeat_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string value to repeat."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_repeat_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("times"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The number of times to repeat the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_repeat_string_parameters[] = {
    &impl_repeat_string_parameter_1,
    &impl_repeat_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_repeat_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__repeat_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("repeat<string>"),
    AFW_UTF8_LITERAL("repeat"),
    AFW_UTF8_LITERAL("repeat_string"),
    AFW_UTF8_LITERAL("repeatString"),
    AFW_UTF8_LITERAL("afwRepeatString"),
    AFW_UTF8_LITERAL("Returns a repeated value"),
    AFW_UTF8_LITERAL("Repeat a string value a specified number of times."),
    AFW_UTF8_LITERAL("(value: string, times: integer): string"),
    AFW_UTF8_LITERAL("/* Returns a repeated value */\nfunction repeat<string> (\n    value: string,\n    times: integer\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_repeat,
    NULL,
    2,
    2,
    &impl_repeat_string_parameters[0],
    2,
    &impl_repeat_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_repeat,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- replace<string> ---------- */

static const afw_utf8_t
impl_object_path__replace_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/replace_string");

static const afw_runtime_object_indirect_t
impl_object__replace_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_replace_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__replace_string
        }
    },
    (void *)&afw_function_definition_replace_string
};

static const afw_value_function_parameter_t
impl_replace_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A string value with the matched string(s) replaced."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The original string value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string to replace."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("replacement"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The replacement string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_replace_string_parameter_4 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_replace_string_parameters[] = {
    &impl_replace_string_parameter_1,
    &impl_replace_string_parameter_2,
    &impl_replace_string_parameter_3,
    &impl_replace_string_parameter_4,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__replace_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("replace<string>"),
    AFW_UTF8_LITERAL("replace"),
    AFW_UTF8_LITERAL("replace_string"),
    AFW_UTF8_LITERAL("replaceString"),
    AFW_UTF8_LITERAL("afwReplaceString"),
    AFW_UTF8_LITERAL("Replace strings"),
    AFW_UTF8_LITERAL("Replace string(s) in a string value."),
    AFW_UTF8_LITERAL("(value: string, match: string, replacement: string, limit?: integer): string"),
    AFW_UTF8_LITERAL("/* Replace strings */\nfunction replace<string> (\n    value: string,\n    match: string,\n    replacement: string,\n    limit?: integer\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_replace,
    NULL,
    3,
    4,
    &impl_replace_string_parameters[0],
    4,
    &impl_replace_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_replace,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<string> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_string");

static const afw_runtime_object_indirect_t
impl_object__set_equals_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_string
        }
    },
    (void *)&afw_function_definition_set_equals_string
};

static const afw_value_function_parameter_t
impl_set_equals_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_string_parameters[] = {
    &impl_set_equals_string_parameter_1,
    &impl_set_equals_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("set_equals<string>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_string"),
    AFW_UTF8_LITERAL("setEqualsString"),
    AFW_UTF8_LITERAL("afwSetEqualsString"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if string list1 and string list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list string), list2: (list string)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<string> (\n    list1: (list string),\n    list2: (list string)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_string_parameters[0],
    2,
    &impl_set_equals_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- split<string> ---------- */

static const afw_utf8_t
impl_object_path__split_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/split_string");

static const afw_runtime_object_indirect_t
impl_object__split_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_split_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__split_string
        }
    },
    (void *)&afw_function_definition_split_string
};

static const afw_value_function_parameter_t
impl_split_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An list of strings."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string value to split."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("separator"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The separator to use. If this is an empty string or separator is not specified, the value is split between characters."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_split_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("limit"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the maximum number of splits. Any remaining part of value is ignored."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_split_string_parameters[] = {
    &impl_split_string_parameter_1,
    &impl_split_string_parameter_2,
    &impl_split_string_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_split_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__split_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("split<string>"),
    AFW_UTF8_LITERAL("split"),
    AFW_UTF8_LITERAL("split_string"),
    AFW_UTF8_LITERAL("splitString"),
    AFW_UTF8_LITERAL("afwSplitString"),
    AFW_UTF8_LITERAL("Split at a separator"),
    AFW_UTF8_LITERAL("Split string value into an list of strings using a separator."),
    AFW_UTF8_LITERAL("(value: string, separator?: string, limit?: integer): list"),
    AFW_UTF8_LITERAL("/* Split at a separator */\nfunction split<string> (\n    value: string,\n    separator?: string,\n    limit?: integer\n): list;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_split,
    NULL,
    1,
    3,
    &impl_split_string_parameters[0],
    3,
    &impl_split_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_split,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- starts_with<string> ---------- */

static const afw_utf8_t
impl_object_path__starts_with_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/starts_with_string");

static const afw_runtime_object_indirect_t
impl_object__starts_with_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_starts_with_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__starts_with_string
        }
    },
    (void *)&afw_function_definition_starts_with_string
};

static const afw_value_function_parameter_t
impl_starts_with_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_starts_with_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_starts_with_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("subString"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_starts_with_string_parameters[] = {
    &impl_starts_with_string_parameter_1,
    &impl_starts_with_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_starts_with_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__starts_with_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("starts_with<string>"),
    AFW_UTF8_LITERAL("starts_with"),
    AFW_UTF8_LITERAL("starts_with_string"),
    AFW_UTF8_LITERAL("startsWithString"),
    AFW_UTF8_LITERAL("afwStartsWithString"),
    AFW_UTF8_LITERAL("Checks whether value starts with a string"),
    AFW_UTF8_LITERAL("Checks whether string value starts with a subString and return the boolean result."),
    AFW_UTF8_LITERAL("(value: string, subString: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value starts with a string */\nfunction starts_with<string> (\n    value: string,\n    subString: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_starts_with,
    NULL,
    2,
    2,
    &impl_starts_with_string_parameters[0],
    2,
    &impl_starts_with_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_starts_with,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- string ---------- */

static const afw_utf8_t
impl_object_path__string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/string");

static const afw_runtime_object_indirect_t
impl_object__string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__string
        }
    },
    (void *)&afw_function_definition_string
};

static const afw_value_function_parameter_t
impl_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Concatenated value"),
    AFW_UTF8_LITERAL("The concatenated string values."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_string_parameters[] = {
    &impl_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("afwString"),
    AFW_UTF8_LITERAL("Convert one or more values to string and concatenate"),
    AFW_UTF8_LITERAL("Convert one or more values of any data type to string and return the concatenated result. A value with an undefined value is represented by '<undefined>'."),
    AFW_UTF8_LITERAL("(values_1: any, ...values_rest: (list of any)): string"),
    AFW_UTF8_LITERAL("/* Convert one or more values to string and concatenate */\nfunction string (\n    values_1: any,\n    ...values_rest: (list of any)\n): string; /* Concatenated value */\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_string,
    NULL,
    1,
    -1,
    &impl_string_parameters[0],
    1,
    &impl_string_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_string_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<string> ---------- */

static const afw_utf8_t
impl_object_path__subset_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_string");

static const afw_runtime_object_indirect_t
impl_object__subset_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_string
        }
    },
    (void *)&afw_function_definition_subset_string
};

static const afw_value_function_parameter_t
impl_subset_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_string_parameters[] = {
    &impl_subset_string_parameter_1,
    &impl_subset_string_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("subset<string>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_string"),
    AFW_UTF8_LITERAL("subsetString"),
    AFW_UTF8_LITERAL("afwSubsetString"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in string list1 are all in string list2."),
    AFW_UTF8_LITERAL("(list1: (list string), list2: (list string)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<string> (\n    list1: (list string),\n    list2: (list string)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_string_parameters[0],
    2,
    &impl_subset_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- substring<string> ---------- */

static const afw_utf8_t
impl_object_path__substring_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/substring_string");

static const afw_runtime_object_indirect_t
impl_object__substring_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_substring_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__substring_string
        }
    },
    (void *)&afw_function_definition_substring_string
};

static const afw_value_function_parameter_t
impl_substring_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_substring_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_substring_string_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_substring_string_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("endIndex"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_substring_string_parameters[] = {
    &impl_substring_string_parameter_1,
    &impl_substring_string_parameter_2,
    &impl_substring_string_parameter_3,
    NULL
};

static const afw_utf8_z_t *
impl_substring_string_errorsThrown[] = {
    "error", "arg_error",
    "reason", "startIndex or endIndex is out of range",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_substring_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__substring_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("substring<string>"),
    AFW_UTF8_LITERAL("substring"),
    AFW_UTF8_LITERAL("substring_string"),
    AFW_UTF8_LITERAL("substringString"),
    AFW_UTF8_LITERAL("afwSubstringString"),
    AFW_UTF8_LITERAL("Extract a substring"),
    AFW_UTF8_LITERAL("Returns the string substring of value beginning at zero-based position integer startIndex and ending at the position before integer endIndex. Specify -1 or omitting endIndex to return up to end of string."),
    AFW_UTF8_LITERAL("(string: string, startIndex: integer, endIndex?: integer): string"),
    AFW_UTF8_LITERAL("/* Extract a substring */\nfunction substring<string> (\n    string: string,\n    startIndex: integer,\n    endIndex?: integer\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_substring,
    NULL,
    2,
    3,
    &impl_substring_string_parameters[0],
    3,
    &impl_substring_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_substring_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_substring,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_anyURI<string> ---------- */

static const afw_utf8_t
impl_object_path__to_anyURI_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_anyURI_string");

static const afw_runtime_object_indirect_t
impl_object__to_anyURI_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_anyURI_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_anyURI_string
        }
    },
    (void *)&afw_function_definition_to_anyURI_string
};

static const afw_value_function_parameter_t
impl_to_anyURI_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_anyURI_direct,
    AFW_UTF8_LITERAL("anyURI"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_anyURI_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_anyURI_string_parameters[] = {
    &impl_to_anyURI_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_anyURI_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_anyURI_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_anyURI_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_anyURI<string>"),
    AFW_UTF8_LITERAL("to_anyURI"),
    AFW_UTF8_LITERAL("to_anyURI_string"),
    AFW_UTF8_LITERAL("toAnyURIString"),
    AFW_UTF8_LITERAL("afwToAnyURIString"),
    AFW_UTF8_LITERAL("Converts string to anyURI"),
    AFW_UTF8_LITERAL("Converts string value to anyURI."),
    AFW_UTF8_LITERAL("(value: string): anyURI"),
    AFW_UTF8_LITERAL("/* Converts string to anyURI */\nfunction to_anyURI<string> (\n    value: string\n): anyURI;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_anyURI_string_parameters[0],
    1,
    &impl_to_anyURI_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_anyURI_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_anyURI,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_boolean<string> ---------- */

static const afw_utf8_t
impl_object_path__to_boolean_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_boolean_string");

static const afw_runtime_object_indirect_t
impl_object__to_boolean_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_boolean_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_boolean_string
        }
    },
    (void *)&afw_function_definition_to_boolean_string
};

static const afw_value_function_parameter_t
impl_to_boolean_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_boolean_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_boolean_string_parameters[] = {
    &impl_to_boolean_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_boolean_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_boolean_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_boolean_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_boolean<string>"),
    AFW_UTF8_LITERAL("to_boolean"),
    AFW_UTF8_LITERAL("to_boolean_string"),
    AFW_UTF8_LITERAL("toBooleanString"),
    AFW_UTF8_LITERAL("afwToBooleanString"),
    AFW_UTF8_LITERAL("Converts string to boolean"),
    AFW_UTF8_LITERAL("Converts string value to boolean."),
    AFW_UTF8_LITERAL("(value: string): boolean"),
    AFW_UTF8_LITERAL("/* Converts string to boolean */\nfunction to_boolean<string> (\n    value: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_boolean_string_parameters[0],
    1,
    &impl_to_boolean_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_boolean_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_boolean,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_dateTime<string> ---------- */

static const afw_utf8_t
impl_object_path__to_dateTime_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_dateTime_string");

static const afw_runtime_object_indirect_t
impl_object__to_dateTime_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_dateTime_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_dateTime_string
        }
    },
    (void *)&afw_function_definition_to_dateTime_string
};

static const afw_value_function_parameter_t
impl_to_dateTime_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dateTime_direct,
    AFW_UTF8_LITERAL("dateTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_dateTime_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_dateTime_string_parameters[] = {
    &impl_to_dateTime_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_dateTime_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dateTime_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_dateTime_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_dateTime<string>"),
    AFW_UTF8_LITERAL("to_dateTime"),
    AFW_UTF8_LITERAL("to_dateTime_string"),
    AFW_UTF8_LITERAL("toDateTimeString"),
    AFW_UTF8_LITERAL("afwToDateTimeString"),
    AFW_UTF8_LITERAL("Converts string to dateTime"),
    AFW_UTF8_LITERAL("Converts string value to dateTime."),
    AFW_UTF8_LITERAL("(value: string): dateTime"),
    AFW_UTF8_LITERAL("/* Converts string to dateTime */\nfunction to_dateTime<string> (\n    value: string\n): dateTime;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_dateTime_string_parameters[0],
    1,
    &impl_to_dateTime_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_dateTime_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_dateTime,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_date<string> ---------- */

static const afw_utf8_t
impl_object_path__to_date_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_date_string");

static const afw_runtime_object_indirect_t
impl_object__to_date_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_date_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_date_string
        }
    },
    (void *)&afw_function_definition_to_date_string
};

static const afw_value_function_parameter_t
impl_to_date_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_date_direct,
    AFW_UTF8_LITERAL("date"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_date_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_date_string_parameters[] = {
    &impl_to_date_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_date_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_date_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_date_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_date<string>"),
    AFW_UTF8_LITERAL("to_date"),
    AFW_UTF8_LITERAL("to_date_string"),
    AFW_UTF8_LITERAL("toDateString"),
    AFW_UTF8_LITERAL("afwToDateString"),
    AFW_UTF8_LITERAL("Converts string to date"),
    AFW_UTF8_LITERAL("Converts string value to date."),
    AFW_UTF8_LITERAL("(value: string): date"),
    AFW_UTF8_LITERAL("/* Converts string to date */\nfunction to_date<string> (\n    value: string\n): date;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_date_string_parameters[0],
    1,
    &impl_to_date_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_date_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_date,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_dayTimeDuration<string> ---------- */

static const afw_utf8_t
impl_object_path__to_dayTimeDuration_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_dayTimeDuration_string");

static const afw_runtime_object_indirect_t
impl_object__to_dayTimeDuration_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_dayTimeDuration_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_dayTimeDuration_string
        }
    },
    (void *)&afw_function_definition_to_dayTimeDuration_string
};

static const afw_value_function_parameter_t
impl_to_dayTimeDuration_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dayTimeDuration_direct,
    AFW_UTF8_LITERAL("dayTimeDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_dayTimeDuration_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_dayTimeDuration_string_parameters[] = {
    &impl_to_dayTimeDuration_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_dayTimeDuration_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dayTimeDuration_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_dayTimeDuration_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_dayTimeDuration<string>"),
    AFW_UTF8_LITERAL("to_dayTimeDuration"),
    AFW_UTF8_LITERAL("to_dayTimeDuration_string"),
    AFW_UTF8_LITERAL("toDayTimeDurationString"),
    AFW_UTF8_LITERAL("afwToDayTimeDurationString"),
    AFW_UTF8_LITERAL("Converts string to dayTimeDuration"),
    AFW_UTF8_LITERAL("Converts string value to dayTimeDuration."),
    AFW_UTF8_LITERAL("(value: string): dayTimeDuration"),
    AFW_UTF8_LITERAL("/* Converts string to dayTimeDuration */\nfunction to_dayTimeDuration<string> (\n    value: string\n): dayTimeDuration;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_dayTimeDuration_string_parameters[0],
    1,
    &impl_to_dayTimeDuration_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_dayTimeDuration_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_dayTimeDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_dnsName<string> ---------- */

static const afw_utf8_t
impl_object_path__to_dnsName_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_dnsName_string");

static const afw_runtime_object_indirect_t
impl_object__to_dnsName_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_dnsName_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_dnsName_string
        }
    },
    (void *)&afw_function_definition_to_dnsName_string
};

static const afw_value_function_parameter_t
impl_to_dnsName_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_dnsName_direct,
    AFW_UTF8_LITERAL("dnsName"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_dnsName_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_dnsName_string_parameters[] = {
    &impl_to_dnsName_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_dnsName_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dnsName_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_dnsName_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_dnsName<string>"),
    AFW_UTF8_LITERAL("to_dnsName"),
    AFW_UTF8_LITERAL("to_dnsName_string"),
    AFW_UTF8_LITERAL("toDnsNameString"),
    AFW_UTF8_LITERAL("afwToDnsNameString"),
    AFW_UTF8_LITERAL("Converts string to dnsName"),
    AFW_UTF8_LITERAL("Converts string value to dnsName."),
    AFW_UTF8_LITERAL("(value: string): dnsName"),
    AFW_UTF8_LITERAL("/* Converts string to dnsName */\nfunction to_dnsName<string> (\n    value: string\n): dnsName;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_dnsName_string_parameters[0],
    1,
    &impl_to_dnsName_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_dnsName_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_dnsName,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_double<string> ---------- */

static const afw_utf8_t
impl_object_path__to_double_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_double_string");

static const afw_runtime_object_indirect_t
impl_object__to_double_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_double_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_double_string
        }
    },
    (void *)&afw_function_definition_to_double_string
};

static const afw_value_function_parameter_t
impl_to_double_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_double_direct,
    AFW_UTF8_LITERAL("double"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_double_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_double_string_parameters[] = {
    &impl_to_double_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_double_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_double_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_double_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_double<string>"),
    AFW_UTF8_LITERAL("to_double"),
    AFW_UTF8_LITERAL("to_double_string"),
    AFW_UTF8_LITERAL("toDoubleString"),
    AFW_UTF8_LITERAL("afwToDoubleString"),
    AFW_UTF8_LITERAL("Converts to double"),
    AFW_UTF8_LITERAL("Converts string value to double and returns double result."),
    AFW_UTF8_LITERAL("(value: string): double"),
    AFW_UTF8_LITERAL("/* Converts to double */\nfunction to_double<string> (\n    value: string\n): double;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_double_string_parameters[0],
    1,
    &impl_to_double_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_double_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_double,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_integer<string> ---------- */

static const afw_utf8_t
impl_object_path__to_integer_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_integer_string");

static const afw_runtime_object_indirect_t
impl_object__to_integer_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_integer_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_integer_string
        }
    },
    (void *)&afw_function_definition_to_integer_string
};

static const afw_value_function_parameter_t
impl_to_integer_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_integer_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_integer_string_parameters[] = {
    &impl_to_integer_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_integer_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_integer_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_integer<string>"),
    AFW_UTF8_LITERAL("to_integer"),
    AFW_UTF8_LITERAL("to_integer_string"),
    AFW_UTF8_LITERAL("toIntegerString"),
    AFW_UTF8_LITERAL("afwToIntegerString"),
    AFW_UTF8_LITERAL("Converts to integer"),
    AFW_UTF8_LITERAL("Truncate string value to a whole number and returns integer result."),
    AFW_UTF8_LITERAL("(value: string): integer"),
    AFW_UTF8_LITERAL("/* Converts to integer */\nfunction to_integer<string> (\n    value: string\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_integer_string_parameters[0],
    1,
    &impl_to_integer_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_to_integer,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_ipAddress<string> ---------- */

static const afw_utf8_t
impl_object_path__to_ipAddress_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_ipAddress_string");

static const afw_runtime_object_indirect_t
impl_object__to_ipAddress_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_ipAddress_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_ipAddress_string
        }
    },
    (void *)&afw_function_definition_to_ipAddress_string
};

static const afw_value_function_parameter_t
impl_to_ipAddress_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_ipAddress_direct,
    AFW_UTF8_LITERAL("ipAddress"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_ipAddress_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_ipAddress_string_parameters[] = {
    &impl_to_ipAddress_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_ipAddress_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_ipAddress_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_ipAddress_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_ipAddress<string>"),
    AFW_UTF8_LITERAL("to_ipAddress"),
    AFW_UTF8_LITERAL("to_ipAddress_string"),
    AFW_UTF8_LITERAL("toIpAddressString"),
    AFW_UTF8_LITERAL("afwToIpAddressString"),
    AFW_UTF8_LITERAL("Converts string to ipAddress"),
    AFW_UTF8_LITERAL("Converts string value to ipAddress."),
    AFW_UTF8_LITERAL("(value: string): ipAddress"),
    AFW_UTF8_LITERAL("/* Converts string to ipAddress */\nfunction to_ipAddress<string> (\n    value: string\n): ipAddress;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_ipAddress_string_parameters[0],
    1,
    &impl_to_ipAddress_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_ipAddress_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_ipAddress,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_rfc822Name<string> ---------- */

static const afw_utf8_t
impl_object_path__to_rfc822Name_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_rfc822Name_string");

static const afw_runtime_object_indirect_t
impl_object__to_rfc822Name_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_rfc822Name_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_rfc822Name_string
        }
    },
    (void *)&afw_function_definition_to_rfc822Name_string
};

static const afw_value_function_parameter_t
impl_to_rfc822Name_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_rfc822Name_direct,
    AFW_UTF8_LITERAL("rfc822Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_rfc822Name_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_rfc822Name_string_parameters[] = {
    &impl_to_rfc822Name_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_rfc822Name_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_rfc822Name_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_rfc822Name_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_rfc822Name<string>"),
    AFW_UTF8_LITERAL("to_rfc822Name"),
    AFW_UTF8_LITERAL("to_rfc822Name_string"),
    AFW_UTF8_LITERAL("toRfc822NameString"),
    AFW_UTF8_LITERAL("afwToRfc822NameString"),
    AFW_UTF8_LITERAL("Converts string to rfc822Name"),
    AFW_UTF8_LITERAL("Converts string value to rfc822Name."),
    AFW_UTF8_LITERAL("(value: string): rfc822Name"),
    AFW_UTF8_LITERAL("/* Converts string to rfc822Name */\nfunction to_rfc822Name<string> (\n    value: string\n): rfc822Name;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_rfc822Name_string_parameters[0],
    1,
    &impl_to_rfc822Name_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_rfc822Name_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_rfc822Name,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<string> ---------- */

static const afw_utf8_t
impl_object_path__to_string_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_string");

static const afw_runtime_object_indirect_t
impl_object__to_string_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_string
        }
    },
    (void *)&afw_function_definition_to_string_string
};

static const afw_value_function_parameter_t
impl_to_string_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A string value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_string_parameters[] = {
    &impl_to_string_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_string<string>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_string"),
    AFW_UTF8_LITERAL("toStringString"),
    AFW_UTF8_LITERAL("afwToStringString"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts string value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: string): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<string> (\n    value: string\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_string_parameters[0],
    1,
    &impl_to_string_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_time<string> ---------- */

static const afw_utf8_t
impl_object_path__to_time_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_time_string");

static const afw_runtime_object_indirect_t
impl_object__to_time_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_time_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_time_string
        }
    },
    (void *)&afw_function_definition_to_time_string
};

static const afw_value_function_parameter_t
impl_to_time_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_time_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_time_string_parameters[] = {
    &impl_to_time_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_time_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_time_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_time_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_time<string>"),
    AFW_UTF8_LITERAL("to_time"),
    AFW_UTF8_LITERAL("to_time_string"),
    AFW_UTF8_LITERAL("toTimeString"),
    AFW_UTF8_LITERAL("afwToTimeString"),
    AFW_UTF8_LITERAL("Converts string to time"),
    AFW_UTF8_LITERAL("Converts string value to time."),
    AFW_UTF8_LITERAL("(value: string): time"),
    AFW_UTF8_LITERAL("/* Converts string to time */\nfunction to_time<string> (\n    value: string\n): time;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_time_string_parameters[0],
    1,
    &impl_to_time_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_time_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_time,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_x500Name<string> ---------- */

static const afw_utf8_t
impl_object_path__to_x500Name_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_x500Name_string");

static const afw_runtime_object_indirect_t
impl_object__to_x500Name_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_x500Name_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_x500Name_string
        }
    },
    (void *)&afw_function_definition_to_x500Name_string
};

static const afw_value_function_parameter_t
impl_to_x500Name_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_x500Name_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_x500Name_string_parameters[] = {
    &impl_to_x500Name_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_x500Name_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_x500Name_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_x500Name_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_x500Name<string>"),
    AFW_UTF8_LITERAL("to_x500Name"),
    AFW_UTF8_LITERAL("to_x500Name_string"),
    AFW_UTF8_LITERAL("toX500NameString"),
    AFW_UTF8_LITERAL("afwToX500NameString"),
    AFW_UTF8_LITERAL("Converts string to x500Name"),
    AFW_UTF8_LITERAL("Converts string value to x500Name."),
    AFW_UTF8_LITERAL("(value: string): x500Name"),
    AFW_UTF8_LITERAL("/* Converts string to x500Name */\nfunction to_x500Name<string> (\n    value: string\n): x500Name;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_x500Name_string_parameters[0],
    1,
    &impl_to_x500Name_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_x500Name_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_x500Name,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_yearMonthDuration<string> ---------- */

static const afw_utf8_t
impl_object_path__to_yearMonthDuration_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_yearMonthDuration_string");

static const afw_runtime_object_indirect_t
impl_object__to_yearMonthDuration_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_yearMonthDuration_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_yearMonthDuration_string
        }
    },
    (void *)&afw_function_definition_to_yearMonthDuration_string
};

static const afw_value_function_parameter_t
impl_to_yearMonthDuration_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_yearMonthDuration_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_yearMonthDuration_string_parameters[] = {
    &impl_to_yearMonthDuration_string_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_to_yearMonthDuration_string_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_yearMonthDuration_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_yearMonthDuration_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("to_yearMonthDuration<string>"),
    AFW_UTF8_LITERAL("to_yearMonthDuration"),
    AFW_UTF8_LITERAL("to_yearMonthDuration_string"),
    AFW_UTF8_LITERAL("toYearMonthDurationString"),
    AFW_UTF8_LITERAL("afwToYearMonthDurationString"),
    AFW_UTF8_LITERAL("Converts string to yearMonthDuration"),
    AFW_UTF8_LITERAL("Converts string value to yearMonthDuration."),
    AFW_UTF8_LITERAL("(value: string): yearMonthDuration"),
    AFW_UTF8_LITERAL("/* Converts string to yearMonthDuration */\nfunction to_yearMonthDuration<string> (\n    value: string\n): yearMonthDuration;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_yearMonthDuration_string_parameters[0],
    1,
    &impl_to_yearMonthDuration_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    &impl_to_yearMonthDuration_string_errorsThrown[0],
    NULL,
    afw_data_type_method_number_to_yearMonthDuration,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<string> ---------- */

static const afw_utf8_t
impl_object_path__union_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_string");

static const afw_runtime_object_indirect_t
impl_object__union_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_string
        }
    },
    (void *)&afw_function_definition_union_string
};

static const afw_value_function_parameter_t
impl_union_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_string_parameters[] = {
    &impl_union_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("union<string>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_string"),
    AFW_UTF8_LITERAL("unionString"),
    AFW_UTF8_LITERAL("afwUnionString"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of string contains all of the unique values in two or more list of string values."),
    AFW_UTF8_LITERAL("(lists_1: (list string), lists_2: (list string), ...lists_rest: (list of (list string))): (list string)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<string> (\n    lists_1: (list string),\n    lists_2: (list string),\n    ...lists_rest: (list of (list string))\n): (list string);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_string_parameters[0],
    1,
    &impl_union_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- url_decode ---------- */

static const afw_utf8_t
impl_object_path__url_decode =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/url_decode");

static const afw_runtime_object_indirect_t
impl_object__url_decode = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_url_decode,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__url_decode
        }
    },
    (void *)&afw_function_definition_url_decode
};

static const afw_value_function_parameter_t
impl_url_decode_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A string or bag of strings."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_url_decode_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("encoded"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URL decode a single string or a bag of string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_url_decode_parameters[] = {
    &impl_url_decode_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_decode = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__url_decode,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("url_decode"),
    AFW_UTF8_LITERAL("url_decode"),
    AFW_UTF8_LITERAL("url_decode"),
    AFW_UTF8_LITERAL("urlDecode"),
    AFW_UTF8_LITERAL("afwUrlDecode"),
    AFW_UTF8_LITERAL("URL decode"),
    AFW_UTF8_LITERAL("URL decode a value or bag of values."),
    AFW_UTF8_LITERAL("(encoded: string): string"),
    AFW_UTF8_LITERAL("/* URL decode */\nfunction url_decode (\n    encoded: string\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_url_decode,
    NULL,
    1,
    1,
    &impl_url_decode_parameters[0],
    1,
    &impl_url_decode_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_url_decode,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- url_encode<string> ---------- */

static const afw_utf8_t
impl_object_path__url_encode_string =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/url_encode_string");

static const afw_runtime_object_indirect_t
impl_object__url_encode_string = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_url_encode_string,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__url_encode_string
        }
    },
    (void *)&afw_function_definition_url_encode_string
};

static const afw_value_function_parameter_t
impl_url_encode_string_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URI encoded string."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_url_encode_string_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("unencoded"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("URL encode a single value. See the url_encode method for the data type of more details."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_url_encode_string_parameters[] = {
    &impl_url_encode_string_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_encode_string = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__url_encode_string,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL("url_encode<string>"),
    AFW_UTF8_LITERAL("url_encode"),
    AFW_UTF8_LITERAL("url_encode_string"),
    AFW_UTF8_LITERAL("urlEncodeString"),
    AFW_UTF8_LITERAL("afwUrlEncodeString"),
    AFW_UTF8_LITERAL("URI encode"),
    AFW_UTF8_LITERAL("URL encode a value or bag of values."),
    AFW_UTF8_LITERAL("(unencoded: string): string"),
    AFW_UTF8_LITERAL("/* URI encode */\nfunction url_encode<string> (\n    unencoded: string\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_url_encode,
    NULL,
    1,
    1,
    &impl_url_encode_string_parameters[0],
    1,
    &impl_url_encode_string_returns,
    NULL,
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    NULL,
    NULL,
    afw_data_type_method_number_url_encode,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<template> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_template");

static const afw_runtime_object_indirect_t
impl_object__bag_size_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_template
        }
    },
    (void *)&afw_function_definition_bag_size_template
};

static const afw_value_function_parameter_t
impl_bag_size_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_template_parameters[] = {
    &impl_bag_size_template_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("bag_size<template>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_template"),
    AFW_UTF8_LITERAL("bagSizeTemplate"),
    AFW_UTF8_LITERAL("afwBagSizeTemplate"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list template)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<template> (\n    value: (list template)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_template_parameters[0],
    1,
    &impl_bag_size_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<template> ---------- */

static const afw_utf8_t
impl_object_path__bag_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_template");

static const afw_runtime_object_indirect_t
impl_object__bag_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_template
        }
    },
    (void *)&afw_function_definition_bag_template
};

static const afw_value_function_parameter_t
impl_bag_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_template_parameters[] = {
    &impl_bag_template_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("bag<template>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_template"),
    AFW_UTF8_LITERAL("bagTemplate"),
    AFW_UTF8_LITERAL("afwBagTemplate"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of template values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list template))): (list template)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<template> (\n    ...values: (list of (list template))\n): (list template);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_template_parameters[0],
    1,
    &impl_bag_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compile<template> ---------- */

static const afw_utf8_t
impl_object_path__compile_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_template");

static const afw_runtime_object_indirect_t
impl_object__compile_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_template
        }
    },
    (void *)&afw_function_definition_compile_template
};

static const afw_value_function_parameter_t
impl_compile_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to compile"),
    AFW_UTF8_LITERAL("template string to compile"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL("Listing option"),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_template_parameters[] = {
    &impl_compile_template_parameter_1,
    &impl_compile_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("compile<template>"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile_template"),
    AFW_UTF8_LITERAL("compileTemplate"),
    AFW_UTF8_LITERAL("afwCompileTemplate"),
    AFW_UTF8_LITERAL("Compile template value"),
    AFW_UTF8_LITERAL("Compile template value and return either an unevaluated adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(source: template, listing?: any): unevaluated"),
    AFW_UTF8_LITERAL("/* Compile template value */\nfunction compile<template> (\n    source: template /* Source to compile */,\n    listing?: any    /* Listing option */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_template,
    NULL,
    1,
    2,
    &impl_compile_template_parameters[0],
    2,
    &impl_compile_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_compile,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<template> ---------- */

static const afw_utf8_t
impl_object_path__eq_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_template");

static const afw_runtime_object_indirect_t
impl_object__eq_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_template
        }
    },
    (void *)&afw_function_definition_eq_template
};

static const afw_value_function_parameter_t
impl_eq_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_template_parameters[] = {
    &impl_eq_template_parameter_1,
    &impl_eq_template_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_template_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("eq<template>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_template"),
    AFW_UTF8_LITERAL("eqTemplate"),
    AFW_UTF8_LITERAL("afwEqTemplate"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if template arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<template> (\n    arg1: template,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_template_parameters[0],
    2,
    &impl_eq_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    &impl_eq_template_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<template> ---------- */

static const afw_utf8_t
impl_object_path__eqx_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_template");

static const afw_runtime_object_indirect_t
impl_object__eqx_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_template
        }
    },
    (void *)&afw_function_definition_eqx_template
};

static const afw_value_function_parameter_t
impl_eqx_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_template_parameters[] = {
    &impl_eqx_template_parameter_1,
    &impl_eqx_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("eqx<template>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_template"),
    AFW_UTF8_LITERAL("eqxTemplate"),
    AFW_UTF8_LITERAL("afwEqxTemplate"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for template arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<template> (\n    arg1: template,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_template_parameters[0],
    2,
    &impl_eqx_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- evaluate<template> ---------- */

static const afw_utf8_t
impl_object_path__evaluate_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_template");

static const afw_runtime_object_indirect_t
impl_object__evaluate_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_template
        }
    },
    (void *)&afw_function_definition_evaluate_template
};

static const afw_value_function_parameter_t
impl_evaluate_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to evaluate"),
    AFW_UTF8_LITERAL("template string to compile and evaluate"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_template_parameters[] = {
    &impl_evaluate_template_parameter_1,
    &impl_evaluate_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("evaluate<template>"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate_template"),
    AFW_UTF8_LITERAL("evaluateTemplate"),
    AFW_UTF8_LITERAL("afwEvaluateTemplate"),
    AFW_UTF8_LITERAL("Evaluate template value"),
    AFW_UTF8_LITERAL("Compile and evaluate template value."),
    AFW_UTF8_LITERAL("(source: template, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): unevaluated"),
    AFW_UTF8_LITERAL("/* Evaluate template value */\nfunction evaluate<template> (\n    source: template                                                                   /* Source to evaluate */,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_template,
    NULL,
    1,
    2,
    &impl_evaluate_template_parameters[0],
    2,
    &impl_evaluate_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_evaluate,
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- ge<template> ---------- */

static const afw_utf8_t
impl_object_path__ge_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_template");

static const afw_runtime_object_indirect_t
impl_object__ge_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_template
        }
    },
    (void *)&afw_function_definition_ge_template
};

static const afw_value_function_parameter_t
impl_ge_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_template_parameters[] = {
    &impl_ge_template_parameter_1,
    &impl_ge_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("ge<template>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_template"),
    AFW_UTF8_LITERAL("geTemplate"),
    AFW_UTF8_LITERAL("afwGeTemplate"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for template arg1 is greater than or equal to template arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: template): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<template> (\n    arg1: template,\n    arg2: template\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_template_parameters[0],
    2,
    &impl_ge_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<template> ---------- */

static const afw_utf8_t
impl_object_path__gt_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_template");

static const afw_runtime_object_indirect_t
impl_object__gt_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_template
        }
    },
    (void *)&afw_function_definition_gt_template
};

static const afw_value_function_parameter_t
impl_gt_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_template_parameters[] = {
    &impl_gt_template_parameter_1,
    &impl_gt_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("gt<template>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_template"),
    AFW_UTF8_LITERAL("gtTemplate"),
    AFW_UTF8_LITERAL("afwGtTemplate"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for template arg1 is greater than template arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: template): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<template> (\n    arg1: template,\n    arg2: template\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_template_parameters[0],
    2,
    &impl_gt_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<template> ---------- */

static const afw_utf8_t
impl_object_path__is_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_template");

static const afw_runtime_object_indirect_t
impl_object__is_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_template
        }
    },
    (void *)&afw_function_definition_is_template
};

static const afw_value_function_parameter_t
impl_is_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_template_parameters[] = {
    &impl_is_template_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("is<template>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_template"),
    AFW_UTF8_LITERAL("isTemplate"),
    AFW_UTF8_LITERAL("afwIsTemplate"),
    AFW_UTF8_LITERAL("Checks whether value is dataType template"),
    AFW_UTF8_LITERAL("Checks whether value is dataType template and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType template */\nfunction is<template> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_template_parameters[0],
    1,
    &impl_is_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<template> ---------- */

static const afw_utf8_t
impl_object_path__le_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_template");

static const afw_runtime_object_indirect_t
impl_object__le_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_template
        }
    },
    (void *)&afw_function_definition_le_template
};

static const afw_value_function_parameter_t
impl_le_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_template_parameters[] = {
    &impl_le_template_parameter_1,
    &impl_le_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("le<template>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_template"),
    AFW_UTF8_LITERAL("leTemplate"),
    AFW_UTF8_LITERAL("afwLeTemplate"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for template arg1 is less than or equal to template arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<template> (\n    arg1: template,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_template_parameters[0],
    2,
    &impl_le_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<template> ---------- */

static const afw_utf8_t
impl_object_path__lt_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_template");

static const afw_runtime_object_indirect_t
impl_object__lt_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_template
        }
    },
    (void *)&afw_function_definition_lt_template
};

static const afw_value_function_parameter_t
impl_lt_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_template_parameters[] = {
    &impl_lt_template_parameter_1,
    &impl_lt_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("lt<template>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_template"),
    AFW_UTF8_LITERAL("ltTemplate"),
    AFW_UTF8_LITERAL("afwLtTemplate"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for template arg1 is less that template arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: template): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<template> (\n    arg1: template,\n    arg2: template\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_template_parameters[0],
    2,
    &impl_lt_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<template> ---------- */

static const afw_utf8_t
impl_object_path__ne_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_template");

static const afw_runtime_object_indirect_t
impl_object__ne_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_template
        }
    },
    (void *)&afw_function_definition_ne_template
};

static const afw_value_function_parameter_t
impl_ne_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_template_parameters[] = {
    &impl_ne_template_parameter_1,
    &impl_ne_template_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_template_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("ne<template>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_template"),
    AFW_UTF8_LITERAL("neTemplate"),
    AFW_UTF8_LITERAL("afwNeTemplate"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if template arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<template> (\n    arg1: template,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_template_parameters[0],
    2,
    &impl_ne_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    &impl_ne_template_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<template> ---------- */

static const afw_utf8_t
impl_object_path__nex_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_template");

static const afw_runtime_object_indirect_t
impl_object__nex_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_template
        }
    },
    (void *)&afw_function_definition_nex_template
};

static const afw_value_function_parameter_t
impl_nex_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_template_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_template_parameters[] = {
    &impl_nex_template_parameter_1,
    &impl_nex_template_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("nex<template>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_template"),
    AFW_UTF8_LITERAL("nexTemplate"),
    AFW_UTF8_LITERAL("afwNexTemplate"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for template arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: template, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<template> (\n    arg1: template,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_template_parameters[0],
    2,
    &impl_nex_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- template ---------- */

static const afw_utf8_t
impl_object_path__template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/template");

static const afw_runtime_object_indirect_t
impl_object__template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__template
        }
    },
    (void *)&afw_function_definition_template
};

static const afw_value_function_parameter_t
impl_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_template_parameters[] = {
    &impl_template_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_template_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("afwTemplate"),
    AFW_UTF8_LITERAL("Convert to data type template"),
    AFW_UTF8_LITERAL("Converts value to data type template returning template result."),
    AFW_UTF8_LITERAL("(value: any): template"),
    AFW_UTF8_LITERAL("/* Convert to data type template */\nfunction template (\n    value: any\n): template;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_template_parameters[0],
    1,
    &impl_template_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_template_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<template> ---------- */

static const afw_utf8_t
impl_object_path__to_string_template =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_template");

static const afw_runtime_object_indirect_t
impl_object__to_string_template = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_template,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_template
        }
    },
    (void *)&afw_function_definition_to_string_template
};

static const afw_value_function_parameter_t
impl_to_string_template_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_template_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A template value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_template_parameters[] = {
    &impl_to_string_template_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_template = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_template,
    AFW_UTF8_LITERAL("template"),
    AFW_UTF8_LITERAL("to_string<template>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_template"),
    AFW_UTF8_LITERAL("toStringTemplate"),
    AFW_UTF8_LITERAL("afwToStringTemplate"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts template value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: template): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<template> (\n    value: template\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_template_parameters[0],
    1,
    &impl_to_string_template_returns,
    NULL,
    &afw_data_type_template_direct,
    AFW_UTF8_LITERAL("template"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<time> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_time");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_time
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_time
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_time_parameters[] = {
    &impl_at_least_one_member_of_time_parameter_1,
    &impl_at_least_one_member_of_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("at_least_one_member_of<time>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_time"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfTime"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfTime"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in time list1 is in time list2."),
    AFW_UTF8_LITERAL("(list1: (list time), list2: (list time)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<time> (\n    list1: (list time),\n    list2: (list time)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_time_parameters[0],
    2,
    &impl_at_least_one_member_of_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<time> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_time");

static const afw_runtime_object_indirect_t
impl_object__bag_size_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_time
        }
    },
    (void *)&afw_function_definition_bag_size_time
};

static const afw_value_function_parameter_t
impl_bag_size_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_time_parameters[] = {
    &impl_bag_size_time_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("bag_size<time>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_time"),
    AFW_UTF8_LITERAL("bagSizeTime"),
    AFW_UTF8_LITERAL("afwBagSizeTime"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list time)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<time> (\n    value: (list time)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_time_parameters[0],
    1,
    &impl_bag_size_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<time> ---------- */

static const afw_utf8_t
impl_object_path__bag_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_time");

static const afw_runtime_object_indirect_t
impl_object__bag_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_time
        }
    },
    (void *)&afw_function_definition_bag_time
};

static const afw_value_function_parameter_t
impl_bag_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_time_parameters[] = {
    &impl_bag_time_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("bag<time>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_time"),
    AFW_UTF8_LITERAL("bagTime"),
    AFW_UTF8_LITERAL("afwBagTime"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of time values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list time))): (list time)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<time> (\n    ...values: (list of (list time))\n): (list time);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_time_parameters[0],
    1,
    &impl_bag_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<time> ---------- */

static const afw_utf8_t
impl_object_path__eq_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_time");

static const afw_runtime_object_indirect_t
impl_object__eq_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_time
        }
    },
    (void *)&afw_function_definition_eq_time
};

static const afw_value_function_parameter_t
impl_eq_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_time_parameters[] = {
    &impl_eq_time_parameter_1,
    &impl_eq_time_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_time_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("eq<time>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_time"),
    AFW_UTF8_LITERAL("eqTime"),
    AFW_UTF8_LITERAL("afwEqTime"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if time arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<time> (\n    arg1: time,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_time_parameters[0],
    2,
    &impl_eq_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    &impl_eq_time_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<time> ---------- */

static const afw_utf8_t
impl_object_path__eqx_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_time");

static const afw_runtime_object_indirect_t
impl_object__eqx_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_time
        }
    },
    (void *)&afw_function_definition_eqx_time
};

static const afw_value_function_parameter_t
impl_eqx_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_time_parameters[] = {
    &impl_eqx_time_parameter_1,
    &impl_eqx_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("eqx<time>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_time"),
    AFW_UTF8_LITERAL("eqxTime"),
    AFW_UTF8_LITERAL("afwEqxTime"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for time arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<time> (\n    arg1: time,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_time_parameters[0],
    2,
    &impl_eqx_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<time> ---------- */

static const afw_utf8_t
impl_object_path__ge_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_time");

static const afw_runtime_object_indirect_t
impl_object__ge_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_time
        }
    },
    (void *)&afw_function_definition_ge_time
};

static const afw_value_function_parameter_t
impl_ge_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_time_parameters[] = {
    &impl_ge_time_parameter_1,
    &impl_ge_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("ge<time>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_time"),
    AFW_UTF8_LITERAL("geTime"),
    AFW_UTF8_LITERAL("afwGeTime"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for time arg1 is greater than or equal to time arg2 and return the boolean result.\n\nIt is illegal to compare a time that includes a time-zone value with one that does not. In such cases, the in_range<time> function should be used."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: time): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<time> (\n    arg1: time,\n    arg2: time\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_time_parameters[0],
    2,
    &impl_ge_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<time> ---------- */

static const afw_utf8_t
impl_object_path__gt_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_time");

static const afw_runtime_object_indirect_t
impl_object__gt_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_time
        }
    },
    (void *)&afw_function_definition_gt_time
};

static const afw_value_function_parameter_t
impl_gt_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_time_parameters[] = {
    &impl_gt_time_parameter_1,
    &impl_gt_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("gt<time>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_time"),
    AFW_UTF8_LITERAL("gtTime"),
    AFW_UTF8_LITERAL("afwGtTime"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for time arg1 is greater than time arg2 and return the boolean result.\n\nIt is illegal to compare a time that includes a time-zone value with one that does not. In such cases, the in_range<time> function should be used."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: time): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<time> (\n    arg1: time,\n    arg2: time\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_time_parameters[0],
    2,
    &impl_gt_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- in_range<time> ---------- */

static const afw_utf8_t
impl_object_path__in_range_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/in_range_time");

static const afw_runtime_object_indirect_t
impl_object__in_range_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_in_range_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__in_range_time
        }
    },
    (void *)&afw_function_definition_in_range_time
};

static const afw_value_function_parameter_t
impl_in_range_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_in_range_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_in_range_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("startTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_in_range_time_parameter_3 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("endTime"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_in_range_time_parameters[] = {
    &impl_in_range_time_parameter_1,
    &impl_in_range_time_parameter_2,
    &impl_in_range_time_parameter_3,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_in_range_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__in_range_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("in_range<time>"),
    AFW_UTF8_LITERAL("in_range"),
    AFW_UTF8_LITERAL("in_range_time"),
    AFW_UTF8_LITERAL("inRangeTime"),
    AFW_UTF8_LITERAL("afwInRangeTime"),
    AFW_UTF8_LITERAL("Checks if time in range"),
    AFW_UTF8_LITERAL("Checks if time is between startTime and endTime, inclusive. Regardless of endTime value, it is always considered to be equal to, but less than 24 hours greater than startTime. If no time zone is specified for time, the default time zone is used. If no time zone is specified for startTime or endTime, the time zone of time is used."),
    AFW_UTF8_LITERAL("(time: time, startTime: time, endTime: time): boolean"),
    AFW_UTF8_LITERAL("/* Checks if time in range */\nfunction in_range<time> (\n    time: time,\n    startTime: time,\n    endTime: time\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_in_range_time,
    NULL,
    3,
    3,
    &impl_in_range_time_parameters[0],
    3,
    &impl_in_range_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_in_range,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<time> ---------- */

static const afw_utf8_t
impl_object_path__intersection_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_time");

static const afw_runtime_object_indirect_t
impl_object__intersection_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_time
        }
    },
    (void *)&afw_function_definition_intersection_time
};

static const afw_value_function_parameter_t
impl_intersection_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_time_parameters[] = {
    &impl_intersection_time_parameter_1,
    &impl_intersection_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("intersection<time>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_time"),
    AFW_UTF8_LITERAL("intersectionTime"),
    AFW_UTF8_LITERAL("afwIntersectionTime"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of time with the values that are common to both list of time list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list time), list2: (list time)): (list time)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<time> (\n    list1: (list time),\n    list2: (list time)\n): (list time);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_time_parameters[0],
    2,
    &impl_intersection_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<time> ---------- */

static const afw_utf8_t
impl_object_path__is_in_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_time");

static const afw_runtime_object_indirect_t
impl_object__is_in_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_time
        }
    },
    (void *)&afw_function_definition_is_in_time
};

static const afw_value_function_parameter_t
impl_is_in_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_time_parameters[] = {
    &impl_is_in_time_parameter_1,
    &impl_is_in_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("is_in<time>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_time"),
    AFW_UTF8_LITERAL("isInTime"),
    AFW_UTF8_LITERAL("afwIsInTime"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether time value is in list of time list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: time, list: (list time)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<time> (\n    value: time,\n    list: (list time)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_time_parameters[0],
    2,
    &impl_is_in_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<time> ---------- */

static const afw_utf8_t
impl_object_path__is_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_time");

static const afw_runtime_object_indirect_t
impl_object__is_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_time
        }
    },
    (void *)&afw_function_definition_is_time
};

static const afw_value_function_parameter_t
impl_is_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_time_parameters[] = {
    &impl_is_time_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("is<time>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_time"),
    AFW_UTF8_LITERAL("isTime"),
    AFW_UTF8_LITERAL("afwIsTime"),
    AFW_UTF8_LITERAL("Checks whether value is dataType time"),
    AFW_UTF8_LITERAL("Checks whether value is dataType time and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType time */\nfunction is<time> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_time_parameters[0],
    1,
    &impl_is_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<time> ---------- */

static const afw_utf8_t
impl_object_path__le_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_time");

static const afw_runtime_object_indirect_t
impl_object__le_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_time
        }
    },
    (void *)&afw_function_definition_le_time
};

static const afw_value_function_parameter_t
impl_le_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_time_parameters[] = {
    &impl_le_time_parameter_1,
    &impl_le_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("le<time>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_time"),
    AFW_UTF8_LITERAL("leTime"),
    AFW_UTF8_LITERAL("afwLeTime"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for time arg1 is less than or equal to time arg2 and return the boolean result.\n\nIt is illegal to compare a time that includes a time-zone value with one that does not. In such cases, the in_range<time> function should be used."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<time> (\n    arg1: time,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_time_parameters[0],
    2,
    &impl_le_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<time> ---------- */

static const afw_utf8_t
impl_object_path__lt_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_time");

static const afw_runtime_object_indirect_t
impl_object__lt_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_time
        }
    },
    (void *)&afw_function_definition_lt_time
};

static const afw_value_function_parameter_t
impl_lt_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_time_parameters[] = {
    &impl_lt_time_parameter_1,
    &impl_lt_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("lt<time>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_time"),
    AFW_UTF8_LITERAL("ltTime"),
    AFW_UTF8_LITERAL("afwLtTime"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for time arg1 is less that time arg2 and return the boolean result.\n\nIt is illegal to compare a time that includes a time-zone value with one that does not. In such cases, the in_range<time> function should be used."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: time): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<time> (\n    arg1: time,\n    arg2: time\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_time_parameters[0],
    2,
    &impl_lt_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- max<time> ---------- */

static const afw_utf8_t
impl_object_path__max_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/max_time");

static const afw_runtime_object_indirect_t
impl_object__max_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_max_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__max_time
        }
    },
    (void *)&afw_function_definition_max_time
};

static const afw_value_function_parameter_t
impl_max_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_max_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_max_time_parameters[] = {
    &impl_max_time_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__max_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("max<time>"),
    AFW_UTF8_LITERAL("max"),
    AFW_UTF8_LITERAL("max_time"),
    AFW_UTF8_LITERAL("maxTime"),
    AFW_UTF8_LITERAL("afwMaxTime"),
    AFW_UTF8_LITERAL("Maximum value"),
    AFW_UTF8_LITERAL("Return the time value that is greater than or equal to the others.\n\nIt is illegal to compare a time that includes a time-zone value with one that does not. In such cases, the in_range<time> function should be used."),
    AFW_UTF8_LITERAL("(values_1: time, ...values_rest: (list of time)): time"),
    AFW_UTF8_LITERAL("/* Maximum value */\nfunction max<time> (\n    values_1: time,\n    ...values_rest: (list of time)\n): time;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_max,
    NULL,
    1,
    -1,
    &impl_max_time_parameters[0],
    1,
    &impl_max_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_max,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- min<time> ---------- */

static const afw_utf8_t
impl_object_path__min_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/min_time");

static const afw_runtime_object_indirect_t
impl_object__min_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_min_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__min_time
        }
    },
    (void *)&afw_function_definition_min_time
};

static const afw_value_function_parameter_t
impl_min_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_min_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_min_time_parameters[] = {
    &impl_min_time_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__min_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("min<time>"),
    AFW_UTF8_LITERAL("min"),
    AFW_UTF8_LITERAL("min_time"),
    AFW_UTF8_LITERAL("minTime"),
    AFW_UTF8_LITERAL("afwMinTime"),
    AFW_UTF8_LITERAL("Minimum value"),
    AFW_UTF8_LITERAL("Return the time value that is less than or equal to the others.\n\nIt is illegal to compare a time that includes a time-zone value with one that does not. In such cases, the in_range<time> function should be used."),
    AFW_UTF8_LITERAL("(values_1: time, ...values_rest: (list of time)): time"),
    AFW_UTF8_LITERAL("/* Minimum value */\nfunction min<time> (\n    values_1: time,\n    ...values_rest: (list of time)\n): time;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_min,
    NULL,
    1,
    -1,
    &impl_min_time_parameters[0],
    1,
    &impl_min_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_min,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<time> ---------- */

static const afw_utf8_t
impl_object_path__ne_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_time");

static const afw_runtime_object_indirect_t
impl_object__ne_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_time
        }
    },
    (void *)&afw_function_definition_ne_time
};

static const afw_value_function_parameter_t
impl_ne_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_time_parameters[] = {
    &impl_ne_time_parameter_1,
    &impl_ne_time_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_time_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("ne<time>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_time"),
    AFW_UTF8_LITERAL("neTime"),
    AFW_UTF8_LITERAL("afwNeTime"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if time arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<time> (\n    arg1: time,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_time_parameters[0],
    2,
    &impl_ne_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    &impl_ne_time_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<time> ---------- */

static const afw_utf8_t
impl_object_path__nex_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_time");

static const afw_runtime_object_indirect_t
impl_object__nex_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_time
        }
    },
    (void *)&afw_function_definition_nex_time
};

static const afw_value_function_parameter_t
impl_nex_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_time_parameters[] = {
    &impl_nex_time_parameter_1,
    &impl_nex_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("nex<time>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_time"),
    AFW_UTF8_LITERAL("nexTime"),
    AFW_UTF8_LITERAL("afwNexTime"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for time arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: time, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<time> (\n    arg1: time,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_time_parameters[0],
    2,
    &impl_nex_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<time> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_time");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_time
        }
    },
    (void *)&afw_function_definition_one_and_only_time
};

static const afw_value_function_parameter_t
impl_one_and_only_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_time_parameters[] = {
    &impl_one_and_only_time_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_time_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("one_and_only<time>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_time"),
    AFW_UTF8_LITERAL("oneAndOnlyTime"),
    AFW_UTF8_LITERAL("afwOneAndOnlyTime"),
    AFW_UTF8_LITERAL("Converts a one value list to a time value"),
    AFW_UTF8_LITERAL("This converts a list of time values that contains one value to a single time value."),
    AFW_UTF8_LITERAL("(list: (list list)): time"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a time value */\nfunction one_and_only<time> (\n    list: (list list)\n): time;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_time_parameters[0],
    1,
    &impl_one_and_only_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    &impl_one_and_only_time_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<time> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_time");

static const afw_runtime_object_indirect_t
impl_object__set_equals_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_time
        }
    },
    (void *)&afw_function_definition_set_equals_time
};

static const afw_value_function_parameter_t
impl_set_equals_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_time_parameters[] = {
    &impl_set_equals_time_parameter_1,
    &impl_set_equals_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("set_equals<time>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_time"),
    AFW_UTF8_LITERAL("setEqualsTime"),
    AFW_UTF8_LITERAL("afwSetEqualsTime"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if time list1 and time list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list time), list2: (list time)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<time> (\n    list1: (list time),\n    list2: (list time)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_time_parameters[0],
    2,
    &impl_set_equals_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<time> ---------- */

static const afw_utf8_t
impl_object_path__subset_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_time");

static const afw_runtime_object_indirect_t
impl_object__subset_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_time
        }
    },
    (void *)&afw_function_definition_subset_time
};

static const afw_value_function_parameter_t
impl_subset_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_time_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_time_parameters[] = {
    &impl_subset_time_parameter_1,
    &impl_subset_time_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("subset<time>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_time"),
    AFW_UTF8_LITERAL("subsetTime"),
    AFW_UTF8_LITERAL("afwSubsetTime"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in time list1 are all in time list2."),
    AFW_UTF8_LITERAL("(list1: (list time), list2: (list time)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<time> (\n    list1: (list time),\n    list2: (list time)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_time_parameters[0],
    2,
    &impl_subset_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- time ---------- */

static const afw_utf8_t
impl_object_path__time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/time");

static const afw_runtime_object_indirect_t
impl_object__time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__time
        }
    },
    (void *)&afw_function_definition_time
};

static const afw_value_function_parameter_t
impl_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_time_parameters[] = {
    &impl_time_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_time_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("afwTime"),
    AFW_UTF8_LITERAL("Convert to data type time"),
    AFW_UTF8_LITERAL("Converts value to data type time returning time result."),
    AFW_UTF8_LITERAL("(value: any): time"),
    AFW_UTF8_LITERAL("/* Convert to data type time */\nfunction time (\n    value: any\n): time;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_time_parameters[0],
    1,
    &impl_time_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_time_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<time> ---------- */

static const afw_utf8_t
impl_object_path__to_string_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_time");

static const afw_runtime_object_indirect_t
impl_object__to_string_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_time
        }
    },
    (void *)&afw_function_definition_to_string_time
};

static const afw_value_function_parameter_t
impl_to_string_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A time value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_time_parameters[] = {
    &impl_to_string_time_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("to_string<time>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_time"),
    AFW_UTF8_LITERAL("toStringTime"),
    AFW_UTF8_LITERAL("afwToStringTime"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts time value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: time): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<time> (\n    value: time\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_time_parameters[0],
    1,
    &impl_to_string_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<time> ---------- */

static const afw_utf8_t
impl_object_path__union_time =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_time");

static const afw_runtime_object_indirect_t
impl_object__union_time = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_time,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_time
        }
    },
    (void *)&afw_function_definition_union_time
};

static const afw_value_function_parameter_t
impl_union_time_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_time_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_time_parameters[] = {
    &impl_union_time_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_time = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_time,
    AFW_UTF8_LITERAL("time"),
    AFW_UTF8_LITERAL("union<time>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_time"),
    AFW_UTF8_LITERAL("unionTime"),
    AFW_UTF8_LITERAL("afwUnionTime"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of time contains all of the unique values in two or more list of time values."),
    AFW_UTF8_LITERAL("(lists_1: (list time), lists_2: (list time), ...lists_rest: (list of (list time))): (list time)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<time> (\n    lists_1: (list time),\n    lists_2: (list time),\n    ...lists_rest: (list of (list time))\n): (list time);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_time_parameters[0],
    1,
    &impl_union_time_returns,
    NULL,
    &afw_data_type_time_direct,
    AFW_UTF8_LITERAL("time"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<unevaluated> ---------- */

static const afw_utf8_t
impl_object_path__is_unevaluated =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_unevaluated");

static const afw_runtime_object_indirect_t
impl_object__is_unevaluated = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_unevaluated,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_unevaluated
        }
    },
    (void *)&afw_function_definition_is_unevaluated
};

static const afw_value_function_parameter_t
impl_is_unevaluated_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_unevaluated_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_unevaluated_parameters[] = {
    &impl_is_unevaluated_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_unevaluated = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_unevaluated,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL("is<unevaluated>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_unevaluated"),
    AFW_UTF8_LITERAL("isUnevaluated"),
    AFW_UTF8_LITERAL("afwIsUnevaluated"),
    AFW_UTF8_LITERAL("Checks whether value is dataType unevaluated"),
    AFW_UTF8_LITERAL("Checks whether value is dataType unevaluated and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType unevaluated */\nfunction is<unevaluated> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_unevaluated_parameters[0],
    1,
    &impl_is_unevaluated_returns,
    NULL,
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- meta ---------- */

static const afw_utf8_t
impl_object_path__meta =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/meta");

static const afw_runtime_object_indirect_t
impl_object__meta = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_meta,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__meta
        }
    },
    (void *)&afw_function_definition_meta
};

static const afw_value_function_parameter_t
impl_meta_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An object containing the meta information for the adaptive value. The objectType of this object is normally _AdaptiveValueMeta_ or one of its descendants."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_meta_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is the adaptive value whose meta object is to be returned."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_meta_parameters[] = {
    &impl_meta_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_meta = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__meta,
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL("meta"),
    AFW_UTF8_LITERAL("meta"),
    AFW_UTF8_LITERAL("meta"),
    AFW_UTF8_LITERAL("meta"),
    AFW_UTF8_LITERAL("afwMeta"),
    AFW_UTF8_LITERAL("Return the meta object about an adaptive value"),
    AFW_UTF8_LITERAL("This function returns an object containing meta information for an adaptive value."),
    AFW_UTF8_LITERAL("(value: any): object"),
    AFW_UTF8_LITERAL("/* Return the meta object about an adaptive value */\nfunction meta (\n    value: any\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_meta,
    NULL,
    1,
    1,
    &impl_meta_parameters[0],
    1,
    &impl_meta_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- metas ---------- */

static const afw_utf8_t
impl_object_path__metas =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/metas");

static const afw_runtime_object_indirect_t
impl_object__metas = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_metas,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__metas
        }
    },
    (void *)&afw_function_definition_metas
};

static const afw_value_function_parameter_t
impl_metas_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("An list containing the result of calling meta() of each value in list or object adaptive value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_metas_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("This is an adaptive list or object."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_metas_parameters[] = {
    &impl_metas_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_metas = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__metas,
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL("metas"),
    AFW_UTF8_LITERAL("metas"),
    AFW_UTF8_LITERAL("metas"),
    AFW_UTF8_LITERAL("metas"),
    AFW_UTF8_LITERAL("afwMetas"),
    AFW_UTF8_LITERAL("Return a list of the result of calling meta() for each value in a list or object adaptive value"),
    AFW_UTF8_LITERAL("This function returns a list of the result of calling meta() for each value in a list or object adaptive value."),
    AFW_UTF8_LITERAL("(value: any): object"),
    AFW_UTF8_LITERAL("/* Return a list of the result of calling meta() for each value in a list or object adaptive value */\nfunction metas (\n    value: any\n): object;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_metas,
    NULL,
    1,
    1,
    &impl_metas_parameters[0],
    1,
    &impl_metas_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_x500Name");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_x500Name
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_x500Name
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_x500Name_parameters[] = {
    &impl_at_least_one_member_of_x500Name_parameter_1,
    &impl_at_least_one_member_of_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("at_least_one_member_of<x500Name>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_x500Name"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfX500Name"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfX500Name"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in x500Name list1 is in x500Name list2."),
    AFW_UTF8_LITERAL("(list1: (list x500Name), list2: (list x500Name)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<x500Name> (\n    list1: (list x500Name),\n    list2: (list x500Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_x500Name_parameters[0],
    2,
    &impl_at_least_one_member_of_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_x500Name");

static const afw_runtime_object_indirect_t
impl_object__bag_size_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_x500Name
        }
    },
    (void *)&afw_function_definition_bag_size_x500Name
};

static const afw_value_function_parameter_t
impl_bag_size_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_x500Name_parameters[] = {
    &impl_bag_size_x500Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("bag_size<x500Name>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_x500Name"),
    AFW_UTF8_LITERAL("bagSizeX500Name"),
    AFW_UTF8_LITERAL("afwBagSizeX500Name"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list x500Name)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<x500Name> (\n    value: (list x500Name)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_x500Name_parameters[0],
    1,
    &impl_bag_size_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__bag_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_x500Name");

static const afw_runtime_object_indirect_t
impl_object__bag_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_x500Name
        }
    },
    (void *)&afw_function_definition_bag_x500Name
};

static const afw_value_function_parameter_t
impl_bag_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_x500Name_parameters[] = {
    &impl_bag_x500Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("bag<x500Name>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_x500Name"),
    AFW_UTF8_LITERAL("bagX500Name"),
    AFW_UTF8_LITERAL("afwBagX500Name"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of x500Name values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list x500Name))): (list x500Name)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<x500Name> (\n    ...values: (list of (list x500Name))\n): (list x500Name);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_x500Name_parameters[0],
    1,
    &impl_bag_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__eq_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_x500Name");

static const afw_runtime_object_indirect_t
impl_object__eq_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_x500Name
        }
    },
    (void *)&afw_function_definition_eq_x500Name
};

static const afw_value_function_parameter_t
impl_eq_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_x500Name_parameters[] = {
    &impl_eq_x500Name_parameter_1,
    &impl_eq_x500Name_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_x500Name_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("eq<x500Name>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_x500Name"),
    AFW_UTF8_LITERAL("eqX500Name"),
    AFW_UTF8_LITERAL("afwEqX500Name"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if x500Name arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<x500Name> (\n    arg1: x500Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_x500Name_parameters[0],
    2,
    &impl_eq_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    &impl_eq_x500Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__eqx_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_x500Name");

static const afw_runtime_object_indirect_t
impl_object__eqx_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_x500Name
        }
    },
    (void *)&afw_function_definition_eqx_x500Name
};

static const afw_value_function_parameter_t
impl_eqx_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_x500Name_parameters[] = {
    &impl_eqx_x500Name_parameter_1,
    &impl_eqx_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("eqx<x500Name>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_x500Name"),
    AFW_UTF8_LITERAL("eqxX500Name"),
    AFW_UTF8_LITERAL("afwEqxX500Name"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for x500Name arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<x500Name> (\n    arg1: x500Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_x500Name_parameters[0],
    2,
    &impl_eqx_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__ge_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_x500Name");

static const afw_runtime_object_indirect_t
impl_object__ge_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_x500Name
        }
    },
    (void *)&afw_function_definition_ge_x500Name
};

static const afw_value_function_parameter_t
impl_ge_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_x500Name_parameters[] = {
    &impl_ge_x500Name_parameter_1,
    &impl_ge_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("ge<x500Name>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_x500Name"),
    AFW_UTF8_LITERAL("geX500Name"),
    AFW_UTF8_LITERAL("afwGeX500Name"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for x500Name arg1 is greater than or equal to x500Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: x500Name): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<x500Name> (\n    arg1: x500Name,\n    arg2: x500Name\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_x500Name_parameters[0],
    2,
    &impl_ge_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__gt_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_x500Name");

static const afw_runtime_object_indirect_t
impl_object__gt_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_x500Name
        }
    },
    (void *)&afw_function_definition_gt_x500Name
};

static const afw_value_function_parameter_t
impl_gt_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_x500Name_parameters[] = {
    &impl_gt_x500Name_parameter_1,
    &impl_gt_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("gt<x500Name>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_x500Name"),
    AFW_UTF8_LITERAL("gtX500Name"),
    AFW_UTF8_LITERAL("afwGtX500Name"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for x500Name arg1 is greater than x500Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: x500Name): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<x500Name> (\n    arg1: x500Name,\n    arg2: x500Name\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_x500Name_parameters[0],
    2,
    &impl_gt_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__intersection_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_x500Name");

static const afw_runtime_object_indirect_t
impl_object__intersection_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_x500Name
        }
    },
    (void *)&afw_function_definition_intersection_x500Name
};

static const afw_value_function_parameter_t
impl_intersection_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_x500Name_parameters[] = {
    &impl_intersection_x500Name_parameter_1,
    &impl_intersection_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("intersection<x500Name>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_x500Name"),
    AFW_UTF8_LITERAL("intersectionX500Name"),
    AFW_UTF8_LITERAL("afwIntersectionX500Name"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of x500Name with the values that are common to both list of x500Name list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list x500Name), list2: (list x500Name)): (list x500Name)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<x500Name> (\n    list1: (list x500Name),\n    list2: (list x500Name)\n): (list x500Name);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_x500Name_parameters[0],
    2,
    &impl_intersection_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__is_in_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_x500Name");

static const afw_runtime_object_indirect_t
impl_object__is_in_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_x500Name
        }
    },
    (void *)&afw_function_definition_is_in_x500Name
};

static const afw_value_function_parameter_t
impl_is_in_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_x500Name_parameters[] = {
    &impl_is_in_x500Name_parameter_1,
    &impl_is_in_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("is_in<x500Name>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_x500Name"),
    AFW_UTF8_LITERAL("isInX500Name"),
    AFW_UTF8_LITERAL("afwIsInX500Name"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether x500Name value is in list of x500Name list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: x500Name, list: (list x500Name)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<x500Name> (\n    value: x500Name,\n    list: (list x500Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_x500Name_parameters[0],
    2,
    &impl_is_in_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__is_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_x500Name");

static const afw_runtime_object_indirect_t
impl_object__is_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_x500Name
        }
    },
    (void *)&afw_function_definition_is_x500Name
};

static const afw_value_function_parameter_t
impl_is_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_x500Name_parameters[] = {
    &impl_is_x500Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("is<x500Name>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_x500Name"),
    AFW_UTF8_LITERAL("isX500Name"),
    AFW_UTF8_LITERAL("afwIsX500Name"),
    AFW_UTF8_LITERAL("Checks whether value is dataType x500Name"),
    AFW_UTF8_LITERAL("Checks whether value is dataType x500Name and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType x500Name */\nfunction is<x500Name> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_x500Name_parameters[0],
    1,
    &impl_is_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__le_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_x500Name");

static const afw_runtime_object_indirect_t
impl_object__le_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_x500Name
        }
    },
    (void *)&afw_function_definition_le_x500Name
};

static const afw_value_function_parameter_t
impl_le_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_x500Name_parameters[] = {
    &impl_le_x500Name_parameter_1,
    &impl_le_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("le<x500Name>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_x500Name"),
    AFW_UTF8_LITERAL("leX500Name"),
    AFW_UTF8_LITERAL("afwLeX500Name"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for x500Name arg1 is less than or equal to x500Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<x500Name> (\n    arg1: x500Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_x500Name_parameters[0],
    2,
    &impl_le_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__lt_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_x500Name");

static const afw_runtime_object_indirect_t
impl_object__lt_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_x500Name
        }
    },
    (void *)&afw_function_definition_lt_x500Name
};

static const afw_value_function_parameter_t
impl_lt_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_x500Name_parameters[] = {
    &impl_lt_x500Name_parameter_1,
    &impl_lt_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("lt<x500Name>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_x500Name"),
    AFW_UTF8_LITERAL("ltX500Name"),
    AFW_UTF8_LITERAL("afwLtX500Name"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for x500Name arg1 is less that x500Name arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: x500Name): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<x500Name> (\n    arg1: x500Name,\n    arg2: x500Name\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_x500Name_parameters[0],
    2,
    &impl_lt_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- match<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__match_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/match_x500Name");

static const afw_runtime_object_indirect_t
impl_object__match_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_match_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__match_x500Name
        }
    },
    (void *)&afw_function_definition_match_x500Name
};

static const afw_value_function_parameter_t
impl_match_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_match_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_match_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_match_x500Name_parameters[] = {
    &impl_match_x500Name_parameter_1,
    &impl_match_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_match_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__match_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("match<x500Name>"),
    AFW_UTF8_LITERAL("match"),
    AFW_UTF8_LITERAL("match_x500Name"),
    AFW_UTF8_LITERAL("matchX500Name"),
    AFW_UTF8_LITERAL("afwMatchX500Name"),
    AFW_UTF8_LITERAL("Checks if x500Name matches"),
    AFW_UTF8_LITERAL("Returns true if arg1 matches some terminal sequence of RDNs from arg2 when compared using equal_x500Name."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: string): boolean"),
    AFW_UTF8_LITERAL("/* Checks if x500Name matches */\nfunction match<x500Name> (\n    arg1: x500Name,\n    arg2: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_match_x500Name,
    NULL,
    2,
    2,
    &impl_match_x500Name_parameters[0],
    2,
    &impl_match_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__ne_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_x500Name");

static const afw_runtime_object_indirect_t
impl_object__ne_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_x500Name
        }
    },
    (void *)&afw_function_definition_ne_x500Name
};

static const afw_value_function_parameter_t
impl_ne_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_x500Name_parameters[] = {
    &impl_ne_x500Name_parameter_1,
    &impl_ne_x500Name_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_x500Name_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("ne<x500Name>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_x500Name"),
    AFW_UTF8_LITERAL("neX500Name"),
    AFW_UTF8_LITERAL("afwNeX500Name"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if x500Name arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<x500Name> (\n    arg1: x500Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_x500Name_parameters[0],
    2,
    &impl_ne_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    &impl_ne_x500Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__nex_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_x500Name");

static const afw_runtime_object_indirect_t
impl_object__nex_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_x500Name
        }
    },
    (void *)&afw_function_definition_nex_x500Name
};

static const afw_value_function_parameter_t
impl_nex_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_x500Name_parameters[] = {
    &impl_nex_x500Name_parameter_1,
    &impl_nex_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("nex<x500Name>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_x500Name"),
    AFW_UTF8_LITERAL("nexX500Name"),
    AFW_UTF8_LITERAL("afwNexX500Name"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for x500Name arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: x500Name, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<x500Name> (\n    arg1: x500Name,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_x500Name_parameters[0],
    2,
    &impl_nex_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_x500Name");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_x500Name
        }
    },
    (void *)&afw_function_definition_one_and_only_x500Name
};

static const afw_value_function_parameter_t
impl_one_and_only_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_x500Name_parameters[] = {
    &impl_one_and_only_x500Name_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_x500Name_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("one_and_only<x500Name>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_x500Name"),
    AFW_UTF8_LITERAL("oneAndOnlyX500Name"),
    AFW_UTF8_LITERAL("afwOneAndOnlyX500Name"),
    AFW_UTF8_LITERAL("Converts a one value list to a x500Name value"),
    AFW_UTF8_LITERAL("This converts a list of x500Name values that contains one value to a single x500Name value."),
    AFW_UTF8_LITERAL("(list: (list list)): x500Name"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a x500Name value */\nfunction one_and_only<x500Name> (\n    list: (list list)\n): x500Name;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_x500Name_parameters[0],
    1,
    &impl_one_and_only_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    &impl_one_and_only_x500Name_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- regexp_match<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__regexp_match_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/regexp_match_x500Name");

static const afw_runtime_object_indirect_t
impl_object__regexp_match_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_regexp_match_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__regexp_match_x500Name
        }
    },
    (void *)&afw_function_definition_regexp_match_x500Name
};

static const afw_value_function_parameter_t
impl_regexp_match_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_regexp_match_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("regexp"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_regexp_match_x500Name_parameters[] = {
    &impl_regexp_match_x500Name_parameter_1,
    &impl_regexp_match_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__regexp_match_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("regexp_match<x500Name>"),
    AFW_UTF8_LITERAL("regexp_match"),
    AFW_UTF8_LITERAL("regexp_match_x500Name"),
    AFW_UTF8_LITERAL("regexpMatchX500Name"),
    AFW_UTF8_LITERAL("afwRegexpMatchX500Name"),
    AFW_UTF8_LITERAL("Search for a match using a regular expression"),
    AFW_UTF8_LITERAL("Checks whether x500Name value matches the regular expression regexp and return the boolean result."),
    AFW_UTF8_LITERAL("(value: x500Name, regexp: string): boolean"),
    AFW_UTF8_LITERAL("/* Search for a match using a regular expression */\nfunction regexp_match<x500Name> (\n    value: x500Name,\n    regexp: string\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_regexp_match,
    NULL,
    2,
    2,
    &impl_regexp_match_x500Name_parameters[0],
    2,
    &impl_regexp_match_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_regexp_match,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_x500Name");

static const afw_runtime_object_indirect_t
impl_object__set_equals_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_x500Name
        }
    },
    (void *)&afw_function_definition_set_equals_x500Name
};

static const afw_value_function_parameter_t
impl_set_equals_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_x500Name_parameters[] = {
    &impl_set_equals_x500Name_parameter_1,
    &impl_set_equals_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("set_equals<x500Name>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_x500Name"),
    AFW_UTF8_LITERAL("setEqualsX500Name"),
    AFW_UTF8_LITERAL("afwSetEqualsX500Name"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if x500Name list1 and x500Name list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list x500Name), list2: (list x500Name)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<x500Name> (\n    list1: (list x500Name),\n    list2: (list x500Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_x500Name_parameters[0],
    2,
    &impl_set_equals_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__subset_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_x500Name");

static const afw_runtime_object_indirect_t
impl_object__subset_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_x500Name
        }
    },
    (void *)&afw_function_definition_subset_x500Name
};

static const afw_value_function_parameter_t
impl_subset_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_x500Name_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_x500Name_parameters[] = {
    &impl_subset_x500Name_parameter_1,
    &impl_subset_x500Name_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("subset<x500Name>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_x500Name"),
    AFW_UTF8_LITERAL("subsetX500Name"),
    AFW_UTF8_LITERAL("afwSubsetX500Name"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in x500Name list1 are all in x500Name list2."),
    AFW_UTF8_LITERAL("(list1: (list x500Name), list2: (list x500Name)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<x500Name> (\n    list1: (list x500Name),\n    list2: (list x500Name)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_x500Name_parameters[0],
    2,
    &impl_subset_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__to_string_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_x500Name");

static const afw_runtime_object_indirect_t
impl_object__to_string_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_x500Name
        }
    },
    (void *)&afw_function_definition_to_string_x500Name
};

static const afw_value_function_parameter_t
impl_to_string_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A x500Name value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_x500Name_parameters[] = {
    &impl_to_string_x500Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("to_string<x500Name>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_x500Name"),
    AFW_UTF8_LITERAL("toStringX500Name"),
    AFW_UTF8_LITERAL("afwToStringX500Name"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts x500Name value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: x500Name): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<x500Name> (\n    value: x500Name\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_x500Name_parameters[0],
    1,
    &impl_to_string_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<x500Name> ---------- */

static const afw_utf8_t
impl_object_path__union_x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_x500Name");

static const afw_runtime_object_indirect_t
impl_object__union_x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_x500Name
        }
    },
    (void *)&afw_function_definition_union_x500Name
};

static const afw_value_function_parameter_t
impl_union_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_x500Name_parameters[] = {
    &impl_union_x500Name_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("union<x500Name>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_x500Name"),
    AFW_UTF8_LITERAL("unionX500Name"),
    AFW_UTF8_LITERAL("afwUnionX500Name"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of x500Name contains all of the unique values in two or more list of x500Name values."),
    AFW_UTF8_LITERAL("(lists_1: (list x500Name), lists_2: (list x500Name), ...lists_rest: (list of (list x500Name))): (list x500Name)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<x500Name> (\n    lists_1: (list x500Name),\n    lists_2: (list x500Name),\n    ...lists_rest: (list of (list x500Name))\n): (list x500Name);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_x500Name_parameters[0],
    1,
    &impl_union_x500Name_returns,
    NULL,
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- x500Name ---------- */

static const afw_utf8_t
impl_object_path__x500Name =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/x500Name");

static const afw_runtime_object_indirect_t
impl_object__x500Name = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_x500Name,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__x500Name
        }
    },
    (void *)&afw_function_definition_x500Name
};

static const afw_value_function_parameter_t
impl_x500Name_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_x500Name_direct,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_x500Name_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_x500Name_parameters[] = {
    &impl_x500Name_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_x500Name_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_x500Name = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__x500Name,
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("x500Name"),
    AFW_UTF8_LITERAL("afwX500Name"),
    AFW_UTF8_LITERAL("Convert to data type x500Name"),
    AFW_UTF8_LITERAL("Converts value to data type x500Name returning x500Name result."),
    AFW_UTF8_LITERAL("(value: any): x500Name"),
    AFW_UTF8_LITERAL("/* Convert to data type x500Name */\nfunction x500Name (\n    value: any\n): x500Name;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_x500Name_parameters[0],
    1,
    &impl_x500Name_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_x500Name_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__bag_size_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_xpathExpression
        }
    },
    (void *)&afw_function_definition_bag_size_xpathExpression
};

static const afw_value_function_parameter_t
impl_bag_size_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_xpathExpression_parameters[] = {
    &impl_bag_size_xpathExpression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("bag_size<xpathExpression>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_xpathExpression"),
    AFW_UTF8_LITERAL("bagSizeXpathExpression"),
    AFW_UTF8_LITERAL("afwBagSizeXpathExpression"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list xpathExpression)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<xpathExpression> (\n    value: (list xpathExpression)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_xpathExpression_parameters[0],
    1,
    &impl_bag_size_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__bag_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__bag_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_xpathExpression
        }
    },
    (void *)&afw_function_definition_bag_xpathExpression
};

static const afw_value_function_parameter_t
impl_bag_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_xpathExpression_parameters[] = {
    &impl_bag_xpathExpression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("bag<xpathExpression>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_xpathExpression"),
    AFW_UTF8_LITERAL("bagXpathExpression"),
    AFW_UTF8_LITERAL("afwBagXpathExpression"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of xpathExpression values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list xpathExpression))): (list xpathExpression)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<xpathExpression> (\n    ...values: (list of (list xpathExpression))\n): (list xpathExpression);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_xpathExpression_parameters[0],
    1,
    &impl_bag_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- compile<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__compile_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/compile_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__compile_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_compile_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__compile_xpathExpression
        }
    },
    (void *)&afw_function_definition_compile_xpathExpression
};

static const afw_value_function_parameter_t
impl_compile_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to compile"),
    AFW_UTF8_LITERAL("xpathExpression string to compile"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_compile_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("listing"),
    AFW_UTF8_LITERAL("Listing option"),
    AFW_UTF8_LITERAL("If specified, a compiler listing is produced instead of an unevaluated expression value.\n\nThis parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_compile_xpathExpression_parameters[] = {
    &impl_compile_xpathExpression_parameter_1,
    &impl_compile_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__compile_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("compile<xpathExpression>"),
    AFW_UTF8_LITERAL("compile"),
    AFW_UTF8_LITERAL("compile_xpathExpression"),
    AFW_UTF8_LITERAL("compileXpathExpression"),
    AFW_UTF8_LITERAL("afwCompileXpathExpression"),
    AFW_UTF8_LITERAL("Compile xpathExpression value"),
    AFW_UTF8_LITERAL("Compile xpathExpression value and return either an unevaluated adaptive value or a string containing the compiler listing."),
    AFW_UTF8_LITERAL("(source: xpathExpression, listing?: any): unevaluated"),
    AFW_UTF8_LITERAL("/* Compile xpathExpression value */\nfunction compile<xpathExpression> (\n    source: xpathExpression /* Source to compile */,\n    listing?: any           /* Listing option */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_compile_xpathExpression,
    NULL,
    1,
    2,
    &impl_compile_xpathExpression_parameters[0],
    2,
    &impl_compile_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_compile,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__eq_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__eq_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_xpathExpression
        }
    },
    (void *)&afw_function_definition_eq_xpathExpression
};

static const afw_value_function_parameter_t
impl_eq_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_xpathExpression_parameters[] = {
    &impl_eq_xpathExpression_parameter_1,
    &impl_eq_xpathExpression_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_xpathExpression_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("eq<xpathExpression>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_xpathExpression"),
    AFW_UTF8_LITERAL("eqXpathExpression"),
    AFW_UTF8_LITERAL("afwEqXpathExpression"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if xpathExpression arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_xpathExpression_parameters[0],
    2,
    &impl_eq_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    &impl_eq_xpathExpression_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__eqx_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__eqx_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_xpathExpression
        }
    },
    (void *)&afw_function_definition_eqx_xpathExpression
};

static const afw_value_function_parameter_t
impl_eqx_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_xpathExpression_parameters[] = {
    &impl_eqx_xpathExpression_parameter_1,
    &impl_eqx_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("eqx<xpathExpression>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_xpathExpression"),
    AFW_UTF8_LITERAL("eqxXpathExpression"),
    AFW_UTF8_LITERAL("afwEqxXpathExpression"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for xpathExpression arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_xpathExpression_parameters[0],
    2,
    &impl_eqx_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- evaluate<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__evaluate_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/evaluate_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__evaluate_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_evaluate_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__evaluate_xpathExpression
        }
    },
    (void *)&afw_function_definition_evaluate_xpathExpression
};

static const afw_value_function_parameter_t
impl_evaluate_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_unevaluated_direct,
    AFW_UTF8_LITERAL("unevaluated"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("source"),
    AFW_UTF8_LITERAL("Source to evaluate"),
    AFW_UTF8_LITERAL("xpathExpression string to compile and evaluate"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_evaluate_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_object_direct,
    AFW_UTF8_LITERAL("object"),
    AFW_UTF8_LITERAL("_AdaptiveHybridPropertiesObjects_"),
    AFW_UTF8_LITERAL("additionalUntrustedQualifiedVariables"),
    AFW_UTF8_LITERAL("Additional untrusted qualified variables"),
    AFW_UTF8_LITERAL("This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production."),
    -1,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_evaluate_xpathExpression_parameters[] = {
    &impl_evaluate_xpathExpression_parameter_1,
    &impl_evaluate_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__evaluate_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("evaluate<xpathExpression>"),
    AFW_UTF8_LITERAL("evaluate"),
    AFW_UTF8_LITERAL("evaluate_xpathExpression"),
    AFW_UTF8_LITERAL("evaluateXpathExpression"),
    AFW_UTF8_LITERAL("afwEvaluateXpathExpression"),
    AFW_UTF8_LITERAL("Evaluate xpathExpression value"),
    AFW_UTF8_LITERAL("Compile and evaluate xpathExpression value."),
    AFW_UTF8_LITERAL("(source: xpathExpression, additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_)): unevaluated"),
    AFW_UTF8_LITERAL("/* Evaluate xpathExpression value */\nfunction evaluate<xpathExpression> (\n    source: xpathExpression                                                            /* Source to evaluate */,\n    additionalUntrustedQualifiedVariables?: (object _AdaptiveHybridPropertiesObjects_) /* Additional untrusted qualified variables */\n): unevaluated;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_evaluate_xpathExpression,
    NULL,
    1,
    2,
    &impl_evaluate_xpathExpression_parameters[0],
    2,
    &impl_evaluate_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_evaluate,
    0,
    false,
    false,
    false,
    false,
    false
};

/* ---------- ge<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__ge_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__ge_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_xpathExpression
        }
    },
    (void *)&afw_function_definition_ge_xpathExpression
};

static const afw_value_function_parameter_t
impl_ge_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_xpathExpression_parameters[] = {
    &impl_ge_xpathExpression_parameter_1,
    &impl_ge_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("ge<xpathExpression>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_xpathExpression"),
    AFW_UTF8_LITERAL("geXpathExpression"),
    AFW_UTF8_LITERAL("afwGeXpathExpression"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for xpathExpression arg1 is greater than or equal to xpathExpression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: xpathExpression): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: xpathExpression\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_xpathExpression_parameters[0],
    2,
    &impl_ge_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__gt_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__gt_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_xpathExpression
        }
    },
    (void *)&afw_function_definition_gt_xpathExpression
};

static const afw_value_function_parameter_t
impl_gt_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_xpathExpression_parameters[] = {
    &impl_gt_xpathExpression_parameter_1,
    &impl_gt_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("gt<xpathExpression>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_xpathExpression"),
    AFW_UTF8_LITERAL("gtXpathExpression"),
    AFW_UTF8_LITERAL("afwGtXpathExpression"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for xpathExpression arg1 is greater than xpathExpression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: xpathExpression): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: xpathExpression\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_xpathExpression_parameters[0],
    2,
    &impl_gt_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__is_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__is_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_xpathExpression
        }
    },
    (void *)&afw_function_definition_is_xpathExpression
};

static const afw_value_function_parameter_t
impl_is_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_xpathExpression_parameters[] = {
    &impl_is_xpathExpression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("is<xpathExpression>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_xpathExpression"),
    AFW_UTF8_LITERAL("isXpathExpression"),
    AFW_UTF8_LITERAL("afwIsXpathExpression"),
    AFW_UTF8_LITERAL("Checks whether value is dataType xpathExpression"),
    AFW_UTF8_LITERAL("Checks whether value is dataType xpathExpression and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType xpathExpression */\nfunction is<xpathExpression> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_xpathExpression_parameters[0],
    1,
    &impl_is_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__le_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__le_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_xpathExpression
        }
    },
    (void *)&afw_function_definition_le_xpathExpression
};

static const afw_value_function_parameter_t
impl_le_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_xpathExpression_parameters[] = {
    &impl_le_xpathExpression_parameter_1,
    &impl_le_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("le<xpathExpression>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_xpathExpression"),
    AFW_UTF8_LITERAL("leXpathExpression"),
    AFW_UTF8_LITERAL("afwLeXpathExpression"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for xpathExpression arg1 is less than or equal to xpathExpression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_xpathExpression_parameters[0],
    2,
    &impl_le_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__lt_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__lt_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_xpathExpression
        }
    },
    (void *)&afw_function_definition_lt_xpathExpression
};

static const afw_value_function_parameter_t
impl_lt_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_xpathExpression_parameters[] = {
    &impl_lt_xpathExpression_parameter_1,
    &impl_lt_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("lt<xpathExpression>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_xpathExpression"),
    AFW_UTF8_LITERAL("ltXpathExpression"),
    AFW_UTF8_LITERAL("afwLtXpathExpression"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for xpathExpression arg1 is less that xpathExpression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: xpathExpression): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: xpathExpression\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_xpathExpression_parameters[0],
    2,
    &impl_lt_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__ne_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__ne_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_xpathExpression
        }
    },
    (void *)&afw_function_definition_ne_xpathExpression
};

static const afw_value_function_parameter_t
impl_ne_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_xpathExpression_parameters[] = {
    &impl_ne_xpathExpression_parameter_1,
    &impl_ne_xpathExpression_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_xpathExpression_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("ne<xpathExpression>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_xpathExpression"),
    AFW_UTF8_LITERAL("neXpathExpression"),
    AFW_UTF8_LITERAL("afwNeXpathExpression"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if xpathExpression arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_xpathExpression_parameters[0],
    2,
    &impl_ne_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    &impl_ne_xpathExpression_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__nex_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__nex_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_xpathExpression
        }
    },
    (void *)&afw_function_definition_nex_xpathExpression
};

static const afw_value_function_parameter_t
impl_nex_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_xpathExpression_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_xpathExpression_parameters[] = {
    &impl_nex_xpathExpression_parameter_1,
    &impl_nex_xpathExpression_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("nex<xpathExpression>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_xpathExpression"),
    AFW_UTF8_LITERAL("nexXpathExpression"),
    AFW_UTF8_LITERAL("afwNexXpathExpression"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for xpathExpression arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<xpathExpression> (\n    arg1: xpathExpression,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_xpathExpression_parameters[0],
    2,
    &impl_nex_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<xpathExpression> ---------- */

static const afw_utf8_t
impl_object_path__to_string_xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__to_string_xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_xpathExpression
        }
    },
    (void *)&afw_function_definition_to_string_xpathExpression
};

static const afw_value_function_parameter_t
impl_to_string_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A xpathExpression value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_xpathExpression_parameters[] = {
    &impl_to_string_xpathExpression_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("to_string<xpathExpression>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_xpathExpression"),
    AFW_UTF8_LITERAL("toStringXpathExpression"),
    AFW_UTF8_LITERAL("afwToStringXpathExpression"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts xpathExpression value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: xpathExpression): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<xpathExpression> (\n    value: xpathExpression\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_xpathExpression_parameters[0],
    1,
    &impl_to_string_xpathExpression_returns,
    NULL,
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- xpathExpression ---------- */

static const afw_utf8_t
impl_object_path__xpathExpression =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/xpathExpression");

static const afw_runtime_object_indirect_t
impl_object__xpathExpression = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_xpathExpression,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__xpathExpression
        }
    },
    (void *)&afw_function_definition_xpathExpression
};

static const afw_value_function_parameter_t
impl_xpathExpression_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_xpathExpression_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_xpathExpression_parameters[] = {
    &impl_xpathExpression_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_xpathExpression_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpathExpression = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__xpathExpression,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("afwXpathExpression"),
    AFW_UTF8_LITERAL("Convert to data type xpathExpression"),
    AFW_UTF8_LITERAL("Converts value to data type xpathExpression returning xpathExpression result."),
    AFW_UTF8_LITERAL("(value: any): xpathExpression"),
    AFW_UTF8_LITERAL("/* Convert to data type xpathExpression */\nfunction xpathExpression (\n    value: any\n): xpathExpression;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_xpathExpression_parameters[0],
    1,
    &impl_xpathExpression_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_xpathExpression_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- xpath_node_count ---------- */

static const afw_utf8_t
impl_object_path__xpath_node_count =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/xpath_node_count");

static const afw_runtime_object_indirect_t
impl_object__xpath_node_count = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_xpath_node_count,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__xpath_node_count
        }
    },
    (void *)&afw_function_definition_xpath_node_count
};

static const afw_value_function_parameter_t
impl_xpath_node_count_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_xpath_node_count_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("nodeset"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_xpath_node_count_parameters[] = {
    &impl_xpath_node_count_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpath_node_count = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__xpath_node_count,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("xpath_node_count"),
    AFW_UTF8_LITERAL("xpath_node_count"),
    AFW_UTF8_LITERAL("xpath_node_count"),
    AFW_UTF8_LITERAL("xpathNodeCount"),
    AFW_UTF8_LITERAL("afwXpathNodeCount"),
    AFW_UTF8_LITERAL("Number of nodes in node-set"),
    AFW_UTF8_LITERAL("The number of nodes in a node-set."),
    AFW_UTF8_LITERAL("(nodeset: xpathExpression): integer"),
    AFW_UTF8_LITERAL("/* Number of nodes in node-set */\nfunction xpath_node_count (\n    nodeset: xpathExpression\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_xpath_node_count,
    NULL,
    1,
    1,
    &impl_xpath_node_count_parameters[0],
    1,
    &impl_xpath_node_count_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- xpath_node_eq ---------- */

static const afw_utf8_t
impl_object_path__xpath_node_eq =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/xpath_node_eq");

static const afw_runtime_object_indirect_t
impl_object__xpath_node_eq = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_xpath_node_eq,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__xpath_node_eq
        }
    },
    (void *)&afw_function_definition_xpath_node_eq
};

static const afw_value_function_parameter_t
impl_xpath_node_eq_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_xpath_node_eq_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_xpath_node_eq_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_xpath_node_eq_parameters[] = {
    &impl_xpath_node_eq_parameter_1,
    &impl_xpath_node_eq_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpath_node_eq = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__xpath_node_eq,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("xpath_node_eq"),
    AFW_UTF8_LITERAL("xpath_node_eq"),
    AFW_UTF8_LITERAL("xpath_node_eq"),
    AFW_UTF8_LITERAL("xpathNodeEq"),
    AFW_UTF8_LITERAL("afwXpathNodeEq"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Checks for xpathExpression arg1 is equal to xpathExpression arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: xpathExpression, arg2: xpathExpression): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction xpath_node_eq (\n    arg1: xpathExpression,\n    arg2: xpathExpression\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_xpath_node_eq,
    NULL,
    2,
    2,
    &impl_xpath_node_eq_parameters[0],
    2,
    &impl_xpath_node_eq_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- xpath_node_match ---------- */

static const afw_utf8_t
impl_object_path__xpath_node_match =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/xpath_node_match");

static const afw_runtime_object_indirect_t
impl_object__xpath_node_match = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_xpath_node_match,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__xpath_node_match
        }
    },
    (void *)&afw_function_definition_xpath_node_match
};

static const afw_value_function_parameter_t
impl_xpath_node_match_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_xpath_node_match_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("nodeset2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_xpath_node_match_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_xpathExpression_direct,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_xpath_node_match_parameters[] = {
    &impl_xpath_node_match_parameter_1,
    &impl_xpath_node_match_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpath_node_match = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__xpath_node_match,
    AFW_UTF8_LITERAL("xpathExpression"),
    AFW_UTF8_LITERAL("xpath_node_match"),
    AFW_UTF8_LITERAL("xpath_node_match"),
    AFW_UTF8_LITERAL("xpath_node_match"),
    AFW_UTF8_LITERAL("xpathNodeMatch"),
    AFW_UTF8_LITERAL("afwXpathNodeMatch"),
    AFW_UTF8_LITERAL("Checks whether two node-sets or their children have an equal node"),
    AFW_UTF8_LITERAL("Returns true if any of the nodes matched by nodeset1 are equal to any of the nodes matched by nodeset2 or their corresponding children."),
    AFW_UTF8_LITERAL("(nodeset2: xpathExpression, arg2: xpathExpression): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two node-sets or their children have an equal node */\nfunction xpath_node_match (\n    nodeset2: xpathExpression,\n    arg2: xpathExpression\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_xpath_node_match,
    NULL,
    2,
    2,
    &impl_xpath_node_match_parameters[0],
    2,
    &impl_xpath_node_match_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    NULL,
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- at_least_one_member_of<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__at_least_one_member_of_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/at_least_one_member_of_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__at_least_one_member_of_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_at_least_one_member_of_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__at_least_one_member_of_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_at_least_one_member_of_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_at_least_one_member_of_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_at_least_one_member_of_yearMonthDuration_parameters[] = {
    &impl_at_least_one_member_of_yearMonthDuration_parameter_1,
    &impl_at_least_one_member_of_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__at_least_one_member_of_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("at_least_one_member_of<yearMonthDuration>"),
    AFW_UTF8_LITERAL("at_least_one_member_of"),
    AFW_UTF8_LITERAL("at_least_one_member_of_yearMonthDuration"),
    AFW_UTF8_LITERAL("atLeastOneMemberOfYearMonthDuration"),
    AFW_UTF8_LITERAL("afwAtLeastOneMemberOfYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for at least one value in common"),
    AFW_UTF8_LITERAL("Returns boolean true if at least one value in yearMonthDuration list1 is in yearMonthDuration list2."),
    AFW_UTF8_LITERAL("(list1: (list yearMonthDuration), list2: (list yearMonthDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Checks for at least one value in common */\nfunction at_least_one_member_of<yearMonthDuration> (\n    list1: (list yearMonthDuration),\n    list2: (list yearMonthDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_at_least_one_member_of,
    NULL,
    2,
    2,
    &impl_at_least_one_member_of_yearMonthDuration_parameters[0],
    2,
    &impl_at_least_one_member_of_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_at_least_one_member_of,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag_size<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__bag_size_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_size_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__bag_size_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_size_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_size_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_bag_size_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_bag_size_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_integer_direct,
    AFW_UTF8_LITERAL("integer"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_size_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_size_yearMonthDuration_parameters[] = {
    &impl_bag_size_yearMonthDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_size_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("bag_size<yearMonthDuration>"),
    AFW_UTF8_LITERAL("bag_size"),
    AFW_UTF8_LITERAL("bag_size_yearMonthDuration"),
    AFW_UTF8_LITERAL("bagSizeYearMonthDuration"),
    AFW_UTF8_LITERAL("afwBagSizeYearMonthDuration"),
    AFW_UTF8_LITERAL("Returns the number of values in a bag"),
    AFW_UTF8_LITERAL("This returns the integer number of values in list."),
    AFW_UTF8_LITERAL("(value: (list yearMonthDuration)): integer"),
    AFW_UTF8_LITERAL("/* Returns the number of values in a bag */\nfunction bag_size<yearMonthDuration> (\n    value: (list yearMonthDuration)\n): integer;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag_size,
    NULL,
    1,
    1,
    &impl_bag_size_yearMonthDuration_parameters[0],
    1,
    &impl_bag_size_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_bag_size,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- bag<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__bag_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/bag_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__bag_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_bag_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__bag_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_bag_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_bag_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_bag_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("values"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    0,
    true,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_bag_yearMonthDuration_parameters[] = {
    &impl_bag_yearMonthDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__bag_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("bag<yearMonthDuration>"),
    AFW_UTF8_LITERAL("bag"),
    AFW_UTF8_LITERAL("bag_yearMonthDuration"),
    AFW_UTF8_LITERAL("bagYearMonthDuration"),
    AFW_UTF8_LITERAL("afwBagYearMonthDuration"),
    AFW_UTF8_LITERAL("Makes a list from values"),
    AFW_UTF8_LITERAL("Takes any number of yearMonthDuration values and returns a list of list."),
    AFW_UTF8_LITERAL("(...values: (list of (list yearMonthDuration))): (list yearMonthDuration)"),
    AFW_UTF8_LITERAL("/* Makes a list from values */\nfunction bag<yearMonthDuration> (\n    ...values: (list of (list yearMonthDuration))\n): (list yearMonthDuration);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_bag,
    NULL,
    0,
    -1,
    &impl_bag_yearMonthDuration_parameters[0],
    1,
    &impl_bag_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_bag,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eq<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__eq_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eq_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__eq_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eq_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eq_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_eq_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_eq_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eq_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eq_yearMonthDuration_parameters[] = {
    &impl_eq_yearMonthDuration_parameter_1,
    &impl_eq_yearMonthDuration_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_eq_yearMonthDuration_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eq_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("eq<yearMonthDuration>"),
    AFW_UTF8_LITERAL("eq"),
    AFW_UTF8_LITERAL("eq_yearMonthDuration"),
    AFW_UTF8_LITERAL("eqYearMonthDuration"),
    AFW_UTF8_LITERAL("afwEqYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for equal"),
    AFW_UTF8_LITERAL("Determine if yearMonthDuration arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"eqx\" (\"===\") instead if you want false to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal */\nfunction eq<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("=="),
    afw_function_execute_eq,
    NULL,
    2,
    2,
    &impl_eq_yearMonthDuration_parameters[0],
    2,
    &impl_eq_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    &impl_eq_yearMonthDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_eq,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- eqx<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__eqx_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/eqx_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__eqx_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_eqx_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__eqx_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_eqx_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_eqx_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_eqx_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_eqx_yearMonthDuration_parameters[] = {
    &impl_eqx_yearMonthDuration_parameter_1,
    &impl_eqx_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__eqx_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("eqx<yearMonthDuration>"),
    AFW_UTF8_LITERAL("eqx"),
    AFW_UTF8_LITERAL("eqx_yearMonthDuration"),
    AFW_UTF8_LITERAL("eqxYearMonthDuration"),
    AFW_UTF8_LITERAL("afwEqxYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for equal and type"),
    AFW_UTF8_LITERAL("Determine if for yearMonthDuration arg1 is equal to the value and data type of arg2 then return the boolean result. Use \"eq\" (\"==\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for equal and type */\nfunction eqx<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("==="),
    afw_function_execute_eqx,
    NULL,
    2,
    2,
    &impl_eqx_yearMonthDuration_parameters[0],
    2,
    &impl_eqx_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_eqx,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ge<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__ge_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ge_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__ge_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ge_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ge_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_ge_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_ge_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ge_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ge_yearMonthDuration_parameters[] = {
    &impl_ge_yearMonthDuration_parameter_1,
    &impl_ge_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ge_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("ge<yearMonthDuration>"),
    AFW_UTF8_LITERAL("ge"),
    AFW_UTF8_LITERAL("ge_yearMonthDuration"),
    AFW_UTF8_LITERAL("geYearMonthDuration"),
    AFW_UTF8_LITERAL("afwGeYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for greater than or equal"),
    AFW_UTF8_LITERAL("Checks for yearMonthDuration arg1 is greater than or equal to yearMonthDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: yearMonthDuration): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than or equal */\nfunction ge<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: yearMonthDuration\n): boolean;\n"),
    AFW_UTF8_LITERAL(">="),
    afw_function_execute_ge,
    NULL,
    2,
    2,
    &impl_ge_yearMonthDuration_parameters[0],
    2,
    &impl_ge_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_ge,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- gt<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__gt_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/gt_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__gt_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_gt_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__gt_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_gt_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_gt_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_gt_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_gt_yearMonthDuration_parameters[] = {
    &impl_gt_yearMonthDuration_parameter_1,
    &impl_gt_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__gt_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("gt<yearMonthDuration>"),
    AFW_UTF8_LITERAL("gt"),
    AFW_UTF8_LITERAL("gt_yearMonthDuration"),
    AFW_UTF8_LITERAL("gtYearMonthDuration"),
    AFW_UTF8_LITERAL("afwGtYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for greater than"),
    AFW_UTF8_LITERAL("Checks for yearMonthDuration arg1 is greater than yearMonthDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: yearMonthDuration): boolean"),
    AFW_UTF8_LITERAL("/* Checks for greater than */\nfunction gt<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: yearMonthDuration\n): boolean;\n"),
    AFW_UTF8_LITERAL(">"),
    afw_function_execute_gt,
    NULL,
    2,
    2,
    &impl_gt_yearMonthDuration_parameters[0],
    2,
    &impl_gt_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_gt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- intersection<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__intersection_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/intersection_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__intersection_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_intersection_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__intersection_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_intersection_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_intersection_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_intersection_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_intersection_yearMonthDuration_parameters[] = {
    &impl_intersection_yearMonthDuration_parameter_1,
    &impl_intersection_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__intersection_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("intersection<yearMonthDuration>"),
    AFW_UTF8_LITERAL("intersection"),
    AFW_UTF8_LITERAL("intersection_yearMonthDuration"),
    AFW_UTF8_LITERAL("intersectionYearMonthDuration"),
    AFW_UTF8_LITERAL("afwIntersectionYearMonthDuration"),
    AFW_UTF8_LITERAL("Returns intersection of two lists"),
    AFW_UTF8_LITERAL("Returns a list of yearMonthDuration with the values that are common to both list of yearMonthDuration list1 and list2."),
    AFW_UTF8_LITERAL("(list1: (list yearMonthDuration), list2: (list yearMonthDuration)): (list yearMonthDuration)"),
    AFW_UTF8_LITERAL("/* Returns intersection of two lists */\nfunction intersection<yearMonthDuration> (\n    list1: (list yearMonthDuration),\n    list2: (list yearMonthDuration)\n): (list yearMonthDuration);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_intersection,
    NULL,
    2,
    2,
    &impl_intersection_yearMonthDuration_parameters[0],
    2,
    &impl_intersection_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_intersection,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is_in<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__is_in_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_in_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__is_in_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_in_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_in_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_is_in_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_is_in_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_in_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_in_yearMonthDuration_parameters[] = {
    &impl_is_in_yearMonthDuration_parameter_1,
    &impl_is_in_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_in_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("is_in<yearMonthDuration>"),
    AFW_UTF8_LITERAL("is_in"),
    AFW_UTF8_LITERAL("is_in_yearMonthDuration"),
    AFW_UTF8_LITERAL("isInYearMonthDuration"),
    AFW_UTF8_LITERAL("afwIsInYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks whether a value is in a list"),
    AFW_UTF8_LITERAL("Checks whether yearMonthDuration value is in list of yearMonthDuration list and returns the boolean result."),
    AFW_UTF8_LITERAL("(value: yearMonthDuration, list: (list yearMonthDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether a value is in a list */\nfunction is_in<yearMonthDuration> (\n    value: yearMonthDuration,\n    list: (list yearMonthDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is_in,
    NULL,
    2,
    2,
    &impl_is_in_yearMonthDuration_parameters[0],
    2,
    &impl_is_in_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_is_in,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- is<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__is_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/is_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__is_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_is_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__is_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_is_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_is_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_is_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to check"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_is_yearMonthDuration_parameters[] = {
    &impl_is_yearMonthDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__is_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("is<yearMonthDuration>"),
    AFW_UTF8_LITERAL("is"),
    AFW_UTF8_LITERAL("is_yearMonthDuration"),
    AFW_UTF8_LITERAL("isYearMonthDuration"),
    AFW_UTF8_LITERAL("afwIsYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks whether value is dataType yearMonthDuration"),
    AFW_UTF8_LITERAL("Checks whether value is dataType yearMonthDuration and return the boolean result."),
    AFW_UTF8_LITERAL("(value: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether value is dataType yearMonthDuration */\nfunction is<yearMonthDuration> (\n    value: any\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_is,
    NULL,
    1,
    1,
    &impl_is_yearMonthDuration_parameters[0],
    1,
    &impl_is_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_is,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- le<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__le_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/le_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__le_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_le_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__le_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_le_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_le_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_le_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_le_yearMonthDuration_parameters[] = {
    &impl_le_yearMonthDuration_parameter_1,
    &impl_le_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__le_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("le<yearMonthDuration>"),
    AFW_UTF8_LITERAL("le"),
    AFW_UTF8_LITERAL("le_yearMonthDuration"),
    AFW_UTF8_LITERAL("leYearMonthDuration"),
    AFW_UTF8_LITERAL("afwLeYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for less than or equal"),
    AFW_UTF8_LITERAL("Checks for yearMonthDuration arg1 is less than or equal to yearMonthDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than or equal */\nfunction le<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("<="),
    afw_function_execute_le,
    NULL,
    2,
    2,
    &impl_le_yearMonthDuration_parameters[0],
    2,
    &impl_le_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_le,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- lt<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__lt_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/lt_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__lt_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_lt_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__lt_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_lt_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_lt_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_lt_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_lt_yearMonthDuration_parameters[] = {
    &impl_lt_yearMonthDuration_parameter_1,
    &impl_lt_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__lt_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("lt<yearMonthDuration>"),
    AFW_UTF8_LITERAL("lt"),
    AFW_UTF8_LITERAL("lt_yearMonthDuration"),
    AFW_UTF8_LITERAL("ltYearMonthDuration"),
    AFW_UTF8_LITERAL("afwLtYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for less than"),
    AFW_UTF8_LITERAL("Checks for yearMonthDuration arg1 is less that yearMonthDuration arg2 and return the boolean result."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: yearMonthDuration): boolean"),
    AFW_UTF8_LITERAL("/* Checks for less than */\nfunction lt<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: yearMonthDuration\n): boolean;\n"),
    AFW_UTF8_LITERAL("<"),
    afw_function_execute_lt,
    NULL,
    2,
    2,
    &impl_lt_yearMonthDuration_parameters[0],
    2,
    &impl_lt_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_lt,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- ne<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__ne_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/ne_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__ne_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_ne_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__ne_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_ne_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_ne_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_ne_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_ne_yearMonthDuration_parameters[] = {
    &impl_ne_yearMonthDuration_parameter_1,
    &impl_ne_yearMonthDuration_parameter_2,
    NULL
};

static const afw_utf8_z_t *
impl_ne_yearMonthDuration_errorsThrown[] = {
    "error", "conversion",
    "reason", "arg2 cannot be converted to the data type of arg1.",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__ne_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("ne<yearMonthDuration>"),
    AFW_UTF8_LITERAL("ne"),
    AFW_UTF8_LITERAL("ne_yearMonthDuration"),
    AFW_UTF8_LITERAL("neYearMonthDuration"),
    AFW_UTF8_LITERAL("afwNeYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for not equal"),
    AFW_UTF8_LITERAL("Determine if yearMonthDuration arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use \"nex\" (\"!==\") instead if you want true to be returned if arg1 and arg2's data type don't match."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal */\nfunction ne<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!="),
    afw_function_execute_ne,
    NULL,
    2,
    2,
    &impl_ne_yearMonthDuration_parameters[0],
    2,
    &impl_ne_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    &impl_ne_yearMonthDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_ne,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- nex<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__nex_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/nex_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__nex_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_nex_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__nex_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_nex_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_nex_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_nex_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("arg2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    true,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_nex_yearMonthDuration_parameters[] = {
    &impl_nex_yearMonthDuration_parameter_1,
    &impl_nex_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__nex_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("nex<yearMonthDuration>"),
    AFW_UTF8_LITERAL("nex"),
    AFW_UTF8_LITERAL("nex_yearMonthDuration"),
    AFW_UTF8_LITERAL("nexYearMonthDuration"),
    AFW_UTF8_LITERAL("afwNexYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks for not equal value or type"),
    AFW_UTF8_LITERAL("Determine if for yearMonthDuration arg1 is not equal to the value or data type of arg2 then return the boolean result. Use \"ne\" (\"!=\") instead if you want arg2 to be converted to the data type of arg1 before comparison."),
    AFW_UTF8_LITERAL("(arg1: yearMonthDuration, arg2: any): boolean"),
    AFW_UTF8_LITERAL("/* Checks for not equal value or type */\nfunction nex<yearMonthDuration> (\n    arg1: yearMonthDuration,\n    arg2: any\n): boolean;\n"),
    AFW_UTF8_LITERAL("!=="),
    afw_function_execute_nex,
    NULL,
    2,
    2,
    &impl_nex_yearMonthDuration_parameters[0],
    2,
    &impl_nex_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_nex,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- one_and_only<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__one_and_only_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/one_and_only_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__one_and_only_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_one_and_only_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__one_and_only_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_one_and_only_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_one_and_only_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_one_and_only_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_one_and_only_yearMonthDuration_parameters[] = {
    &impl_one_and_only_yearMonthDuration_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_one_and_only_yearMonthDuration_errorsThrown[] = {
    "error", "arg_error",
    "reason", "list does not contain exactly one value",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__one_and_only_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("one_and_only<yearMonthDuration>"),
    AFW_UTF8_LITERAL("one_and_only"),
    AFW_UTF8_LITERAL("one_and_only_yearMonthDuration"),
    AFW_UTF8_LITERAL("oneAndOnlyYearMonthDuration"),
    AFW_UTF8_LITERAL("afwOneAndOnlyYearMonthDuration"),
    AFW_UTF8_LITERAL("Converts a one value list to a yearMonthDuration value"),
    AFW_UTF8_LITERAL("This converts a list of yearMonthDuration values that contains one value to a single yearMonthDuration value."),
    AFW_UTF8_LITERAL("(list: (list list)): yearMonthDuration"),
    AFW_UTF8_LITERAL("/* Converts a one value list to a yearMonthDuration value */\nfunction one_and_only<yearMonthDuration> (\n    list: (list list)\n): yearMonthDuration;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_one_and_only,
    NULL,
    1,
    1,
    &impl_one_and_only_yearMonthDuration_parameters[0],
    1,
    &impl_one_and_only_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    &impl_one_and_only_yearMonthDuration_errorsThrown[0],
    NULL,
    afw_data_type_method_number_one_and_only,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- set_equals<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__set_equals_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/set_equals_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__set_equals_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_set_equals_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__set_equals_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_set_equals_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_set_equals_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_set_equals_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_set_equals_yearMonthDuration_parameters[] = {
    &impl_set_equals_yearMonthDuration_parameter_1,
    &impl_set_equals_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__set_equals_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("set_equals<yearMonthDuration>"),
    AFW_UTF8_LITERAL("set_equals"),
    AFW_UTF8_LITERAL("set_equals_yearMonthDuration"),
    AFW_UTF8_LITERAL("setEqualsYearMonthDuration"),
    AFW_UTF8_LITERAL("afwSetEqualsYearMonthDuration"),
    AFW_UTF8_LITERAL("Checks whether two lists are subsets of each other"),
    AFW_UTF8_LITERAL("Returns boolean true if yearMonthDuration list1 and yearMonthDuration list2 are subsets of each other and return the boolean result."),
    AFW_UTF8_LITERAL("(list1: (list yearMonthDuration), list2: (list yearMonthDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Checks whether two lists are subsets of each other */\nfunction set_equals<yearMonthDuration> (\n    list1: (list yearMonthDuration),\n    list2: (list yearMonthDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_set_equals,
    NULL,
    2,
    2,
    &impl_set_equals_yearMonthDuration_parameters[0],
    2,
    &impl_set_equals_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_set_equals,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- subset<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__subset_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/subset_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__subset_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_subset_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__subset_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_subset_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_subset_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_boolean_direct,
    AFW_UTF8_LITERAL("boolean"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list1"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The first list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_subset_yearMonthDuration_parameter_2 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("list2"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The second list."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_subset_yearMonthDuration_parameters[] = {
    &impl_subset_yearMonthDuration_parameter_1,
    &impl_subset_yearMonthDuration_parameter_2,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__subset_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("subset<yearMonthDuration>"),
    AFW_UTF8_LITERAL("subset"),
    AFW_UTF8_LITERAL("subset_yearMonthDuration"),
    AFW_UTF8_LITERAL("subsetYearMonthDuration"),
    AFW_UTF8_LITERAL("afwSubsetYearMonthDuration"),
    AFW_UTF8_LITERAL("Determines if the first list is a subset of second list"),
    AFW_UTF8_LITERAL("Returns boolean true if the unique values in yearMonthDuration list1 are all in yearMonthDuration list2."),
    AFW_UTF8_LITERAL("(list1: (list yearMonthDuration), list2: (list yearMonthDuration)): boolean"),
    AFW_UTF8_LITERAL("/* Determines if the first list is a subset of second list */\nfunction subset<yearMonthDuration> (\n    list1: (list yearMonthDuration),\n    list2: (list yearMonthDuration)\n): boolean;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_subset,
    NULL,
    2,
    2,
    &impl_subset_yearMonthDuration_parameters[0],
    2,
    &impl_subset_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_subset,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- to_string<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__to_string_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/to_string_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__to_string_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_to_string_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__to_string_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_to_string_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_to_string_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_string_direct,
    AFW_UTF8_LITERAL("string"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("The string representation of the value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_to_string_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("A yearMonthDuration value."),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_to_string_yearMonthDuration_parameters[] = {
    &impl_to_string_yearMonthDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__to_string_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("to_string<yearMonthDuration>"),
    AFW_UTF8_LITERAL("to_string"),
    AFW_UTF8_LITERAL("to_string_yearMonthDuration"),
    AFW_UTF8_LITERAL("toStringYearMonthDuration"),
    AFW_UTF8_LITERAL("afwToStringYearMonthDuration"),
    AFW_UTF8_LITERAL("Converts value to string"),
    AFW_UTF8_LITERAL("Converts yearMonthDuration value to string. For list values, the to_string() value for each entry is returned separated with commas."),
    AFW_UTF8_LITERAL("(value: yearMonthDuration): string"),
    AFW_UTF8_LITERAL("/* Converts value to string */\nfunction to_string<yearMonthDuration> (\n    value: yearMonthDuration\n): string;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_to_string_yearMonthDuration_parameters[0],
    1,
    &impl_to_string_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_to_string,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- union<yearMonthDuration> ---------- */

static const afw_utf8_t
impl_object_path__union_yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/union_yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__union_yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_union_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__union_yearMonthDuration
        }
    },
    (void *)&afw_function_definition_union_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_union_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_union_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_list_direct,
    AFW_UTF8_LITERAL("list"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("lists"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Two or more lists."),
    2,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_union_yearMonthDuration_parameters[] = {
    &impl_union_yearMonthDuration_parameter_1,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__union_yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("union<yearMonthDuration>"),
    AFW_UTF8_LITERAL("union"),
    AFW_UTF8_LITERAL("union_yearMonthDuration"),
    AFW_UTF8_LITERAL("unionYearMonthDuration"),
    AFW_UTF8_LITERAL("afwUnionYearMonthDuration"),
    AFW_UTF8_LITERAL("Returns union of two or more string lists"),
    AFW_UTF8_LITERAL("Returns a list of yearMonthDuration contains all of the unique values in two or more list of yearMonthDuration values."),
    AFW_UTF8_LITERAL("(lists_1: (list yearMonthDuration), lists_2: (list yearMonthDuration), ...lists_rest: (list of (list yearMonthDuration))): (list yearMonthDuration)"),
    AFW_UTF8_LITERAL("/* Returns union of two or more string lists */\nfunction union<yearMonthDuration> (\n    lists_1: (list yearMonthDuration),\n    lists_2: (list yearMonthDuration),\n    ...lists_rest: (list of (list yearMonthDuration))\n): (list yearMonthDuration);\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_union,
    NULL,
    2,
    -1,
    &impl_union_yearMonthDuration_parameters[0],
    1,
    &impl_union_yearMonthDuration_returns,
    NULL,
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    NULL,
    NULL,
    afw_data_type_method_number_union,
    0,
    false,
    false,
    false,
    true,
    false
};

/* ---------- yearMonthDuration ---------- */

static const afw_utf8_t
impl_object_path__yearMonthDuration =
    AFW_UTF8_LITERAL("/afw/_AdaptiveFunction_/yearMonthDuration");

static const afw_runtime_object_indirect_t
impl_object__yearMonthDuration = {
    {
        &afw_runtime_inf__AdaptiveFunction_,
        NULL,
        {
            NULL,
            NULL,
            &afw_s_yearMonthDuration,
            &afw_s__AdaptiveFunction_,
            &impl_object_path__yearMonthDuration
        }
    },
    (void *)&afw_function_definition_yearMonthDuration
};

static const afw_value_function_parameter_t
impl_yearMonthDuration_returns = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    &afw_data_type_yearMonthDuration_direct,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Converted value"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t
impl_yearMonthDuration_parameter_1 = {
    {
        &afw_runtime_inf__AdaptiveFunctionParameter_,
        NULL,
        {
            NULL,
            NULL,
            NULL,
            &afw_s__AdaptiveFunctionParameter_,
            NULL,
        }
    },
    NULL,
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("value"),
    AFW_UTF8_LITERAL(""),
    AFW_UTF8_LITERAL("Value to convert"),
    -1,
    false,
    false,
    false,
    false,
};

static const afw_value_function_parameter_t *
impl_yearMonthDuration_parameters[] = {
    &impl_yearMonthDuration_parameter_1,
    NULL
};

static const afw_utf8_z_t *
impl_yearMonthDuration_errorsThrown[] = {
    "error", "cast_error",
    "reason", "value could not be converted",
    NULL,
    NULL
};

AFW_DEFINE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_yearMonthDuration = {
    &afw_value_function_definition_inf,
    (const afw_object_t *)&impl_object__yearMonthDuration,
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("yearMonthDuration"),
    AFW_UTF8_LITERAL("afwYearMonthDuration"),
    AFW_UTF8_LITERAL("Convert to data type yearMonthDuration"),
    AFW_UTF8_LITERAL("Converts value to data type yearMonthDuration returning yearMonthDuration result."),
    AFW_UTF8_LITERAL("(value: any): yearMonthDuration"),
    AFW_UTF8_LITERAL("/* Convert to data type yearMonthDuration */\nfunction yearMonthDuration (\n    value: any\n): yearMonthDuration;\n"),
    AFW_UTF8_LITERAL(""),
    afw_function_execute_convert,
    NULL,
    1,
    1,
    &impl_yearMonthDuration_parameters[0],
    1,
    &impl_yearMonthDuration_returns,
    NULL,
    NULL,
    AFW_UTF8_LITERAL(""),
    &impl_yearMonthDuration_errorsThrown[0],
    NULL,
    0, /* Not a data type method. */
    0,
    false,
    false,
    false,
    true,
    false
};

static const afw_value_function_definition_t * 
impl_function_bindings[] = {
    &afw_function_definition_adaptor_objectCallback_signature,
    &afw_function_definition_add_object,
    &afw_function_definition_add_object_with_uri,
    &afw_function_definition_convert_AdaptiveQueryCriteria_to_query_string,
    &afw_function_definition_convert_query_string_to_AdaptiveQueryCriteria,
    &afw_function_definition_delete_object,
    &afw_function_definition_delete_object_with_uri,
    &afw_function_definition_get_object,
    &afw_function_definition_get_object_with_uri,
    &afw_function_definition_modify_object,
    &afw_function_definition_modify_object_with_uri,
    &afw_function_definition_reconcile_object,
    &afw_function_definition_replace_object,
    &afw_function_definition_replace_object_with_uri,
    &afw_function_definition_retrieve_objects,
    &afw_function_definition_retrieve_objects_to_callback,
    &afw_function_definition_retrieve_objects_to_response,
    &afw_function_definition_retrieve_objects_to_stream,
    &afw_function_definition_retrieve_objects_with_uri,
    &afw_function_definition_retrieve_objects_with_uri_to_callback,
    &afw_function_definition_retrieve_objects_with_uri_to_response,
    &afw_function_definition_retrieve_objects_with_uri_to_stream,
    &afw_function_definition_update_object,
    &afw_function_definition_update_object_with_uri,
    &afw_function_definition_extension_load,
    &afw_function_definition_extension_load_by_module_path,
    &afw_function_definition_flag_get_active,
    &afw_function_definition_flag_get_active_defaults,
    &afw_function_definition_flag_get_defaults,
    &afw_function_definition_flag_modify_defaults,
    &afw_function_definition_flag_replace_defaults,
    &afw_function_definition_flag_set,
    &afw_function_definition_registry_key_check,
    &afw_function_definition_service_get,
    &afw_function_definition_service_restart,
    &afw_function_definition_service_start,
    &afw_function_definition_service_stop,
    &afw_function_definition_anyURI,
    &afw_function_definition_at_least_one_member_of_anyURI,
    &afw_function_definition_bag_anyURI,
    &afw_function_definition_bag_size_anyURI,
    &afw_function_definition_ends_with_anyURI,
    &afw_function_definition_eq_anyURI,
    &afw_function_definition_eqx_anyURI,
    &afw_function_definition_ge_anyURI,
    &afw_function_definition_gt_anyURI,
    &afw_function_definition_includes_anyURI,
    &afw_function_definition_index_of_anyURI,
    &afw_function_definition_intersection_anyURI,
    &afw_function_definition_is_anyURI,
    &afw_function_definition_is_in_anyURI,
    &afw_function_definition_last_index_of_anyURI,
    &afw_function_definition_le_anyURI,
    &afw_function_definition_length_anyURI,
    &afw_function_definition_lt_anyURI,
    &afw_function_definition_ne_anyURI,
    &afw_function_definition_nex_anyURI,
    &afw_function_definition_one_and_only_anyURI,
    &afw_function_definition_regexp_index_of_anyURI,
    &afw_function_definition_regexp_match_anyURI,
    &afw_function_definition_regexp_replace_anyURI,
    &afw_function_definition_repeat_anyURI,
    &afw_function_definition_replace_anyURI,
    &afw_function_definition_set_equals_anyURI,
    &afw_function_definition_split_anyURI,
    &afw_function_definition_starts_with_anyURI,
    &afw_function_definition_subset_anyURI,
    &afw_function_definition_substring_anyURI,
    &afw_function_definition_to_string_anyURI,
    &afw_function_definition_union_anyURI,
    &afw_function_definition_url_encode_anyURI,
    &afw_function_definition_at_least_one_member_of_base64Binary,
    &afw_function_definition_bag_base64Binary,
    &afw_function_definition_bag_size_base64Binary,
    &afw_function_definition_base64Binary,
    &afw_function_definition_decode_to_string_base64Binary,
    &afw_function_definition_eq_base64Binary,
    &afw_function_definition_eqx_base64Binary,
    &afw_function_definition_ge_base64Binary,
    &afw_function_definition_gt_base64Binary,
    &afw_function_definition_intersection_base64Binary,
    &afw_function_definition_is_base64Binary,
    &afw_function_definition_is_in_base64Binary,
    &afw_function_definition_le_base64Binary,
    &afw_function_definition_lt_base64Binary,
    &afw_function_definition_ne_base64Binary,
    &afw_function_definition_nex_base64Binary,
    &afw_function_definition_one_and_only_base64Binary,
    &afw_function_definition_set_equals_base64Binary,
    &afw_function_definition_subset_base64Binary,
    &afw_function_definition_to_string_base64Binary,
    &afw_function_definition_union_base64Binary,
    &afw_function_definition_at_least_one_member_of_boolean,
    &afw_function_definition_bag_boolean,
    &afw_function_definition_bag_size_boolean,
    &afw_function_definition_boolean,
    &afw_function_definition_eq_boolean,
    &afw_function_definition_eqx_boolean,
    &afw_function_definition_ge_boolean,
    &afw_function_definition_gt_boolean,
    &afw_function_definition_intersection_boolean,
    &afw_function_definition_is_boolean,
    &afw_function_definition_is_in_boolean,
    &afw_function_definition_le_boolean,
    &afw_function_definition_lt_boolean,
    &afw_function_definition_ne_boolean,
    &afw_function_definition_nex_boolean,
    &afw_function_definition_one_and_only_boolean,
    &afw_function_definition_set_equals_boolean,
    &afw_function_definition_subset_boolean,
    &afw_function_definition_to_string_boolean,
    &afw_function_definition_union_boolean,
    &afw_function_definition_assert,
    &afw_function_definition_compile_expression_tuple,
    &afw_function_definition_compile_json,
    &afw_function_definition_compile_relaxed_json,
    &afw_function_definition_convert_syntax_hybrid_to_expression,
    &afw_function_definition_decompile,
    &afw_function_definition_evaluate_expression_tuple,
    &afw_function_definition_evaluate_value,
    &afw_function_definition_evaluate_with_retry,
    &afw_function_definition_qualifier,
    &afw_function_definition_qualifiers,
    &afw_function_definition_safe_evaluate,
    &afw_function_definition_stringify,
    &afw_function_definition_test_expression,
    &afw_function_definition_test_expression_tuple,
    &afw_function_definition_test_hybrid,
    &afw_function_definition_test_script,
    &afw_function_definition_test_script_runtime_support,
    &afw_function_definition_test_template,
    &afw_function_definition_test_value,
    &afw_function_definition_add_dayTimeDuration_dateTime,
    &afw_function_definition_add_yearMonthDuration_dateTime,
    &afw_function_definition_at_least_one_member_of_dateTime,
    &afw_function_definition_bag_dateTime,
    &afw_function_definition_bag_size_dateTime,
    &afw_function_definition_dateTime,
    &afw_function_definition_eq_dateTime,
    &afw_function_definition_eqx_dateTime,
    &afw_function_definition_ge_dateTime,
    &afw_function_definition_gt_dateTime,
    &afw_function_definition_intersection_dateTime,
    &afw_function_definition_is_dateTime,
    &afw_function_definition_is_in_dateTime,
    &afw_function_definition_le_dateTime,
    &afw_function_definition_lt_dateTime,
    &afw_function_definition_max_dateTime,
    &afw_function_definition_min_dateTime,
    &afw_function_definition_ne_dateTime,
    &afw_function_definition_nex_dateTime,
    &afw_function_definition_one_and_only_dateTime,
    &afw_function_definition_set_equals_dateTime,
    &afw_function_definition_subset_dateTime,
    &afw_function_definition_subtract_dayTimeDuration_dateTime,
    &afw_function_definition_subtract_yearMonthDuration_dateTime,
    &afw_function_definition_to_string_dateTime,
    &afw_function_definition_union_dateTime,
    &afw_function_definition_add_yearMonthDuration_date,
    &afw_function_definition_at_least_one_member_of_date,
    &afw_function_definition_bag_date,
    &afw_function_definition_bag_size_date,
    &afw_function_definition_date,
    &afw_function_definition_eq_date,
    &afw_function_definition_eqx_date,
    &afw_function_definition_ge_date,
    &afw_function_definition_gt_date,
    &afw_function_definition_intersection_date,
    &afw_function_definition_is_date,
    &afw_function_definition_is_in_date,
    &afw_function_definition_le_date,
    &afw_function_definition_lt_date,
    &afw_function_definition_max_date,
    &afw_function_definition_min_date,
    &afw_function_definition_ne_date,
    &afw_function_definition_nex_date,
    &afw_function_definition_one_and_only_date,
    &afw_function_definition_set_equals_date,
    &afw_function_definition_subset_date,
    &afw_function_definition_subtract_yearMonthDuration_date,
    &afw_function_definition_to_string_date,
    &afw_function_definition_union_date,
    &afw_function_definition_at_least_one_member_of_dayTimeDuration,
    &afw_function_definition_bag_dayTimeDuration,
    &afw_function_definition_bag_size_dayTimeDuration,
    &afw_function_definition_dayTimeDuration,
    &afw_function_definition_eq_dayTimeDuration,
    &afw_function_definition_eqx_dayTimeDuration,
    &afw_function_definition_ge_dayTimeDuration,
    &afw_function_definition_gt_dayTimeDuration,
    &afw_function_definition_intersection_dayTimeDuration,
    &afw_function_definition_is_dayTimeDuration,
    &afw_function_definition_is_in_dayTimeDuration,
    &afw_function_definition_le_dayTimeDuration,
    &afw_function_definition_lt_dayTimeDuration,
    &afw_function_definition_ne_dayTimeDuration,
    &afw_function_definition_nex_dayTimeDuration,
    &afw_function_definition_one_and_only_dayTimeDuration,
    &afw_function_definition_set_equals_dayTimeDuration,
    &afw_function_definition_subset_dayTimeDuration,
    &afw_function_definition_to_string_dayTimeDuration,
    &afw_function_definition_union_dayTimeDuration,
    &afw_function_definition_bag_dnsName,
    &afw_function_definition_bag_size_dnsName,
    &afw_function_definition_dnsName,
    &afw_function_definition_eq_dnsName,
    &afw_function_definition_eqx_dnsName,
    &afw_function_definition_ge_dnsName,
    &afw_function_definition_gt_dnsName,
    &afw_function_definition_is_dnsName,
    &afw_function_definition_is_in_dnsName,
    &afw_function_definition_le_dnsName,
    &afw_function_definition_lt_dnsName,
    &afw_function_definition_ne_dnsName,
    &afw_function_definition_nex_dnsName,
    &afw_function_definition_one_and_only_dnsName,
    &afw_function_definition_regexp_match_dnsName,
    &afw_function_definition_to_string_dnsName,
    &afw_function_definition_abs_double,
    &afw_function_definition_add_double,
    &afw_function_definition_at_least_one_member_of_double,
    &afw_function_definition_bag_double,
    &afw_function_definition_bag_size_double,
    &afw_function_definition_ceil_double,
    &afw_function_definition_divide_double,
    &afw_function_definition_double,
    &afw_function_definition_eq_double,
    &afw_function_definition_eqx_double,
    &afw_function_definition_floor_double,
    &afw_function_definition_ge_double,
    &afw_function_definition_gt_double,
    &afw_function_definition_intersection_double,
    &afw_function_definition_is_NaN,
    &afw_function_definition_is_double,
    &afw_function_definition_is_finite,
    &afw_function_definition_is_in_double,
    &afw_function_definition_le_double,
    &afw_function_definition_lt_double,
    &afw_function_definition_max_double,
    &afw_function_definition_min_double,
    &afw_function_definition_multiply_double,
    &afw_function_definition_ne_double,
    &afw_function_definition_negative_double,
    &afw_function_definition_nex_double,
    &afw_function_definition_one_and_only_double,
    &afw_function_definition_pow_double,
    &afw_function_definition_round_double,
    &afw_function_definition_set_equals_double,
    &afw_function_definition_subset_double,
    &afw_function_definition_subtract_double,
    &afw_function_definition_to_integer_double,
    &afw_function_definition_to_string_double,
    &afw_function_definition_union_double,
    &afw_function_definition_bag_expression,
    &afw_function_definition_bag_size_expression,
    &afw_function_definition_compile_expression,
    &afw_function_definition_eq_expression,
    &afw_function_definition_eqx_expression,
    &afw_function_definition_evaluate_expression,
    &afw_function_definition_expression,
    &afw_function_definition_ge_expression,
    &afw_function_definition_gt_expression,
    &afw_function_definition_is_expression,
    &afw_function_definition_le_expression,
    &afw_function_definition_lt_expression,
    &afw_function_definition_ne_expression,
    &afw_function_definition_nex_expression,
    &afw_function_definition_to_string_expression,
    &afw_function_definition_bag_function,
    &afw_function_definition_bag_size_function,
    &afw_function_definition_eq_function,
    &afw_function_definition_eqx_function,
    &afw_function_definition_function,
    &afw_function_definition_ge_function,
    &afw_function_definition_gt_function,
    &afw_function_definition_is_function,
    &afw_function_definition_le_function,
    &afw_function_definition_lt_function,
    &afw_function_definition_ne_function,
    &afw_function_definition_nex_function,
    &afw_function_definition_at_least_one_member_of_hexBinary,
    &afw_function_definition_bag_hexBinary,
    &afw_function_definition_bag_size_hexBinary,
    &afw_function_definition_decode_to_string_hexBinary,
    &afw_function_definition_eq_hexBinary,
    &afw_function_definition_eqx_hexBinary,
    &afw_function_definition_ge_hexBinary,
    &afw_function_definition_gt_hexBinary,
    &afw_function_definition_hexBinary,
    &afw_function_definition_intersection_hexBinary,
    &afw_function_definition_is_hexBinary,
    &afw_function_definition_is_in_hexBinary,
    &afw_function_definition_le_hexBinary,
    &afw_function_definition_lt_hexBinary,
    &afw_function_definition_ne_hexBinary,
    &afw_function_definition_nex_hexBinary,
    &afw_function_definition_one_and_only_hexBinary,
    &afw_function_definition_set_equals_hexBinary,
    &afw_function_definition_subset_hexBinary,
    &afw_function_definition_to_string_hexBinary,
    &afw_function_definition_union_hexBinary,
    &afw_function_definition_all_of,
    &afw_function_definition_all_of_all,
    &afw_function_definition_all_of_any,
    &afw_function_definition_any_of,
    &afw_function_definition_any_of_all,
    &afw_function_definition_any_of_any,
    &afw_function_definition_filter,
    &afw_function_definition_find,
    &afw_function_definition_map,
    &afw_function_definition_reduce,
    &afw_function_definition_sort,
    &afw_function_definition_bag_hybrid,
    &afw_function_definition_bag_size_hybrid,
    &afw_function_definition_compile_hybrid,
    &afw_function_definition_eq_hybrid,
    &afw_function_definition_eqx_hybrid,
    &afw_function_definition_evaluate_hybrid,
    &afw_function_definition_ge_hybrid,
    &afw_function_definition_gt_hybrid,
    &afw_function_definition_hybrid,
    &afw_function_definition_is_hybrid,
    &afw_function_definition_le_hybrid,
    &afw_function_definition_lt_hybrid,
    &afw_function_definition_ne_hybrid,
    &afw_function_definition_nex_hybrid,
    &afw_function_definition_to_string_hybrid,
    &afw_function_definition_bag_ia5String,
    &afw_function_definition_bag_size_ia5String,
    &afw_function_definition_eq_ia5String,
    &afw_function_definition_eqx_ia5String,
    &afw_function_definition_ge_ia5String,
    &afw_function_definition_gt_ia5String,
    &afw_function_definition_ia5String,
    &afw_function_definition_is_ia5String,
    &afw_function_definition_le_ia5String,
    &afw_function_definition_lt_ia5String,
    &afw_function_definition_ne_ia5String,
    &afw_function_definition_nex_ia5String,
    &afw_function_definition_to_string_ia5String,
    &afw_function_definition_index_create,
    &afw_function_definition_index_list,
    &afw_function_definition_index_remove,
    &afw_function_definition_abs_integer,
    &afw_function_definition_add_integer,
    &afw_function_definition_at_least_one_member_of_integer,
    &afw_function_definition_bag_integer,
    &afw_function_definition_bag_size_integer,
    &afw_function_definition_divide_integer,
    &afw_function_definition_eq_integer,
    &afw_function_definition_eqx_integer,
    &afw_function_definition_ge_integer,
    &afw_function_definition_gt_integer,
    &afw_function_definition_integer,
    &afw_function_definition_intersection_integer,
    &afw_function_definition_is_in_integer,
    &afw_function_definition_is_integer,
    &afw_function_definition_le_integer,
    &afw_function_definition_lt_integer,
    &afw_function_definition_max_integer,
    &afw_function_definition_min_integer,
    &afw_function_definition_mod_integer,
    &afw_function_definition_multiply_integer,
    &afw_function_definition_ne_integer,
    &afw_function_definition_negative_integer,
    &afw_function_definition_nex_integer,
    &afw_function_definition_one_and_only_integer,
    &afw_function_definition_set_equals_integer,
    &afw_function_definition_subset_integer,
    &afw_function_definition_subtract_integer,
    &afw_function_definition_to_double_integer,
    &afw_function_definition_to_string_integer,
    &afw_function_definition_union_integer,
    &afw_function_definition_bag_ipAddress,
    &afw_function_definition_bag_size_ipAddress,
    &afw_function_definition_eq_ipAddress,
    &afw_function_definition_eqx_ipAddress,
    &afw_function_definition_ge_ipAddress,
    &afw_function_definition_gt_ipAddress,
    &afw_function_definition_ipAddress,
    &afw_function_definition_is_in_ipAddress,
    &afw_function_definition_is_ipAddress,
    &afw_function_definition_le_ipAddress,
    &afw_function_definition_lt_ipAddress,
    &afw_function_definition_ne_ipAddress,
    &afw_function_definition_nex_ipAddress,
    &afw_function_definition_one_and_only_ipAddress,
    &afw_function_definition_regexp_match_ipAddress,
    &afw_function_definition_to_string_ipAddress,
    &afw_function_definition_journal_advance_cursor_for_consumer,
    &afw_function_definition_journal_get_by_cursor,
    &afw_function_definition_journal_get_first,
    &afw_function_definition_journal_get_next_after_cursor,
    &afw_function_definition_journal_get_next_for_consumer,
    &afw_function_definition_journal_get_next_for_consumer_after_cursor,
    &afw_function_definition_journal_mark_consumed,
    &afw_function_definition_add_entries,
    &afw_function_definition_bag_list,
    &afw_function_definition_bag_size_list,
    &afw_function_definition_clone_list,
    &afw_function_definition_eq_list,
    &afw_function_definition_eqx_list,
    &afw_function_definition_ge_list,
    &afw_function_definition_gt_list,
    &afw_function_definition_includes_list,
    &afw_function_definition_is_list,
    &afw_function_definition_join,
    &afw_function_definition_le_list,
    &afw_function_definition_length_list,
    &afw_function_definition_list,
    &afw_function_definition_lt_list,
    &afw_function_definition_ne_list,
    &afw_function_definition_nex_list,
    &afw_function_definition_reverse,
    &afw_function_definition_slice,
    &afw_function_definition_to_string_list,
    &afw_function_definition_and,
    &afw_function_definition_n_of,
    &afw_function_definition_not,
    &afw_function_definition_or,
    &afw_function_definition_annotate,
    &afw_function_definition_compare_uri,
    &afw_function_definition_debug,
    &afw_function_definition_execution_start_time_local,
    &afw_function_definition_execution_start_time_utc,
    &afw_function_definition_generate_uuid,
    &afw_function_definition_is_defined,
    &afw_function_definition_is_nullish,
    &afw_function_definition_log,
    &afw_function_definition_now_local,
    &afw_function_definition_now_utc,
    &afw_function_definition_nullish_coalescing,
    &afw_function_definition_optional_chaining,
    &afw_function_definition_parse_uri,
    &afw_function_definition_perform,
    &afw_function_definition_trace,
    &afw_function_definition_variable_exists,
    &afw_function_definition_variable_get,
    &afw_function_definition_variable_is_not_null,
    &afw_function_definition_model_default_add_object_action,
    &afw_function_definition_model_default_delete_object_action,
    &afw_function_definition_model_default_modify_object_action,
    &afw_function_definition_model_default_replace_object_action,
    &afw_function_definition_model_mapBackObject_signature,
    &afw_function_definition_model_mapObject_signature,
    &afw_function_definition_model_returnObject_signature,
    &afw_function_definition_bag_null,
    &afw_function_definition_bag_size_null,
    &afw_function_definition_is_null,
    &afw_function_definition_null,
    &afw_function_definition_to_string_null,
    &afw_function_definition_bag_objectId,
    &afw_function_definition_bag_size_objectId,
    &afw_function_definition_eq_objectId,
    &afw_function_definition_eqx_objectId,
    &afw_function_definition_ge_objectId,
    &afw_function_definition_gt_objectId,
    &afw_function_definition_is_objectId,
    &afw_function_definition_le_objectId,
    &afw_function_definition_lt_objectId,
    &afw_function_definition_ne_objectId,
    &afw_function_definition_nex_objectId,
    &afw_function_definition_objectId,
    &afw_function_definition_to_string_objectId,
    &afw_function_definition_bag_objectPath,
    &afw_function_definition_bag_size_objectPath,
    &afw_function_definition_eq_objectPath,
    &afw_function_definition_eqx_objectPath,
    &afw_function_definition_ge_objectPath,
    &afw_function_definition_gt_objectPath,
    &afw_function_definition_is_objectPath,
    &afw_function_definition_le_objectPath,
    &afw_function_definition_lt_objectPath,
    &afw_function_definition_ne_objectPath,
    &afw_function_definition_nex_objectPath,
    &afw_function_definition_objectPath,
    &afw_function_definition_to_string_objectPath,
    &afw_function_definition_add_properties,
    &afw_function_definition_apply_object_options,
    &afw_function_definition_bag_object,
    &afw_function_definition_bag_size_object,
    &afw_function_definition_clone_object,
    &afw_function_definition_eq_object,
    &afw_function_definition_eqx_object,
    &afw_function_definition_ge_object,
    &afw_function_definition_gt_object,
    &afw_function_definition_is_object,
    &afw_function_definition_le_object,
    &afw_function_definition_local_object_meta_set_ids,
    &afw_function_definition_lt_object,
    &afw_function_definition_ne_object,
    &afw_function_definition_nex_object,
    &afw_function_definition_object,
    &afw_function_definition_property_exists,
    &afw_function_definition_property_get,
    &afw_function_definition_property_is_not_null,
    &afw_function_definition_to_string_object,
    &afw_function_definition_bag_password,
    &afw_function_definition_bag_size_password,
    &afw_function_definition_eq_password,
    &afw_function_definition_eqx_password,
    &afw_function_definition_ge_password,
    &afw_function_definition_gt_password,
    &afw_function_definition_is_password,
    &afw_function_definition_le_password,
    &afw_function_definition_lt_password,
    &afw_function_definition_ne_password,
    &afw_function_definition_nex_password,
    &afw_function_definition_password,
    &afw_function_definition_to_string_password,
    &afw_function_definition_abs,
    &afw_function_definition_add,
    &afw_function_definition_add_dayTimeDuration,
    &afw_function_definition_add_yearMonthDuration,
    &afw_function_definition_at_least_one_member_of,
    &afw_function_definition_bag,
    &afw_function_definition_bag_size,
    &afw_function_definition_ceil,
    &afw_function_definition_clone,
    &afw_function_definition_compile,
    &afw_function_definition_decode_to_string,
    &afw_function_definition_divide,
    &afw_function_definition_encode_as_base64Binary,
    &afw_function_definition_encode_as_hexBinary,
    &afw_function_definition_ends_with,
    &afw_function_definition_eq,
    &afw_function_definition_eq_ignore_case,
    &afw_function_definition_eqx,
    &afw_function_definition_evaluate,
    &afw_function_definition_floor,
    &afw_function_definition_ge,
    &afw_function_definition_gt,
    &afw_function_definition_in_range,
    &afw_function_definition_includes,
    &afw_function_definition_index_of,
    &afw_function_definition_intersection,
    &afw_function_definition_is,
    &afw_function_definition_is_in,
    &afw_function_definition_last_index_of,
    &afw_function_definition_le,
    &afw_function_definition_length,
    &afw_function_definition_lt,
    &afw_function_definition_match,
    &afw_function_definition_max,
    &afw_function_definition_min,
    &afw_function_definition_mod,
    &afw_function_definition_multiply,
    &afw_function_definition_ne,
    &afw_function_definition_negative,
    &afw_function_definition_nex,
    &afw_function_definition_normalize_space,
    &afw_function_definition_normalize_to_lower_case,
    &afw_function_definition_one_and_only,
    &afw_function_definition_pow,
    &afw_function_definition_regexp_index_of,
    &afw_function_definition_regexp_match,
    &afw_function_definition_regexp_replace,
    &afw_function_definition_repeat,
    &afw_function_definition_replace,
    &afw_function_definition_round,
    &afw_function_definition_set_equals,
    &afw_function_definition_split,
    &afw_function_definition_starts_with,
    &afw_function_definition_subset,
    &afw_function_definition_substring,
    &afw_function_definition_subtract,
    &afw_function_definition_subtract_dayTimeDuration,
    &afw_function_definition_subtract_yearMonthDuration,
    &afw_function_definition_to_anyURI,
    &afw_function_definition_to_boolean,
    &afw_function_definition_to_date,
    &afw_function_definition_to_dateTime,
    &afw_function_definition_to_dayTimeDuration,
    &afw_function_definition_to_dnsName,
    &afw_function_definition_to_double,
    &afw_function_definition_to_integer,
    &afw_function_definition_to_ipAddress,
    &afw_function_definition_to_rfc822Name,
    &afw_function_definition_to_string,
    &afw_function_definition_to_time,
    &afw_function_definition_to_x500Name,
    &afw_function_definition_to_yearMonthDuration,
    &afw_function_definition_union,
    &afw_function_definition_url_encode,
    &afw_function_definition_random_base64Binary,
    &afw_function_definition_random_digits,
    &afw_function_definition_random_hexBinary,
    &afw_function_definition_random_integer,
    &afw_function_definition_random_number,
    &afw_function_definition_compile_regexp,
    &afw_function_definition_eq_regexp,
    &afw_function_definition_eqx_regexp,
    &afw_function_definition_ge_regexp,
    &afw_function_definition_gt_regexp,
    &afw_function_definition_le_regexp,
    &afw_function_definition_lt_regexp,
    &afw_function_definition_ne_regexp,
    &afw_function_definition_nex_regexp,
    &afw_function_definition_regexp,
    &afw_function_definition_at_least_one_member_of_rfc822Name,
    &afw_function_definition_bag_rfc822Name,
    &afw_function_definition_bag_size_rfc822Name,
    &afw_function_definition_eq_rfc822Name,
    &afw_function_definition_eqx_rfc822Name,
    &afw_function_definition_ge_rfc822Name,
    &afw_function_definition_gt_rfc822Name,
    &afw_function_definition_intersection_rfc822Name,
    &afw_function_definition_is_in_rfc822Name,
    &afw_function_definition_is_rfc822Name,
    &afw_function_definition_le_rfc822Name,
    &afw_function_definition_lt_rfc822Name,
    &afw_function_definition_match_rfc822Name,
    &afw_function_definition_ne_rfc822Name,
    &afw_function_definition_nex_rfc822Name,
    &afw_function_definition_one_and_only_rfc822Name,
    &afw_function_definition_regexp_match_rfc822Name,
    &afw_function_definition_rfc822Name,
    &afw_function_definition_set_equals_rfc822Name,
    &afw_function_definition_subset_rfc822Name,
    &afw_function_definition_to_string_rfc822Name,
    &afw_function_definition_union_rfc822Name,
    &afw_function_definition_assign,
    &afw_function_definition_bag_script,
    &afw_function_definition_bag_size_script,
    &afw_function_definition_break,
    &afw_function_definition_compile_script,
    &afw_function_definition_const,
    &afw_function_definition_continue,
    &afw_function_definition_do_while,
    &afw_function_definition_eq_script,
    &afw_function_definition_eqx_script,
    &afw_function_definition_evaluate_script,
    &afw_function_definition_for,
    &afw_function_definition_foreach,
    &afw_function_definition_ge_script,
    &afw_function_definition_gt_script,
    &afw_function_definition_if,
    &afw_function_definition_is_script,
    &afw_function_definition_le_script,
    &afw_function_definition_loc,
    &afw_function_definition_lt_script,
    &afw_function_definition_ne_script,
    &afw_function_definition_nex_script,
    &afw_function_definition_return,
    &afw_function_definition_script,
    &afw_function_definition_while,
    &afw_function_definition_close,
    &afw_function_definition_flush,
    &afw_function_definition_get_stream_error,
    &afw_function_definition_open_file,
    &afw_function_definition_open_response,
    &afw_function_definition_open_uri,
    &afw_function_definition_print,
    &afw_function_definition_println,
    &afw_function_definition_read,
    &afw_function_definition_read_to_base64Binary,
    &afw_function_definition_read_to_hexBinary,
    &afw_function_definition_readln,
    &afw_function_definition_stream,
    &afw_function_definition_write,
    &afw_function_definition_write_internal,
    &afw_function_definition_writeln,
    &afw_function_definition_add_string,
    &afw_function_definition_at_least_one_member_of_string,
    &afw_function_definition_bag_size_string,
    &afw_function_definition_bag_string,
    &afw_function_definition_concat,
    &afw_function_definition_encode_as_base64Binary_string,
    &afw_function_definition_encode_as_hexBinary_string,
    &afw_function_definition_ends_with_string,
    &afw_function_definition_eq_ignore_case_string,
    &afw_function_definition_eq_string,
    &afw_function_definition_eqx_string,
    &afw_function_definition_ge_string,
    &afw_function_definition_gt_string,
    &afw_function_definition_includes_string,
    &afw_function_definition_index_of_string,
    &afw_function_definition_intersection_string,
    &afw_function_definition_is_in_string,
    &afw_function_definition_is_string,
    &afw_function_definition_last_index_of_string,
    &afw_function_definition_le_string,
    &afw_function_definition_length_string,
    &afw_function_definition_lt_string,
    &afw_function_definition_max_string,
    &afw_function_definition_min_string,
    &afw_function_definition_ne_string,
    &afw_function_definition_nex_string,
    &afw_function_definition_normalize_space_string,
    &afw_function_definition_normalize_to_lower_case_string,
    &afw_function_definition_one_and_only_string,
    &afw_function_definition_regexp_index_of_string,
    &afw_function_definition_regexp_match_string,
    &afw_function_definition_regexp_replace_string,
    &afw_function_definition_repeat_string,
    &afw_function_definition_replace_string,
    &afw_function_definition_set_equals_string,
    &afw_function_definition_split_string,
    &afw_function_definition_starts_with_string,
    &afw_function_definition_string,
    &afw_function_definition_subset_string,
    &afw_function_definition_substring_string,
    &afw_function_definition_to_anyURI_string,
    &afw_function_definition_to_boolean_string,
    &afw_function_definition_to_dateTime_string,
    &afw_function_definition_to_date_string,
    &afw_function_definition_to_dayTimeDuration_string,
    &afw_function_definition_to_dnsName_string,
    &afw_function_definition_to_double_string,
    &afw_function_definition_to_integer_string,
    &afw_function_definition_to_ipAddress_string,
    &afw_function_definition_to_rfc822Name_string,
    &afw_function_definition_to_string_string,
    &afw_function_definition_to_time_string,
    &afw_function_definition_to_x500Name_string,
    &afw_function_definition_to_yearMonthDuration_string,
    &afw_function_definition_union_string,
    &afw_function_definition_url_decode,
    &afw_function_definition_url_encode_string,
    &afw_function_definition_bag_size_template,
    &afw_function_definition_bag_template,
    &afw_function_definition_compile_template,
    &afw_function_definition_eq_template,
    &afw_function_definition_eqx_template,
    &afw_function_definition_evaluate_template,
    &afw_function_definition_ge_template,
    &afw_function_definition_gt_template,
    &afw_function_definition_is_template,
    &afw_function_definition_le_template,
    &afw_function_definition_lt_template,
    &afw_function_definition_ne_template,
    &afw_function_definition_nex_template,
    &afw_function_definition_template,
    &afw_function_definition_to_string_template,
    &afw_function_definition_at_least_one_member_of_time,
    &afw_function_definition_bag_size_time,
    &afw_function_definition_bag_time,
    &afw_function_definition_eq_time,
    &afw_function_definition_eqx_time,
    &afw_function_definition_ge_time,
    &afw_function_definition_gt_time,
    &afw_function_definition_in_range_time,
    &afw_function_definition_intersection_time,
    &afw_function_definition_is_in_time,
    &afw_function_definition_is_time,
    &afw_function_definition_le_time,
    &afw_function_definition_lt_time,
    &afw_function_definition_max_time,
    &afw_function_definition_min_time,
    &afw_function_definition_ne_time,
    &afw_function_definition_nex_time,
    &afw_function_definition_one_and_only_time,
    &afw_function_definition_set_equals_time,
    &afw_function_definition_subset_time,
    &afw_function_definition_time,
    &afw_function_definition_to_string_time,
    &afw_function_definition_union_time,
    &afw_function_definition_is_unevaluated,
    &afw_function_definition_meta,
    &afw_function_definition_metas,
    &afw_function_definition_at_least_one_member_of_x500Name,
    &afw_function_definition_bag_size_x500Name,
    &afw_function_definition_bag_x500Name,
    &afw_function_definition_eq_x500Name,
    &afw_function_definition_eqx_x500Name,
    &afw_function_definition_ge_x500Name,
    &afw_function_definition_gt_x500Name,
    &afw_function_definition_intersection_x500Name,
    &afw_function_definition_is_in_x500Name,
    &afw_function_definition_is_x500Name,
    &afw_function_definition_le_x500Name,
    &afw_function_definition_lt_x500Name,
    &afw_function_definition_match_x500Name,
    &afw_function_definition_ne_x500Name,
    &afw_function_definition_nex_x500Name,
    &afw_function_definition_one_and_only_x500Name,
    &afw_function_definition_regexp_match_x500Name,
    &afw_function_definition_set_equals_x500Name,
    &afw_function_definition_subset_x500Name,
    &afw_function_definition_to_string_x500Name,
    &afw_function_definition_union_x500Name,
    &afw_function_definition_x500Name,
    &afw_function_definition_bag_size_xpathExpression,
    &afw_function_definition_bag_xpathExpression,
    &afw_function_definition_compile_xpathExpression,
    &afw_function_definition_eq_xpathExpression,
    &afw_function_definition_eqx_xpathExpression,
    &afw_function_definition_evaluate_xpathExpression,
    &afw_function_definition_ge_xpathExpression,
    &afw_function_definition_gt_xpathExpression,
    &afw_function_definition_is_xpathExpression,
    &afw_function_definition_le_xpathExpression,
    &afw_function_definition_lt_xpathExpression,
    &afw_function_definition_ne_xpathExpression,
    &afw_function_definition_nex_xpathExpression,
    &afw_function_definition_to_string_xpathExpression,
    &afw_function_definition_xpathExpression,
    &afw_function_definition_xpath_node_count,
    &afw_function_definition_xpath_node_eq,
    &afw_function_definition_xpath_node_match,
    &afw_function_definition_at_least_one_member_of_yearMonthDuration,
    &afw_function_definition_bag_size_yearMonthDuration,
    &afw_function_definition_bag_yearMonthDuration,
    &afw_function_definition_eq_yearMonthDuration,
    &afw_function_definition_eqx_yearMonthDuration,
    &afw_function_definition_ge_yearMonthDuration,
    &afw_function_definition_gt_yearMonthDuration,
    &afw_function_definition_intersection_yearMonthDuration,
    &afw_function_definition_is_in_yearMonthDuration,
    &afw_function_definition_is_yearMonthDuration,
    &afw_function_definition_le_yearMonthDuration,
    &afw_function_definition_lt_yearMonthDuration,
    &afw_function_definition_ne_yearMonthDuration,
    &afw_function_definition_nex_yearMonthDuration,
    &afw_function_definition_one_and_only_yearMonthDuration,
    &afw_function_definition_set_equals_yearMonthDuration,
    &afw_function_definition_subset_yearMonthDuration,
    &afw_function_definition_to_string_yearMonthDuration,
    &afw_function_definition_union_yearMonthDuration,
    &afw_function_definition_yearMonthDuration,
    NULL
};

/* Get array of pointers to afw_function bindings. */
AFW_DEFINE(const afw_value_function_definition_t **)
afw_function_bindings_get()
{
    return &impl_function_bindings[0];
}
