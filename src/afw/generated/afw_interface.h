// See the 'COPYING' file in the project root for licensing information.
/*
 * Interface afw_interface Header
 *
 * Copyright (c) 2010-2023 Clemson University
 *
 */

/*  ----------------------------- N O T E -------------------------------------
 *
 * This file is generated by "afwdev generate afw".
 *
 * Do not change this file directly or the changes will be lost the next time
 * this file is regenerated.
 *
 * -------------------------------------------------------------------------*/


#ifndef __AFW_INTERFACE_H__
#define __AFW_INTERFACE_H__


/**
 * @file afw_interface.h
 * @brief Interfaceafw_interface header.
 */

#include "afw_interface_common.h"
#include "afw_interface_opaques.h"
#include "afw_common_opaques.h"

AFW_BEGIN_DECLARES

/**
 * @addtogroup afw_interface Interfaces
 *
 * @{
 */

/**
 * @addtogroup afw_extension_interface afw_extension
 *
 * 
 * Interface returned from afw_extension_initialize() of an
 * Adaptive Framework environment extension module. Additional
 * information about an extension is found in object
 * `/afw/_AdaptiveManifest_/<extension_id>`.
 * 
 *
 * @{
 */


/** @brief Interface afw_extension public struct. */
struct afw_extension_s {
    const afw_extension_inf_t *inf;
    afw_utf8_t extension_id;
    afw_utf8_t extension_version;
    afw_utf8_t afw_compiled_version;
    unsigned int afw_compiled_version_hex;
};

/** @brief define for interface afw_extension name. */
#define AFW_EXTENSION_INTERFACE_NAME \
"afw_extension"

/** @sa afw_extension_initialize() */
typedef const afw_extension_t *
(*afw_extension_initialize_t)(
    const afw_extension_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_extension_release() */
typedef void
(*afw_extension_release_t)(
    const afw_extension_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_extension_inf_s struct. */
struct afw_extension_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_extension_initialize_t initialize;
    afw_extension_release_t release;
};

/**
 * @brief Call method initialize of interface afw_extension
 * @param instance This extension's instance.
 * @param properties This is the properties supplied to
 *     afw_environment_load_extension() or NULL.
 * @param p This is the pool to use for extension resources.
 * @param xctx This is the caller's xctx.
 */
#define afw_extension_initialize( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->initialize( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method release of interface afw_extension
 * @param instance Pointer to this adaptor instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_extension_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_factory_interface afw_adaptor_factory
 *
 * Factory to create an instance of an afw_adaptor.
 *
 * @{
 */


/** @brief Interface afw_adaptor_factory public struct. */
struct afw_adaptor_factory_s {
    const afw_adaptor_factory_inf_t *inf;
    afw_utf8_t adaptor_type;
    const afw_utf8_t * description;
};

/** @brief define for interface afw_adaptor_factory name. */
#define AFW_ADAPTOR_FACTORY_INTERFACE_NAME \
"afw_adaptor_factory"

/** @sa afw_adaptor_factory_create_adaptor_cede_p() */
typedef const afw_adaptor_t *
(*afw_adaptor_factory_create_adaptor_cede_p_t)(
    const afw_adaptor_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_factory_inf_s struct. */
struct afw_adaptor_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_factory_create_adaptor_cede_p_t create_adaptor_cede_p;
};

/**
 * @brief Call method create_adaptor_cede_p of interface afw_adaptor_factory
 * @param instance Pointer to this adaptor instance.
 * @param properties Configuration parameters for the particular type of
 *     adaptor. This          will become the properties object for adaptor.
 * @param p The pool that will be used for adaptor resources.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_factory_create_adaptor_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_adaptor_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_interface afw_adaptor
 *
 * 
 * Adaptor interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_adaptor public struct. */
struct afw_adaptor_s {
    const afw_adaptor_inf_t *inf;
    const afw_pool_t * p;
    afw_utf8_t adaptor_id;
    const afw_utf8_t * adaptor_type_id;
    const afw_utf8_t * service_id;
    const afw_object_t * properties;
    const afw_utf8_t * source_location;
    const afw_utf8_t * trace_flag_id;
    afw_size_t trace_flag_index;
    const afw_utf8_t * detail_flag_id;
    afw_size_t detail_flag_index;
    const afw_adaptor_impl_t * impl;
};

/** @brief define for interface afw_adaptor name. */
#define AFW_ADAPTOR_INTERFACE_NAME \
"afw_adaptor"

/** @sa afw_adaptor_destroy() */
typedef void
(*afw_adaptor_destroy_t)(
    const afw_adaptor_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_create_adaptor_session() */
typedef const afw_adaptor_session_t *
(*afw_adaptor_create_adaptor_session_t)(
    const afw_adaptor_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_get_additional_metrics() */
typedef const afw_object_t *
(*afw_adaptor_get_additional_metrics_t)(
    const afw_adaptor_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_inf_s struct. */
struct afw_adaptor_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_destroy_t destroy;
    afw_adaptor_create_adaptor_session_t create_adaptor_session;
    afw_adaptor_get_additional_metrics_t get_additional_metrics;
};

/**
 * @brief Call method destroy of interface afw_adaptor
 * @param instance Pointer to this adaptor instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method create_adaptor_session of interface afw_adaptor
 * @param instance Pointer to this adaptor instance.
 * @param xctx The execution context (xctx) of caller.
 */
#define afw_adaptor_create_adaptor_session( \
    instance, \
    xctx \
) \
(instance)->inf->create_adaptor_session( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_additional_metrics of interface afw_adaptor
 * @param instance Pointer to this adaptor instance.
 * @param p Pool used for results.
 * @param xctx The execution context (xctx) of caller.
 */
#define afw_adaptor_get_additional_metrics( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_additional_metrics( \
    (instance), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_object_type_cache_interface afw_adaptor_object_type_cache
 *
 * 
 * Adaptor object type cache interface. This interface is used by
 * afw_adaptor_get_object_type().
 * 
 *
 * @{
 */


/** @brief Interface afw_adaptor_object_type_cache public struct. */
struct afw_adaptor_object_type_cache_s {
    const afw_adaptor_object_type_cache_inf_t *inf;
    const afw_adaptor_session_t * session;
    afw_boolean_t all_object_types_immutable;
};

/** @brief define for interface afw_adaptor_object_type_cache name. */
#define AFW_ADAPTOR_OBJECT_TYPE_CACHE_INTERFACE_NAME \
"afw_adaptor_object_type_cache"

/** @sa afw_adaptor_object_type_cache_get() */
typedef const afw_object_type_t *
(*afw_adaptor_object_type_cache_get_t)(
    const afw_adaptor_object_type_cache_t * instance,
    const afw_utf8_t * object_type_id,
    afw_boolean_t * final_result,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_object_type_cache_set() */
typedef void
(*afw_adaptor_object_type_cache_set_t)(
    const afw_adaptor_object_type_cache_t * instance,
    const afw_object_type_t * object_type,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_object_type_cache_inf_s struct. */
struct afw_adaptor_object_type_cache_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_object_type_cache_get_t get;
    afw_adaptor_object_type_cache_set_t set;
};

/**
 * @brief Call method get of interface afw_adaptor_object_type_cache
 * @param instance Pointer to this adaptor object type cache instance.
 * @param object_type_id Object type id of object type to get from cache.
 * @param final_result Pointer to place to return flag.          If true,
 *     afw_adaptor_get_object_type() will always return the          result of
 *     calling the get() method.          If false and get() returns NULL,
 *     afw_adaptor_get_object_type()          will try to create and return a
 *     new object_type and return.          The set() method will be called if
 *     all_object_types_immutable is          true.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_object_type_cache_get( \
    instance, \
    object_type_id, \
    final_result, \
    xctx \
) \
(instance)->inf->get( \
    (instance), \
    (object_type_id), \
    (final_result), \
    (xctx) \
)

/**
 * @brief Call method set of interface afw_adaptor_object_type_cache
 * @param instance Pointer to this adaptor object type cache instance.
 * @param object_type Object type to set in cache.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_object_type_cache_set( \
    instance, \
    object_type, \
    xctx \
) \
(instance)->inf->set( \
    (instance), \
    (object_type), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_session_interface afw_adaptor_session
 *
 * 
 * Adaptor session interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_adaptor_session public struct. */
struct afw_adaptor_session_s {
    const afw_adaptor_session_inf_t *inf;
    const afw_adaptor_t * adaptor;
    const afw_pool_t * p;
};

/** @brief define for interface afw_adaptor_session name. */
#define AFW_ADAPTOR_SESSION_INTERFACE_NAME \
"afw_adaptor_session"

/** @sa afw_adaptor_session_destroy() */
typedef void
(*afw_adaptor_session_destroy_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_retrieve_objects() */
typedef void
(*afw_adaptor_session_retrieve_objects_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_query_criteria_t * criteria,
    void * context,
    afw_object_cb_t callback,
    const afw_object_t * adaptor_type_specific,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_object() */
typedef void
(*afw_adaptor_session_get_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    void * context,
    afw_object_cb_t callback,
    const afw_object_t * adaptor_type_specific,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_add_object() */
typedef const afw_utf8_t *
(*afw_adaptor_session_add_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * suggested_object_id,
    const afw_object_t * object,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_modify_object() */
typedef void
(*afw_adaptor_session_modify_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_adaptor_modify_entry_t * const * entry,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_replace_object() */
typedef void
(*afw_adaptor_session_replace_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_object_t * replacement_object,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_delete_object() */
typedef void
(*afw_adaptor_session_delete_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_begin_transaction() */
typedef const afw_adaptor_transaction_t *
(*afw_adaptor_session_begin_transaction_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_journal_interface() */
typedef const afw_adaptor_journal_t *
(*afw_adaptor_session_get_journal_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_key_value_interface() */
typedef const afw_adaptor_key_value_t *
(*afw_adaptor_session_get_key_value_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_index_interface() */
typedef const afw_adaptor_impl_index_t *
(*afw_adaptor_session_get_index_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_object_type_cache_interface() */
typedef const afw_adaptor_object_type_cache_t *
(*afw_adaptor_session_get_object_type_cache_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_session_inf_s struct. */
struct afw_adaptor_session_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_session_destroy_t destroy;
    afw_adaptor_session_retrieve_objects_t retrieve_objects;
    afw_adaptor_session_get_object_t get_object;
    afw_adaptor_session_add_object_t add_object;
    afw_adaptor_session_modify_object_t modify_object;
    afw_adaptor_session_replace_object_t replace_object;
    afw_adaptor_session_delete_object_t delete_object;
    afw_adaptor_session_begin_transaction_t begin_transaction;
    afw_adaptor_session_get_journal_interface_t get_journal_interface;
    afw_adaptor_session_get_key_value_interface_t get_key_value_interface;
    afw_adaptor_session_get_index_interface_t get_index_interface;
    afw_adaptor_session_get_object_type_cache_interface_t get_object_type_cache_interface;
};

/**
 * @brief Call method destroy of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.          Make sure
 *     to call commit or changes will be lost.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method retrieve_objects of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param object_type_id The object type of objects to be retrieved.
 * @param criteria Query criteria. Use member filter or normalized, whichever
 *     is easier,          to filter the objects retrieved. See
 *     afw_query_criteria.h for more          information.          The other
 *     members should be ignored.
 * @param context Pointer passed to callback routine.
 * @param callback Callback function will be called each time an object is
 *     retrieved and once          with a NULL object pointer when finished.   
 *           The callback function will call afw_object_release() on the object
 *              when finished with it. If you want to have the object last past
 *     the          callback, call afw_object_add_reference() on the object
 *     before calling          the callback.
 * @param adaptor_type_specific This is an adaptor type specific object
 *     parameter or NULL.                    If the adaptor type supports this
 *     parameter, the object type of the          object is available via the
 *     afw adaptor with an object type id of:         
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects         
 *     where ${adaptorType} is the adaptor type id.
 * @param p Pool used for objects passed to callback.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_retrieve_objects( \
    instance, \
    impl_request, \
    object_type_id, \
    criteria, \
    context, \
    callback, \
    adaptor_type_specific, \
    p, \
    xctx \
) \
(instance)->inf->retrieve_objects( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (criteria), \
    (context), \
    (callback), \
    (adaptor_type_specific), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_object of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param object_type_id Object type of object to get.
 * @param object_id Object id of object to get.
 * @param context Pointer passed to callback routine.
 * @param callback Callback function will be called once with either the object
 *     retrieved          or a NULL object pointer if not found.          The
 *     callback function will call afw_object_release() on the object         
 *     when finished with it. If you want to have the object last past the     
 *         callback, call afw_object_add_reference() on the object before
 *     calling          the callback.
 * @param adaptor_type_specific This is an adaptor type specific object
 *     parameter or NULL.          If the adaptor type supports this parameter,
 *     the object type of the          object is available via the afw adaptor
 *     with an object type id of:         
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_get_object          where
 *     ${adaptorType} is the adaptor type id.
 * @param p Pool used for object passed to callback.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_get_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    context, \
    callback, \
    adaptor_type_specific, \
    p, \
    xctx \
) \
(instance)->inf->get_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (context), \
    (callback), \
    (adaptor_type_specific), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method add_object of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param object_type_id Object type of object to add.
 * @param suggested_object_id The suggested object id of the added object. This
 *     object id must be          unique within the object type. If NULL or at
 *     the adaptor's option,          the adaptor will generate a unique object
 *     id.
 * @param object Object to add.          Unless documented otherwise by
 *     non-default options, this object only needs          to exist for the
 *     life of the add_object() call. Some adaptors have options          that
 *     require longer lifetimes for these objects. For example, a memory       
 *       adaptor can be created with the option to not clone an object when
 *     added          to memory store. In this case, it's the caller
 *     responsibility to create          the object in a pool that has the
 *     minimal lifetime of the memory adaptor          itself. For instance,
 *     the adaptor's pool can be used during object create.          The memory
 *     adaptor then uses the object's pool's add_reference() and release()     
 *         methods to manage the lifetime of the object.
 * @param adaptor_type_specific This is an adaptor type specific object
 *     parameter or NULL.          If the adaptor type supports this parameter,
 *     the object type of the          object is available via the afw adaptor
 *     with an object type id of:         
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_add_object          where
 *     ${adaptorType} is the adaptor type id.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_add_object( \
    instance, \
    impl_request, \
    object_type_id, \
    suggested_object_id, \
    object, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->add_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (suggested_object_id), \
    (object), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method modify_object of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param object_type_id Object type of object to modify.
 * @param object_id Object id of object to modify.
 * @param entry NULL terminated array of pointers to adaptor modify entries.
 * @param adaptor_type_specific This is an adaptor type specific object
 *     parameter or NULL.          If the adaptor type supports this parameter,
 *     the object type of the          object is available via the afw adaptor
 *     with an object type id of:         
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object          where
 *     ${adaptorType} is the adaptor type id.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_modify_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    entry, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->modify_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (entry), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method replace_object of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param object_type_id Object type of object to update.
 * @param object_id Object id of object to update.
 * @param replacement_object Replacement object.
 * @param adaptor_type_specific This is an adaptor type specific object
 *     parameter or NULL.          If the adaptor type supports this parameter,
 *     the object type of the          object is available via the afw adaptor
 *     with an object type id of:         
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_replace_object         
 *     where ${adaptorType} is the adaptor type id.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_replace_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    replacement_object, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->replace_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (replacement_object), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method delete_object of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param object_type_id Object type of object to delete.
 * @param object_id Object id of object to delete.
 * @param adaptor_type_specific This is an adaptor type specific object
 *     parameter or NULL.          If the adaptor type supports this parameter,
 *     the object type of the          object is available via the afw adaptor
 *     with an object type id of:         
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_delete_object          where
 *     ${adaptorType} is the adaptor type id.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_delete_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->delete_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method begin_transaction of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_begin_transaction( \
    instance, \
    xctx \
) \
(instance)->inf->begin_transaction( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_journal_interface of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_get_journal_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_journal_interface( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_key_value_interface of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_get_key_value_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_key_value_interface( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_index_interface of interface afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_get_index_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_index_interface( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_object_type_cache_interface of interface
 *     afw_adaptor_session
 * @param instance Pointer to this adaptor session instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_session_get_object_type_cache_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_object_type_cache_interface( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_transaction_interface afw_adaptor_transaction
 *
 * 
 * Adaptor session transaction interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_adaptor_transaction public struct. */
struct afw_adaptor_transaction_s {
    const afw_adaptor_transaction_inf_t *inf;
};

/** @brief define for interface afw_adaptor_transaction name. */
#define AFW_ADAPTOR_TRANSACTION_INTERFACE_NAME \
"afw_adaptor_transaction"

/** @sa afw_adaptor_transaction_release() */
typedef void
(*afw_adaptor_transaction_release_t)(
    const afw_adaptor_transaction_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_transaction_commit() */
typedef void
(*afw_adaptor_transaction_commit_t)(
    const afw_adaptor_transaction_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_transaction_inf_s struct. */
struct afw_adaptor_transaction_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_transaction_release_t release;
    afw_adaptor_transaction_commit_t commit;
};

/**
 * @brief Call method release of interface afw_adaptor_transaction
 * @param instance Pointer to this adaptor session transaction instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_transaction_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method commit of interface afw_adaptor_transaction
 * @param instance Pointer to this adaptor session transaction instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_transaction_commit( \
    instance, \
    xctx \
) \
(instance)->inf->commit( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_impl_index_cursor_interface afw_adaptor_impl_index_cursor
 *
 * 
 * Adaptor implementation index cursor interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_adaptor_impl_index_cursor public struct. */
struct afw_adaptor_impl_index_cursor_s {
    const afw_adaptor_impl_index_cursor_inf_t *inf;
    const afw_query_criteria_filter_entry_t * filter_entry;
    afw_boolean_t inner_join;
};

/** @brief define for interface afw_adaptor_impl_index_cursor name. */
#define AFW_ADAPTOR_IMPL_INDEX_CURSOR_INTERFACE_NAME \
"afw_adaptor_impl_index_cursor"

/** @sa afw_adaptor_impl_index_cursor_release() */
typedef void
(*afw_adaptor_impl_index_cursor_release_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_get_next_object() */
typedef const afw_object_t *
(*afw_adaptor_impl_index_cursor_get_next_object_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_contains_object() */
typedef afw_boolean_t
(*afw_adaptor_impl_index_cursor_contains_object_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    const afw_object_t * object,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_inner_join() */
typedef const afw_adaptor_impl_index_cursor_t *
(*afw_adaptor_impl_index_cursor_inner_join_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    const afw_adaptor_impl_index_cursor_t * cursor,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_get_count() */
typedef afw_boolean_t
(*afw_adaptor_impl_index_cursor_get_count_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    size_t * count,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_impl_index_cursor_inf_s struct. */
struct afw_adaptor_impl_index_cursor_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_impl_index_cursor_release_t release;
    afw_adaptor_impl_index_cursor_get_next_object_t get_next_object;
    afw_adaptor_impl_index_cursor_contains_object_t contains_object;
    afw_adaptor_impl_index_cursor_inner_join_t inner_join;
    afw_adaptor_impl_index_cursor_get_count_t get_count;
};

/**
 * @brief Call method release of interface afw_adaptor_impl_index_cursor
 * @param instance Pointer to this adaptor impl index cursor instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_next_object of interface
 *     afw_adaptor_impl_index_cursor
 * @param instance Pointer to this adaptor impl index cursor instance.
 * @param pool Memory pool to allocate resources in.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_get_next_object( \
    instance, \
    pool, \
    xctx \
) \
(instance)->inf->get_next_object( \
    (instance), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method contains_object of interface
 *     afw_adaptor_impl_index_cursor
 * @param instance Pointer to this adaptor impl index cursor instance.
 * @param object Pointer to object we need to determine is in this cursor.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_contains_object( \
    instance, \
    object, \
    xctx \
) \
(instance)->inf->contains_object( \
    (instance), \
    (object), \
    (xctx) \
)

/**
 * @brief Call method inner_join of interface afw_adaptor_impl_index_cursor
 * @param instance Pointer to this adaptor impl index cursor instance.
 * @param cursor Pointer to the cursor we need to join with.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_inner_join( \
    instance, \
    cursor, \
    xctx \
) \
(instance)->inf->inner_join( \
    (instance), \
    (cursor), \
    (xctx) \
)

/**
 * @brief Call method get_count of interface afw_adaptor_impl_index_cursor
 * @param instance Pointer to this adaptor impl index cursor instance.
 * @param count Pointer to the count, where the caller should return the value.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_get_count( \
    instance, \
    count, \
    xctx \
) \
(instance)->inf->get_count( \
    (instance), \
    (count), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_key_value_interface afw_adaptor_key_value
 *
 * 
 * Adaptor implementation of key value interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_adaptor_key_value public struct. */
struct afw_adaptor_key_value_s {
    const afw_adaptor_key_value_inf_t *inf;
};

/** @brief define for interface afw_adaptor_key_value name. */
#define AFW_ADAPTOR_KEY_VALUE_INTERFACE_NAME \
"afw_adaptor_key_value"

/** @sa afw_adaptor_key_value_add() */
typedef void
(*afw_adaptor_key_value_add_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    const afw_memory_t * value,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_key_value_delete() */
typedef void
(*afw_adaptor_key_value_delete_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    const afw_memory_t * value,
    afw_boolean_t must_exist,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_key_value_replace() */
typedef void
(*afw_adaptor_key_value_replace_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    const afw_memory_t * value,
    afw_boolean_t must_exist,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_key_value_get() */
typedef const afw_memory_t *
(*afw_adaptor_key_value_get_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_key_value_inf_s struct. */
struct afw_adaptor_key_value_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_key_value_add_t add;
    afw_adaptor_key_value_delete_t delete;
    afw_adaptor_key_value_replace_t replace;
    afw_adaptor_key_value_get_t get;
};

/**
 * @brief Call method add of interface afw_adaptor_key_value
 * @param instance Pointer to this adaptor key value instance.
 * @param namespace Namespace for key.
 * @param key Key.
 * @param value Value.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_key_value_add( \
    instance, \
    namespace, \
    key, \
    value, \
    xctx \
) \
(instance)->inf->add( \
    (instance), \
    (namespace), \
    (key), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method delete of interface afw_adaptor_key_value
 * @param instance Pointer to this adaptor key value instance.
 * @param namespace Namespace for key.
 * @param key Key.
 * @param value Value the key must have or NULL if it doesn't matter.
 * @param must_exist It is an error if value does not exist.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_key_value_delete( \
    instance, \
    namespace, \
    key, \
    value, \
    must_exist, \
    xctx \
) \
(instance)->inf->delete( \
    (instance), \
    (namespace), \
    (key), \
    (value), \
    (must_exist), \
    (xctx) \
)

/**
 * @brief Call method replace of interface afw_adaptor_key_value
 * @param instance Pointer to this adaptor key value instance.
 * @param namespace Namespace for key.
 * @param key Key.
 * @param value Value the key must have or NULL if it doesn't matter.
 * @param must_exist It is an error if value does not exist. If must_exist is  
 *            false, the keyed value will be added if it doesn't exist.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_key_value_replace( \
    instance, \
    namespace, \
    key, \
    value, \
    must_exist, \
    xctx \
) \
(instance)->inf->replace( \
    (instance), \
    (namespace), \
    (key), \
    (value), \
    (must_exist), \
    (xctx) \
)

/**
 * @brief Call method get of interface afw_adaptor_key_value
 * @param instance Pointer to this adaptor key value instance.
 * @param namespace Namespace for key.
 * @param key Key.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_key_value_get( \
    instance, \
    namespace, \
    key, \
    xctx \
) \
(instance)->inf->get( \
    (instance), \
    (namespace), \
    (key), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_impl_index_interface afw_adaptor_impl_index
 *
 * 
 * Adaptor implementation index interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_adaptor_impl_index public struct. */
struct afw_adaptor_impl_index_s {
    const afw_adaptor_impl_index_inf_t *inf;
    const afw_object_t * indexDefinitions;
};

/** @brief define for interface afw_adaptor_impl_index name. */
#define AFW_ADAPTOR_IMPL_INDEX_INTERFACE_NAME \
"afw_adaptor_impl_index"

/** @sa afw_adaptor_impl_index_open() */
typedef void
(*afw_adaptor_impl_index_open_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * key,
    afw_boolean_t integer,
    afw_boolean_t unique,
    afw_boolean_t reverse,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_release() */
typedef void
(*afw_adaptor_impl_index_release_t)(
    const afw_adaptor_impl_index_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_get_index_definitions() */
typedef const afw_object_t *
(*afw_adaptor_impl_index_get_index_definitions_t)(
    const afw_adaptor_impl_index_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_update_index_definitions() */
typedef void
(*afw_adaptor_impl_index_update_index_definitions_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_object_t * indexDefinitions,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_add() */
typedef afw_rc_t
(*afw_adaptor_impl_index_add_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_utf8_t * key,
    const afw_utf8_t* value,
    afw_boolean_t unique,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_delete() */
typedef afw_rc_t
(*afw_adaptor_impl_index_delete_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_utf8_t * key,
    const afw_utf8_t* value,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_replace() */
typedef afw_rc_t
(*afw_adaptor_impl_index_replace_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_utf8_t * key,
    const afw_utf8_t* old_value,
    const afw_utf8_t* new_value,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_drop() */
typedef afw_rc_t
(*afw_adaptor_impl_index_drop_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * key,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_open_cursor() */
typedef afw_adaptor_impl_index_cursor_t *
(*afw_adaptor_impl_index_open_cursor_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * index_key,
    int operator,
    const afw_utf8_t * value,
    afw_boolean_t unique,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_get_session() */
typedef const afw_adaptor_session_t *
(*afw_adaptor_impl_index_get_session_t)(
    const afw_adaptor_impl_index_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_impl_index_inf_s struct. */
struct afw_adaptor_impl_index_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_impl_index_open_t open;
    afw_adaptor_impl_index_release_t release;
    afw_adaptor_impl_index_get_index_definitions_t get_index_definitions;
    afw_adaptor_impl_index_update_index_definitions_t update_index_definitions;
    afw_adaptor_impl_index_add_t add;
    afw_adaptor_impl_index_delete_t delete;
    afw_adaptor_impl_index_replace_t replace;
    afw_adaptor_impl_index_drop_t drop;
    afw_adaptor_impl_index_open_cursor_t open_cursor;
    afw_adaptor_impl_index_get_session_t get_session;
};

/**
 * @brief Call method open of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param object_type_id Object type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine
 *     the target table or database to store the index. NULL means all
 *     objectTypes are applicable.
 * @param key Index key associated with the index value we are creating.
 * @param integer Should index values be stored as integer values.
 * @param unique Should generated index values be unique.
 * @param reverse Should index values be stored in reverse order.
 * @param pool Caller's pool.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_open( \
    instance, \
    object_type_id, \
    key, \
    integer, \
    unique, \
    reverse, \
    pool, \
    xctx \
) \
(instance)->inf->open( \
    (instance), \
    (object_type_id), \
    (key), \
    (integer), \
    (unique), \
    (reverse), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method release of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_index_definitions of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_get_index_definitions( \
    instance, \
    xctx \
) \
(instance)->inf->get_index_definitions( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method update_index_definitions of interface
 *     afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param indexDefinitions Updated indexes definitions.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_update_index_definitions( \
    instance, \
    indexDefinitions, \
    xctx \
) \
(instance)->inf->update_index_definitions( \
    (instance), \
    (indexDefinitions), \
    (xctx) \
)

/**
 * @brief Call method add of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param object_type_id Object type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine
 *     the target table or database to store the index.
 * @param object_id Object id for the object associated with the property and
 *     value that we are indexing. This should be used by the adaptor as a
 *     reference to the primary entry.
 * @param key Index key associated with the index value we are creating.
 * @param value Index value associated with the index we are creating. This
 *     should be used by the adaptor as the key to the index entry.
 * @param unique Flag indicating that the index being added should be unique.
 * @param pool Caller's pool.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_add( \
    instance, \
    object_type_id, \
    object_id, \
    key, \
    value, \
    unique, \
    pool, \
    xctx \
) \
(instance)->inf->add( \
    (instance), \
    (object_type_id), \
    (object_id), \
    (key), \
    (value), \
    (unique), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method delete of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param object_type_id Object type id associated with the property and value
 *     of the index we are removing. This may be useful for the adaptor to
 *     determine the target table or database to store the index.
 * @param object_id Object id for the object associated with the property and
 *     value of the index we are removing. This should be used by the adaptor
 *     as a reference to the primary entry.
 * @param key Index key associated with the index value we are deleting.
 * @param value Index value associated with the index we are deleting. This
 *     should be used by the adaptor as the key to the index entry.
 * @param pool Caller's pool.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_delete( \
    instance, \
    object_type_id, \
    object_id, \
    key, \
    value, \
    pool, \
    xctx \
) \
(instance)->inf->delete( \
    (instance), \
    (object_type_id), \
    (object_id), \
    (key), \
    (value), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method replace of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param object_type_id Object type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine
 *     the target table or database to store the index.
 * @param object_id Object id for the object associated with the property and
 *     value that we are indexing. This should be used by the adaptor as a
 *     reference to the primary entry.
 * @param key Index key associated with the index value we are replacing.
 * @param old_value Old index value associated with the index we are replacing.
 *     This should be used by the adaptor as the key to the index entry.
 * @param new_value New index value associated with the index we are replacing.
 *     This should be used by the adaptor as the key to the index entry.
 * @param pool Caller's pool.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_replace( \
    instance, \
    object_type_id, \
    object_id, \
    key, \
    old_value, \
    new_value, \
    pool, \
    xctx \
) \
(instance)->inf->replace( \
    (instance), \
    (object_type_id), \
    (object_id), \
    (key), \
    (old_value), \
    (new_value), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method drop of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param object_type_id Object type id associated with the index. This may be
 *     useful for the adaptor to determine the target table or database for the
 *     index.
 * @param key Index key.
 * @param pool Caller's pool.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_drop( \
    instance, \
    object_type_id, \
    key, \
    pool, \
    xctx \
) \
(instance)->inf->drop( \
    (instance), \
    (object_type_id), \
    (key), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method open_cursor of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param object_type_id Object type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine
 *     the target table or database to find the index.
 * @param index_key Key associated with the index we are replacing.
 * @param operator Query criteria operator.
 * @param value Index value associated with the index we are querying. This
 *     should be used by the adaptor as the key to the index entry.
 * @param unique Index values are unique.
 * @param pool Caller's pool.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_open_cursor( \
    instance, \
    object_type_id, \
    index_key, \
    operator, \
    value, \
    unique, \
    pool, \
    xctx \
) \
(instance)->inf->open_cursor( \
    (instance), \
    (object_type_id), \
    (index_key), \
    (operator), \
    (value), \
    (unique), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method get_session of interface afw_adaptor_impl_index
 * @param instance Pointer to this adaptor impl index instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_impl_index_get_session( \
    instance, \
    xctx \
) \
(instance)->inf->get_session( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_authorization_handler_factory_interface afw_authorization_handler_factory
 *
 * Factory to create an instance of an afw_authorization_handler.
 *
 * @{
 */


/** @brief Interface afw_authorization_handler_factory public struct. */
struct afw_authorization_handler_factory_s {
    const afw_authorization_handler_factory_inf_t *inf;
    afw_utf8_t authorization_handler_type;
    const afw_utf8_t * description;
};

/** @brief define for interface afw_authorization_handler_factory name. */
#define AFW_AUTHORIZATION_HANDLER_FACTORY_INTERFACE_NAME \
"afw_authorization_handler_factory"

/** @sa afw_authorization_handler_factory_create_authorization_handler_cede_p() */
typedef const afw_authorization_handler_t *
(*afw_authorization_handler_factory_create_authorization_handler_cede_p_t)(
    const afw_authorization_handler_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_authorization_handler_factory_inf_s struct. */
struct afw_authorization_handler_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_authorization_handler_factory_create_authorization_handler_cede_p_t create_authorization_handler_cede_p;
};

/**
 * @brief Call method create_authorization_handler_cede_p of interface
 *     afw_authorization_handler_factory
 * @param instance Pointer to this authorization handler factory instance.
 * @param properties Configuration parameters for the particular type of
 *     authorization handler.          This will become the properties object
 *     for handler.
 * @param p The pool that will be used for authorization handler resources.
 * @param xctx This is the caller's xctx.
 */
#define afw_authorization_handler_factory_create_authorization_handler_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_authorization_handler_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_authorization_handler_interface afw_authorization_handler
 *
 * Adaptive framework authorization handler interface.
 *
 * @{
 */


/** @brief Interface afw_authorization_handler public struct. */
struct afw_authorization_handler_s {
    const afw_authorization_handler_inf_t *inf;
    const afw_pool_t * p;
    afw_utf8_t authorization_handler_id;
    const afw_utf8_t * authorization_handler_type_id;
    const afw_utf8_t * service_id;
    const afw_object_t * properties;
    const afw_utf8_t * source_location;
    const afw_utf8_t * trace_flag_id;
    afw_size_t trace_flag_index;
    const afw_utf8_t * detail_flag_id;
    afw_size_t detail_flag_index;
    const afw_lock_rw_t * authorization_handler_lock_rw;
    afw_integer_t priority;
    afw_boolean_t allow_deny_override;
    afw_boolean_t allow_permit_override;
    afw_boolean_t required;
    const afw_authorization_handler_impl_t * impl;
};

/** @brief define for interface afw_authorization_handler name. */
#define AFW_AUTHORIZATION_HANDLER_INTERFACE_NAME \
"afw_authorization_handler"

/** @sa afw_authorization_handler_destroy() */
typedef void
(*afw_authorization_handler_destroy_t)(
    const afw_authorization_handler_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_authorization_handler_check() */
typedef const afw_value_t *
(*afw_authorization_handler_check_t)(
    const afw_authorization_handler_t * instance,
    const afw_value_t * resource_id,
    const afw_value_t * object,
    const afw_value_t * action_id,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_authorization_handler_inf_s struct. */
struct afw_authorization_handler_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_authorization_handler_destroy_t destroy;
    afw_authorization_handler_check_t check;
};

/**
 * @brief Call method destroy of interface afw_authorization_handler
 * @param instance Pointer to this adaptive authorization handler instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_authorization_handler_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method check of interface afw_authorization_handler
 * @param instance Pointer to this adaptive request instance.
 * @param resource_id Adaptive string value for the URI of resource to check.
 * @param object Adaptive object value for the object associated with resource
 *     or NULL.
 * @param action_id Adaptive string value for the action to check.
 * @param p Pool for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_authorization_handler_check( \
    instance, \
    resource_id, \
    object, \
    action_id, \
    p, \
    xctx \
) \
(instance)->inf->check( \
    (instance), \
    (resource_id), \
    (object), \
    (action_id), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_content_type_interface afw_content_type
 *
 * Adaptive Content Type.
 *
 * @{
 */


/** @brief Interface afw_content_type public struct. */
struct afw_content_type_s {
    const afw_content_type_inf_t *inf;
    afw_utf8_t content_type_id;
    afw_size_t media_type_count;
    const afw_utf8_t * media_types;
};

/** @brief define for interface afw_content_type name. */
#define AFW_CONTENT_TYPE_INTERFACE_NAME \
"afw_content_type"

/** @sa afw_content_type_raw_to_value() */
typedef const afw_value_t *
(*afw_content_type_raw_to_value_t)(
    const afw_content_type_t * instance,
    const afw_memory_t * raw,
    const afw_utf8_t * source_location,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_content_type_raw_to_object() */
typedef const afw_object_t *
(*afw_content_type_raw_to_object_t)(
    const afw_content_type_t * instance,
    const afw_memory_t * raw,
    const afw_utf8_t * source_location,
    const afw_utf8_t * adaptor_id,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    afw_boolean_t cede_p,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_content_type_write_value() */
typedef void
(*afw_content_type_write_value_t)(
    const afw_content_type_t * instance,
    const afw_value_t * value,
    const afw_object_options_t * options,
    void * context,
    afw_write_cb_t callback,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_content_type_create_object_list_writer() */
typedef const afw_content_type_object_list_writer_t *
(*afw_content_type_create_object_list_writer_t)(
    const afw_content_type_t * instance,
    const afw_object_options_t * options,
    void * context,
    afw_write_cb_t callback,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_content_type_inf_s struct. */
struct afw_content_type_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_content_type_raw_to_value_t raw_to_value;
    afw_content_type_raw_to_object_t raw_to_object;
    afw_content_type_write_value_t write_value;
    afw_content_type_create_object_list_writer_t create_object_list_writer;
};

/**
 * @brief Call method raw_to_value of interface afw_content_type
 * @param instance Pointer to this content type instance.
 * @param raw Raw encoded representation of this content type.
 * @param source_location Source location or NULL.
 * @param p Pool to use to hold returned value.
 * @param xctx This is the caller's xctx.
 */
#define afw_content_type_raw_to_value( \
    instance, \
    raw, \
    source_location, \
    p, \
    xctx \
) \
(instance)->inf->raw_to_value( \
    (instance), \
    (raw), \
    (source_location), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method raw_to_object of interface afw_content_type
 * @param instance Pointer to this content type instance.
 * @param raw Raw encoded object representation of this content type.
 * @param source_location Source location or NULL.
 * @param adaptor_id Adaptor id for created object.
 * @param object_type_id Object type id for created object.
 * @param object_id Object id for created object.
 * @param cede_p If true, cede control of p to the created object.          If
 *     false, a subpool will be created in p for the object.
 * @param p The pool to use.
 * @param xctx This is the caller's xctx.
 */
#define afw_content_type_raw_to_object( \
    instance, \
    raw, \
    source_location, \
    adaptor_id, \
    object_type_id, \
    object_id, \
    cede_p, \
    p, \
    xctx \
) \
(instance)->inf->raw_to_object( \
    (instance), \
    (raw), \
    (source_location), \
    (adaptor_id), \
    (object_type_id), \
    (object_id), \
    (cede_p), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method write_value of interface afw_content_type
 * @param instance Pointer to this content type instance.
 * @param value Adaptive value to convert and write.
 * @param options These options can determine if none, some, or all object meta
 *              information should be included in output.          See
 *     afw_object_options_t for more information. Only options flagged         
 *     for use by content type processing are honored. All other options       
 *       are ignored. For instance, a call to afw_object_view_create() with    
 *          the composite option is needed before calling a content type write 
 *             function if inherited properties should be included in output.
 * @param context Pointer passed to callback routine.
 * @param callback Callback function that will be called to write multiple
 *     times to write          the raw representation of the value.
 * @param p Pool to use.
 * @param xctx This is the caller's xctx.
 */
#define afw_content_type_write_value( \
    instance, \
    value, \
    options, \
    context, \
    callback, \
    p, \
    xctx \
) \
(instance)->inf->write_value( \
    (instance), \
    (value), \
    (options), \
    (context), \
    (callback), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method create_object_list_writer of interface afw_content_type
 * @param instance Pointer to this content type instance.
 * @param options These options can determine if none, some, or all object meta
 *              information should be included in output.          See
 *     afw_object_options_t for more information. Only options flagged         
 *     for use by content type processing are honored. All other options       
 *       are ignored. For instance, a call to afw_object_view_create() with    
 *          the composite option is needed before calling a content type write 
 *             function if inherited properties should be included in output.
 * @param context Pointer passed to callback routine.
 * @param callback Callback function that will be called each time the object
 *     list          writer has something to write.
 * @param p Pool to use.
 * @param xctx This is the caller's xctx.
 */
#define afw_content_type_create_object_list_writer( \
    instance, \
    options, \
    context, \
    callback, \
    p, \
    xctx \
) \
(instance)->inf->create_object_list_writer( \
    (instance), \
    (options), \
    (context), \
    (callback), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_content_type_object_list_writer_interface afw_content_type_object_list_writer
 *
 *
 * @{
 */


/** @brief Interface afw_content_type_object_list_writer public struct. */
struct afw_content_type_object_list_writer_s {
    const afw_content_type_object_list_writer_inf_t *inf;
};

/** @brief define for interface afw_content_type_object_list_writer name. */
#define AFW_CONTENT_TYPE_OBJECT_LIST_WRITER_INTERFACE_NAME \
"afw_content_type_object_list_writer"

/** @sa afw_content_type_object_list_writer_release() */
typedef void
(*afw_content_type_object_list_writer_release_t)(
    const afw_content_type_object_list_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_content_type_object_list_writer_write_object() */
typedef void
(*afw_content_type_object_list_writer_write_object_t)(
    const afw_content_type_object_list_writer_t * instance,
    const afw_object_t * object,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_content_type_object_list_writer_inf_s struct. */
struct afw_content_type_object_list_writer_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_content_type_object_list_writer_release_t release;
    afw_content_type_object_list_writer_write_object_t write_object;
};

/**
 * @brief Call method release of interface afw_content_type_object_list_writer
 * @param instance Pointer to this instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_content_type_object_list_writer_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method write_object of interface
 *     afw_content_type_object_list_writer
 * @param instance Pointer to this instance.
 * @param object The object to write.
 * @param p Pool to use.
 * @param xctx This is the caller's xctx.
 */
#define afw_content_type_object_list_writer_write_object( \
    instance, \
    object, \
    p, \
    xctx \
) \
(instance)->inf->write_object( \
    (instance), \
    (object), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_data_type_interface afw_data_type
 *
 * Adaptive Data Type.
 *
 * @{
 */


/** @brief Interface afw_data_type public struct. */
struct afw_data_type_s {
    const afw_data_type_inf_t *inf;
    const afw_object_t * object;
    afw_utf8_t data_type_id;
    afw_utf8_t brief;
    afw_utf8_t description;
    afw_utf8_t data_type_parameter_type;
    int data_type_number;
    afw_utf8_t ldapOid;
    afw_utf8_t jsonPrimitive;
    afw_utf8_t jsonSchemaStringFormat;
    afw_utf8_t cType;
    afw_size_t c_type_size;
    const afw_array_t * empty_array;
    const afw_value_t * empty_array_value;
    const afw_value_inf_t * evaluated_value_inf;
    afw_compile_type_t compile_type;
    afw_boolean_t json_implies_data_type;
    afw_boolean_t evaluated;
    afw_boolean_t directReturn;
    afw_boolean_t relationalCompares;
    afw_boolean_t scalar;
    afw_boolean_t special;
};

/** @brief define for interface afw_data_type name. */
#define AFW_DATA_TYPE_INTERFACE_NAME \
"afw_data_type"

/** @sa afw_data_type_internal_to_utf8() */
typedef const afw_utf8_t *
(*afw_data_type_internal_to_utf8_t)(
    const afw_data_type_t * instance,
    const void * from_internal,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_utf8_to_internal() */
typedef void
(*afw_data_type_utf8_to_internal_t)(
    const afw_data_type_t * instance,
    void * to_internal,
    const afw_utf8_t * from_utf8,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_compare_internal() */
typedef int
(*afw_data_type_compare_internal_t)(
    const afw_data_type_t * instance,
    const void * internal1,
    const void * internal2,
    afw_xctx_t * xctx);

/** @sa afw_data_type_convert_internal() */
typedef void
(*afw_data_type_convert_internal_t)(
    const afw_data_type_t * instance,
    void * to_internal,
    const void * from_internal,
    const afw_data_type_t * to_data_type,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_clone_internal() */
typedef void
(*afw_data_type_clone_internal_t)(
    const afw_data_type_t * instance,
    void * to_internal,
    const void * from_internal,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_value_compiler_listing() */
typedef void
(*afw_data_type_value_compiler_listing_t)(
    const afw_data_type_t * instance,
    const afw_writer_t * writer,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @sa afw_data_type_write_as_expression() */
typedef void
(*afw_data_type_write_as_expression_t)(
    const afw_data_type_t * instance,
    const afw_writer_t * writer,
    const void * from_internal,
    afw_xctx_t * xctx);

/** @brief Interface afw_data_type_inf_s struct. */
struct afw_data_type_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_data_type_internal_to_utf8_t internal_to_utf8;
    afw_data_type_utf8_to_internal_t utf8_to_internal;
    afw_data_type_compare_internal_t compare_internal;
    afw_data_type_convert_internal_t convert_internal;
    afw_data_type_clone_internal_t clone_internal;
    afw_data_type_value_compiler_listing_t value_compiler_listing;
    afw_data_type_write_as_expression_t write_as_expression;
};

/**
 * @brief Call method internal_to_utf8 of interface afw_data_type
 * @param instance Pointer to this data type instance.
 * @param from_internal Internal representation of this data type of correct
 *     cType to          convert.
 * @param p Pool to use to hold returned value.
 * @param xctx This is the caller's xctx.
 */
#define afw_data_type_internal_to_utf8( \
    instance, \
    from_internal, \
    p, \
    xctx \
) \
(instance)->inf->internal_to_utf8( \
    (instance), \
    (from_internal), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method utf8_to_internal of interface afw_data_type
 * @param instance Pointer to this data type instance.
 * @param to_internal The address of the place to return result. This place
 *     must be the correct size          based on data type (c_type_size).
 * @param from_utf8 NFC UTF-8 representation for of this data type.
 * @param p Pool to use to hold returned value.
 * @param xctx This is the caller's xctx.
 */
#define afw_data_type_utf8_to_internal( \
    instance, \
    to_internal, \
    from_utf8, \
    p, \
    xctx \
) \
(instance)->inf->utf8_to_internal( \
    (instance), \
    (to_internal), \
    (from_utf8), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method compare_internal of interface afw_data_type
 * @param instance Pointer to this data type instance.
 * @param internal1 First value of correct cType to compare.
 * @param internal2 Second value of correct cType to compare.
 * @param xctx This is the caller's xctx.
 */
#define afw_data_type_compare_internal( \
    instance, \
    internal1, \
    internal2, \
    xctx \
) \
(instance)->inf->compare_internal( \
    (instance), \
    (internal1), \
    (internal2), \
    (xctx) \
)

/**
 * @brief Call method convert_internal of interface afw_data_type
 * @param instance Pointer to this data type instance.
 * @param to_internal The address of the place to return result. This place
 *     must be the correct size          based on data type (c_type_size) of
 *     to_data_type.
 * @param from_internal Value of correct cType to of this data type to convert.
 * @param to_data_type Data type of to value.
 * @param p Pool to use to hold returned value.
 * @param xctx This is the caller's xctx.
 */
#define afw_data_type_convert_internal( \
    instance, \
    to_internal, \
    from_internal, \
    to_data_type, \
    p, \
    xctx \
) \
(instance)->inf->convert_internal( \
    (instance), \
    (to_internal), \
    (from_internal), \
    (to_data_type), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method clone_internal of interface afw_data_type
 * @param instance Pointer to this data type instance.
 * @param to_internal The address of the place to return result. This place
 *     must be the correct size          based on data type (c_type_size) of
 *     to_data_type.
 * @param from_internal Value of correct cType to of this data type to convert.
 * @param p Pool to use to hold returned value.
 * @param xctx This is the caller's xctx.
 */
#define afw_data_type_clone_internal( \
    instance, \
    to_internal, \
    from_internal, \
    p, \
    xctx \
) \
(instance)->inf->clone_internal( \
    (instance), \
    (to_internal), \
    (from_internal), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method value_compiler_listing of interface afw_data_type
 * @param instance Pointer to this data type instance.
 * @param writer Writer instance to use.
 * @param value Value to write to compiler listing.
 * @param xctx This is the caller's xctx.
 */
#define afw_data_type_value_compiler_listing( \
    instance, \
    writer, \
    value, \
    xctx \
) \
(instance)->inf->value_compiler_listing( \
    (instance), \
    (writer), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method write_as_expression of interface afw_data_type
 * @param instance Pointer to this data type instance.
 * @param writer Writer instance to use.
 * @param from_internal Value of correct cType to of this data type to convert.
 * @param xctx This is the caller's xctx.
 */
#define afw_data_type_write_as_expression( \
    instance, \
    writer, \
    from_internal, \
    xctx \
) \
(instance)->inf->write_as_expression( \
    (instance), \
    (writer), \
    (from_internal), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_array_setter_interface afw_array_setter
 *
 * 
 * Adaptive array setter interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_array_setter public struct. */
struct afw_array_setter_s {
    const afw_array_setter_inf_t *inf;
    const afw_array_t * array;
};

/** @brief define for interface afw_array_setter name. */
#define AFW_ARRAY_SETTER_INTERFACE_NAME \
"afw_array_setter"

/** @sa afw_array_setter_set_immutable() */
typedef void
(*afw_array_setter_set_immutable_t)(
    const afw_array_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_determine_data_type_and_set_immutable() */
typedef const afw_data_type_t *
(*afw_array_setter_determine_data_type_and_set_immutable_t)(
    const afw_array_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_add_internal() */
typedef void
(*afw_array_setter_add_internal_t)(
    const afw_array_setter_t * instance,
    const afw_data_type_t * data_type,
    const void * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_add_value() */
typedef void
(*afw_array_setter_add_value_t)(
    const afw_array_setter_t * instance,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_insert_internal() */
typedef void
(*afw_array_setter_insert_internal_t)(
    const afw_array_setter_t * instance,
    const afw_data_type_t * data_type,
    const void * internal,
    afw_size_t index,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_insert_value() */
typedef void
(*afw_array_setter_insert_value_t)(
    const afw_array_setter_t * instance,
    const afw_value_t * value,
    afw_size_t index,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_remove_all_values() */
typedef void
(*afw_array_setter_remove_all_values_t)(
    const afw_array_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_remove_internal() */
typedef void
(*afw_array_setter_remove_internal_t)(
    const afw_array_setter_t * instance,
    const afw_data_type_t * data_type,
    const void * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_remove_value() */
typedef void
(*afw_array_setter_remove_value_t)(
    const afw_array_setter_t * instance,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_set_value_by_index() */
typedef void
(*afw_array_setter_set_value_by_index_t)(
    const afw_array_setter_t * instance,
    afw_size_t index,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @brief Interface afw_array_setter_inf_s struct. */
struct afw_array_setter_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_array_setter_set_immutable_t set_immutable;
    afw_array_setter_determine_data_type_and_set_immutable_t determine_data_type_and_set_immutable;
    afw_array_setter_add_internal_t add_internal;
    afw_array_setter_add_value_t add_value;
    afw_array_setter_insert_internal_t insert_internal;
    afw_array_setter_insert_value_t insert_value;
    afw_array_setter_remove_all_values_t remove_all_values;
    afw_array_setter_remove_internal_t remove_internal;
    afw_array_setter_remove_value_t remove_value;
    afw_array_setter_set_value_by_index_t set_value_by_index;
};

/**
 * @brief Call method set_immutable of interface afw_array_setter
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_set_immutable( \
    instance, \
    xctx \
) \
(instance)->inf->set_immutable( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method determine_data_type_and_set_immutable of interface
 *     afw_array_setter
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_determine_data_type_and_set_immutable( \
    instance, \
    xctx \
) \
(instance)->inf->determine_data_type_and_set_immutable( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method add_internal of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param data_type The data type of internal.
 * @param internal The internal value to add of type data_type->cType.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_add_internal( \
    instance, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->add_internal( \
    (instance), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method add_value of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param value A value.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_add_value( \
    instance, \
    value, \
    xctx \
) \
(instance)->inf->add_value( \
    (instance), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method insert_internal of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param data_type The data type of internal.
 * @param internal The internal value to add of type data_type->cType.
 * @param index The zero based index for insert.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_insert_internal( \
    instance, \
    data_type, \
    internal, \
    index, \
    xctx \
) \
(instance)->inf->insert_internal( \
    (instance), \
    (data_type), \
    (internal), \
    (index), \
    (xctx) \
)

/**
 * @brief Call method insert_value of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param value A value.
 * @param index The zero based index for insert.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_insert_value( \
    instance, \
    value, \
    index, \
    xctx \
) \
(instance)->inf->insert_value( \
    (instance), \
    (value), \
    (index), \
    (xctx) \
)

/**
 * @brief Call method remove_all_values of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_remove_all_values( \
    instance, \
    xctx \
) \
(instance)->inf->remove_all_values( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method remove_internal of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param data_type The data type of internal.
 * @param internal The internal value to delete of type data_type->cType.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_remove_internal( \
    instance, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->remove_internal( \
    (instance), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method remove_value of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param value Value.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_remove_value( \
    instance, \
    value, \
    xctx \
) \
(instance)->inf->remove_value( \
    (instance), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method set_value_by_index of interface afw_array_setter
 * @param instance Pointer to this value array instance.
 * @param index Index relative to 0.
 * @param value Value.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_setter_set_value_by_index( \
    instance, \
    index, \
    value, \
    xctx \
) \
(instance)->inf->set_value_by_index( \
    (instance), \
    (index), \
    (value), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_array_interface afw_array
 *
 * 
 * Adaptive value array interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_array public struct. */
struct afw_array_s {
    const afw_array_inf_t *inf;
};

/** @brief define for interface afw_array name. */
#define AFW_ARRAY_INTERFACE_NAME \
"afw_array"

/** @sa afw_array_release() */
typedef void
(*afw_array_release_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_get_count() */
typedef afw_size_t
(*afw_array_get_count_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_get_data_type() */
typedef const afw_data_type_t *
(*afw_array_get_data_type_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_get_entry_meta() */
typedef const afw_value_t *
(*afw_array_get_entry_meta_t)(
    const afw_array_t * instance,
    afw_integer_t index,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_entry_internal() */
typedef afw_boolean_t
(*afw_array_get_entry_internal_t)(
    const afw_array_t * instance,
    afw_integer_t index,
    const afw_data_type_t * * data_type,
    const void * * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_get_entry_value() */
typedef const afw_value_t *
(*afw_array_get_entry_value_t)(
    const afw_array_t * instance,
    afw_integer_t index,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_next_entry_meta() */
typedef const afw_value_t *
(*afw_array_get_next_entry_meta_t)(
    const afw_array_t * instance,
    const afw_iterator_t * * iterator,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_next_internal() */
typedef afw_boolean_t
(*afw_array_get_next_internal_t)(
    const afw_array_t * instance,
    const afw_iterator_t * * iterator,
    const afw_data_type_t * * data_type,
    const void * * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_get_next_value() */
typedef const afw_value_t *
(*afw_array_get_next_value_t)(
    const afw_array_t * instance,
    const afw_iterator_t * * iterator,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_setter() */
typedef const afw_array_setter_t *
(*afw_array_get_setter_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_array_inf_s struct. */
struct afw_array_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_array_release_t release;
    afw_array_get_count_t get_count;
    afw_array_get_data_type_t get_data_type;
    afw_array_get_entry_meta_t get_entry_meta;
    afw_array_get_entry_internal_t get_entry_internal;
    afw_array_get_entry_value_t get_entry_value;
    afw_array_get_next_entry_meta_t get_next_entry_meta;
    afw_array_get_next_internal_t get_next_internal;
    afw_array_get_next_value_t get_next_value;
    afw_array_get_setter_t get_setter;
};

/**
 * @brief Call method release of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_count of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_count( \
    instance, \
    xctx \
) \
(instance)->inf->get_count( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_data_type of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_data_type( \
    instance, \
    xctx \
) \
(instance)->inf->get_data_type( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_entry_meta of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param index Zero-based index of array entry to return.
 * @param p If necessary, this pool is used to create the return value.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_entry_meta( \
    instance, \
    index, \
    p, \
    xctx \
) \
(instance)->inf->get_entry_meta( \
    (instance), \
    (index), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_entry_internal of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param index Zero-based index of array entry to return.
 * @param data_type Place to put data type pointer or NULL.
 * @param internal Place to put data_type->cType pointer to the internal at the
 *     specified index.          This will be set to NULL if index is out of
 *     range.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_entry_internal( \
    instance, \
    index, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->get_entry_internal( \
    (instance), \
    (index), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method get_entry_value of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param index Zero-based index of array entry to return.
 * @param p If necessary, this pool is used to create the return value.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_entry_value( \
    instance, \
    index, \
    p, \
    xctx \
) \
(instance)->inf->get_entry_value( \
    (instance), \
    (index), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_next_entry_meta of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param iterator Address of iterator pointer.
 * @param p If necessary, this pool is used to create the return value.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_next_entry_meta( \
    instance, \
    iterator, \
    p, \
    xctx \
) \
(instance)->inf->get_next_entry_meta( \
    (instance), \
    (iterator), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_next_internal of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param iterator Address of iterator pointer.
 * @param data_type Place to put data type pointer or NULL.
 * @param internal Place to put data_type->cType pointer to next internal.     
 *         This will be set to NULL if there is no next internal.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_next_internal( \
    instance, \
    iterator, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->get_next_internal( \
    (instance), \
    (iterator), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method get_next_value of interface afw_array
 * @param instance Pointer to this value array instance.
 * @param iterator Address of iterator pointer.
 * @param p If necessary, this pool is used to create the return value.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_next_value( \
    instance, \
    iterator, \
    p, \
    xctx \
) \
(instance)->inf->get_next_value( \
    (instance), \
    (iterator), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_setter of interface afw_array
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_array_get_setter( \
    instance, \
    xctx \
) \
(instance)->inf->get_setter( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_log_factory_interface afw_log_factory
 *
 * 
 * Log factory.
 * 
 *
 * @{
 */


/** @brief Interface afw_log_factory public struct. */
struct afw_log_factory_s {
    const afw_log_factory_inf_t *inf;
    afw_utf8_t log_type;
    const afw_utf8_t * description;
};

/** @brief define for interface afw_log_factory name. */
#define AFW_LOG_FACTORY_INTERFACE_NAME \
"afw_log_factory"

/** @sa afw_log_factory_create_log_cede_p() */
typedef const afw_log_t *
(*afw_log_factory_create_log_cede_p_t)(
    const afw_log_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_log_factory_inf_s struct. */
struct afw_log_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_log_factory_create_log_cede_p_t create_log_cede_p;
};

/**
 * @brief Call method create_log_cede_p of interface afw_log_factory
 * @param instance Pointer to this log factory instance.
 * @param properties Creation parameters for the particular type of log. This
 *     will become properties object for log.
 * @param p Pool to use for log resources.
 * @param xctx This is the caller's xctx.
 */
#define afw_log_factory_create_log_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_log_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_log_interface afw_log
 *
 * 
 * Log.
 * 
 *
 * @{
 */


/** @brief Interface afw_log public struct. */
struct afw_log_s {
    const afw_log_inf_t *inf;
    const afw_pool_t * p;
    afw_utf8_t log_id;
    const afw_utf8_t * service_id;
    const afw_object_t * properties;
    const afw_utf8_t * source_location;
    const afw_log_impl_t * impl;
};

/** @brief define for interface afw_log name. */
#define AFW_LOG_INTERFACE_NAME \
"afw_log"

/** @sa afw_log_destroy() */
typedef void
(*afw_log_destroy_t)(
    const afw_log_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_log_set_own_mask() */
typedef void
(*afw_log_set_own_mask_t)(
    const afw_log_t * instance,
    afw_log_priority_mask_t mask,
    afw_xctx_t * xctx);

/** @sa afw_log_write() */
typedef void
(*afw_log_write_t)(
    const afw_log_t * instance,
    afw_log_priority_t priority,
    const afw_utf8_z_t * source_z,
    const afw_utf8_t * message,
    afw_xctx_t * xctx);

/** @brief Interface afw_log_inf_s struct. */
struct afw_log_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_log_destroy_t destroy;
    afw_log_set_own_mask_t set_own_mask;
    afw_log_write_t write;
};

/**
 * @brief Call method destroy of interface afw_log
 * @param instance Pointer to this log instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_log_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method set_own_mask of interface afw_log
 * @param instance Pointer to this log instance.
 * @param mask Log priority mask.
 * @param xctx This is the caller's xctx.
 */
#define afw_log_set_own_mask( \
    instance, \
    mask, \
    xctx \
) \
(instance)->inf->set_own_mask( \
    (instance), \
    (mask), \
    (xctx) \
)

/**
 * @brief Call method write of interface afw_log
 * @param instance Pointer to this log instance.
 * @param priority Log priority level.
 * @param source_z Source file name
 * @param message Message to log.
 * @param xctx This is the caller's xctx.
 */
#define afw_log_write( \
    instance, \
    priority, \
    source_z, \
    message, \
    xctx \
) \
(instance)->inf->write( \
    (instance), \
    (priority), \
    (source_z), \
    (message), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_object_setter_interface afw_object_setter
 *
 * 
 * This is interface used to set properties and meta of an adaptive
 * object.
 * See interface afw_object method get_object_setter for more
 * information.
 * 
 *
 * @{
 */


/** @brief Interface afw_object_setter public struct. */
struct afw_object_setter_s {
    const afw_object_setter_inf_t *inf;
    const afw_object_t * object;
};

/** @brief define for interface afw_object_setter name. */
#define AFW_OBJECT_SETTER_INTERFACE_NAME \
"afw_object_setter"

/** @sa afw_object_setter_set_immutable() */
typedef void
(*afw_object_setter_set_immutable_t)(
    const afw_object_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_setter_set_property() */
typedef void
(*afw_object_setter_set_property_t)(
    const afw_object_setter_t * instance,
    const afw_utf8_t * property_name,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @brief Interface afw_object_setter_inf_s struct. */
struct afw_object_setter_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_object_setter_set_immutable_t set_immutable;
    afw_object_setter_set_property_t set_property;
};

/**
 * @brief Call method set_immutable of interface afw_object_setter
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_setter_set_immutable( \
    instance, \
    xctx \
) \
(instance)->inf->set_immutable( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method set_property of interface afw_object_setter
 * @param instance Pointer to this object setter instance.
 * @param property_name Property name of property to set.
 * @param value Value to set or NULL to remove the property.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_setter_set_property( \
    instance, \
    property_name, \
    value, \
    xctx \
) \
(instance)->inf->set_property( \
    (instance), \
    (property_name), \
    (value), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_object_interface afw_object
 *
 * 
 * This is interface used to access the properties of an adaptive object.
 * 
 *
 * @{
 */


/** @brief Interface afw_object public struct. */
struct afw_object_s {
    const afw_object_inf_t *inf;
    const afw_pool_t * p;
    afw_object_meta_t meta;
};

/** @brief define for interface afw_object name. */
#define AFW_OBJECT_INTERFACE_NAME \
"afw_object"

/** @sa afw_object_release() */
typedef void
(*afw_object_release_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_add_reference() */
typedef void
(*afw_object_add_reference_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_get_count() */
typedef afw_size_t
(*afw_object_get_count_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_get_meta() */
typedef const afw_value_t *
(*afw_object_get_meta_t)(
    const afw_object_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_object_get_property() */
typedef const afw_value_t *
(*afw_object_get_property_t)(
    const afw_object_t * instance,
    const afw_utf8_t * property_name,
    afw_xctx_t * xctx);

/** @sa afw_object_get_property_meta() */
typedef const afw_value_t *
(*afw_object_get_property_meta_t)(
    const afw_object_t * instance,
    const afw_utf8_t * property_name,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_object_get_next_property() */
typedef const afw_value_t *
(*afw_object_get_next_property_t)(
    const afw_object_t * instance,
    const afw_iterator_t * * iterator,
    const afw_utf8_t * * property_name,
    afw_xctx_t * xctx);

/** @sa afw_object_get_next_property_meta() */
typedef const afw_value_t *
(*afw_object_get_next_property_meta_t)(
    const afw_object_t * instance,
    const afw_iterator_t * * iterator,
    const afw_utf8_t * * property_name,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_object_has_property() */
typedef afw_boolean_t
(*afw_object_has_property_t)(
    const afw_object_t * instance,
    const afw_utf8_t * property_name,
    afw_xctx_t * xctx);

/** @sa afw_object_get_setter() */
typedef const afw_object_setter_t *
(*afw_object_get_setter_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_object_inf_s struct. */
struct afw_object_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_object_release_t release;
    afw_object_add_reference_t add_reference;
    afw_object_get_count_t get_count;
    afw_object_get_meta_t get_meta;
    afw_object_get_property_t get_property;
    afw_object_get_property_meta_t get_property_meta;
    afw_object_get_next_property_t get_next_property;
    afw_object_get_next_property_meta_t get_next_property_meta;
    afw_object_has_property_t has_property;
    afw_object_get_setter_t get_setter;
};

/**
 * @brief Call method release of interface afw_object
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method add_reference of interface afw_object
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_add_reference( \
    instance, \
    xctx \
) \
(instance)->inf->add_reference( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_count of interface afw_object
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_get_count( \
    instance, \
    xctx \
) \
(instance)->inf->get_count( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_meta of interface afw_object
 * @param instance Pointer to this object instance.
 * @param p Pool to use for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_get_meta( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_meta( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_property of interface afw_object
 * @param instance Pointer to this object instance.
 * @param property_name Property name.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_get_property( \
    instance, \
    property_name, \
    xctx \
) \
(instance)->inf->get_property( \
    (instance), \
    (property_name), \
    (xctx) \
)

/**
 * @brief Call method get_property_meta of interface afw_object
 * @param instance Pointer to this object instance.
 * @param property_name Property name.
 * @param p Pool to use for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_get_property_meta( \
    instance, \
    property_name, \
    p, \
    xctx \
) \
(instance)->inf->get_property_meta( \
    (instance), \
    (property_name), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_next_property of interface afw_object
 * @param instance Pointer to this object instance.
 * @param iterator Address of iterator pointer. Set to NULL before call to get
 *     first property.
 * @param property_name Place to return pointer to property name or NULL.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_get_next_property( \
    instance, \
    iterator, \
    property_name, \
    xctx \
) \
(instance)->inf->get_next_property( \
    (instance), \
    (iterator), \
    (property_name), \
    (xctx) \
)

/**
 * @brief Call method get_next_property_meta of interface afw_object
 * @param instance Pointer to this object instance.
 * @param iterator Address of iterator pointer. Set to NULL before call to get
 *     first property.
 * @param property_name Place to return pointer to property name.
 * @param p Pool to use for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_get_next_property_meta( \
    instance, \
    iterator, \
    property_name, \
    p, \
    xctx \
) \
(instance)->inf->get_next_property_meta( \
    (instance), \
    (iterator), \
    (property_name), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method has_property of interface afw_object
 * @param instance Pointer to this object instance.
 * @param property_name Property name.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_has_property( \
    instance, \
    property_name, \
    xctx \
) \
(instance)->inf->has_property( \
    (instance), \
    (property_name), \
    (xctx) \
)

/**
 * @brief Call method get_setter of interface afw_object
 * @param instance Pointer to this object instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_get_setter( \
    instance, \
    xctx \
) \
(instance)->inf->get_setter( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_server_interface afw_server
 *
 * Adaptive framework server interface.
 *
 * @{
 */


/** @brief Interface afw_server public struct. */
struct afw_server_s {
    const afw_server_inf_t *inf;
    afw_xctx_t * xctx;
    const afw_object_t * properties;
    const afw_utf8_t * afw_compiled_version;
    const afw_utf8_t * afw_version;
    AFW_ATOMIC afw_integer_t concurrent;
    AFW_ATOMIC afw_integer_t max_concurrent;
    AFW_ATOMIC afw_integer_t request_count;
    const afw_utf8_t * server_type;
    const afw_utf8_t * server_version;
    const afw_dateTime_t * start_time;
    AFW_ATOMIC afw_integer_t thread_count;
    AFW_ATOMIC afw_integer_t unhandled_errors;
};

/** @brief define for interface afw_server name. */
#define AFW_SERVER_INTERFACE_NAME \
"afw_server"

/** @sa afw_server_release() */
typedef void
(*afw_server_release_t)(
    const afw_server_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_server_run() */
typedef void
(*afw_server_run_t)(
    const afw_server_t * instance,
    const afw_request_handler_t * handler,
    afw_xctx_t * xctx);

/** @brief Interface afw_server_inf_s struct. */
struct afw_server_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_server_release_t release;
    afw_server_run_t run;
};

/**
 * @brief Call method release of interface afw_server
 * @param instance Pointer to this adaptive server instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_server_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method run of interface afw_server
 * @param instance Pointer to this adaptive server instance.
 * @param handler Main request handler function.
 * @param xctx This is the caller's xctx.
 */
#define afw_server_run( \
    instance, \
    handler, \
    xctx \
) \
(instance)->inf->run( \
    (instance), \
    (handler), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_service_type_interface afw_service_type
 *
 * Adaptive framework service type interface. Each instance is registered in
 * the environment with type of "service_type" and id of the service type id.
 *
 * @{
 */


/** @brief Interface afw_service_type public struct. */
struct afw_service_type_s {
    const afw_service_type_inf_t *inf;
    afw_utf8_t service_type_id;
    const afw_utf8_t * title;
    const afw_utf8_t * description;
    const afw_environment_conf_type_t * conf_type;
    const afw_object_t * conf_type_object;
};

/** @brief define for interface afw_service_type name. */
#define AFW_SERVICE_TYPE_INTERFACE_NAME \
"afw_service_type"

/** @sa afw_service_type_related_instance_count() */
typedef afw_integer_t
(*afw_service_type_related_instance_count_t)(
    const afw_service_type_t * instance,
    const afw_utf8_t * id,
    afw_xctx_t * xctx);

/** @sa afw_service_type_start_cede_p() */
typedef void
(*afw_service_type_start_cede_p_t)(
    const afw_service_type_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_service_type_stop() */
typedef void
(*afw_service_type_stop_t)(
    const afw_service_type_t * instance,
    const afw_utf8_t * id,
    afw_xctx_t * xctx);

/** @sa afw_service_type_restart_cede_p() */
typedef void
(*afw_service_type_restart_cede_p_t)(
    const afw_service_type_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_service_type_inf_s struct. */
struct afw_service_type_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_service_type_related_instance_count_t related_instance_count;
    afw_service_type_start_cede_p_t start_cede_p;
    afw_service_type_stop_t stop;
    afw_service_type_restart_cede_p_t restart_cede_p;
};

/**
 * @brief Call method related_instance_count of interface afw_service_type
 * @param instance Pointer to this adaptive service type instance.
 * @param id Value of appropriate id property for type.
 * @param xctx This is the caller's xctx.
 */
#define afw_service_type_related_instance_count( \
    instance, \
    id, \
    xctx \
) \
(instance)->inf->related_instance_count( \
    (instance), \
    (id), \
    (xctx) \
)

/**
 * @brief Call method start_cede_p of interface afw_service_type
 * @param instance Pointer to this adaptive service type instance.
 * @param properties Properties for start. This object will already be checked
 *     to insure          the appropriate id and subtype property is present
 *     for the          type. Other than that, these properties need to be
 *     validated using         
 *     `/afw/_AdaptiveObjectType_/_AdaptiveConf_<type>_<subtype>`.
 * @param p Pool to cede to start.
 * @param xctx This is the caller's xctx.
 */
#define afw_service_type_start_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->start_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method stop of interface afw_service_type
 * @param instance Pointer to this adaptive service type instance.
 * @param id Value of appropriate id property for type.
 * @param xctx This is the caller's xctx.
 */
#define afw_service_type_stop( \
    instance, \
    id, \
    xctx \
) \
(instance)->inf->stop( \
    (instance), \
    (id), \
    (xctx) \
)

/**
 * @brief Call method restart_cede_p of interface afw_service_type
 * @param instance Pointer to this adaptive service type instance.
 * @param properties Properties for start. This object will already be checked
 *     to insure          the appropriate id and subtype property is present
 *     for the          type. Other than that, these properties need to be
 *     validated using         
 *     `/afw/_AdaptiveObjectType_/_AdaptiveConf_<type>_<subtype>`.
 * @param p Pool to cede to start.
 * @param xctx This is the caller's xctx.
 */
#define afw_service_type_restart_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->restart_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_object_associative_array_interface afw_object_associative_array
 *
 * 
 * This is interface for an object associative array.
 * 
 *
 * @{
 */


/** @brief Interface afw_object_associative_array public struct. */
struct afw_object_associative_array_s {
    const afw_object_associative_array_inf_t *inf;
    const afw_pool_t * p;
};

/** @brief define for interface afw_object_associative_array name. */
#define AFW_OBJECT_ASSOCIATIVE_ARRAY_INTERFACE_NAME \
"afw_object_associative_array"

/** @sa afw_object_associative_array_release() */
typedef void
(*afw_object_associative_array_release_t)(
    const afw_object_associative_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_add_reference() */
typedef void
(*afw_object_associative_array_add_reference_t)(
    const afw_object_associative_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_get() */
typedef const afw_object_t *
(*afw_object_associative_array_get_t)(
    const afw_object_associative_array_t * instance,
    const afw_utf8_t * key,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_get_reference() */
typedef const afw_object_t *
(*afw_object_associative_array_get_reference_t)(
    const afw_object_associative_array_t * instance,
    const afw_utf8_t * key,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_for_each() */
typedef void
(*afw_object_associative_array_for_each_t)(
    const afw_object_associative_array_t * instance,
    void * context,
    afw_object_cb_t cb,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_set() */
typedef void
(*afw_object_associative_array_set_t)(
    const afw_object_associative_array_t * instance,
    const afw_utf8_t * key,
    const afw_object_t * object,
    afw_xctx_t * xctx);

/** @brief Interface afw_object_associative_array_inf_s struct. */
struct afw_object_associative_array_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_object_associative_array_release_t release;
    afw_object_associative_array_add_reference_t add_reference;
    afw_object_associative_array_get_t get;
    afw_object_associative_array_get_reference_t get_reference;
    afw_object_associative_array_for_each_t for_each;
    afw_object_associative_array_set_t set;
};

/**
 * @brief Call method release of interface afw_object_associative_array
 * @param instance Pointer to this object associative array instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_associative_array_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method add_reference of interface afw_object_associative_array
 * @param instance Pointer to this object associative array instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_associative_array_add_reference( \
    instance, \
    xctx \
) \
(instance)->inf->add_reference( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get of interface afw_object_associative_array
 * @param instance Pointer to this object associative array instance.
 * @param key The key associated with the object.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_associative_array_get( \
    instance, \
    key, \
    xctx \
) \
(instance)->inf->get( \
    (instance), \
    (key), \
    (xctx) \
)

/**
 * @brief Call method get_reference of interface afw_object_associative_array
 * @param instance Pointer to this object associative array instance.
 * @param key The key associated with the object.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_associative_array_get_reference( \
    instance, \
    key, \
    xctx \
) \
(instance)->inf->get_reference( \
    (instance), \
    (key), \
    (xctx) \
)

/**
 * @brief Call method for_each of interface afw_object_associative_array
 * @param instance Pointer to this object associative array instance.
 * @param context Context passed to callback function.
 * @param cb Callback function.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_associative_array_for_each( \
    instance, \
    context, \
    cb, \
    xctx \
) \
(instance)->inf->for_each( \
    (instance), \
    (context), \
    (cb), \
    (xctx) \
)

/**
 * @brief Call method set of interface afw_object_associative_array
 * @param instance Pointer to this object associative array instance.
 * @param key The key associated with the object instance.
 * @param object Object instance to associate with the key or NULL to remove a
 *     key.
 * @param xctx This is the caller's xctx.
 */
#define afw_object_associative_array_set( \
    instance, \
    key, \
    object, \
    xctx \
) \
(instance)->inf->set( \
    (instance), \
    (key), \
    (object), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_request_handler_factory_interface afw_request_handler_factory
 *
 * Create an instance of an afw_request_handler.
 *
 * @{
 */


/** @brief Interface afw_request_handler_factory public struct. */
struct afw_request_handler_factory_s {
    const afw_request_handler_factory_inf_t *inf;
    afw_utf8_t request_handler_type;
    const afw_utf8_t * description;
};

/** @brief define for interface afw_request_handler_factory name. */
#define AFW_REQUEST_HANDLER_FACTORY_INTERFACE_NAME \
"afw_request_handler_factory"

/** @sa afw_request_handler_factory_create_request_handler_cede_p() */
typedef const afw_request_handler_t *
(*afw_request_handler_factory_create_request_handler_cede_p_t)(
    const afw_request_handler_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_request_handler_factory_inf_s struct. */
struct afw_request_handler_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_request_handler_factory_create_request_handler_cede_p_t create_request_handler_cede_p;
};

/**
 * @brief Call method create_request_handler_cede_p of interface
 *     afw_request_handler_factory
 * @param instance Pointer to this request handler factory instance.
 * @param properties Creation parameters for the particular type of request
 *     handler. This will become properties object for request handler.
 * @param p Pool to use for request handler resources.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_handler_factory_create_request_handler_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_request_handler_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_request_handler_interface afw_request_handler
 *
 * Adaptive framework request handler interface.
 *
 * @{
 */


/** @brief Interface afw_request_handler public struct. */
struct afw_request_handler_s {
    const afw_request_handler_inf_t *inf;
};

/** @brief define for interface afw_request_handler name. */
#define AFW_REQUEST_HANDLER_INTERFACE_NAME \
"afw_request_handler"

/** @sa afw_request_handler_release() */
typedef void
(*afw_request_handler_release_t)(
    const afw_request_handler_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_request_handler_process() */
typedef void
(*afw_request_handler_process_t)(
    const afw_request_handler_t * instance,
    const afw_request_t * request,
    afw_xctx_t * xctx);

/** @brief Interface afw_request_handler_inf_s struct. */
struct afw_request_handler_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_request_handler_release_t release;
    afw_request_handler_process_t process;
};

/**
 * @brief Call method release of interface afw_request_handler
 * @param instance Pointer to this adaptive request handler instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_handler_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method process of interface afw_request_handler
 * @param instance Pointer to this adaptive request instance.
 * @param request Buffer to store data read.
 * @param xctx Execution context (xctx) the request should run in. If this is a
 *     new          request session, this should be the request session's xctx.
 */
#define afw_request_handler_process( \
    instance, \
    request, \
    xctx \
) \
(instance)->inf->process( \
    (instance), \
    (request), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_connection_interface afw_connection
 *
 * Adaptive Framework connection. This has not yet been developed.
 *
 * @{
 */


/** @brief Interface afw_connection public struct. */
struct afw_connection_s {
    const afw_connection_inf_t *inf;
};

/** @brief define for interface afw_connection name. */
#define AFW_CONNECTION_INTERFACE_NAME \
"afw_connection"

/** @sa afw_connection_release() */
typedef void
(*afw_connection_release_t)(
    const afw_connection_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_connection_inf_s struct. */
struct afw_connection_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_connection_release_t release;
};

/**
 * @brief Call method release of interface afw_connection
 * @param instance Pointer to this adaptive request instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_connection_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_request_interface afw_request
 *
 * Adaptive framework request interface.
 *
 * @{
 */


/** @brief Interface afw_request public struct. */
struct afw_request_s {
    const afw_request_inf_t *inf;
    afw_xctx_t * xctx;
    afw_read_cb_t read_content_cb;
    afw_write_cb_t write_content_cb;
    const afw_object_t * properties;
    const afw_utf8_t * method;
    const afw_utf8_t * uri;
    const afw_utf8_t * query_string;
    const afw_utf8_t * content_type;
    afw_size_t content_length;
    const afw_utf8_t * const * accept;
    const afw_object_t * error_info;
    const afw_content_type_t * response_content_type;
    afw_boolean_t is_closed;
};

/** @brief define for interface afw_request name. */
#define AFW_REQUEST_INTERFACE_NAME \
"afw_request"

/** @sa afw_request_release() */
typedef void
(*afw_request_release_t)(
    const afw_request_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_request_set_error_info() */
typedef void
(*afw_request_set_error_info_t)(
    const afw_request_t * instance,
    const afw_object_t * error_info,
    afw_xctx_t * xctx);

/** @sa afw_request_read_raw_request_body() */
typedef void
(*afw_request_read_raw_request_body_t)(
    const afw_request_t * instance,
    afw_size_t buffer_size,
    void * buffer,
    afw_size_t * size,
    afw_boolean_t * more_to_read,
    afw_xctx_t * xctx);

/** @sa afw_request_set_response_status_code() */
typedef void
(*afw_request_set_response_status_code_t)(
    const afw_request_t * instance,
    const afw_utf8_t * code,
    const afw_utf8_t * reason,
    afw_xctx_t * xctx);

/** @sa afw_request_write_response_header() */
typedef void
(*afw_request_write_response_header_t)(
    const afw_request_t * instance,
    const afw_utf8_t * name,
    const afw_utf8_t * value,
    afw_xctx_t * xctx);

/** @sa afw_request_write_raw_response_body() */
typedef void
(*afw_request_write_raw_response_body_t)(
    const afw_request_t * instance,
    afw_size_t size,
    const void * buffer,
    afw_xctx_t * xctx);

/** @sa afw_request_flush_response() */
typedef void
(*afw_request_flush_response_t)(
    const afw_request_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_request_finish_response() */
typedef void
(*afw_request_finish_response_t)(
    const afw_request_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_request_inf_s struct. */
struct afw_request_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_request_release_t release;
    afw_request_set_error_info_t set_error_info;
    afw_request_read_raw_request_body_t read_raw_request_body;
    afw_request_set_response_status_code_t set_response_status_code;
    afw_request_write_response_header_t write_response_header;
    afw_request_write_raw_response_body_t write_raw_response_body;
    afw_request_flush_response_t flush_response;
    afw_request_finish_response_t finish_response;
};

/**
 * @brief Call method release of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method set_error_info of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param error_info Error info object pointer.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_set_error_info( \
    instance, \
    error_info, \
    xctx \
) \
(instance)->inf->set_error_info( \
    (instance), \
    (error_info), \
    (xctx) \
)

/**
 * @brief Call method read_raw_request_body of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param buffer_size Length of the buffer in bytes.
 * @param buffer Buffer to store data read.
 * @param size Place to return number of bytes read.
 * @param more_to_read Indicate there is more input to read.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_read_raw_request_body( \
    instance, \
    buffer_size, \
    buffer, \
    size, \
    more_to_read, \
    xctx \
) \
(instance)->inf->read_raw_request_body( \
    (instance), \
    (buffer_size), \
    (buffer), \
    (size), \
    (more_to_read), \
    (xctx) \
)

/**
 * @brief Call method set_response_status_code of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param code Three-digit status code that conforms to http RFC.
 * @param reason Status reason phrase. If NULL and the status_code is standard,
 *     the standard phrase is supplied.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_set_response_status_code( \
    instance, \
    code, \
    reason, \
    xctx \
) \
(instance)->inf->set_response_status_code( \
    (instance), \
    (code), \
    (reason), \
    (xctx) \
)

/**
 * @brief Call method write_response_header of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param name Type of header.
 * @param value Value of header.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_write_response_header( \
    instance, \
    name, \
    value, \
    xctx \
) \
(instance)->inf->write_response_header( \
    (instance), \
    (name), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method write_raw_response_body of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param size Number of bytes in buffer to write.
 * @param buffer Buffer to write.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_write_raw_response_body( \
    instance, \
    size, \
    buffer, \
    xctx \
) \
(instance)->inf->write_raw_response_body( \
    (instance), \
    (size), \
    (buffer), \
    (xctx) \
)

/**
 * @brief Call method flush_response of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_flush_response( \
    instance, \
    xctx \
) \
(instance)->inf->flush_response( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method finish_response of interface afw_request
 * @param instance Pointer to this adaptive request instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_request_finish_response( \
    instance, \
    xctx \
) \
(instance)->inf->finish_response( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_xctx_interface afw_xctx
 *
 * 
 * Adaptive Framework Execution Context (xctx) interface.
 * 
 * An execution context holds common information related to a unit of
 * work in
 * Adaptive Framework. This unit of work runs in a single thread of a
 * single-threaded or multi-threaded process. In a multi-threaded
 * process,
 * the main thread has the global execution context. Other threads have
 * their
 * own execution context and required the appropriate mutexes or queued
 * work
 * to access memory in the global execution context.
 * 
 * The type of execution contexts can be "server", "request_session',
 * etc. A
 * execution context's pool, properties, and object cache will last for
 * the
 * life of the execution context. An execution context's parent will
 * always
 * have a longer life.
 * 
 *
 * @{
 */


/** @brief Interface afw_xctx public struct. */
struct afw_xctx_s {
    const afw_xctx_inf_t *inf;
    const afw_pool_t * p;
    const afw_utf8_t * name;
    afw_xctx_t * parent;
    const afw_environment_t * env;
    const afw_thread_t * thread;
    const afw_request_t * request;
    const afw_utf8_t * uuid;
    const afw_object_t * properties;
    const afw_value_t * mode;
    const afw_stream_anchor_t * stream_anchor;
    afw_integer_t write_sequence;
    void * priv;
    afw_error_t * error;
    afw_try_t * current_try;
    const afw_runtime_objects_t * runtime_objects;
    afw_size_t scope_count;
    apr_array_header_t * scope_stack;
    const afw_value_t * evaluation_result;
    afw_xctx_evaluation_stack_t * evaluation_stack;
    const afw_xctx_qualifier_stack_t * qualifier_stack;
    afw_adaptor_xctx_internal_t * adaptor_xctx_internal;
    afw_adaptor_internal_cache_t * cache;
    afw_dateTime_t local_dateTime_when_created;
    afw_dateTime_t utc_dateTime_when_created;
    afw_size_t flags_count;
    const afw_boolean_t * flags;
    afw_boolean_t flags_is_mutable_copy;
    void * libxml2_error_func;
    afw_boolean_t secure;
};

/** @brief define for interface afw_xctx name. */
#define AFW_XCTX_INTERFACE_NAME \
"afw_xctx"

/** @sa afw_xctx_release() */
typedef void
(*afw_xctx_release_t)(
    const afw_xctx_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_xctx_inf_s struct. */
struct afw_xctx_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_xctx_release_t release;
};

/**
 * @brief Call method release of interface afw_xctx
 * @param instance Pointer to this adaptive request instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_xctx_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_stream_interface afw_stream
 *
 * An interface for a stream.
 *
 * @{
 */


/** @brief Interface afw_stream public struct. */
struct afw_stream_s {
    const afw_stream_inf_t *inf;
    const afw_pool_t * p;
    const afw_utf8_t * streamId;
    afw_read_cb_t read_cb;
    afw_write_cb_t write_cb;
    const afw_boolean_t is_standard;
};

/** @brief define for interface afw_stream name. */
#define AFW_STREAM_INTERFACE_NAME \
"afw_stream"

/** @sa afw_stream_release() */
typedef void
(*afw_stream_release_t)(
    const afw_stream_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_stream_flush() */
typedef void
(*afw_stream_flush_t)(
    const afw_stream_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_stream_read() */
typedef void
(*afw_stream_read_t)(
    const afw_stream_t * instance,
    const void * buffer,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_stream_write() */
typedef void
(*afw_stream_write_t)(
    const afw_stream_t * instance,
    const void * buffer,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @brief Interface afw_stream_inf_s struct. */
struct afw_stream_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_stream_release_t release;
    afw_stream_flush_t flush;
    afw_stream_read_t read;
    afw_stream_write_t write;
};

/**
 * @brief Call method release of interface afw_stream
 * @param instance Pointer to this stream instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_stream_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method flush of interface afw_stream
 * @param instance Pointer to this stream instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_stream_flush( \
    instance, \
    xctx \
) \
(instance)->inf->flush( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method read of interface afw_stream
 * @param instance Pointer to this stream instance.
 * @param buffer Buffer to write.
 * @param size Size of buffer.
 * @param xctx This is the caller's xctx.
 */
#define afw_stream_read( \
    instance, \
    buffer, \
    size, \
    xctx \
) \
(instance)->inf->read( \
    (instance), \
    (buffer), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method write of interface afw_stream
 * @param instance Pointer to this stream instance.
 * @param buffer Buffer to write.
 * @param size Size of buffer.
 * @param xctx This is the caller's xctx.
 */
#define afw_stream_write( \
    instance, \
    buffer, \
    size, \
    xctx \
) \
(instance)->inf->write( \
    (instance), \
    (buffer), \
    (size), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_pool_interface afw_pool
 *
 * 
 * Adaptive framework pool interface.
 * 
 *
 * @{
 */


/** @brief Interface afw_pool public struct. */
struct afw_pool_s {
    const afw_pool_inf_t *inf;
};

/** @brief define for interface afw_pool name. */
#define AFW_POOL_INTERFACE_NAME \
"afw_pool"

/** @sa afw_pool_release() */
typedef void
(*afw_pool_release_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_pool_add_reference() */
typedef void
(*afw_pool_add_reference_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_pool_destroy() */
typedef void
(*afw_pool_destroy_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_pool_get_apr_pool() */
typedef apr_pool_t *
(*afw_pool_get_apr_pool_t)(
    const afw_pool_t * instance);

/** @sa afw_pool_calloc() */
typedef void *
(*afw_pool_calloc_t)(
    const afw_pool_t * instance,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_pool_malloc() */
typedef void *
(*afw_pool_malloc_t)(
    const afw_pool_t * instance,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_pool_free() */
typedef void
(*afw_pool_free_t)(
    const afw_pool_t * instance,
    void * address,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_pool_register_cleanup_before() */
typedef void
(*afw_pool_register_cleanup_before_t)(
    const afw_pool_t * instance,
    void * data,
    void * data2,
    afw_pool_cleanup_function_p_t cleanup,
    afw_xctx_t * xctx);

/** @sa afw_pool_deregister_cleanup() */
typedef void
(*afw_pool_deregister_cleanup_t)(
    const afw_pool_t * instance,
    void * data,
    void * data2,
    afw_pool_cleanup_function_p_t cleanup,
    afw_xctx_t * xctx);

/** @sa afw_pool_release_debug() */
typedef void
(*afw_pool_release_debug_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @sa afw_pool_add_reference_debug() */
typedef void
(*afw_pool_add_reference_debug_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @sa afw_pool_destroy_debug() */
typedef void
(*afw_pool_destroy_debug_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @sa afw_pool_calloc_debug() */
typedef void *
(*afw_pool_calloc_debug_t)(
    const afw_pool_t * instance,
    afw_size_t size,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @sa afw_pool_malloc_debug() */
typedef void *
(*afw_pool_malloc_debug_t)(
    const afw_pool_t * instance,
    afw_size_t size,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @sa afw_pool_free_debug() */
typedef void
(*afw_pool_free_debug_t)(
    const afw_pool_t * instance,
    void * address,
    afw_size_t size,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @sa afw_pool_register_cleanup_before_debug() */
typedef void
(*afw_pool_register_cleanup_before_debug_t)(
    const afw_pool_t * instance,
    void * data,
    void * data2,
    afw_pool_cleanup_function_p_t cleanup,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @sa afw_pool_deregister_cleanup_debug() */
typedef void
(*afw_pool_deregister_cleanup_debug_t)(
    const afw_pool_t * instance,
    void * data,
    void * data2,
    afw_pool_cleanup_function_p_t cleanup,
    afw_xctx_t * xctx,
    const afw_utf8_z_t * source_z);

/** @brief Interface afw_pool_inf_s struct. */
struct afw_pool_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_pool_release_t release;
    afw_pool_add_reference_t add_reference;
    afw_pool_destroy_t destroy;
    afw_pool_get_apr_pool_t get_apr_pool;
    afw_pool_calloc_t calloc;
    afw_pool_malloc_t malloc;
    afw_pool_free_t free;
    afw_pool_register_cleanup_before_t register_cleanup_before;
    afw_pool_deregister_cleanup_t deregister_cleanup;
    afw_pool_release_debug_t release_debug;
    afw_pool_add_reference_debug_t add_reference_debug;
    afw_pool_destroy_debug_t destroy_debug;
    afw_pool_calloc_debug_t calloc_debug;
    afw_pool_malloc_debug_t malloc_debug;
    afw_pool_free_debug_t free_debug;
    afw_pool_register_cleanup_before_debug_t register_cleanup_before_debug;
    afw_pool_deregister_cleanup_debug_t deregister_cleanup_debug;
};

/**
 * @brief Call method release of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method add_reference of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_add_reference( \
    instance, \
    xctx \
) \
(instance)->inf->add_reference( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method destroy of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_apr_pool of interface afw_pool
 * @param instance Pointer to this pool instance.
 */
#define afw_pool_get_apr_pool( \
    instance \
) \
(instance)->inf->get_apr_pool( \
    (instance) \
)

/**
 * @brief Call method calloc of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param size Size of memory to allocate.
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_calloc( \
    instance, \
    size, \
    xctx \
) \
(instance)->inf->calloc( \
    (instance), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method malloc of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param size Size of memory to allocate.
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_malloc( \
    instance, \
    size, \
    xctx \
) \
(instance)->inf->malloc( \
    (instance), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method free of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param address Address of memory to free.
 * @param size Size of memory to free.
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_free( \
    instance, \
    address, \
    size, \
    xctx \
) \
(instance)->inf->free( \
    (instance), \
    (address), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method register_cleanup_before of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param data Data to pass to the cleanup function.
 * @param data2 Data2 to pass to the cleanup function.
 * @param cleanup Cleanup function to call when pool is released..
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_register_cleanup_before( \
    instance, \
    data, \
    data2, \
    cleanup, \
    xctx \
) \
(instance)->inf->register_cleanup_before( \
    (instance), \
    (data), \
    (data2), \
    (cleanup), \
    (xctx) \
)

/**
 * @brief Call method deregister_cleanup of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param data Data to pass to the cleanup function.
 * @param data2 Data2 to pass to the cleanup function.
 * @param cleanup Cleanup function to call when pool is released..
 * @param xctx This is the caller's xctx.
 */
#define afw_pool_deregister_cleanup( \
    instance, \
    data, \
    data2, \
    cleanup, \
    xctx \
) \
(instance)->inf->deregister_cleanup( \
    (instance), \
    (data), \
    (data2), \
    (cleanup), \
    (xctx) \
)

/**
 * @brief Call method release_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_release_debug( \
    instance, \
    xctx, \
    source_z \
) \
(instance)->inf->release_debug( \
    (instance), \
    (xctx), \
    (source_z) \
)

/**
 * @brief Call method add_reference_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_add_reference_debug( \
    instance, \
    xctx, \
    source_z \
) \
(instance)->inf->add_reference_debug( \
    (instance), \
    (xctx), \
    (source_z) \
)

/**
 * @brief Call method destroy_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_destroy_debug( \
    instance, \
    xctx, \
    source_z \
) \
(instance)->inf->destroy_debug( \
    (instance), \
    (xctx), \
    (source_z) \
)

/**
 * @brief Call method calloc_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param size Size of memory to allocate.
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_calloc_debug( \
    instance, \
    size, \
    xctx, \
    source_z \
) \
(instance)->inf->calloc_debug( \
    (instance), \
    (size), \
    (xctx), \
    (source_z) \
)

/**
 * @brief Call method malloc_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param size Size of memory to allocate.
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_malloc_debug( \
    instance, \
    size, \
    xctx, \
    source_z \
) \
(instance)->inf->malloc_debug( \
    (instance), \
    (size), \
    (xctx), \
    (source_z) \
)

/**
 * @brief Call method free_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param address Address of memory to free.
 * @param size Size of memory to free.
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_free_debug( \
    instance, \
    address, \
    size, \
    xctx, \
    source_z \
) \
(instance)->inf->free_debug( \
    (instance), \
    (address), \
    (size), \
    (xctx), \
    (source_z) \
)

/**
 * @brief Call method register_cleanup_before_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param data Data to pass to the cleanup function.
 * @param data2 Data2 to pass to the cleanup function.
 * @param cleanup Cleanup function to call when pool is released..
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_register_cleanup_before_debug( \
    instance, \
    data, \
    data2, \
    cleanup, \
    xctx, \
    source_z \
) \
(instance)->inf->register_cleanup_before_debug( \
    (instance), \
    (data), \
    (data2), \
    (cleanup), \
    (xctx), \
    (source_z) \
)

/**
 * @brief Call method deregister_cleanup_debug of interface afw_pool
 * @param instance Pointer to this pool instance.
 * @param data Data to pass to the cleanup function.
 * @param data2 Data2 to pass to the cleanup function.
 * @param cleanup Cleanup function to call when pool is released..
 * @param xctx This is the caller's xctx.
 * @param source_z Source file:line where method was called.
 */
#define afw_pool_deregister_cleanup_debug( \
    instance, \
    data, \
    data2, \
    cleanup, \
    xctx, \
    source_z \
) \
(instance)->inf->deregister_cleanup_debug( \
    (instance), \
    (data), \
    (data2), \
    (cleanup), \
    (xctx), \
    (source_z) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_journal_interface afw_adaptor_journal
 *
 * Adaptor journal interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor_journal public struct. */
struct afw_adaptor_journal_s {
    const afw_adaptor_journal_inf_t *inf;
    const afw_adaptor_session_t * session;
};

/** @brief define for interface afw_adaptor_journal name. */
#define AFW_ADAPTOR_JOURNAL_INTERFACE_NAME \
"afw_adaptor_journal"

/** @sa afw_adaptor_journal_add_entry() */
typedef const afw_utf8_t *
(*afw_adaptor_journal_add_entry_t)(
    const afw_adaptor_journal_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_object_t * entry,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_journal_get_entry() */
typedef void
(*afw_adaptor_journal_get_entry_t)(
    const afw_adaptor_journal_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    afw_adaptor_journal_option_t option,
    const afw_utf8_t * consumer_id,
    const afw_utf8_t * entry_cursor,
    afw_size_t limit,
    const afw_object_t * response,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_journal_mark_entry_consumed() */
typedef void
(*afw_adaptor_journal_mark_entry_consumed_t)(
    const afw_adaptor_journal_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * consumer_id,
    const afw_utf8_t * entry_cursor,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_journal_inf_s struct. */
struct afw_adaptor_journal_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_journal_add_entry_t add_entry;
    afw_adaptor_journal_get_entry_t get_entry;
    afw_adaptor_journal_mark_entry_consumed_t mark_entry_consumed;
};

/**
 * @brief Call method add_entry of interface afw_adaptor_journal
 * @param instance Pointer to this adaptive event journal instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param entry Pointer to the event to be logged in the journal.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_journal_add_entry( \
    instance, \
    impl_request, \
    entry, \
    xctx \
) \
(instance)->inf->add_entry( \
    (instance), \
    (impl_request), \
    (entry), \
    (xctx) \
)

/**
 * @brief Call method get_entry of interface afw_adaptor_journal
 * @param instance Pointer to this adaptive event journal instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param option Get entry option. See afw_adaptor_journal_option_t for        
 *      more information.
 * @param consumer_id Peer id of consumer of event of NULL. See         
 *     afw_adaptor_journal_option_t for information on how this         
 *     parameter is used or ignored.
 * @param entry_cursor Journal entry cursor or NULL. See         
 *     afw_adaptor_journal_option_t for information on how this         
 *     parameter is used or ignored.
 * @param limit Limit or 0. See          afw_adaptor_journal_option_t for
 *     information on how this          parameter is used or ignored.
 * @param response This is an existing response object that can have properties
 *     already          set. Depending on the option specified, get_entry()
 *     will set          additional properties. See
 *     afw_adaptor_journal_option_t          for information on which
 *     properties are set and under what condition.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_journal_get_entry( \
    instance, \
    impl_request, \
    option, \
    consumer_id, \
    entry_cursor, \
    limit, \
    response, \
    xctx \
) \
(instance)->inf->get_entry( \
    (instance), \
    (impl_request), \
    (option), \
    (consumer_id), \
    (entry_cursor), \
    (limit), \
    (response), \
    (xctx) \
)

/**
 * @brief Call method mark_entry_consumed of interface afw_adaptor_journal
 * @param instance Pointer to this adaptive event journal instance.
 * @param impl_request Pass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.          See afw_adaptor_impl.h
 *     for more information.
 * @param consumer_id Get entry option. See afw_adaptor_journal_option_t for   
 *           more information.
 * @param entry_cursor Token of the event to mark consumed.
 * @param xctx This is the caller's xctx.
 */
#define afw_adaptor_journal_mark_entry_consumed( \
    instance, \
    impl_request, \
    consumer_id, \
    entry_cursor, \
    xctx \
) \
(instance)->inf->mark_entry_consumed( \
    (instance), \
    (impl_request), \
    (consumer_id), \
    (entry_cursor), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_value_interface afw_value
 *
 * Adaptive value.
 *
 * @{
 */


/** @brief Interface afw_value public struct. */
struct afw_value_s {
    const afw_value_inf_t *inf;
};

/** @brief define for interface afw_value name. */
#define AFW_VALUE_INTERFACE_NAME \
"afw_value"

/** @sa afw_value_optional_release() */
typedef void
(*afw_value_optional_release_t)(
    const afw_value_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_value_get_reference() */
typedef const afw_value_t *
(*afw_value_get_reference_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_optional_evaluate() */
typedef const afw_value_t *
(*afw_value_optional_evaluate_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_get_data_type() */
typedef const afw_data_type_t *
(*afw_value_get_data_type_t)(
    const afw_value_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_value_get_evaluated_meta() */
typedef const afw_value_t *
(*afw_value_get_evaluated_meta_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_get_evaluated_metas() */
typedef const afw_value_t *
(*afw_value_get_evaluated_metas_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_produce_compiler_listing() */
typedef void
(*afw_value_produce_compiler_listing_t)(
    const afw_value_t * instance,
    const afw_writer_t * writer,
    afw_xctx_t * xctx);

/** @sa afw_value_decompile() */
typedef void
(*afw_value_decompile_t)(
    const afw_value_t * instance,
    const afw_writer_t * writer,
    afw_xctx_t * xctx);

/** @sa afw_value_get_info() */
typedef void
(*afw_value_get_info_t)(
    const afw_value_t * instance,
    afw_value_info_t * info,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_value_inf_s struct. */
struct afw_value_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_value_optional_release_t optional_release;
    afw_value_get_reference_t get_reference;
    afw_value_optional_evaluate_t optional_evaluate;
    afw_value_get_data_type_t get_data_type;
    afw_value_get_evaluated_meta_t get_evaluated_meta;
    afw_value_get_evaluated_metas_t get_evaluated_metas;
    afw_value_produce_compiler_listing_t produce_compiler_listing;
    afw_value_decompile_t decompile;
    afw_value_get_info_t get_info;
    const afw_data_type_t * data_type;
    const afw_data_type_t * is_evaluated_of_data_type;
};

/**
 * @brief Call method optional_release of interface afw_value
 * @param instance Pointer to this pool instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_optional_release( \
    instance, \
    xctx \
) \
(instance)->inf->optional_release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_reference of interface afw_value
 * @param instance Pointer to this adaptive value instance.
 * @param p Pool for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_get_reference( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_reference( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method optional_evaluate of interface afw_value
 * @param instance Pointer to this adaptive value instance.
 * @param p Pool for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_optional_evaluate( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->optional_evaluate( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_data_type of interface afw_value
 * @param instance Pointer to this adaptive value instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_get_data_type( \
    instance, \
    xctx \
) \
(instance)->inf->get_data_type( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_evaluated_meta of interface afw_value
 * @param instance Pointer to this adaptive value instance.                   
 *     IMPORTANT: Do not evaluate instance before calling since meta is
 *     harvested from the value's inf.
 * @param p Pool to use for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_get_evaluated_meta( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_evaluated_meta( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_evaluated_metas of interface afw_value
 * @param instance Pointer to this adaptive value instance.                   
 *     NOTE: Always evaluate instance before calling so that right value inf is
 *     used.
 * @param p Pool to use for result.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_get_evaluated_metas( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_evaluated_metas( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method produce_compiler_listing of interface afw_value
 * @param instance Pointer to this adaptive value instance.
 * @param writer Pointer to writer instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_produce_compiler_listing( \
    instance, \
    writer, \
    xctx \
) \
(instance)->inf->produce_compiler_listing( \
    (instance), \
    (writer), \
    (xctx) \
)

/**
 * @brief Call method decompile of interface afw_value
 * @param instance Pointer to this adaptive value instance.
 * @param writer Pointer to writer instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_decompile( \
    instance, \
    writer, \
    xctx \
) \
(instance)->inf->decompile( \
    (instance), \
    (writer), \
    (xctx) \
)

/**
 * @brief Call method get_info of interface afw_value
 * @param instance Pointer to this adaptive value instance.
 * @param info Struct that will be filled by this method with info about this
 *     value.
 * @param p Pool to use if needed.
 * @param xctx This is the caller's xctx.
 */
#define afw_value_get_info( \
    instance, \
    info, \
    p, \
    xctx \
) \
(instance)->inf->get_info( \
    (instance), \
    (info), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_variable_handler_interface afw_variable_handler
 *
 * Adaptive variable handler.
 *
 * @{
 */


/** @brief Interface afw_variable_handler public struct. */
struct afw_variable_handler_s {
    const afw_variable_handler_inf_t *inf;
};

/** @brief define for interface afw_variable_handler name. */
#define AFW_VARIABLE_HANDLER_INTERFACE_NAME \
"afw_variable_handler"

/** @sa afw_variable_handler_get_variable() */
typedef const afw_value_t *
(*afw_variable_handler_get_variable_t)(
    const afw_variable_handler_t * instance,
    const afw_utf8_t * qualifier,
    const afw_utf8_t * name,
    afw_xctx_t * xctx);

/** @sa afw_variable_handler_set_variable() */
typedef afw_boolean_t
(*afw_variable_handler_set_variable_t)(
    const afw_variable_handler_t * instance,
    const afw_utf8_t * qualifier,
    const afw_utf8_t * name,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @brief Interface afw_variable_handler_inf_s struct. */
struct afw_variable_handler_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_variable_handler_get_variable_t get_variable;
    afw_variable_handler_set_variable_t set_variable;
};

/**
 * @brief Call method get_variable of interface afw_variable_handler
 * @param instance Pointer to this adaptive variable handler instance.
 * @param qualifier Qualifier or NULL.
 * @param name Variable name.
 * @param xctx This is the caller's xctx.
 */
#define afw_variable_handler_get_variable( \
    instance, \
    qualifier, \
    name, \
    xctx \
) \
(instance)->inf->get_variable( \
    (instance), \
    (qualifier), \
    (name), \
    (xctx) \
)

/**
 * @brief Call method set_variable of interface afw_variable_handler
 * @param instance Pointer to this adaptive variable handler instance.
 * @param qualifier Qualifier or NULL.
 * @param name Variable name.
 * @param value Value to set.
 * @param xctx This is the caller's xctx.
 */
#define afw_variable_handler_set_variable( \
    instance, \
    qualifier, \
    name, \
    value, \
    xctx \
) \
(instance)->inf->set_variable( \
    (instance), \
    (qualifier), \
    (name), \
    (value), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_writer_interface afw_writer
 *
 * An interface for a writer.
 *
 * @{
 */


/** @brief Interface afw_writer public struct. */
struct afw_writer_s {
    const afw_writer_inf_t *inf;
    const afw_pool_t * p;
    afw_write_cb_t write_raw_cb;
    afw_size_t indent;
    const afw_utf8_t * tab;
};

/** @brief define for interface afw_writer name. */
#define AFW_WRITER_INTERFACE_NAME \
"afw_writer"

/** @sa afw_writer_release() */
typedef void
(*afw_writer_release_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_flush() */
typedef void
(*afw_writer_flush_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_write() */
typedef void
(*afw_writer_write_t)(
    const afw_writer_t * instance,
    const void * buffer,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_writer_write_eol() */
typedef void
(*afw_writer_write_eol_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_increment_indent() */
typedef void
(*afw_writer_increment_indent_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_decrement_indent() */
typedef void
(*afw_writer_decrement_indent_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_writer_inf_s struct. */
struct afw_writer_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_writer_release_t release;
    afw_writer_flush_t flush;
    afw_writer_write_t write;
    afw_writer_write_eol_t write_eol;
    afw_writer_increment_indent_t increment_indent;
    afw_writer_decrement_indent_t decrement_indent;
};

/**
 * @brief Call method release of interface afw_writer
 * @param instance Pointer to this writer instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_writer_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method flush of interface afw_writer
 * @param instance Pointer to this writer instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_writer_flush( \
    instance, \
    xctx \
) \
(instance)->inf->flush( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method write of interface afw_writer
 * @param instance Pointer to this writer instance.
 * @param buffer Buffer to write.
 * @param size Size of buffer.
 * @param xctx This is the caller's xctx.
 */
#define afw_writer_write( \
    instance, \
    buffer, \
    size, \
    xctx \
) \
(instance)->inf->write( \
    (instance), \
    (buffer), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method write_eol of interface afw_writer
 * @param instance Pointer to this writer instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_writer_write_eol( \
    instance, \
    xctx \
) \
(instance)->inf->write_eol( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method increment_indent of interface afw_writer
 * @param instance Pointer to this writer instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_writer_increment_indent( \
    instance, \
    xctx \
) \
(instance)->inf->increment_indent( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method decrement_indent of interface afw_writer
 * @param instance Pointer to this writer instance.
 * @param xctx This is the caller's xctx.
 */
#define afw_writer_decrement_indent( \
    instance, \
    xctx \
) \
(instance)->inf->decrement_indent( \
    (instance), \
    (xctx) \
)

/** @} */


/** @} */

AFW_END_DECLARES



#endif /* __AFW_INTERFACE_H__ */
