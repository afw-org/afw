// See the 'COPYING' file in the project root for licensing information.
/*
 * Interface afw_interface Header
 *
 * Copyright (c) 2010-2024 Clemson University
 *
 */

/*  ----------------------------- N O T E -------------------------------------
 *
 * This file is generated by "afwdev generate afw".
 *
 * Do not change this file directly or the changes will be lost the next time
 * this file is regenerated.
 *
 * -------------------------------------------------------------------------*/


#ifndef __AFW_INTERFACE_H__
#define __AFW_INTERFACE_H__


/**
 * @file afw_interface.h
 * @brief Interfaceafw_interface header.
 */

#include "afw_interface_common.h"
#include "afw_interface_opaques.h"
#include "afw_common_opaques.h"

AFW_BEGIN_DECLARES

/**
 * @addtogroup afw_interface Interfaces
 *
 * @{
 */

/**
 * @addtogroup afw_extension_interface afw_extension
 *
 * Interface returned from afw_extension_initialize() of an
 * Adaptive Framework environment extension module. Additional
 * information about an extension is found in `object
 * /afw/_AdaptiveManifest_/<extension_id>`.
 *
 * @{
 */


/** @brief Interface afw_extension public struct. */
struct afw_extension_s {
    const afw_extension_inf_t *inf;

    /**
     * Id of this extension.
     */
    afw_utf8_t extension_id;

    /**
     * Version of this extension.
     */
    afw_utf8_t extension_version;

    /**
     * Version of libafw this extension was compiled against.
     */
    afw_utf8_t afw_compiled_version;

    /**
     * The hex version of libafw this extension was compiled against.
     */
    unsigned int afw_compiled_version_hex;
};

/** @brief define for interface afw_extension name. */
#define AFW_EXTENSION_INTERFACE_NAME \
"afw_extension"

/** @sa afw_extension_initialize() */
typedef const afw_extension_t *
(*afw_extension_initialize_t)(
    const afw_extension_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_extension_release() */
typedef void
(*afw_extension_release_t)(
    const afw_extension_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_extension_inf_s struct. */
struct afw_extension_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_extension_initialize_t initialize;
    afw_extension_release_t release;
};

/**
 * @brief Call method initialize of interface afw_extension
 * @param instanceThis extension's instance.
 * @param propertiesThis is the properties supplied to
 *     afw_environment_load_extension() or NULL.
 * @param pThis is the pool to use for extension resources.
 * @param xctxThis is the caller's xctx.
 */
#define afw_extension_initialize( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->initialize( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method release of interface afw_extension
 * @param instancePointer to this adaptor instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_extension_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_factory_interface afw_adaptor_factory
 *
 * Factory to create an instance of an afw_adaptor.
 *
 * @{
 */


/** @brief Interface afw_adaptor_factory public struct. */
struct afw_adaptor_factory_s {
    const afw_adaptor_factory_inf_t *inf;

    /**
     * Type of adaptor this factory creates.
     */
    afw_utf8_t adaptor_type;

    /**
     * Type of adaptor this factory creates.
     */
    const afw_utf8_t * description;
};

/** @brief define for interface afw_adaptor_factory name. */
#define AFW_ADAPTOR_FACTORY_INTERFACE_NAME \
"afw_adaptor_factory"

/** @sa afw_adaptor_factory_create_adaptor_cede_p() */
typedef const afw_adaptor_t *
(*afw_adaptor_factory_create_adaptor_cede_p_t)(
    const afw_adaptor_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_factory_inf_s struct. */
struct afw_adaptor_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_factory_create_adaptor_cede_p_t create_adaptor_cede_p;
};

/**
 * @brief Call method create_adaptor_cede_p of interface afw_adaptor_factory
 * @param instancePointer to this adaptor instance.
 * @param propertiesConfiguration parameters for the particular type of adaptor.
 *     This
 *     will become the properties object for adaptor.
 * @param pThe pool that will be used for adaptor resources.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_factory_create_adaptor_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_adaptor_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_interface afw_adaptor
 *
 * Adaptor interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor public struct. */
struct afw_adaptor_s {
    const afw_adaptor_inf_t *inf;

    /**
     * Adaptor's pool. This pool will exist for the life of the adaptor.
     */
    const afw_pool_t * p;

    /**
     * Id of adaptor.
     */
    afw_utf8_t adaptor_id;

    /**
     * Id of adaptor type.
     */
    const afw_utf8_t * adaptor_type_id;

    /**
     * This is the associated service id. The path of the service is
     * "/afw/_AdaptiveService_/" followed by this id.
     */
    const afw_utf8_t * service_id;

    /**
     * This adaptor's properties (configuration) object.
     */
    const afw_object_t * properties;

    /**
     * This is the source location to help determine how this adaptor was
     * defined.
     */
    const afw_utf8_t * source_location;

    /**
     * This is the basic trace flag id for this adaptor's adaptor id.
     */
    const afw_utf8_t * trace_flag_id;

    /**
     * This is the basic trace flag index for this adaptor's adaptor id.
     */
    afw_size_t trace_flag_index;

    /**
     * This is the detail trace flag id for this adaptor's adaptor id.
     */
    const afw_utf8_t * detail_flag_id;

    /**
     * This is the detail trace flag index for this adaptor's adaptor id.
     */
    afw_size_t detail_flag_index;

    /**
     * Used by adaptor common code.
     */
    const afw_adaptor_impl_t * impl;
};

/** @brief define for interface afw_adaptor name. */
#define AFW_ADAPTOR_INTERFACE_NAME \
"afw_adaptor"

/** @sa afw_adaptor_destroy() */
typedef void
(*afw_adaptor_destroy_t)(
    const afw_adaptor_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_create_adaptor_session() */
typedef const afw_adaptor_session_t *
(*afw_adaptor_create_adaptor_session_t)(
    const afw_adaptor_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_get_additional_metrics() */
typedef const afw_object_t *
(*afw_adaptor_get_additional_metrics_t)(
    const afw_adaptor_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_inf_s struct. */
struct afw_adaptor_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_destroy_t destroy;
    afw_adaptor_create_adaptor_session_t create_adaptor_session;
    afw_adaptor_get_additional_metrics_t get_additional_metrics;
};

/**
 * @brief Call method destroy of interface afw_adaptor
 * @param instancePointer to this adaptor instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method create_adaptor_session of interface afw_adaptor
 * @param instancePointer to this adaptor instance.
 * @param xctxThe execution context (xctx) of caller.
 */
#define afw_adaptor_create_adaptor_session( \
    instance, \
    xctx \
) \
(instance)->inf->create_adaptor_session( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_additional_metrics of interface afw_adaptor
 * @param instancePointer to this adaptor instance.
 * @param pPool used for results.
 * @param xctxThe execution context (xctx) of caller.
 */
#define afw_adaptor_get_additional_metrics( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_additional_metrics( \
    (instance), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_object_type_cache_interface afw_adaptor_object_type_cache
 *
 * Adaptor object type cache interface. This interface is used by
 * afw_adaptor_get_object_type().
 *
 * @{
 */


/** @brief Interface afw_adaptor_object_type_cache public struct. */
struct afw_adaptor_object_type_cache_s {
    const afw_adaptor_object_type_cache_inf_t *inf;

    /**
     * Associated adaptor session.
     */
    const afw_adaptor_session_t * session;

    /**
     * All object types for associated adaptor are immutable.
     * 
     * If true, afw_adaptor_get_object_type() will call the set()
     * method when new object types are created.
     * 
     * If false, afw_adaptor_get_object_type() will only cache object
     * type for session.
     */
    afw_boolean_t all_object_types_immutable;
};

/** @brief define for interface afw_adaptor_object_type_cache name. */
#define AFW_ADAPTOR_OBJECT_TYPE_CACHE_INTERFACE_NAME \
"afw_adaptor_object_type_cache"

/** @sa afw_adaptor_object_type_cache_get() */
typedef const afw_object_type_t *
(*afw_adaptor_object_type_cache_get_t)(
    const afw_adaptor_object_type_cache_t * instance,
    const afw_utf8_t * object_type_id,
    afw_boolean_t * final_result,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_object_type_cache_set() */
typedef void
(*afw_adaptor_object_type_cache_set_t)(
    const afw_adaptor_object_type_cache_t * instance,
    const afw_object_type_t * object_type,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_object_type_cache_inf_s struct. */
struct afw_adaptor_object_type_cache_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_object_type_cache_get_t get;
    afw_adaptor_object_type_cache_set_t set;
};

/**
 * @brief Call method get of interface afw_adaptor_object_type_cache
 * @param instancePointer to this adaptor object type cache instance.
 * @param object_type_idObject type id of object type to get from cache.
 * @param final_resultPointer to place to return flag.
 * 
 *     If true, afw_adaptor_get_object_type() will always return the
 *     result of calling the get() method.
 * 
 *     If false and get() returns NULL, afw_adaptor_get_object_type()
 *     will try to create and return a new object_type and return.
 *     The set() method will be called if all_object_types_immutable is
 *     true.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_object_type_cache_get( \
    instance, \
    object_type_id, \
    final_result, \
    xctx \
) \
(instance)->inf->get( \
    (instance), \
    (object_type_id), \
    (final_result), \
    (xctx) \
)

/**
 * @brief Call method set of interface afw_adaptor_object_type_cache
 * @param instancePointer to this adaptor object type cache instance.
 * @param object_typeObject type to set in cache.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_object_type_cache_set( \
    instance, \
    object_type, \
    xctx \
) \
(instance)->inf->set( \
    (instance), \
    (object_type), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_session_interface afw_adaptor_session
 *
 * Adaptor session interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor_session public struct. */
struct afw_adaptor_session_s {
    const afw_adaptor_session_inf_t *inf;

    /**
     * Adaptor sessions's associated adaptor.
     */
    const afw_adaptor_t * adaptor;

    /**
     * Adaptor sessions's pool. This pool will exist for the life of the adaptor
     * session.
     */
    const afw_pool_t * p;
};

/** @brief define for interface afw_adaptor_session name. */
#define AFW_ADAPTOR_SESSION_INTERFACE_NAME \
"afw_adaptor_session"

/** @sa afw_adaptor_session_destroy() */
typedef void
(*afw_adaptor_session_destroy_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_retrieve_objects() */
typedef void
(*afw_adaptor_session_retrieve_objects_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_query_criteria_t * criteria,
    void * context,
    afw_object_cb_t callback,
    const afw_object_t * adaptor_type_specific,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_object() */
typedef void
(*afw_adaptor_session_get_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    void * context,
    afw_object_cb_t callback,
    const afw_object_t * adaptor_type_specific,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_add_object() */
typedef const afw_utf8_t *
(*afw_adaptor_session_add_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * suggested_object_id,
    const afw_object_t * object,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_modify_object() */
typedef void
(*afw_adaptor_session_modify_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_adaptor_modify_entry_t * const * entry,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_replace_object() */
typedef void
(*afw_adaptor_session_replace_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_object_t * replacement_object,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_delete_object() */
typedef void
(*afw_adaptor_session_delete_object_t)(
    const afw_adaptor_session_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_object_t * adaptor_type_specific,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_begin_transaction() */
typedef const afw_adaptor_transaction_t *
(*afw_adaptor_session_begin_transaction_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_journal_interface() */
typedef const afw_adaptor_journal_t *
(*afw_adaptor_session_get_journal_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_key_value_interface() */
typedef const afw_adaptor_key_value_t *
(*afw_adaptor_session_get_key_value_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_index_interface() */
typedef const afw_adaptor_impl_index_t *
(*afw_adaptor_session_get_index_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_session_get_object_type_cache_interface() */
typedef const afw_adaptor_object_type_cache_t *
(*afw_adaptor_session_get_object_type_cache_interface_t)(
    const afw_adaptor_session_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_session_inf_s struct. */
struct afw_adaptor_session_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_session_destroy_t destroy;
    afw_adaptor_session_retrieve_objects_t retrieve_objects;
    afw_adaptor_session_get_object_t get_object;
    afw_adaptor_session_add_object_t add_object;
    afw_adaptor_session_modify_object_t modify_object;
    afw_adaptor_session_replace_object_t replace_object;
    afw_adaptor_session_delete_object_t delete_object;
    afw_adaptor_session_begin_transaction_t begin_transaction;
    afw_adaptor_session_get_journal_interface_t get_journal_interface;
    afw_adaptor_session_get_key_value_interface_t get_key_value_interface;
    afw_adaptor_session_get_index_interface_t get_index_interface;
    afw_adaptor_session_get_object_type_cache_interface_t get_object_type_cache_interface;
};

/**
 * @brief Call method destroy of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 *     Make sure to call commit or changes will be lost.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method retrieve_objects of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param object_type_idThe object type of objects to be retrieved.
 * @param criteriaQuery criteria. Use member filter or normalized, whichever is
 *     easier,
 *     to filter the objects retrieved. See afw_query_criteria.h for more
 *     information.
 *     The other members should be ignored.
 * @param contextPointer passed to callback routine.
 * @param callbackCallback function will be called each time an object is
 *     retrieved and once
 *     with a NULL object pointer when finished.
 * 
 *     The callback function will call afw_object_release() on the object
 *     when finished with it. If you want to have the object last past the
 *     callback, call afw_object_get_reference() on the object before calling
 *     the callback.
 * @param adaptor_type_specificThis is an adaptor type specific object parameter
 *     or NULL.
 * 
 *     If the adaptor type supports this parameter, the object type of the
 *     object is available via the afw adaptor with an object type id of:
 * 
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *     where ${adaptorType} is the adaptor type id.
 * @param pPool used for objects passed to callback.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_retrieve_objects( \
    instance, \
    impl_request, \
    object_type_id, \
    criteria, \
    context, \
    callback, \
    adaptor_type_specific, \
    p, \
    xctx \
) \
(instance)->inf->retrieve_objects( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (criteria), \
    (context), \
    (callback), \
    (adaptor_type_specific), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_object of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param object_type_idObject type of object to get.
 * @param object_idObject id of object to get.
 * @param contextPointer passed to callback routine.
 * @param callbackCallback function will be called once with either the object
 *     retrieved
 *     or a NULL object pointer if not found.
 * 
 *     The callback function will call afw_object_release() on the object
 *     when finished with it. If you want to have the object last past the
 *     callback, call afw_object_get_reference() on the object before calling
 *     the callback.
 * @param adaptor_type_specificThis is an adaptor type specific object parameter
 *     or NULL.
 * 
 *     If the adaptor type supports this parameter, the object type of the
 *     object is available via the afw adaptor with an object type id of:
 * 
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_get_object
 * 
 *     where ${adaptorType} is the adaptor type id.
 * @param pPool used for object passed to callback.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_get_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    context, \
    callback, \
    adaptor_type_specific, \
    p, \
    xctx \
) \
(instance)->inf->get_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (context), \
    (callback), \
    (adaptor_type_specific), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method add_object of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param object_type_idObject type of object to add.
 * @param suggested_object_idThe suggested object id of the added object. This
 *     object id must be
 *     unique within the object type. If NULL or at the adaptor's option,
 *     the adaptor will generate a unique object id.
 * @param objectObject to add.
 * 
 *     Unless documented otherwise by non-default options, this object only
 *     needs
 *     to exist for the life of the add_object() call. Some adaptors have
 *     options
 *     that require longer lifetimes for these objects. For example, a memory
 *     adaptor can be created with the option to not clone an object when added
 *     to memory store. In this case, it's the caller responsibility to create
 *     the object in a pool that has the minimal lifetime of the memory adaptor
 *     itself. For instance, the adaptor's pool can be used during object
 *     create.
 *     The memory adaptor then uses the object's pool's get_reference() and
 *     release()
 *     methods to manage the lifetime of the object.
 * @param adaptor_type_specificThis is an adaptor type specific object parameter
 *     or NULL.
 * 
 *     If the adaptor type supports this parameter, the object type of the
 *     object is available via the afw adaptor with an object type id of:
 * 
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_add_object
 * 
 *     where ${adaptorType} is the adaptor type id.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_add_object( \
    instance, \
    impl_request, \
    object_type_id, \
    suggested_object_id, \
    object, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->add_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (suggested_object_id), \
    (object), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method modify_object of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param object_type_idObject type of object to modify.
 * @param object_idObject id of object to modify.
 * @param entryNULL terminated array of pointers to adaptor modify entries.
 * @param adaptor_type_specificThis is an adaptor type specific object parameter
 *     or NULL.
 * 
 *     If the adaptor type supports this parameter, the object type of the
 *     object is available via the afw adaptor with an object type id of:
 * 
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object
 * 
 *     where ${adaptorType} is the adaptor type id.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_modify_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    entry, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->modify_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (entry), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method replace_object of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param object_type_idObject type of object to update.
 * @param object_idObject id of object to update.
 * @param replacement_objectReplacement object.
 * @param adaptor_type_specificThis is an adaptor type specific object parameter
 *     or NULL.
 * 
 *     If the adaptor type supports this parameter, the object type of the
 *     object is available via the afw adaptor with an object type id of:
 * 
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_replace_object
 * 
 *     where ${adaptorType} is the adaptor type id.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_replace_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    replacement_object, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->replace_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (replacement_object), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method delete_object of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param object_type_idObject type of object to delete.
 * @param object_idObject id of object to delete.
 * @param adaptor_type_specificThis is an adaptor type specific object parameter
 *     or NULL.
 * 
 *     If the adaptor type supports this parameter, the object type of the
 *     object is available via the afw adaptor with an object type id of:
 * 
 *     _AdaptiveAdaptorTypeSpecific_${adaptorType}_delete_object
 * 
 *     where ${adaptorType} is the adaptor type id.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_delete_object( \
    instance, \
    impl_request, \
    object_type_id, \
    object_id, \
    adaptor_type_specific, \
    xctx \
) \
(instance)->inf->delete_object( \
    (instance), \
    (impl_request), \
    (object_type_id), \
    (object_id), \
    (adaptor_type_specific), \
    (xctx) \
)

/**
 * @brief Call method begin_transaction of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_begin_transaction( \
    instance, \
    xctx \
) \
(instance)->inf->begin_transaction( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_journal_interface of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_get_journal_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_journal_interface( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_key_value_interface of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_get_key_value_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_key_value_interface( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_index_interface of interface afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_get_index_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_index_interface( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_object_type_cache_interface of interface
 *     afw_adaptor_session
 * @param instancePointer to this adaptor session instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_session_get_object_type_cache_interface( \
    instance, \
    xctx \
) \
(instance)->inf->get_object_type_cache_interface( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_transaction_interface afw_adaptor_transaction
 *
 * Adaptor session transaction interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor_transaction public struct. */
struct afw_adaptor_transaction_s {
    const afw_adaptor_transaction_inf_t *inf;
};

/** @brief define for interface afw_adaptor_transaction name. */
#define AFW_ADAPTOR_TRANSACTION_INTERFACE_NAME \
"afw_adaptor_transaction"

/** @sa afw_adaptor_transaction_release() */
typedef void
(*afw_adaptor_transaction_release_t)(
    const afw_adaptor_transaction_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_transaction_commit() */
typedef void
(*afw_adaptor_transaction_commit_t)(
    const afw_adaptor_transaction_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_transaction_inf_s struct. */
struct afw_adaptor_transaction_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_transaction_release_t release;
    afw_adaptor_transaction_commit_t commit;
};

/**
 * @brief Call method release of interface afw_adaptor_transaction
 * @param instancePointer to this adaptor session transaction instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_transaction_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method commit of interface afw_adaptor_transaction
 * @param instancePointer to this adaptor session transaction instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_transaction_commit( \
    instance, \
    xctx \
) \
(instance)->inf->commit( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_impl_index_cursor_interface afw_adaptor_impl_index_cursor
 *
 * Adaptor implementation index cursor interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor_impl_index_cursor public struct. */
struct afw_adaptor_impl_index_cursor_s {
    const afw_adaptor_impl_index_cursor_inf_t *inf;

    /**
     * The query criteria associated with this cursor.
     */
    const afw_query_criteria_filter_entry_t * filter_entry;

    /**
     * This variable indicates whether this cursor describes a strict
     * intersection of cursor(s) (true), or if it's a left/right outer join
     * (false).
     */
    afw_boolean_t inner_join;
};

/** @brief define for interface afw_adaptor_impl_index_cursor name. */
#define AFW_ADAPTOR_IMPL_INDEX_CURSOR_INTERFACE_NAME \
"afw_adaptor_impl_index_cursor"

/** @sa afw_adaptor_impl_index_cursor_release() */
typedef void
(*afw_adaptor_impl_index_cursor_release_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_get_next_object() */
typedef const afw_object_t *
(*afw_adaptor_impl_index_cursor_get_next_object_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_contains_object() */
typedef afw_boolean_t
(*afw_adaptor_impl_index_cursor_contains_object_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    const afw_object_t * object,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_inner_join() */
typedef const afw_adaptor_impl_index_cursor_t *
(*afw_adaptor_impl_index_cursor_inner_join_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    const afw_adaptor_impl_index_cursor_t * cursor,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_cursor_get_count() */
typedef afw_boolean_t
(*afw_adaptor_impl_index_cursor_get_count_t)(
    const afw_adaptor_impl_index_cursor_t * instance,
    size_t * count,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_impl_index_cursor_inf_s struct. */
struct afw_adaptor_impl_index_cursor_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_impl_index_cursor_release_t release;
    afw_adaptor_impl_index_cursor_get_next_object_t get_next_object;
    afw_adaptor_impl_index_cursor_contains_object_t contains_object;
    afw_adaptor_impl_index_cursor_inner_join_t inner_join;
    afw_adaptor_impl_index_cursor_get_count_t get_count;
};

/**
 * @brief Call method release of interface afw_adaptor_impl_index_cursor
 * @param instancePointer to this adaptor impl index cursor instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_next_object of interface afw_adaptor_impl_index_cursor
 * @param instancePointer to this adaptor impl index cursor instance.
 * @param poolMemory pool to allocate resources in.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_get_next_object( \
    instance, \
    pool, \
    xctx \
) \
(instance)->inf->get_next_object( \
    (instance), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method contains_object of interface afw_adaptor_impl_index_cursor
 * @param instancePointer to this adaptor impl index cursor instance.
 * @param objectPointer to object we need to determine is in this cursor.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_contains_object( \
    instance, \
    object, \
    xctx \
) \
(instance)->inf->contains_object( \
    (instance), \
    (object), \
    (xctx) \
)

/**
 * @brief Call method inner_join of interface afw_adaptor_impl_index_cursor
 * @param instancePointer to this adaptor impl index cursor instance.
 * @param cursorPointer to the cursor we need to join with.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_inner_join( \
    instance, \
    cursor, \
    xctx \
) \
(instance)->inf->inner_join( \
    (instance), \
    (cursor), \
    (xctx) \
)

/**
 * @brief Call method get_count of interface afw_adaptor_impl_index_cursor
 * @param instancePointer to this adaptor impl index cursor instance.
 * @param countPointer to the count, where the caller should return the value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_cursor_get_count( \
    instance, \
    count, \
    xctx \
) \
(instance)->inf->get_count( \
    (instance), \
    (count), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_key_value_interface afw_adaptor_key_value
 *
 * Adaptor implementation of key value interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor_key_value public struct. */
struct afw_adaptor_key_value_s {
    const afw_adaptor_key_value_inf_t *inf;
};

/** @brief define for interface afw_adaptor_key_value name. */
#define AFW_ADAPTOR_KEY_VALUE_INTERFACE_NAME \
"afw_adaptor_key_value"

/** @sa afw_adaptor_key_value_add() */
typedef void
(*afw_adaptor_key_value_add_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    const afw_memory_t * value,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_key_value_delete() */
typedef void
(*afw_adaptor_key_value_delete_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    const afw_memory_t * value,
    afw_boolean_t must_exist,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_key_value_replace() */
typedef void
(*afw_adaptor_key_value_replace_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    const afw_memory_t * value,
    afw_boolean_t must_exist,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_key_value_get() */
typedef const afw_memory_t *
(*afw_adaptor_key_value_get_t)(
    const afw_adaptor_key_value_t * instance,
    const afw_utf8_t * namespace,
    const afw_memory_t * key,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_key_value_inf_s struct. */
struct afw_adaptor_key_value_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_key_value_add_t add;
    afw_adaptor_key_value_delete_t delete;
    afw_adaptor_key_value_replace_t replace;
    afw_adaptor_key_value_get_t get;
};

/**
 * @brief Call method add of interface afw_adaptor_key_value
 * @param instancePointer to this adaptor key value instance.
 * @param namespaceNamespace for key.
 * @param keyKey.
 * @param valueValue.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_key_value_add( \
    instance, \
    namespace, \
    key, \
    value, \
    xctx \
) \
(instance)->inf->add( \
    (instance), \
    (namespace), \
    (key), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method delete of interface afw_adaptor_key_value
 * @param instancePointer to this adaptor key value instance.
 * @param namespaceNamespace for key.
 * @param keyKey.
 * @param valueValue the key must have or NULL if it doesn't matter.
 * @param must_existIt is an error if value does not exist.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_key_value_delete( \
    instance, \
    namespace, \
    key, \
    value, \
    must_exist, \
    xctx \
) \
(instance)->inf->delete( \
    (instance), \
    (namespace), \
    (key), \
    (value), \
    (must_exist), \
    (xctx) \
)

/**
 * @brief Call method replace of interface afw_adaptor_key_value
 * @param instancePointer to this adaptor key value instance.
 * @param namespaceNamespace for key.
 * @param keyKey.
 * @param valueValue the key must have or NULL if it doesn't matter.
 * @param must_existIt is an error if value does not exist. If must_exist is
 *     false, the keyed value will be added if it doesn't exist.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_key_value_replace( \
    instance, \
    namespace, \
    key, \
    value, \
    must_exist, \
    xctx \
) \
(instance)->inf->replace( \
    (instance), \
    (namespace), \
    (key), \
    (value), \
    (must_exist), \
    (xctx) \
)

/**
 * @brief Call method get of interface afw_adaptor_key_value
 * @param instancePointer to this adaptor key value instance.
 * @param namespaceNamespace for key.
 * @param keyKey.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_key_value_get( \
    instance, \
    namespace, \
    key, \
    xctx \
) \
(instance)->inf->get( \
    (instance), \
    (namespace), \
    (key), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_impl_index_interface afw_adaptor_impl_index
 *
 * Adaptor implementation index interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor_impl_index public struct. */
struct afw_adaptor_impl_index_s {
    const afw_adaptor_impl_index_inf_t *inf;

    /**
     * The index definitions.
     */
    const afw_object_t * indexDefinitions;
};

/** @brief define for interface afw_adaptor_impl_index name. */
#define AFW_ADAPTOR_IMPL_INDEX_INTERFACE_NAME \
"afw_adaptor_impl_index"

/** @sa afw_adaptor_impl_index_open() */
typedef void
(*afw_adaptor_impl_index_open_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * key,
    afw_boolean_t integer,
    afw_boolean_t unique,
    afw_boolean_t reverse,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_release() */
typedef void
(*afw_adaptor_impl_index_release_t)(
    const afw_adaptor_impl_index_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_get_index_definitions() */
typedef const afw_object_t *
(*afw_adaptor_impl_index_get_index_definitions_t)(
    const afw_adaptor_impl_index_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_update_index_definitions() */
typedef void
(*afw_adaptor_impl_index_update_index_definitions_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_object_t * indexDefinitions,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_add() */
typedef afw_rc_t
(*afw_adaptor_impl_index_add_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_utf8_t * key,
    const afw_utf8_t* value,
    afw_boolean_t unique,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_delete() */
typedef afw_rc_t
(*afw_adaptor_impl_index_delete_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_utf8_t * key,
    const afw_utf8_t* value,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_replace() */
typedef afw_rc_t
(*afw_adaptor_impl_index_replace_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    const afw_utf8_t * key,
    const afw_utf8_t* old_value,
    const afw_utf8_t* new_value,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_drop() */
typedef afw_rc_t
(*afw_adaptor_impl_index_drop_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * key,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_open_cursor() */
typedef afw_adaptor_impl_index_cursor_t *
(*afw_adaptor_impl_index_open_cursor_t)(
    const afw_adaptor_impl_index_t * instance,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * index_key,
    int operator,
    const afw_utf8_t * value,
    afw_boolean_t unique,
    const afw_pool_t * pool,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_impl_index_get_session() */
typedef const afw_adaptor_session_t *
(*afw_adaptor_impl_index_get_session_t)(
    const afw_adaptor_impl_index_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_impl_index_inf_s struct. */
struct afw_adaptor_impl_index_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_impl_index_open_t open;
    afw_adaptor_impl_index_release_t release;
    afw_adaptor_impl_index_get_index_definitions_t get_index_definitions;
    afw_adaptor_impl_index_update_index_definitions_t update_index_definitions;
    afw_adaptor_impl_index_add_t add;
    afw_adaptor_impl_index_delete_t delete;
    afw_adaptor_impl_index_replace_t replace;
    afw_adaptor_impl_index_drop_t drop;
    afw_adaptor_impl_index_open_cursor_t open_cursor;
    afw_adaptor_impl_index_get_session_t get_session;
};

/**
 * @brief Call method open of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param object_type_idObject type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine the
 *     target table or database to store the index. NULL means all objectTypes
 *     are applicable.
 * @param keyIndex key associated with the index value we are creating.
 * @param integerShould index values be stored as integer values.
 * @param uniqueShould generated index values be unique.
 * @param reverseShould index values be stored in reverse order.
 * @param poolCaller's pool.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_open( \
    instance, \
    object_type_id, \
    key, \
    integer, \
    unique, \
    reverse, \
    pool, \
    xctx \
) \
(instance)->inf->open( \
    (instance), \
    (object_type_id), \
    (key), \
    (integer), \
    (unique), \
    (reverse), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method release of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_index_definitions of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_get_index_definitions( \
    instance, \
    xctx \
) \
(instance)->inf->get_index_definitions( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method update_index_definitions of interface
 *     afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param indexDefinitionsUpdated indexes definitions.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_update_index_definitions( \
    instance, \
    indexDefinitions, \
    xctx \
) \
(instance)->inf->update_index_definitions( \
    (instance), \
    (indexDefinitions), \
    (xctx) \
)

/**
 * @brief Call method add of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param object_type_idObject type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine the
 *     target table or database to store the index.
 * @param object_idObject id for the object associated with the property and
 *     value that we are indexing. This should be used by the adaptor as a
 *     reference to the primary entry.
 * @param keyIndex key associated with the index value we are creating.
 * @param valueIndex value associated with the index we are creating. This
 *     should be used by the adaptor as the key to the index entry.
 * @param uniqueFlag indicating that the index being added should be unique.
 * @param poolCaller's pool.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_add( \
    instance, \
    object_type_id, \
    object_id, \
    key, \
    value, \
    unique, \
    pool, \
    xctx \
) \
(instance)->inf->add( \
    (instance), \
    (object_type_id), \
    (object_id), \
    (key), \
    (value), \
    (unique), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method delete of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param object_type_idObject type id associated with the property and value of
 *     the index we are removing. This may be useful for the adaptor to
 *     determine the target table or database to store the index.
 * @param object_idObject id for the object associated with the property and
 *     value of the index we are removing. This should be used by the adaptor as
 *     a reference to the primary entry.
 * @param keyIndex key associated with the index value we are deleting.
 * @param valueIndex value associated with the index we are deleting. This
 *     should be used by the adaptor as the key to the index entry.
 * @param poolCaller's pool.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_delete( \
    instance, \
    object_type_id, \
    object_id, \
    key, \
    value, \
    pool, \
    xctx \
) \
(instance)->inf->delete( \
    (instance), \
    (object_type_id), \
    (object_id), \
    (key), \
    (value), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method replace of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param object_type_idObject type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine the
 *     target table or database to store the index.
 * @param object_idObject id for the object associated with the property and
 *     value that we are indexing. This should be used by the adaptor as a
 *     reference to the primary entry.
 * @param keyIndex key associated with the index value we are replacing.
 * @param old_valueOld index value associated with the index we are replacing.
 *     This should be used by the adaptor as the key to the index entry.
 * @param new_valueNew index value associated with the index we are replacing.
 *     This should be used by the adaptor as the key to the index entry.
 * @param poolCaller's pool.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_replace( \
    instance, \
    object_type_id, \
    object_id, \
    key, \
    old_value, \
    new_value, \
    pool, \
    xctx \
) \
(instance)->inf->replace( \
    (instance), \
    (object_type_id), \
    (object_id), \
    (key), \
    (old_value), \
    (new_value), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method drop of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param object_type_idObject type id associated with the index. This may be
 *     useful for the adaptor to determine the target table or database for the
 *     index.
 * @param keyIndex key.
 * @param poolCaller's pool.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_drop( \
    instance, \
    object_type_id, \
    key, \
    pool, \
    xctx \
) \
(instance)->inf->drop( \
    (instance), \
    (object_type_id), \
    (key), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method open_cursor of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param object_type_idObject type id associated with the property and value
 *     that we are indexing. This may be useful for the adaptor to determine the
 *     target table or database to find the index.
 * @param index_keyKey associated with the index we are replacing.
 * @param operatorQuery criteria operator.
 * @param valueIndex value associated with the index we are querying. This
 *     should be used by the adaptor as the key to the index entry.
 * @param uniqueIndex values are unique.
 * @param poolCaller's pool.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_open_cursor( \
    instance, \
    object_type_id, \
    index_key, \
    operator, \
    value, \
    unique, \
    pool, \
    xctx \
) \
(instance)->inf->open_cursor( \
    (instance), \
    (object_type_id), \
    (index_key), \
    (operator), \
    (value), \
    (unique), \
    (pool), \
    (xctx) \
)

/**
 * @brief Call method get_session of interface afw_adaptor_impl_index
 * @param instancePointer to this adaptor impl index instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_impl_index_get_session( \
    instance, \
    xctx \
) \
(instance)->inf->get_session( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_authorization_handler_factory_interface afw_authorization_handler_factory
 *
 * Factory to create an instance of an afw_authorization_handler.
 *
 * @{
 */


/** @brief Interface afw_authorization_handler_factory public struct. */
struct afw_authorization_handler_factory_s {
    const afw_authorization_handler_factory_inf_t *inf;

    /**
     * Type of authorization handler this factory creates.
     */
    afw_utf8_t authorization_handler_type;

    /**
     * Type of adaptor this factory creates.
     */
    const afw_utf8_t * description;
};

/** @brief define for interface afw_authorization_handler_factory name. */
#define AFW_AUTHORIZATION_HANDLER_FACTORY_INTERFACE_NAME \
"afw_authorization_handler_factory"

/** @sa afw_authorization_handler_factory_create_authorization_handler_cede_p() */
typedef const afw_authorization_handler_t *
(*afw_authorization_handler_factory_create_authorization_handler_cede_p_t)(
    const afw_authorization_handler_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_authorization_handler_factory_inf_s struct. */
struct afw_authorization_handler_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_authorization_handler_factory_create_authorization_handler_cede_p_t create_authorization_handler_cede_p;
};

/**
 * @brief Call method create_authorization_handler_cede_p of interface
 *     afw_authorization_handler_factory
 * @param instancePointer to this authorization handler factory instance.
 * @param propertiesConfiguration parameters for the particular type of
 *     authorization handler.
 *     This will become the properties object for handler.
 * @param pThe pool that will be used for authorization handler resources.
 * @param xctxThis is the caller's xctx.
 */
#define afw_authorization_handler_factory_create_authorization_handler_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_authorization_handler_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_authorization_handler_interface afw_authorization_handler
 *
 * Adaptive framework authorization handler interface.
 *
 * @{
 */


/** @brief Interface afw_authorization_handler public struct. */
struct afw_authorization_handler_s {
    const afw_authorization_handler_inf_t *inf;

    /**
     * Authorization handler's pool. This pool will exist for the life of the
     * handler.
     */
    const afw_pool_t * p;

    /**
     * Id of authorization handler.
     */
    afw_utf8_t authorization_handler_id;

    /**
     * Id of authorization handler type.
     */
    const afw_utf8_t * authorization_handler_type_id;

    /**
     * This is the associated service id. The path of the service is
     * "/afw/_AdaptiveService_/" followed by this id.
     */
    const afw_utf8_t * service_id;

    /**
     * This authorization handler's properties (configuration) object.
     */
    const afw_object_t * properties;

    /**
     * This is the source location to help determine how this authorization
     * handler was defined.
     */
    const afw_utf8_t * source_location;

    /**
     * This is the basic trace flag id for this authorization handler's
     * authorization handler id.
     */
    const afw_utf8_t * trace_flag_id;

    /**
     * This is the basic trace flag index for this authorization handler's
     * authorization handler id.
     */
    afw_size_t trace_flag_index;

    /**
     * This is the detail trace flag id for this authorization handler's
     * authorization handler id.
     */
    const afw_utf8_t * detail_flag_id;

    /**
     * This is the detail trace flag index for this authorization handler's
     * authorization handler id.
     */
    afw_size_t detail_flag_index;

    /**
     * Read/write lock for this authorization handler id.
     */
    const afw_lock_rw_t * authorization_handler_lock_rw;

    /**
     * When there are multiple active authorization handlers, this priority
     * determines order this handler will be checked. Priority 1 is the highest
     * and will be checked first. If multiple handlers have the same priority
     * the order will vary.
     */
    afw_integer_t priority;

    /**
     * Use caution when setting this parameter to true. If this parameter is
     * true, a decision of permit by this authorization handler will override a
     * decision of deny by a previous authorization handler.
     */
    afw_boolean_t allow_deny_override;

    /**
     * If this parameter is true, a decision of deny by this authorization
     * handler will override a decision of permit by a previous authorization
     * handler.
     */
    afw_boolean_t allow_permit_override;

    /**
     * If true, this authorization handler must be running to make an
     * authorization decision if not running in core mode and if
     * initialAuthorizationCheck did not make a decision.
     */
    afw_boolean_t required;

    /**
     * Used by authorization handler common code.
     */
    const afw_authorization_handler_impl_t * impl;
};

/** @brief define for interface afw_authorization_handler name. */
#define AFW_AUTHORIZATION_HANDLER_INTERFACE_NAME \
"afw_authorization_handler"

/** @sa afw_authorization_handler_destroy() */
typedef void
(*afw_authorization_handler_destroy_t)(
    const afw_authorization_handler_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_authorization_handler_check() */
typedef const afw_value_t *
(*afw_authorization_handler_check_t)(
    const afw_authorization_handler_t * instance,
    const afw_value_t * resource_id,
    const afw_value_t * object,
    const afw_value_t * action_id,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_authorization_handler_inf_s struct. */
struct afw_authorization_handler_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_authorization_handler_destroy_t destroy;
    afw_authorization_handler_check_t check;
};

/**
 * @brief Call method destroy of interface afw_authorization_handler
 * @param instancePointer to this adaptive authorization handler instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_authorization_handler_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method check of interface afw_authorization_handler
 * @param instancePointer to this adaptive request instance.
 * @param resource_idAdaptive string value for the URI of resource to check.
 * @param objectAdaptive object value for the object associated with resource or
 *     NULL.
 * @param action_idAdaptive string value for the action to check.
 * @param pPool for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_authorization_handler_check( \
    instance, \
    resource_id, \
    object, \
    action_id, \
    p, \
    xctx \
) \
(instance)->inf->check( \
    (instance), \
    (resource_id), \
    (object), \
    (action_id), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_content_type_interface afw_content_type
 *
 * Adaptive Content Type.
 *
 * @{
 */


/** @brief Interface afw_content_type public struct. */
struct afw_content_type_s {
    const afw_content_type_inf_t *inf;

    /**
     * Id of content type.
     */
    afw_utf8_t content_type_id;

    /**
     * The number of media types for this content type.
     */
    afw_size_t media_type_count;

    /**
     * An array of media types for this content type.
     */
    const afw_utf8_t * media_types;
};

/** @brief define for interface afw_content_type name. */
#define AFW_CONTENT_TYPE_INTERFACE_NAME \
"afw_content_type"

/** @sa afw_content_type_raw_to_value() */
typedef const afw_value_t *
(*afw_content_type_raw_to_value_t)(
    const afw_content_type_t * instance,
    const afw_memory_t * raw,
    const afw_utf8_t * source_location,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_content_type_raw_to_object() */
typedef const afw_object_t *
(*afw_content_type_raw_to_object_t)(
    const afw_content_type_t * instance,
    const afw_memory_t * raw,
    const afw_utf8_t * source_location,
    const afw_utf8_t * adaptor_id,
    const afw_utf8_t * object_type_id,
    const afw_utf8_t * object_id,
    afw_boolean_t cede_p,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_content_type_write_value() */
typedef void
(*afw_content_type_write_value_t)(
    const afw_content_type_t * instance,
    const afw_value_t * value,
    const afw_object_options_t * options,
    void * context,
    afw_write_cb_t callback,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_content_type_create_object_list_writer() */
typedef const afw_content_type_object_list_writer_t *
(*afw_content_type_create_object_list_writer_t)(
    const afw_content_type_t * instance,
    const afw_object_options_t * options,
    void * context,
    afw_write_cb_t callback,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_content_type_inf_s struct. */
struct afw_content_type_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_content_type_raw_to_value_t raw_to_value;
    afw_content_type_raw_to_object_t raw_to_object;
    afw_content_type_write_value_t write_value;
    afw_content_type_create_object_list_writer_t create_object_list_writer;
};

/**
 * @brief Call method raw_to_value of interface afw_content_type
 * @param instancePointer to this content type instance.
 * @param rawRaw encoded representation of this content type.
 * @param source_locationSource location or NULL.
 * @param pPool to use to hold returned value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_content_type_raw_to_value( \
    instance, \
    raw, \
    source_location, \
    p, \
    xctx \
) \
(instance)->inf->raw_to_value( \
    (instance), \
    (raw), \
    (source_location), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method raw_to_object of interface afw_content_type
 * @param instancePointer to this content type instance.
 * @param rawRaw encoded object representation of this content type.
 * @param source_locationSource location or NULL.
 * @param adaptor_idAdaptor id for created object.
 * @param object_type_idObject type id for created object.
 * @param object_idObject id for created object.
 * @param cede_pIf true, cede control of p to the created object.
 *     If false, a subpool will be created in p for the object.
 * @param pThe pool to use.
 * @param xctxThis is the caller's xctx.
 */
#define afw_content_type_raw_to_object( \
    instance, \
    raw, \
    source_location, \
    adaptor_id, \
    object_type_id, \
    object_id, \
    cede_p, \
    p, \
    xctx \
) \
(instance)->inf->raw_to_object( \
    (instance), \
    (raw), \
    (source_location), \
    (adaptor_id), \
    (object_type_id), \
    (object_id), \
    (cede_p), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method write_value of interface afw_content_type
 * @param instancePointer to this content type instance.
 * @param valueAdaptive value to convert and write.
 * @param optionsThese options can determine if none, some, or all object meta
 *     information should be included in output.
 * 
 *     See afw_object_options_t for more information. Only options flagged
 *     for use by content type processing are honored. All other options
 *     are ignored. For instance, a call to afw_object_view_create() with
 *     the composite option is needed before calling a content type write
 *     function if inherited properties should be included in output.
 * @param contextPointer passed to callback routine.
 * @param callbackCallback function that will be called to write multiple times
 *     to write
 *     the raw representation of the value.
 * @param pPool to use.
 * @param xctxThis is the caller's xctx.
 */
#define afw_content_type_write_value( \
    instance, \
    value, \
    options, \
    context, \
    callback, \
    p, \
    xctx \
) \
(instance)->inf->write_value( \
    (instance), \
    (value), \
    (options), \
    (context), \
    (callback), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method create_object_list_writer of interface afw_content_type
 * @param instancePointer to this content type instance.
 * @param optionsThese options can determine if none, some, or all object meta
 *     information should be included in output.
 * 
 *     See afw_object_options_t for more information. Only options flagged
 *     for use by content type processing are honored. All other options
 *     are ignored. For instance, a call to afw_object_view_create() with
 *     the composite option is needed before calling a content type write
 *     function if inherited properties should be included in output.
 * @param contextPointer passed to callback routine.
 * @param callbackCallback function that will be called each time the object
 *     list
 *     writer has something to write.
 * @param pPool to use.
 * @param xctxThis is the caller's xctx.
 */
#define afw_content_type_create_object_list_writer( \
    instance, \
    options, \
    context, \
    callback, \
    p, \
    xctx \
) \
(instance)->inf->create_object_list_writer( \
    (instance), \
    (options), \
    (context), \
    (callback), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_content_type_object_list_writer_interface afw_content_type_object_list_writer
 *
 *
 * @{
 */


/** @brief Interface afw_content_type_object_list_writer public struct. */
struct afw_content_type_object_list_writer_s {
    const afw_content_type_object_list_writer_inf_t *inf;
};

/** @brief define for interface afw_content_type_object_list_writer name. */
#define AFW_CONTENT_TYPE_OBJECT_LIST_WRITER_INTERFACE_NAME \
"afw_content_type_object_list_writer"

/** @sa afw_content_type_object_list_writer_release() */
typedef void
(*afw_content_type_object_list_writer_release_t)(
    const afw_content_type_object_list_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_content_type_object_list_writer_write_object() */
typedef void
(*afw_content_type_object_list_writer_write_object_t)(
    const afw_content_type_object_list_writer_t * instance,
    const afw_object_t * object,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_content_type_object_list_writer_inf_s struct. */
struct afw_content_type_object_list_writer_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_content_type_object_list_writer_release_t release;
    afw_content_type_object_list_writer_write_object_t write_object;
};

/**
 * @brief Call method release of interface afw_content_type_object_list_writer
 * @param instancePointer to this instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_content_type_object_list_writer_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method write_object of interface
 *     afw_content_type_object_list_writer
 * @param instancePointer to this instance.
 * @param objectThe object to write.
 * @param pPool to use.
 * @param xctxThis is the caller's xctx.
 */
#define afw_content_type_object_list_writer_write_object( \
    instance, \
    object, \
    p, \
    xctx \
) \
(instance)->inf->write_object( \
    (instance), \
    (object), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_data_type_interface afw_data_type
 *
 * Adaptive Data Type.
 *
 * @{
 */


/** @brief Interface afw_data_type public struct. */
struct afw_data_type_s {
    const afw_data_type_inf_t *inf;

    /**
     * Object interface to this instance.
     */
    const afw_object_t * object;

    /**
     * Id of this data type.
     */
    afw_utf8_t data_type_id;

    /**
     * This is a predicate for the data type with the first letter capitalized
     * and without a trailing period.
     */
    afw_utf8_t brief;

    /**
     * Description of data type.
     */
    afw_utf8_t description;

    /**
     * This is the data type parameter type.
     * 
     * If len is 0, no parameter is allowed following the data type id.
     * 
     * If "dataType", the data type id can be followed by another data type id.
     * For example data type "array" can be followed by the data type of entries
     * in the array.
     * 
     * If "objectType", the data_type_id can be followed by an object type id.
     * This is the case
     */
    afw_utf8_t data_type_parameter_type;

    /**
     * The data type number.
     */
    int data_type_number;

    /**
     * Default LDAP OID.
     */
    afw_utf8_t ldapOid;

    /**
     * JSON primitive used to represent this data type.
     */
    afw_utf8_t jsonPrimitive;

    /**
     * This is the format to use in JSON Schema for this data type. This is only
     * applicable to data types with jsonPrimitive of "string".
     */
    afw_utf8_t jsonSchemaStringFormat;

    /**
     * Type of value in C.
     */
    afw_utf8_t cType;

    /**
     * The internal size of a value of this type.
     */
    afw_size_t c_type_size;

    /**
     * Instance of afw_array for an empty array of this data type.
     */
    const afw_array_t * empty_array;

    /**
     * Instance of afw_value for an empty array of this data type.
     */
    const afw_value_t * empty_array_value;

    /**
     * This is the inf pointer for evaluated adaptive values of this
     * data type.
     */
    const afw_value_inf_t * evaluated_value_inf;

    /**
     * This is the compile type for internal. If this data type can
     * not be compiled, this will be afw_compile_type_error(0).
     */
    afw_compile_type_t compile_type;

    /**
     * Indicates that dataType can be implied from json type. If false, the data
     * type
     * needs to be obtained an alternate way.
     */
    afw_boolean_t json_implies_data_type;

    /**
     * This data type is compiled and evaluated.
     */
    afw_boolean_t evaluated;

    /**
     * This indicates if this is passed and returned as a pointer or directly.
     */
    afw_boolean_t directReturn;

    /**
     * If true, this data type supports equality (equal) and relational compares
     * (greater than and less than). If false, only equality compares are
     * allowed.
     */
    afw_boolean_t relationalCompares;

    /**
     * This is a scalar value (not Bag, List, Object, etc.).
     */
    afw_boolean_t scalar;

    /**
     * Special data types are not associated with a particular instance of a
     * value but can be used to specify what data types a value can be.
     */
    afw_boolean_t special;
};

/** @brief define for interface afw_data_type name. */
#define AFW_DATA_TYPE_INTERFACE_NAME \
"afw_data_type"

/** @sa afw_data_type_internal_to_utf8() */
typedef const afw_utf8_t *
(*afw_data_type_internal_to_utf8_t)(
    const afw_data_type_t * instance,
    const void * from_internal,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_utf8_to_internal() */
typedef void
(*afw_data_type_utf8_to_internal_t)(
    const afw_data_type_t * instance,
    void * to_internal,
    const afw_utf8_t * from_utf8,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_compare_internal() */
typedef int
(*afw_data_type_compare_internal_t)(
    const afw_data_type_t * instance,
    const void * internal1,
    const void * internal2,
    afw_xctx_t * xctx);

/** @sa afw_data_type_convert_internal() */
typedef void
(*afw_data_type_convert_internal_t)(
    const afw_data_type_t * instance,
    void * to_internal,
    const void * from_internal,
    const afw_data_type_t * to_data_type,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_clone_internal() */
typedef void
(*afw_data_type_clone_internal_t)(
    const afw_data_type_t * instance,
    void * to_internal,
    const void * from_internal,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_data_type_value_compiler_listing() */
typedef void
(*afw_data_type_value_compiler_listing_t)(
    const afw_data_type_t * instance,
    const afw_writer_t * writer,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @sa afw_data_type_write_as_expression() */
typedef void
(*afw_data_type_write_as_expression_t)(
    const afw_data_type_t * instance,
    const afw_writer_t * writer,
    const void * from_internal,
    afw_xctx_t * xctx);

/** @brief Interface afw_data_type_inf_s struct. */
struct afw_data_type_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_data_type_internal_to_utf8_t internal_to_utf8;
    afw_data_type_utf8_to_internal_t utf8_to_internal;
    afw_data_type_compare_internal_t compare_internal;
    afw_data_type_convert_internal_t convert_internal;
    afw_data_type_clone_internal_t clone_internal;
    afw_data_type_value_compiler_listing_t value_compiler_listing;
    afw_data_type_write_as_expression_t write_as_expression;
};

/**
 * @brief Call method internal_to_utf8 of interface afw_data_type
 * @param instancePointer to this data type instance.
 * @param from_internalInternal representation of this data type of correct
 *     cType to
 *     convert.
 * @param pPool to use to hold returned value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_data_type_internal_to_utf8( \
    instance, \
    from_internal, \
    p, \
    xctx \
) \
(instance)->inf->internal_to_utf8( \
    (instance), \
    (from_internal), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method utf8_to_internal of interface afw_data_type
 * @param instancePointer to this data type instance.
 * @param to_internalThe address of the place to return result. This place must
 *     be the correct size
 *     based on data type (c_type_size).
 * @param from_utf8NFC UTF-8 representation for of this data type.
 * @param pPool to use to hold returned value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_data_type_utf8_to_internal( \
    instance, \
    to_internal, \
    from_utf8, \
    p, \
    xctx \
) \
(instance)->inf->utf8_to_internal( \
    (instance), \
    (to_internal), \
    (from_utf8), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method compare_internal of interface afw_data_type
 * @param instancePointer to this data type instance.
 * @param internal1First value of correct cType to compare.
 * @param internal2Second value of correct cType to compare.
 * @param xctxThis is the caller's xctx.
 */
#define afw_data_type_compare_internal( \
    instance, \
    internal1, \
    internal2, \
    xctx \
) \
(instance)->inf->compare_internal( \
    (instance), \
    (internal1), \
    (internal2), \
    (xctx) \
)

/**
 * @brief Call method convert_internal of interface afw_data_type
 * @param instancePointer to this data type instance.
 * @param to_internalThe address of the place to return result. This place must
 *     be the correct size
 *     based on data type (c_type_size) of to_data_type.
 * @param from_internalValue of correct cType to of this data type to convert.
 * @param to_data_typeData type of to value.
 * @param pPool to use to hold returned value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_data_type_convert_internal( \
    instance, \
    to_internal, \
    from_internal, \
    to_data_type, \
    p, \
    xctx \
) \
(instance)->inf->convert_internal( \
    (instance), \
    (to_internal), \
    (from_internal), \
    (to_data_type), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method clone_internal of interface afw_data_type
 * @param instancePointer to this data type instance.
 * @param to_internalThe address of the place to return result. This place must
 *     be the correct size
 *     based on data type (c_type_size) of to_data_type.
 * @param from_internalValue of correct cType to of this data type to convert.
 * @param pPool to use to hold returned value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_data_type_clone_internal( \
    instance, \
    to_internal, \
    from_internal, \
    p, \
    xctx \
) \
(instance)->inf->clone_internal( \
    (instance), \
    (to_internal), \
    (from_internal), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method value_compiler_listing of interface afw_data_type
 * @param instancePointer to this data type instance.
 * @param writerWriter instance to use.
 * @param valueValue to write to compiler listing.
 * @param xctxThis is the caller's xctx.
 */
#define afw_data_type_value_compiler_listing( \
    instance, \
    writer, \
    value, \
    xctx \
) \
(instance)->inf->value_compiler_listing( \
    (instance), \
    (writer), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method write_as_expression of interface afw_data_type
 * @param instancePointer to this data type instance.
 * @param writerWriter instance to use.
 * @param from_internalValue of correct cType to of this data type to convert.
 * @param xctxThis is the caller's xctx.
 */
#define afw_data_type_write_as_expression( \
    instance, \
    writer, \
    from_internal, \
    xctx \
) \
(instance)->inf->write_as_expression( \
    (instance), \
    (writer), \
    (from_internal), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_array_setter_interface afw_array_setter
 *
 * Adaptive array setter interface.
 *
 * @{
 */


/** @brief Interface afw_array_setter public struct. */
struct afw_array_setter_s {
    const afw_array_setter_inf_t *inf;

    /**
     * This is the associated array.
     */
    const afw_array_t * array;
};

/** @brief define for interface afw_array_setter name. */
#define AFW_ARRAY_SETTER_INTERFACE_NAME \
"afw_array_setter"

/** @sa afw_array_setter_set_immutable() */
typedef void
(*afw_array_setter_set_immutable_t)(
    const afw_array_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_determine_data_type_and_set_immutable() */
typedef const afw_data_type_t *
(*afw_array_setter_determine_data_type_and_set_immutable_t)(
    const afw_array_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_add_internal() */
typedef void
(*afw_array_setter_add_internal_t)(
    const afw_array_setter_t * instance,
    const afw_data_type_t * data_type,
    const void * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_add_value() */
typedef void
(*afw_array_setter_add_value_t)(
    const afw_array_setter_t * instance,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_insert_internal() */
typedef void
(*afw_array_setter_insert_internal_t)(
    const afw_array_setter_t * instance,
    const afw_data_type_t * data_type,
    const void * internal,
    afw_size_t index,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_insert_value() */
typedef void
(*afw_array_setter_insert_value_t)(
    const afw_array_setter_t * instance,
    const afw_value_t * value,
    afw_size_t index,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_remove_all_values() */
typedef void
(*afw_array_setter_remove_all_values_t)(
    const afw_array_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_remove_internal() */
typedef void
(*afw_array_setter_remove_internal_t)(
    const afw_array_setter_t * instance,
    const afw_data_type_t * data_type,
    const void * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_remove_value() */
typedef void
(*afw_array_setter_remove_value_t)(
    const afw_array_setter_t * instance,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @sa afw_array_setter_set_value_by_index() */
typedef void
(*afw_array_setter_set_value_by_index_t)(
    const afw_array_setter_t * instance,
    afw_size_t index,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @brief Interface afw_array_setter_inf_s struct. */
struct afw_array_setter_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_array_setter_set_immutable_t set_immutable;
    afw_array_setter_determine_data_type_and_set_immutable_t determine_data_type_and_set_immutable;
    afw_array_setter_add_internal_t add_internal;
    afw_array_setter_add_value_t add_value;
    afw_array_setter_insert_internal_t insert_internal;
    afw_array_setter_insert_value_t insert_value;
    afw_array_setter_remove_all_values_t remove_all_values;
    afw_array_setter_remove_internal_t remove_internal;
    afw_array_setter_remove_value_t remove_value;
    afw_array_setter_set_value_by_index_t set_value_by_index;
};

/**
 * @brief Call method set_immutable of interface afw_array_setter
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_set_immutable( \
    instance, \
    xctx \
) \
(instance)->inf->set_immutable( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method determine_data_type_and_set_immutable of interface
 *     afw_array_setter
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_determine_data_type_and_set_immutable( \
    instance, \
    xctx \
) \
(instance)->inf->determine_data_type_and_set_immutable( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method add_internal of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param data_typeThe data type of internal.
 * @param internalThe internal value to add of type data_type->cType.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_add_internal( \
    instance, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->add_internal( \
    (instance), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method add_value of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param valueA value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_add_value( \
    instance, \
    value, \
    xctx \
) \
(instance)->inf->add_value( \
    (instance), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method insert_internal of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param data_typeThe data type of internal.
 * @param internalThe internal value to add of type data_type->cType.
 * @param indexThe zero based index for insert.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_insert_internal( \
    instance, \
    data_type, \
    internal, \
    index, \
    xctx \
) \
(instance)->inf->insert_internal( \
    (instance), \
    (data_type), \
    (internal), \
    (index), \
    (xctx) \
)

/**
 * @brief Call method insert_value of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param valueA value.
 * @param indexThe zero based index for insert.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_insert_value( \
    instance, \
    value, \
    index, \
    xctx \
) \
(instance)->inf->insert_value( \
    (instance), \
    (value), \
    (index), \
    (xctx) \
)

/**
 * @brief Call method remove_all_values of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_remove_all_values( \
    instance, \
    xctx \
) \
(instance)->inf->remove_all_values( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method remove_internal of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param data_typeThe data type of internal.
 * @param internalThe internal value to delete of type data_type->cType.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_remove_internal( \
    instance, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->remove_internal( \
    (instance), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method remove_value of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param valueValue.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_remove_value( \
    instance, \
    value, \
    xctx \
) \
(instance)->inf->remove_value( \
    (instance), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method set_value_by_index of interface afw_array_setter
 * @param instancePointer to this value array instance.
 * @param indexIndex relative to 0.
 * @param valueValue.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_setter_set_value_by_index( \
    instance, \
    index, \
    value, \
    xctx \
) \
(instance)->inf->set_value_by_index( \
    (instance), \
    (index), \
    (value), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_array_interface afw_array
 *
 * Adaptive value array interface.
 *
 * @{
 */


/** @brief Interface afw_array public struct. */
struct afw_array_s {
    const afw_array_inf_t *inf;
};

/** @brief define for interface afw_array name. */
#define AFW_ARRAY_INTERFACE_NAME \
"afw_array"

/** @sa afw_array_release() */
typedef void
(*afw_array_release_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_get_count() */
typedef afw_size_t
(*afw_array_get_count_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_get_data_type() */
typedef const afw_data_type_t *
(*afw_array_get_data_type_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_array_get_entry_meta() */
typedef const afw_value_t *
(*afw_array_get_entry_meta_t)(
    const afw_array_t * instance,
    afw_integer_t index,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_entry_internal() */
typedef afw_boolean_t
(*afw_array_get_entry_internal_t)(
    const afw_array_t * instance,
    afw_integer_t index,
    const afw_data_type_t * * data_type,
    const void * * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_get_entry_value() */
typedef const afw_value_t *
(*afw_array_get_entry_value_t)(
    const afw_array_t * instance,
    afw_integer_t index,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_next_entry_meta() */
typedef const afw_value_t *
(*afw_array_get_next_entry_meta_t)(
    const afw_array_t * instance,
    const afw_iterator_t * * iterator,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_next_internal() */
typedef afw_boolean_t
(*afw_array_get_next_internal_t)(
    const afw_array_t * instance,
    const afw_iterator_t * * iterator,
    const afw_data_type_t * * data_type,
    const void * * internal,
    afw_xctx_t * xctx);

/** @sa afw_array_get_next_value() */
typedef const afw_value_t *
(*afw_array_get_next_value_t)(
    const afw_array_t * instance,
    const afw_iterator_t * * iterator,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_array_get_setter() */
typedef const afw_array_setter_t *
(*afw_array_get_setter_t)(
    const afw_array_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_array_inf_s struct. */
struct afw_array_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_array_release_t release;
    afw_array_get_count_t get_count;
    afw_array_get_data_type_t get_data_type;
    afw_array_get_entry_meta_t get_entry_meta;
    afw_array_get_entry_internal_t get_entry_internal;
    afw_array_get_entry_value_t get_entry_value;
    afw_array_get_next_entry_meta_t get_next_entry_meta;
    afw_array_get_next_internal_t get_next_internal;
    afw_array_get_next_value_t get_next_value;
    afw_array_get_setter_t get_setter;
};

/**
 * @brief Call method release of interface afw_array
 * @param instancePointer to this value array instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_count of interface afw_array
 * @param instancePointer to this value array instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_count( \
    instance, \
    xctx \
) \
(instance)->inf->get_count( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_data_type of interface afw_array
 * @param instancePointer to this value array instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_data_type( \
    instance, \
    xctx \
) \
(instance)->inf->get_data_type( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_entry_meta of interface afw_array
 * @param instancePointer to this value array instance.
 * @param indexZero-based index of array entry to return.
 * @param pIf necessary, this pool is used to create the return value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_entry_meta( \
    instance, \
    index, \
    p, \
    xctx \
) \
(instance)->inf->get_entry_meta( \
    (instance), \
    (index), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_entry_internal of interface afw_array
 * @param instancePointer to this value array instance.
 * @param indexZero-based index of array entry to return.
 * @param data_typePlace to put data type pointer or NULL.
 * @param internalPlace to put data_type->cType pointer to the internal at the
 *     specified index.
 *     This will be set to NULL if index is out of range.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_entry_internal( \
    instance, \
    index, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->get_entry_internal( \
    (instance), \
    (index), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method get_entry_value of interface afw_array
 * @param instancePointer to this value array instance.
 * @param indexZero-based index of array entry to return.
 * @param pIf necessary, this pool is used to create the return value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_entry_value( \
    instance, \
    index, \
    p, \
    xctx \
) \
(instance)->inf->get_entry_value( \
    (instance), \
    (index), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_next_entry_meta of interface afw_array
 * @param instancePointer to this value array instance.
 * @param iteratorAddress of iterator pointer.
 * @param pIf necessary, this pool is used to create the return value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_next_entry_meta( \
    instance, \
    iterator, \
    p, \
    xctx \
) \
(instance)->inf->get_next_entry_meta( \
    (instance), \
    (iterator), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_next_internal of interface afw_array
 * @param instancePointer to this value array instance.
 * @param iteratorAddress of iterator pointer.
 * @param data_typePlace to put data type pointer or NULL.
 * @param internalPlace to put data_type->cType pointer to next internal.
 *     This will be set to NULL if there is no next internal.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_next_internal( \
    instance, \
    iterator, \
    data_type, \
    internal, \
    xctx \
) \
(instance)->inf->get_next_internal( \
    (instance), \
    (iterator), \
    (data_type), \
    (internal), \
    (xctx) \
)

/**
 * @brief Call method get_next_value of interface afw_array
 * @param instancePointer to this value array instance.
 * @param iteratorAddress of iterator pointer.
 * @param pIf necessary, this pool is used to create the return value.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_next_value( \
    instance, \
    iterator, \
    p, \
    xctx \
) \
(instance)->inf->get_next_value( \
    (instance), \
    (iterator), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_setter of interface afw_array
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_array_get_setter( \
    instance, \
    xctx \
) \
(instance)->inf->get_setter( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_log_factory_interface afw_log_factory
 *
 * Log factory.
 *
 * @{
 */


/** @brief Interface afw_log_factory public struct. */
struct afw_log_factory_s {
    const afw_log_factory_inf_t *inf;

    /**
     * Type of log this factory creates.
     */
    afw_utf8_t log_type;

    /**
     * Type of adaptor this factory creates.
     */
    const afw_utf8_t * description;
};

/** @brief define for interface afw_log_factory name. */
#define AFW_LOG_FACTORY_INTERFACE_NAME \
"afw_log_factory"

/** @sa afw_log_factory_create_log_cede_p() */
typedef const afw_log_t *
(*afw_log_factory_create_log_cede_p_t)(
    const afw_log_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_log_factory_inf_s struct. */
struct afw_log_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_log_factory_create_log_cede_p_t create_log_cede_p;
};

/**
 * @brief Call method create_log_cede_p of interface afw_log_factory
 * @param instancePointer to this log factory instance.
 * @param propertiesCreation parameters for the particular type of log. This
 *     will become properties object for log.
 * @param pPool to use for log resources.
 * @param xctxThis is the caller's xctx.
 */
#define afw_log_factory_create_log_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_log_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_log_interface afw_log
 *
 * Log.
 *
 * @{
 */


/** @brief Interface afw_log public struct. */
struct afw_log_s {
    const afw_log_inf_t *inf;

    /**
     * Pool used for afw_log resources.
     */
    const afw_pool_t * p;

    /**
     * Log's id.
     */
    afw_utf8_t log_id;

    /**
     * This is the associated service id. The path of the service is
     * "/afw/_AdaptiveService_/" followed by this id.
     */
    const afw_utf8_t * service_id;

    /**
     * This log's properties (configuration) object.
     */
    const afw_object_t * properties;

    /**
     * This is the source location to help determine how this log was defined.
     */
    const afw_utf8_t * source_location;

    /**
     * Used by log common code.
     */
    const afw_log_impl_t * impl;
};

/** @brief define for interface afw_log name. */
#define AFW_LOG_INTERFACE_NAME \
"afw_log"

/** @sa afw_log_destroy() */
typedef void
(*afw_log_destroy_t)(
    const afw_log_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_log_set_own_mask() */
typedef void
(*afw_log_set_own_mask_t)(
    const afw_log_t * instance,
    afw_log_priority_mask_t mask,
    afw_xctx_t * xctx);

/** @sa afw_log_write() */
typedef void
(*afw_log_write_t)(
    const afw_log_t * instance,
    afw_log_priority_t priority,
    const afw_utf8_z_t * source_z,
    const afw_utf8_t * message,
    afw_xctx_t * xctx);

/** @brief Interface afw_log_inf_s struct. */
struct afw_log_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_log_destroy_t destroy;
    afw_log_set_own_mask_t set_own_mask;
    afw_log_write_t write;
};

/**
 * @brief Call method destroy of interface afw_log
 * @param instancePointer to this log instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_log_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method set_own_mask of interface afw_log
 * @param instancePointer to this log instance.
 * @param maskLog priority mask.
 * @param xctxThis is the caller's xctx.
 */
#define afw_log_set_own_mask( \
    instance, \
    mask, \
    xctx \
) \
(instance)->inf->set_own_mask( \
    (instance), \
    (mask), \
    (xctx) \
)

/**
 * @brief Call method write of interface afw_log
 * @param instancePointer to this log instance.
 * @param priorityLog priority level.
 * @param source_zSource file name
 * @param messageMessage to log.
 * @param xctxThis is the caller's xctx.
 */
#define afw_log_write( \
    instance, \
    priority, \
    source_z, \
    message, \
    xctx \
) \
(instance)->inf->write( \
    (instance), \
    (priority), \
    (source_z), \
    (message), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_object_setter_interface afw_object_setter
 *
 * This is interface used to set properties and meta of an adaptive object.
 * See interface afw_object method get_object_setter for more information.
 *
 * @{
 */


/** @brief Interface afw_object_setter public struct. */
struct afw_object_setter_s {
    const afw_object_setter_inf_t *inf;

    /**
     * This is the object associated with this object setter interface.
     */
    const afw_object_t * object;
};

/** @brief define for interface afw_object_setter name. */
#define AFW_OBJECT_SETTER_INTERFACE_NAME \
"afw_object_setter"

/** @sa afw_object_setter_set_immutable() */
typedef void
(*afw_object_setter_set_immutable_t)(
    const afw_object_setter_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_setter_set_property() */
typedef void
(*afw_object_setter_set_property_t)(
    const afw_object_setter_t * instance,
    const afw_utf8_t * property_name,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @brief Interface afw_object_setter_inf_s struct. */
struct afw_object_setter_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_object_setter_set_immutable_t set_immutable;
    afw_object_setter_set_property_t set_property;
};

/**
 * @brief Call method set_immutable of interface afw_object_setter
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_setter_set_immutable( \
    instance, \
    xctx \
) \
(instance)->inf->set_immutable( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method set_property of interface afw_object_setter
 * @param instancePointer to this object setter instance.
 * @param property_nameProperty name of property to set.
 * @param valueValue to set or NULL to remove the property.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_setter_set_property( \
    instance, \
    property_name, \
    value, \
    xctx \
) \
(instance)->inf->set_property( \
    (instance), \
    (property_name), \
    (value), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_object_interface afw_object
 *
 * This is interface used to access the properties of an adaptive object.
 *
 * @{
 */


/** @brief Interface afw_object public struct. */
struct afw_object_s {
    const afw_object_inf_t *inf;

    /**
     * This is the pool containing the object. This will be NULL if the
     * object is a const object.
     * 
     * This pool can be use to allocate memory that will last for the life
     * of the object and to register callback functions to call when the
     * object is released.
     * 
     * Depending on the afw_object implementation, this may be a subpool
     * of the pool the object was created in. If it is a subpool, the
     * release() method will release the subpool.
     */
    const afw_pool_t * p;

    /**
     * This is the meta associated with this object. See afw_object_meta.h
     * for more information.
     */
    afw_object_meta_t meta;
};

/** @brief define for interface afw_object name. */
#define AFW_OBJECT_INTERFACE_NAME \
"afw_object"

/** @sa afw_object_release() */
typedef void
(*afw_object_release_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_get_reference() */
typedef void
(*afw_object_get_reference_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_get_count() */
typedef afw_size_t
(*afw_object_get_count_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_get_meta() */
typedef const afw_value_t *
(*afw_object_get_meta_t)(
    const afw_object_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_object_get_property() */
typedef const afw_value_t *
(*afw_object_get_property_t)(
    const afw_object_t * instance,
    const afw_utf8_t * property_name,
    afw_xctx_t * xctx);

/** @sa afw_object_get_property_meta() */
typedef const afw_value_t *
(*afw_object_get_property_meta_t)(
    const afw_object_t * instance,
    const afw_utf8_t * property_name,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_object_get_next_property() */
typedef const afw_value_t *
(*afw_object_get_next_property_t)(
    const afw_object_t * instance,
    const afw_iterator_t * * iterator,
    const afw_utf8_t * * property_name,
    afw_xctx_t * xctx);

/** @sa afw_object_get_next_property_meta() */
typedef const afw_value_t *
(*afw_object_get_next_property_meta_t)(
    const afw_object_t * instance,
    const afw_iterator_t * * iterator,
    const afw_utf8_t * * property_name,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_object_has_property() */
typedef afw_boolean_t
(*afw_object_has_property_t)(
    const afw_object_t * instance,
    const afw_utf8_t * property_name,
    afw_xctx_t * xctx);

/** @sa afw_object_get_setter() */
typedef const afw_object_setter_t *
(*afw_object_get_setter_t)(
    const afw_object_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_object_inf_s struct. */
struct afw_object_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_object_release_t release;
    afw_object_get_reference_t get_reference;
    afw_object_get_count_t get_count;
    afw_object_get_meta_t get_meta;
    afw_object_get_property_t get_property;
    afw_object_get_property_meta_t get_property_meta;
    afw_object_get_next_property_t get_next_property;
    afw_object_get_next_property_meta_t get_next_property_meta;
    afw_object_has_property_t has_property;
    afw_object_get_setter_t get_setter;
};

/**
 * @brief Call method release of interface afw_object
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_reference of interface afw_object
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_reference( \
    instance, \
    xctx \
) \
(instance)->inf->get_reference( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_count of interface afw_object
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_count( \
    instance, \
    xctx \
) \
(instance)->inf->get_count( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_meta of interface afw_object
 * @param instancePointer to this object instance.
 * @param pPool to use for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_meta( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_meta( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_property of interface afw_object
 * @param instancePointer to this object instance.
 * @param property_nameProperty name.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_property( \
    instance, \
    property_name, \
    xctx \
) \
(instance)->inf->get_property( \
    (instance), \
    (property_name), \
    (xctx) \
)

/**
 * @brief Call method get_property_meta of interface afw_object
 * @param instancePointer to this object instance.
 * @param property_nameProperty name.
 * @param pPool to use for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_property_meta( \
    instance, \
    property_name, \
    p, \
    xctx \
) \
(instance)->inf->get_property_meta( \
    (instance), \
    (property_name), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_next_property of interface afw_object
 * @param instancePointer to this object instance.
 * @param iteratorAddress of iterator pointer. Set to NULL before call to get
 *     first property.
 * @param property_namePlace to return pointer to property name or NULL.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_next_property( \
    instance, \
    iterator, \
    property_name, \
    xctx \
) \
(instance)->inf->get_next_property( \
    (instance), \
    (iterator), \
    (property_name), \
    (xctx) \
)

/**
 * @brief Call method get_next_property_meta of interface afw_object
 * @param instancePointer to this object instance.
 * @param iteratorAddress of iterator pointer. Set to NULL before call to get
 *     first property.
 * @param property_namePlace to return pointer to property name.
 * @param pPool to use for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_next_property_meta( \
    instance, \
    iterator, \
    property_name, \
    p, \
    xctx \
) \
(instance)->inf->get_next_property_meta( \
    (instance), \
    (iterator), \
    (property_name), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method has_property of interface afw_object
 * @param instancePointer to this object instance.
 * @param property_nameProperty name.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_has_property( \
    instance, \
    property_name, \
    xctx \
) \
(instance)->inf->has_property( \
    (instance), \
    (property_name), \
    (xctx) \
)

/**
 * @brief Call method get_setter of interface afw_object
 * @param instancePointer to this object instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_get_setter( \
    instance, \
    xctx \
) \
(instance)->inf->get_setter( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_server_interface afw_server
 *
 * Adaptive framework server interface.
 *
 * @{
 */


/** @brief Interface afw_server public struct. */
struct afw_server_s {
    const afw_server_inf_t *inf;

    /**
     * Server's xctx.
     */
    afw_xctx_t * xctx;

    /**
     * Adaptive object that contains the properties of this server.
     */
    const afw_object_t * properties;

    /**
     * The version of libafw compiled against.
     */
    const afw_utf8_t * afw_compiled_version;

    /**
     * The version of libafw compiled against.
     */
    const afw_utf8_t * afw_version;

    /**
     * The number of concurrent requests. Set atomically.
     */
    AFW_ATOMIC afw_integer_t concurrent;

    /**
     * The maximum number of concurrent requests. Set atomically.
     */
    AFW_ATOMIC afw_integer_t max_concurrent;

    /**
     * The current request count. Increment atomically.
     */
    AFW_ATOMIC afw_integer_t request_count;

    /**
     * An Adaptive Framework server can be implemented in a variety of ways.
     * This field identifies the type of this server.
     */
    const afw_utf8_t * server_type;

    /**
     * This version represents the compiled version of the Adaptive Framework
     * server code.
     */
    const afw_utf8_t * server_version;

    /**
     * This timestamp represents when the server was started.
     */
    const afw_dateTime_t * start_time;

    /**
     * The number of threads to create at startup to process client requests.
     */
    AFW_ATOMIC afw_integer_t thread_count;

    /**
     * The number of errors that remained unreported. This usually happens when
     * an error occurs while trying to respond to an error.
     */
    AFW_ATOMIC afw_integer_t unhandled_errors;
};

/** @brief define for interface afw_server name. */
#define AFW_SERVER_INTERFACE_NAME \
"afw_server"

/** @sa afw_server_release() */
typedef void
(*afw_server_release_t)(
    const afw_server_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_server_run() */
typedef void
(*afw_server_run_t)(
    const afw_server_t * instance,
    const afw_request_handler_t * handler,
    afw_xctx_t * xctx);

/** @brief Interface afw_server_inf_s struct. */
struct afw_server_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_server_release_t release;
    afw_server_run_t run;
};

/**
 * @brief Call method release of interface afw_server
 * @param instancePointer to this adaptive server instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_server_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method run of interface afw_server
 * @param instancePointer to this adaptive server instance.
 * @param handlerMain request handler function.
 * @param xctxThis is the caller's xctx.
 */
#define afw_server_run( \
    instance, \
    handler, \
    xctx \
) \
(instance)->inf->run( \
    (instance), \
    (handler), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_service_type_interface afw_service_type
 *
 * Adaptive framework service type interface. Each instance is registered in the
 * environment with type of "service_type" and id of the service type id.
 *
 * @{
 */


/** @brief Interface afw_service_type public struct. */
struct afw_service_type_s {
    const afw_service_type_inf_t *inf;

    /**
     * Service type id.
     */
    afw_utf8_t service_type_id;

    /**
     * Service type' title.
     */
    const afw_utf8_t * title;

    /**
     * Service type's description.
     */
    const afw_utf8_t * description;

    /**
     * Conf type for this service type.
     */
    const afw_environment_conf_type_t * conf_type;

    /**
     * Conf type object for this service type.
     */
    const afw_object_t * conf_type_object;
};

/** @brief define for interface afw_service_type name. */
#define AFW_SERVICE_TYPE_INTERFACE_NAME \
"afw_service_type"

/** @sa afw_service_type_related_instance_count() */
typedef afw_integer_t
(*afw_service_type_related_instance_count_t)(
    const afw_service_type_t * instance,
    const afw_utf8_t * id,
    afw_xctx_t * xctx);

/** @sa afw_service_type_start_cede_p() */
typedef void
(*afw_service_type_start_cede_p_t)(
    const afw_service_type_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_service_type_stop() */
typedef void
(*afw_service_type_stop_t)(
    const afw_service_type_t * instance,
    const afw_utf8_t * id,
    afw_xctx_t * xctx);

/** @sa afw_service_type_restart_cede_p() */
typedef void
(*afw_service_type_restart_cede_p_t)(
    const afw_service_type_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_service_type_inf_s struct. */
struct afw_service_type_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_service_type_related_instance_count_t related_instance_count;
    afw_service_type_start_cede_p_t start_cede_p;
    afw_service_type_stop_t stop;
    afw_service_type_restart_cede_p_t restart_cede_p;
};

/**
 * @brief Call method related_instance_count of interface afw_service_type
 * @param instancePointer to this adaptive service type instance.
 * @param idValue of appropriate id property for type.
 * @param xctxThis is the caller's xctx.
 */
#define afw_service_type_related_instance_count( \
    instance, \
    id, \
    xctx \
) \
(instance)->inf->related_instance_count( \
    (instance), \
    (id), \
    (xctx) \
)

/**
 * @brief Call method start_cede_p of interface afw_service_type
 * @param instancePointer to this adaptive service type instance.
 * @param propertiesProperties for start. This object will already be checked to
 *     insure
 *     the appropriate id and subtype property is present for the
 *     type. Other than that, these properties need to be validated `using
 *     /afw/_AdaptiveObjectType_/_AdaptiveConf_<type>_<subtype>`.
 * @param pPool to cede to start.
 * @param xctxThis is the caller's xctx.
 */
#define afw_service_type_start_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->start_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method stop of interface afw_service_type
 * @param instancePointer to this adaptive service type instance.
 * @param idValue of appropriate id property for type.
 * @param xctxThis is the caller's xctx.
 */
#define afw_service_type_stop( \
    instance, \
    id, \
    xctx \
) \
(instance)->inf->stop( \
    (instance), \
    (id), \
    (xctx) \
)

/**
 * @brief Call method restart_cede_p of interface afw_service_type
 * @param instancePointer to this adaptive service type instance.
 * @param propertiesProperties for start. This object will already be checked to
 *     insure
 *     the appropriate id and subtype property is present for the
 *     type. Other than that, these properties need to be validated `using
 *     /afw/_AdaptiveObjectType_/_AdaptiveConf_<type>_<subtype>`.
 * @param pPool to cede to start.
 * @param xctxThis is the caller's xctx.
 */
#define afw_service_type_restart_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->restart_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_object_associative_array_interface afw_object_associative_array
 *
 * This is interface for an object associative array.
 *
 * @{
 */


/** @brief Interface afw_object_associative_array public struct. */
struct afw_object_associative_array_s {
    const afw_object_associative_array_inf_t *inf;

    /**
     * This is a pool specified when the associative array is created.
     * 
     * Depending on the implementation, this will be a subpool of the pool
     * specified on the create function for the object associative array.
     * 
     * This pool can be used for objects created to be part of the object
     * associative array.
     */
    const afw_pool_t * p;
};

/** @brief define for interface afw_object_associative_array name. */
#define AFW_OBJECT_ASSOCIATIVE_ARRAY_INTERFACE_NAME \
"afw_object_associative_array"

/** @sa afw_object_associative_array_release() */
typedef void
(*afw_object_associative_array_release_t)(
    const afw_object_associative_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_get_reference() */
typedef void
(*afw_object_associative_array_get_reference_t)(
    const afw_object_associative_array_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_get() */
typedef const afw_object_t *
(*afw_object_associative_array_get_t)(
    const afw_object_associative_array_t * instance,
    const afw_utf8_t * key,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_get_associated_object_reference() */
typedef const afw_object_t *
(*afw_object_associative_array_get_associated_object_reference_t)(
    const afw_object_associative_array_t * instance,
    const afw_utf8_t * key,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_for_each() */
typedef void
(*afw_object_associative_array_for_each_t)(
    const afw_object_associative_array_t * instance,
    void * context,
    afw_object_cb_t cb,
    afw_xctx_t * xctx);

/** @sa afw_object_associative_array_set() */
typedef void
(*afw_object_associative_array_set_t)(
    const afw_object_associative_array_t * instance,
    const afw_utf8_t * key,
    const afw_object_t * object,
    afw_xctx_t * xctx);

/** @brief Interface afw_object_associative_array_inf_s struct. */
struct afw_object_associative_array_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_object_associative_array_release_t release;
    afw_object_associative_array_get_reference_t get_reference;
    afw_object_associative_array_get_t get;
    afw_object_associative_array_get_associated_object_reference_t get_associated_object_reference;
    afw_object_associative_array_for_each_t for_each;
    afw_object_associative_array_set_t set;
};

/**
 * @brief Call method release of interface afw_object_associative_array
 * @param instancePointer to this object associative array instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_associative_array_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_reference of interface afw_object_associative_array
 * @param instancePointer to this object associative array instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_associative_array_get_reference( \
    instance, \
    xctx \
) \
(instance)->inf->get_reference( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get of interface afw_object_associative_array
 * @param instancePointer to this object associative array instance.
 * @param keyThe key associated with the object.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_associative_array_get( \
    instance, \
    key, \
    xctx \
) \
(instance)->inf->get( \
    (instance), \
    (key), \
    (xctx) \
)

/**
 * @brief Call method get_associated_object_reference of interface
 *     afw_object_associative_array
 * @param instancePointer to this object associative array instance.
 * @param keyThe key associated with the object.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_associative_array_get_associated_object_reference( \
    instance, \
    key, \
    xctx \
) \
(instance)->inf->get_associated_object_reference( \
    (instance), \
    (key), \
    (xctx) \
)

/**
 * @brief Call method for_each of interface afw_object_associative_array
 * @param instancePointer to this object associative array instance.
 * @param contextContext passed to callback function.
 * @param cbCallback function.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_associative_array_for_each( \
    instance, \
    context, \
    cb, \
    xctx \
) \
(instance)->inf->for_each( \
    (instance), \
    (context), \
    (cb), \
    (xctx) \
)

/**
 * @brief Call method set of interface afw_object_associative_array
 * @param instancePointer to this object associative array instance.
 * @param keyThe key associated with the object instance.
 * @param objectObject instance to associate with the key or NULL to remove a
 *     key.
 * @param xctxThis is the caller's xctx.
 */
#define afw_object_associative_array_set( \
    instance, \
    key, \
    object, \
    xctx \
) \
(instance)->inf->set( \
    (instance), \
    (key), \
    (object), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_request_handler_factory_interface afw_request_handler_factory
 *
 * Create an instance of an afw_request_handler.
 *
 * @{
 */


/** @brief Interface afw_request_handler_factory public struct. */
struct afw_request_handler_factory_s {
    const afw_request_handler_factory_inf_t *inf;

    /**
     * Type of request handler this factory creates.
     */
    afw_utf8_t request_handler_type;

    /**
     * Type of adaptor this factory creates.
     */
    const afw_utf8_t * description;
};

/** @brief define for interface afw_request_handler_factory name. */
#define AFW_REQUEST_HANDLER_FACTORY_INTERFACE_NAME \
"afw_request_handler_factory"

/** @sa afw_request_handler_factory_create_request_handler_cede_p() */
typedef const afw_request_handler_t *
(*afw_request_handler_factory_create_request_handler_cede_p_t)(
    const afw_request_handler_factory_t * instance,
    const afw_object_t * properties,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_request_handler_factory_inf_s struct. */
struct afw_request_handler_factory_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_request_handler_factory_create_request_handler_cede_p_t create_request_handler_cede_p;
};

/**
 * @brief Call method create_request_handler_cede_p of interface
 *     afw_request_handler_factory
 * @param instancePointer to this request handler factory instance.
 * @param propertiesCreation parameters for the particular type of request
 *     handler. This will become properties object for request handler.
 * @param pPool to use for request handler resources.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_handler_factory_create_request_handler_cede_p( \
    instance, \
    properties, \
    p, \
    xctx \
) \
(instance)->inf->create_request_handler_cede_p( \
    (instance), \
    (properties), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_request_handler_interface afw_request_handler
 *
 * Adaptive framework request handler interface.
 *
 * @{
 */


/** @brief Interface afw_request_handler public struct. */
struct afw_request_handler_s {
    const afw_request_handler_inf_t *inf;
};

/** @brief define for interface afw_request_handler name. */
#define AFW_REQUEST_HANDLER_INTERFACE_NAME \
"afw_request_handler"

/** @sa afw_request_handler_release() */
typedef void
(*afw_request_handler_release_t)(
    const afw_request_handler_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_request_handler_process() */
typedef void
(*afw_request_handler_process_t)(
    const afw_request_handler_t * instance,
    const afw_request_t * request,
    afw_xctx_t * xctx);

/** @brief Interface afw_request_handler_inf_s struct. */
struct afw_request_handler_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_request_handler_release_t release;
    afw_request_handler_process_t process;
};

/**
 * @brief Call method release of interface afw_request_handler
 * @param instancePointer to this adaptive request handler instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_handler_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method process of interface afw_request_handler
 * @param instancePointer to this adaptive request instance.
 * @param requestBuffer to store data read.
 * @param xctxExecution context (xctx) the request should run in. If this is a
 *     new
 *     request session, this should be the request session's xctx.
 */
#define afw_request_handler_process( \
    instance, \
    request, \
    xctx \
) \
(instance)->inf->process( \
    (instance), \
    (request), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_connection_interface afw_connection
 *
 * Adaptive Framework connection. This has not yet been developed.
 *
 * @{
 */


/** @brief Interface afw_connection public struct. */
struct afw_connection_s {
    const afw_connection_inf_t *inf;
};

/** @brief define for interface afw_connection name. */
#define AFW_CONNECTION_INTERFACE_NAME \
"afw_connection"

/** @sa afw_connection_release() */
typedef void
(*afw_connection_release_t)(
    const afw_connection_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_connection_inf_s struct. */
struct afw_connection_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_connection_release_t release;
};

/**
 * @brief Call method release of interface afw_connection
 * @param instancePointer to this adaptive request instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_connection_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_iterator_interface afw_iterator
 *
 * This is the interface for an iterator. An iterator is created by the
 * 'afw_value' 'create_iterator()' method.
 *
 * @{
 */


/** @brief Interface afw_iterator public struct. */
struct afw_iterator_s {
    const afw_iterator_inf_t *inf;
};

/** @brief define for interface afw_iterator name. */
#define AFW_ITERATOR_INTERFACE_NAME \
"afw_iterator"

/** @sa afw_iterator_release() */
typedef void
(*afw_iterator_release_t)(
    const afw_iterator_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_iterator_next() */
typedef afw_boolean_t
(*afw_iterator_next_t)(
    const afw_iterator_t * instance,
    const afw_value_t ** key,
    const afw_value_t ** value);

/** @brief Interface afw_iterator_inf_s struct. */
struct afw_iterator_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_iterator_release_t release;
    afw_iterator_next_t next;
};

/**
 * @brief Call method release of interface afw_iterator
 * @param instancePointer to this stream instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_iterator_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method next of interface afw_iterator
 * @param instancePointer to this stream instance.
 * @param keyThis is a pointer to the place to return the key value or NULL if
 *     it does not need to be returned.
 * @param valueThis is a pointer to the place to return the value or NULL if
 *     it does not need to be returned.
 */
#define afw_iterator_next( \
    instance, \
    key, \
    value \
) \
(instance)->inf->next( \
    (instance), \
    (key), \
    (value) \
)

/** @} */

/**
 * @addtogroup afw_request_interface afw_request
 *
 * Adaptive framework request interface.
 *
 * @{
 */


/** @brief Interface afw_request public struct. */
struct afw_request_s {
    const afw_request_inf_t *inf;

    /**
     * Request's xctx.
     */
    afw_xctx_t * xctx;

    /**
     * Read content callback function. Context must be this afw_request
     * instance.
     */
    afw_read_cb_t read_content_cb;

    /**
     * Write content callback function. Context must be this afw_request
     * instance.
     */
    afw_write_cb_t write_content_cb;

    /**
     * Adaptive object that holds the request properties.
     * 
     * This object constrains all of the request variables associated with the
     * request. In the case of fastcgi and nginx, this will be all of the
     * variables specified with fastcgi_param in the configuration. The
     * property name within this object matches the variable name.
     * 
     * Additional properties can be set while processing a request.
     * 
     * Property "_cache" is a special property whose value is an object with
     * property names matching the uri of a cached object. These cached
     * objects are any objects retrieved or produced during the processing of
     * a request.
     * 
     * Any property name of the form `"RESPONSE_HEADER_<x>"` will be
     * emitted as a response header field with a name of `<x>`. Always
     * set these properties before calling write_response() or the results are
     * undetermined.
     * 
     * Several standard properties that should be available are:
     * 
     * URI - the normalized uri of request
     * 
     * QUERY_STRING - the query string.
     * 
     * REQUEST_METHOD - the http method of the request. Usually, "GET",
     * "POST", "PUT", or "DELETE".
     * 
     * CONTENT_TYPE - the content type of the request
     * 
     * If any other request information is needed, the creator of this object
     * should make it available.
     */
    const afw_object_t * properties;

    /**
     * Request's method.
     */
    const afw_utf8_t * method;

    /**
     * Request's URI.
     */
    const afw_utf8_t * uri;

    /**
     * Request's query string.
     */
    const afw_utf8_t * query_string;

    /**
     * Request's content type.
     */
    const afw_utf8_t * content_type;

    /**
     * Request's content length or -1 if chunked-encoding
     */
    afw_size_t content_length;

    /**
     * NULL terminated array of acceptable response content types.
     */
    const afw_utf8_t * const * accept;

    /**
     * This can be set using method set_error_info() by a request handler to
     * supply additional informational properties that may be useful if an
     * error is thrown.
     */
    const afw_object_t * error_info;

    /**
     * Response content type instance. Set by first call to
     * afw_request_get_response_content_type().
     */
    const afw_content_type_t * response_content_type;

    /**
     * Connection has been closed so all future writes will be ignored.
     */
    afw_boolean_t is_closed;
};

/** @brief define for interface afw_request name. */
#define AFW_REQUEST_INTERFACE_NAME \
"afw_request"

/** @sa afw_request_release() */
typedef void
(*afw_request_release_t)(
    const afw_request_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_request_set_error_info() */
typedef void
(*afw_request_set_error_info_t)(
    const afw_request_t * instance,
    const afw_object_t * error_info,
    afw_xctx_t * xctx);

/** @sa afw_request_read_raw_request_body() */
typedef void
(*afw_request_read_raw_request_body_t)(
    const afw_request_t * instance,
    afw_size_t buffer_size,
    void * buffer,
    afw_size_t * size,
    afw_boolean_t * more_to_read,
    afw_xctx_t * xctx);

/** @sa afw_request_set_response_status_code() */
typedef void
(*afw_request_set_response_status_code_t)(
    const afw_request_t * instance,
    const afw_utf8_t * code,
    const afw_utf8_t * reason,
    afw_xctx_t * xctx);

/** @sa afw_request_write_response_header() */
typedef void
(*afw_request_write_response_header_t)(
    const afw_request_t * instance,
    const afw_utf8_t * name,
    const afw_utf8_t * value,
    afw_xctx_t * xctx);

/** @sa afw_request_write_raw_response_body() */
typedef void
(*afw_request_write_raw_response_body_t)(
    const afw_request_t * instance,
    afw_size_t size,
    const void * buffer,
    afw_xctx_t * xctx);

/** @sa afw_request_flush_response() */
typedef void
(*afw_request_flush_response_t)(
    const afw_request_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_request_finish_response() */
typedef void
(*afw_request_finish_response_t)(
    const afw_request_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_request_inf_s struct. */
struct afw_request_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_request_release_t release;
    afw_request_set_error_info_t set_error_info;
    afw_request_read_raw_request_body_t read_raw_request_body;
    afw_request_set_response_status_code_t set_response_status_code;
    afw_request_write_response_header_t write_response_header;
    afw_request_write_raw_response_body_t write_raw_response_body;
    afw_request_flush_response_t flush_response;
    afw_request_finish_response_t finish_response;
};

/**
 * @brief Call method release of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method set_error_info of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param error_infoError info object pointer.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_set_error_info( \
    instance, \
    error_info, \
    xctx \
) \
(instance)->inf->set_error_info( \
    (instance), \
    (error_info), \
    (xctx) \
)

/**
 * @brief Call method read_raw_request_body of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param buffer_sizeLength of the buffer in bytes.
 * @param bufferBuffer to store data read.
 * @param sizePlace to return number of bytes read.
 * @param more_to_readIndicate there is more input to read.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_read_raw_request_body( \
    instance, \
    buffer_size, \
    buffer, \
    size, \
    more_to_read, \
    xctx \
) \
(instance)->inf->read_raw_request_body( \
    (instance), \
    (buffer_size), \
    (buffer), \
    (size), \
    (more_to_read), \
    (xctx) \
)

/**
 * @brief Call method set_response_status_code of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param codeThree-digit status code that conforms to http RFC.
 * @param reasonStatus reason phrase. If NULL and the status_code is standard,
 *     the standard phrase is supplied.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_set_response_status_code( \
    instance, \
    code, \
    reason, \
    xctx \
) \
(instance)->inf->set_response_status_code( \
    (instance), \
    (code), \
    (reason), \
    (xctx) \
)

/**
 * @brief Call method write_response_header of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param nameType of header.
 * @param valueValue of header.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_write_response_header( \
    instance, \
    name, \
    value, \
    xctx \
) \
(instance)->inf->write_response_header( \
    (instance), \
    (name), \
    (value), \
    (xctx) \
)

/**
 * @brief Call method write_raw_response_body of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param sizeNumber of bytes in buffer to write.
 * @param bufferBuffer to write.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_write_raw_response_body( \
    instance, \
    size, \
    buffer, \
    xctx \
) \
(instance)->inf->write_raw_response_body( \
    (instance), \
    (size), \
    (buffer), \
    (xctx) \
)

/**
 * @brief Call method flush_response of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_flush_response( \
    instance, \
    xctx \
) \
(instance)->inf->flush_response( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method finish_response of interface afw_request
 * @param instancePointer to this adaptive request instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_request_finish_response( \
    instance, \
    xctx \
) \
(instance)->inf->finish_response( \
    (instance), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_stream_interface afw_stream
 *
 * An interface for a stream.
 *
 * @{
 */


/** @brief Interface afw_stream public struct. */
struct afw_stream_s {
    const afw_stream_inf_t *inf;

    /**
     * Pool used for stream resources including write method implementation.
     */
    const afw_pool_t * p;

    /**
     * This is the id of stream.
     */
    const afw_utf8_t * streamId;

    /**
     * This can be passed to functions that expect an afw_read_cb_t
     * callback. The first parameter passed to the callback must be this
     * afw_stream instance. This can also be NULL if the stream is not
     * readable.
     */
    afw_read_cb_t read_cb;

    /**
     * This can be passed to functions that expect an afw_write_cb_t
     * callback. The first parameter passed to the callback must be this
     * afw_stream instance. This is a raw write, so indentation is ignored
     * and the buffer written must be compatible with the afw_stream
     * instance's content. This can also be NULL if the stream is not
     * writable.
     */
    afw_write_cb_t write_cb;

    /**
     * This is a standard stream that is automatically created and released.
     */
    const afw_boolean_t is_standard;
};

/** @brief define for interface afw_stream name. */
#define AFW_STREAM_INTERFACE_NAME \
"afw_stream"

/** @sa afw_stream_release() */
typedef void
(*afw_stream_release_t)(
    const afw_stream_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_stream_flush() */
typedef void
(*afw_stream_flush_t)(
    const afw_stream_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_stream_read() */
typedef void
(*afw_stream_read_t)(
    const afw_stream_t * instance,
    const void * buffer,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_stream_write() */
typedef void
(*afw_stream_write_t)(
    const afw_stream_t * instance,
    const void * buffer,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @brief Interface afw_stream_inf_s struct. */
struct afw_stream_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_stream_release_t release;
    afw_stream_flush_t flush;
    afw_stream_read_t read;
    afw_stream_write_t write;
};

/**
 * @brief Call method release of interface afw_stream
 * @param instancePointer to this stream instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_stream_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method flush of interface afw_stream
 * @param instancePointer to this stream instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_stream_flush( \
    instance, \
    xctx \
) \
(instance)->inf->flush( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method read of interface afw_stream
 * @param instancePointer to this stream instance.
 * @param bufferBuffer to write.
 * @param sizeSize of buffer.
 * @param xctxThis is the caller's xctx.
 */
#define afw_stream_read( \
    instance, \
    buffer, \
    size, \
    xctx \
) \
(instance)->inf->read( \
    (instance), \
    (buffer), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method write of interface afw_stream
 * @param instancePointer to this stream instance.
 * @param bufferBuffer to write.
 * @param sizeSize of buffer.
 * @param xctxThis is the caller's xctx.
 */
#define afw_stream_write( \
    instance, \
    buffer, \
    size, \
    xctx \
) \
(instance)->inf->write( \
    (instance), \
    (buffer), \
    (size), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_pool_interface afw_pool
 *
 * Adaptive framework pool interface.
 *
 * @{
 */


/** @brief Interface afw_pool public struct. */
struct afw_pool_s {
    const afw_pool_inf_t *inf;
};

/** @brief define for interface afw_pool name. */
#define AFW_POOL_INTERFACE_NAME \
"afw_pool"

/** @sa afw_pool_release() */
typedef void
(*afw_pool_release_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_pool_get_reference() */
typedef void
(*afw_pool_get_reference_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_pool_destroy() */
typedef void
(*afw_pool_destroy_t)(
    const afw_pool_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_pool_get_apr_pool() */
typedef apr_pool_t *
(*afw_pool_get_apr_pool_t)(
    const afw_pool_t * instance);

/** @sa afw_pool_calloc() */
typedef void *
(*afw_pool_calloc_t)(
    const afw_pool_t * instance,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_pool_malloc() */
typedef void *
(*afw_pool_malloc_t)(
    const afw_pool_t * instance,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_pool_free_memory_internal() */
typedef void
(*afw_pool_free_memory_internal_t)(
    const afw_pool_t * instance,
    void * address,
    afw_xctx_t * xctx);

/** @sa afw_pool_register_cleanup_before() */
typedef void
(*afw_pool_register_cleanup_before_t)(
    const afw_pool_t * instance,
    void * data,
    void * data2,
    afw_pool_cleanup_function_p_t cleanup,
    afw_xctx_t * xctx);

/** @sa afw_pool_deregister_cleanup() */
typedef void
(*afw_pool_deregister_cleanup_t)(
    const afw_pool_t * instance,
    void * data,
    void * data2,
    afw_pool_cleanup_function_p_t cleanup,
    afw_xctx_t * xctx);

/** @brief Interface afw_pool_inf_s struct. */
struct afw_pool_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_pool_release_t release;
    afw_pool_get_reference_t get_reference;
    afw_pool_destroy_t destroy;
    afw_pool_get_apr_pool_t get_apr_pool;
    afw_pool_calloc_t calloc;
    afw_pool_malloc_t malloc;
    afw_pool_free_memory_internal_t free_memory_internal;
    afw_pool_register_cleanup_before_t register_cleanup_before;
    afw_pool_deregister_cleanup_t deregister_cleanup;
};

/**
 * @brief Call method release of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_reference of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_get_reference( \
    instance, \
    xctx \
) \
(instance)->inf->get_reference( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method destroy of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_destroy( \
    instance, \
    xctx \
) \
(instance)->inf->destroy( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_apr_pool of interface afw_pool
 * @param instancePointer to this pool instance.
 */
#define afw_pool_get_apr_pool( \
    instance \
) \
(instance)->inf->get_apr_pool( \
    (instance) \
)

/**
 * @brief Call method calloc of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param sizeSize of memory to allocate.
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_calloc( \
    instance, \
    size, \
    xctx \
) \
(instance)->inf->calloc( \
    (instance), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method malloc of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param sizeSize of memory to allocate.
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_malloc( \
    instance, \
    size, \
    xctx \
) \
(instance)->inf->malloc( \
    (instance), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method free_memory_internal of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param addressAddress of memory to free.
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_free_memory_internal( \
    instance, \
    address, \
    xctx \
) \
(instance)->inf->free_memory_internal( \
    (instance), \
    (address), \
    (xctx) \
)

/**
 * @brief Call method register_cleanup_before of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param dataData to pass to the cleanup function.
 * @param data2Data2 to pass to the cleanup function.
 * @param cleanupCleanup function to call when pool is released..
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_register_cleanup_before( \
    instance, \
    data, \
    data2, \
    cleanup, \
    xctx \
) \
(instance)->inf->register_cleanup_before( \
    (instance), \
    (data), \
    (data2), \
    (cleanup), \
    (xctx) \
)

/**
 * @brief Call method deregister_cleanup of interface afw_pool
 * @param instancePointer to this pool instance.
 * @param dataData to pass to the cleanup function.
 * @param data2Data2 to pass to the cleanup function.
 * @param cleanupCleanup function to call when pool is released..
 * @param xctxThis is the caller's xctx.
 */
#define afw_pool_deregister_cleanup( \
    instance, \
    data, \
    data2, \
    cleanup, \
    xctx \
) \
(instance)->inf->deregister_cleanup( \
    (instance), \
    (data), \
    (data2), \
    (cleanup), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_adaptor_journal_interface afw_adaptor_journal
 *
 * Adaptor journal interface.
 *
 * @{
 */


/** @brief Interface afw_adaptor_journal public struct. */
struct afw_adaptor_journal_s {
    const afw_adaptor_journal_inf_t *inf;

    /**
     * Associated adaptor session.
     */
    const afw_adaptor_session_t * session;
};

/** @brief define for interface afw_adaptor_journal name. */
#define AFW_ADAPTOR_JOURNAL_INTERFACE_NAME \
"afw_adaptor_journal"

/** @sa afw_adaptor_journal_add_entry() */
typedef const afw_utf8_t *
(*afw_adaptor_journal_add_entry_t)(
    const afw_adaptor_journal_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_object_t * entry,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_journal_get_entry() */
typedef void
(*afw_adaptor_journal_get_entry_t)(
    const afw_adaptor_journal_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    afw_adaptor_journal_option_t option,
    const afw_utf8_t * consumer_id,
    const afw_utf8_t * entry_cursor,
    afw_size_t limit,
    const afw_object_t * response,
    afw_xctx_t * xctx);

/** @sa afw_adaptor_journal_mark_entry_consumed() */
typedef void
(*afw_adaptor_journal_mark_entry_consumed_t)(
    const afw_adaptor_journal_t * instance,
    const afw_adaptor_impl_request_t * impl_request,
    const afw_utf8_t * consumer_id,
    const afw_utf8_t * entry_cursor,
    afw_xctx_t * xctx);

/** @brief Interface afw_adaptor_journal_inf_s struct. */
struct afw_adaptor_journal_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_adaptor_journal_add_entry_t add_entry;
    afw_adaptor_journal_get_entry_t get_entry;
    afw_adaptor_journal_mark_entry_consumed_t mark_entry_consumed;
};

/**
 * @brief Call method add_entry of interface afw_adaptor_journal
 * @param instancePointer to this adaptive event journal instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param entryPointer to the event to be logged in the journal.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_journal_add_entry( \
    instance, \
    impl_request, \
    entry, \
    xctx \
) \
(instance)->inf->add_entry( \
    (instance), \
    (impl_request), \
    (entry), \
    (xctx) \
)

/**
 * @brief Call method get_entry of interface afw_adaptor_journal
 * @param instancePointer to this adaptive event journal instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param optionGet entry option. See afw_adaptor_journal_option_t for
 *     more information.
 * @param consumer_idPeer id of consumer of event of NULL. See
 *     afw_adaptor_journal_option_t for information on how this
 *     parameter is used or ignored.
 * @param entry_cursorJournal entry cursor or NULL. See
 *     afw_adaptor_journal_option_t for information on how this
 *     parameter is used or ignored.
 * @param limitLimit or 0. See
 *     afw_adaptor_journal_option_t for information on how this
 *     parameter is used or ignored.
 * @param responseThis is an existing response object that can have properties
 *     already
 *     set. Depending on the option specified, get_entry() will set
 *     additional properties. See afw_adaptor_journal_option_t
 *     for information on which properties are set and under what condition.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_journal_get_entry( \
    instance, \
    impl_request, \
    option, \
    consumer_id, \
    entry_cursor, \
    limit, \
    response, \
    xctx \
) \
(instance)->inf->get_entry( \
    (instance), \
    (impl_request), \
    (option), \
    (consumer_id), \
    (entry_cursor), \
    (limit), \
    (response), \
    (xctx) \
)

/**
 * @brief Call method mark_entry_consumed of interface afw_adaptor_journal
 * @param instancePointer to this adaptive event journal instance.
 * @param impl_requestPass this as first parameter of
 *     afw_adaptor_impl_request_*() functions.
 *     See afw_adaptor_impl.h for more information.
 * @param consumer_idGet entry option. See afw_adaptor_journal_option_t for
 *     more information.
 * @param entry_cursorToken of the event to mark consumed.
 * @param xctxThis is the caller's xctx.
 */
#define afw_adaptor_journal_mark_entry_consumed( \
    instance, \
    impl_request, \
    consumer_id, \
    entry_cursor, \
    xctx \
) \
(instance)->inf->mark_entry_consumed( \
    (instance), \
    (impl_request), \
    (consumer_id), \
    (entry_cursor), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_value_interface afw_value
 *
 * Adaptive value.
 *
 * @{
 */


/** @brief Interface afw_value public struct. */
struct afw_value_s {
    const afw_value_inf_t *inf;
};

/** @brief define for interface afw_value name. */
#define AFW_VALUE_INTERFACE_NAME \
"afw_value"

/** @sa afw_value_optional_release() */
typedef void
(*afw_value_optional_release_t)(
    const afw_value_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_value_clone_or_reference() */
typedef const afw_value_t *
(*afw_value_clone_or_reference_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_create_iterator() */
typedef const afw_iterator_t *
(*afw_value_create_iterator_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_optional_evaluate() */
typedef const afw_value_t *
(*afw_value_optional_evaluate_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_get_data_type() */
typedef const afw_data_type_t *
(*afw_value_get_data_type_t)(
    const afw_value_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_value_get_evaluated_meta() */
typedef const afw_value_t *
(*afw_value_get_evaluated_meta_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_get_evaluated_metas() */
typedef const afw_value_t *
(*afw_value_get_evaluated_metas_t)(
    const afw_value_t * instance,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @sa afw_value_produce_compiler_listing() */
typedef void
(*afw_value_produce_compiler_listing_t)(
    const afw_value_t * instance,
    const afw_writer_t * writer,
    afw_xctx_t * xctx);

/** @sa afw_value_decompile() */
typedef void
(*afw_value_decompile_t)(
    const afw_value_t * instance,
    const afw_writer_t * writer,
    afw_xctx_t * xctx);

/** @sa afw_value_get_info() */
typedef void
(*afw_value_get_info_t)(
    const afw_value_t * instance,
    afw_value_info_t * info,
    const afw_pool_t * p,
    afw_xctx_t * xctx);

/** @brief Interface afw_value_inf_s struct. */
struct afw_value_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_value_optional_release_t optional_release;
    afw_value_clone_or_reference_t clone_or_reference;
    afw_value_create_iterator_t create_iterator;
    afw_value_optional_evaluate_t optional_evaluate;
    afw_value_get_data_type_t get_data_type;
    afw_value_get_evaluated_meta_t get_evaluated_meta;
    afw_value_get_evaluated_metas_t get_evaluated_metas;
    afw_value_produce_compiler_listing_t produce_compiler_listing;
    afw_value_decompile_t decompile;
    afw_value_get_info_t get_info;

    /**
     * This is the data type of the value if already evaluated or know before
     * evaluation.
     */
    const afw_data_type_t * data_type;

    /**
     * This is the data type of the value if it's already evaluated. If the
     * value is not evaluated, this value will be NULL.
     */
    const afw_data_type_t     * is_evaluated_of_data_type;
};

/**
 * @brief Call method optional_release of interface afw_value
 * @param instancePointer to this pool instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_optional_release( \
    instance, \
    xctx \
) \
(instance)->inf->optional_release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method clone_or_reference of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * @param pPool for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_clone_or_reference( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->clone_or_reference( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method create_iterator of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * @param pPool for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_create_iterator( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->create_iterator( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method optional_evaluate of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * @param pPool for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_optional_evaluate( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->optional_evaluate( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_data_type of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_get_data_type( \
    instance, \
    xctx \
) \
(instance)->inf->get_data_type( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method get_evaluated_meta of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * 
 *     IMPORTANT: Do not evaluate instance before calling since meta is
 *     harvested from the value's inf.
 * @param pPool to use for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_get_evaluated_meta( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_evaluated_meta( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method get_evaluated_metas of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * 
 *     NOTE: Always evaluate instance before calling so that right value inf
 *     is used.
 * @param pPool to use for result.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_get_evaluated_metas( \
    instance, \
    p, \
    xctx \
) \
(instance)->inf->get_evaluated_metas( \
    (instance), \
    (p), \
    (xctx) \
)

/**
 * @brief Call method produce_compiler_listing of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * @param writerPointer to writer instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_produce_compiler_listing( \
    instance, \
    writer, \
    xctx \
) \
(instance)->inf->produce_compiler_listing( \
    (instance), \
    (writer), \
    (xctx) \
)

/**
 * @brief Call method decompile of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * @param writerPointer to writer instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_decompile( \
    instance, \
    writer, \
    xctx \
) \
(instance)->inf->decompile( \
    (instance), \
    (writer), \
    (xctx) \
)

/**
 * @brief Call method get_info of interface afw_value
 * @param instancePointer to this adaptive value instance.
 * @param infoStruct that will be filled by this method with info about this
 *     value.
 * @param pPool to use if needed.
 * @param xctxThis is the caller's xctx.
 */
#define afw_value_get_info( \
    instance, \
    info, \
    p, \
    xctx \
) \
(instance)->inf->get_info( \
    (instance), \
    (info), \
    (p), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_variable_handler_interface afw_variable_handler
 *
 * Adaptive variable handler.
 *
 * @{
 */


/** @brief Interface afw_variable_handler public struct. */
struct afw_variable_handler_s {
    const afw_variable_handler_inf_t *inf;
};

/** @brief define for interface afw_variable_handler name. */
#define AFW_VARIABLE_HANDLER_INTERFACE_NAME \
"afw_variable_handler"

/** @sa afw_variable_handler_get_variable() */
typedef const afw_value_t *
(*afw_variable_handler_get_variable_t)(
    const afw_variable_handler_t * instance,
    const afw_utf8_t * qualifier,
    const afw_utf8_t * name,
    afw_xctx_t * xctx);

/** @sa afw_variable_handler_set_variable() */
typedef afw_boolean_t
(*afw_variable_handler_set_variable_t)(
    const afw_variable_handler_t * instance,
    const afw_utf8_t * qualifier,
    const afw_utf8_t * name,
    const afw_value_t * value,
    afw_xctx_t * xctx);

/** @brief Interface afw_variable_handler_inf_s struct. */
struct afw_variable_handler_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_variable_handler_get_variable_t get_variable;
    afw_variable_handler_set_variable_t set_variable;
};

/**
 * @brief Call method get_variable of interface afw_variable_handler
 * @param instancePointer to this adaptive variable handler
 *     instance.
 * @param qualifierQualifier or NULL.
 * @param nameVariable name.
 * @param xctxThis is the caller's xctx.
 */
#define afw_variable_handler_get_variable( \
    instance, \
    qualifier, \
    name, \
    xctx \
) \
(instance)->inf->get_variable( \
    (instance), \
    (qualifier), \
    (name), \
    (xctx) \
)

/**
 * @brief Call method set_variable of interface afw_variable_handler
 * @param instancePointer to this adaptive variable handler instance.
 * @param qualifierQualifier or NULL.
 * @param nameVariable name.
 * @param valueValue to set.
 * @param xctxThis is the caller's xctx.
 */
#define afw_variable_handler_set_variable( \
    instance, \
    qualifier, \
    name, \
    value, \
    xctx \
) \
(instance)->inf->set_variable( \
    (instance), \
    (qualifier), \
    (name), \
    (value), \
    (xctx) \
)

/** @} */

/**
 * @addtogroup afw_writer_interface afw_writer
 *
 * An interface for a writer.
 *
 * @{
 */


/** @brief Interface afw_writer public struct. */
struct afw_writer_s {
    const afw_writer_inf_t *inf;

    /**
     * Pool used for writer resources including write method implementation.
     */
    const afw_pool_t * p;

    /**
     * This can be passed to functions that expect an afw_write_cb_t callback.
     * The first parameter passed to the callback must be this afw_writer
     * instance. This is a raw write, so indentation is ignored and the buffer
     * written must be compatible with the afw_writer instance's content.
     */
    afw_write_cb_t write_raw_cb;

    /**
     * The current indent if whitespace is being added.
     */
    afw_size_t indent;

    /**
     * If not NULL, whitespace is added as appropriate. Calls to method
     * write_eol will cause \\n to be written. This tab strings is used as
     * needed to produce the appropriate indent. For example, "\\t" can be
     * specified to cause the number of tab characters needed for the current
     * indent.
     */
    const afw_utf8_t * tab;
};

/** @brief define for interface afw_writer name. */
#define AFW_WRITER_INTERFACE_NAME \
"afw_writer"

/** @sa afw_writer_release() */
typedef void
(*afw_writer_release_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_flush() */
typedef void
(*afw_writer_flush_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_write() */
typedef void
(*afw_writer_write_t)(
    const afw_writer_t * instance,
    const void * buffer,
    afw_size_t size,
    afw_xctx_t * xctx);

/** @sa afw_writer_write_eol() */
typedef void
(*afw_writer_write_eol_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_increment_indent() */
typedef void
(*afw_writer_increment_indent_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @sa afw_writer_decrement_indent() */
typedef void
(*afw_writer_decrement_indent_t)(
    const afw_writer_t * instance,
    afw_xctx_t * xctx);

/** @brief Interface afw_writer_inf_s struct. */
struct afw_writer_inf_s {
    afw_interface_implementation_rti_t rti;
    afw_writer_release_t release;
    afw_writer_flush_t flush;
    afw_writer_write_t write;
    afw_writer_write_eol_t write_eol;
    afw_writer_increment_indent_t increment_indent;
    afw_writer_decrement_indent_t decrement_indent;
};

/**
 * @brief Call method release of interface afw_writer
 * @param instancePointer to this writer instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_writer_release( \
    instance, \
    xctx \
) \
(instance)->inf->release( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method flush of interface afw_writer
 * @param instancePointer to this writer instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_writer_flush( \
    instance, \
    xctx \
) \
(instance)->inf->flush( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method write of interface afw_writer
 * @param instancePointer to this writer instance.
 * @param bufferBuffer to write.
 * @param sizeSize of buffer.
 * @param xctxThis is the caller's xctx.
 */
#define afw_writer_write( \
    instance, \
    buffer, \
    size, \
    xctx \
) \
(instance)->inf->write( \
    (instance), \
    (buffer), \
    (size), \
    (xctx) \
)

/**
 * @brief Call method write_eol of interface afw_writer
 * @param instancePointer to this writer instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_writer_write_eol( \
    instance, \
    xctx \
) \
(instance)->inf->write_eol( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method increment_indent of interface afw_writer
 * @param instancePointer to this writer instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_writer_increment_indent( \
    instance, \
    xctx \
) \
(instance)->inf->increment_indent( \
    (instance), \
    (xctx) \
)

/**
 * @brief Call method decrement_indent of interface afw_writer
 * @param instancePointer to this writer instance.
 * @param xctxThis is the caller's xctx.
 */
#define afw_writer_decrement_indent( \
    instance, \
    xctx \
) \
(instance)->inf->decrement_indent( \
    (instance), \
    (xctx) \
)

/** @} */


/** @} */

AFW_END_DECLARES



#endif /* __AFW_INTERFACE_H__ */
