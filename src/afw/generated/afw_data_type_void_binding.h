// See the 'COPYING' file in the project root for licensing information.
/*
 * Adaptive Data Type void
 *
 * Copyright (c) 2010-2023 Clemson University
 *
 */

/*  ----------------------------- N O T E -------------------------------------
 *
 * This file is generated by "afwdev generate afw".
 *
 * Do not change this file directly or the changes will be lost the next time
 * this file is regenerated.
 *
 * -------------------------------------------------------------------------*/


#ifndef __AFW_DATA_TYPE_VOID_BINDING_H__
#define __AFW_DATA_TYPE_VOID_BINDING_H__


#include "afw_minimal.h"
#include "afw_data_type_typedefs.h"
#include "afw_declare_helpers.h"

/**
 * @defgroup afw_c_api_data_type_void void
 * @ingroup afw_c_api_data_types
 *
 * Adaptive Data Type void
 *
 * @{
 */

/**
 * @file afw_data_type_void_binding.h
 * @brief Adaptive data type void header.
 */

AFW_BEGIN_DECLARES

/** @brief Quoted data type id for void */
#define AFW_DATA_TYPE_ID_Q_void "void"

/** @brief Unquoted data type id for void */
#define AFW_DATA_TYPE_ID_U_void void

/** @brief String for data type id void */
#define AFW_DATA_TYPE_ID_S_void afw_s_void

/** @brief Quoted c type for data type id void */
#define AFW_DATA_TYPE_CTYPE_Q_void "void *"

/** @brief Adaptive string value for "void". */
AFW_DECLARE_CONST_DATA(afw_value_t *)
afw_data_type_void_id_value;

/** @brief Data type struct for void. */
AFW_DECLARE_CONST_DATA(afw_data_type_t *)
afw_data_type_void;

/**
 * @brief Permanent (life of afw environment) value inf for data type void.
 *
 * The lifetime of the value is the lifetime of the afw environment.
 */
AFW_DECLARE_CONST_DATA(afw_value_inf_t)
afw_value_permanent_void_inf;

/**
 * @brief Macro to determine if data type is void.
 * @param A_DATA_TYPE to test.
 * @return boolean result.
 */
#define afw_data_type_is_void(A_DATA_TYPE) \
( \
    (A_DATA_TYPE) && \
    (A_DATA_TYPE) == afw_data_type_void \
)

/** @brief struct for data type void values. */
struct afw_value_void_s {
    /** @brief  Value inf union with afw_value_t pub to reduce casting needed. */
    union {
        const afw_value_inf_t *inf;
        afw_value_t pub;
    };

    /** @brief  Internal void * value. */
    void * internal;
};

/** @brief struct for managed data type void values.
 *
 * This is the same as afw_value_void_s with the addition of a
 * reference count. This is intended for internal use only.
 */
struct afw_value_void_managed_s {
    /** @brief  Value inf union with afw_value_t pub to reduce casting needed. */
    union {
        const afw_value_inf_t *inf;
        afw_value_t pub;
    };

    /** @brief  Internal void * value. */
    void * internal;

    /** @brief  Reference count for value. */
    afw_size_t reference_count;
};

/**
 * @brief extern for data type void struct.
 *
 * This should only be managed in the linkage unit the extern is
 * defined in.  Use afw_data_type_void when not referencing in
 * a static.
 */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_data_type_t)
afw_data_type_void_direct;

/**
 * @brief extern for data type void inf.
 *
 * This should only be managed in the linkage unit the extern is
 * defined in.
 *
 * The implementation of the data type must define this.  It is
 * managed by the generated data type instance.
 */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_data_type_inf_t)
afw_data_type_void_inf;

AFW_END_DECLARES

/** @} */


#endif /* __AFW_DATA_TYPE_VOID_BINDING_H__ */
