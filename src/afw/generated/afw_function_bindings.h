// See the 'COPYING' file in the project root for licensing information.
/*
 * Adaptive Framework Core Adaptive Function Bindings
 *
 * Copyright (c) 2010-2023 Clemson University
 *
 */

/*  ----------------------------- N O T E -------------------------------------
 *
 * This file is generated by "afwdev generate afw".
 *
 * Do not change this file directly or the changes will be lost the next time
 * this file is regenerated.
 *
 * -------------------------------------------------------------------------*/


#ifndef __AFW_FUNCTION_BINDINGS_H__
#define __AFW_FUNCTION_BINDINGS_H__


/**
 * @file afw_function_bindings.h
 * @brief Adaptive Framework core adaptive function bindings header.
 */

#include "afw_declare_helpers.h"

/**
 * @addtogroup afw_c_api_public
 * @{
 *
 */

/**
 * @addtogroup afw_c_api_functions Adaptive functions
 *
 * @{
 */

/**
 * @brief Get array of pointers to afw_function bindings.
 * @return pointer to array of function value pointers.
 */
AFW_DECLARE(const afw_value_function_definition_t **)
afw_function_bindings_get();


/** @addtogroup afw_functions_adaptor adaptor functions
 *
 * adaptor adaptive functions.
 *
 * @{
 */

/** @brief Function definition adaptor_objectCallback_signature */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_adaptor_objectCallback_signature;

/**
 * @brief Adaptive Function `adaptor_objectCallback_signature`
 * @param x function execute parameter.
 *
 * This is the function signature for the objectCallback parameter in adaptor
 * functions. Calling this directly will throw a 'Do not call directly' error.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function adaptor_objectCallback_signature(
 *       object: object,
 *       userData?: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   object - (object) This is the object from adaptor or undefined if there are
 *       no more objects to return.
 *
 *   userData - (optional any) This is the value of the userData parameter when
 *       objectCallback was called.
 *
 * Returns:
 *
 *   (boolean) Return true if this callback should not be called again for any
 *       reason such a limit exceeded or the desired object being found.
 */
const afw_value_t *
afw_function_execute_adaptor_objectCallback_signature(
    afw_function_execute_t *x);

/** @brief Function definition add_object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_object;

/**
 * @brief Adaptive Function `add_object`
 * @param x function execute parameter.
 *
 * Add an adaptive object to an adaptor, specified by the adaptorId, with a
 * specified objectType. You may supply an optional objectId, if the underlying
 * adaptorId allows it.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function add_object(
 *       adaptorId: string,
 *       objectType: string,
 *       object: object,
 *       objectId?: string,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   objectType - (string) Id of adaptive object type of object being added.
 *
 *   object - (object) Object to add.
 *
 *   objectId - (optional string) Optional preferred objectId of object to add.
 *       The adaptor may ignore this.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_add_object
 * 
 *       where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry. Property
 *       'objectId' is the objectId assigned by the adaptor.
 */
const afw_value_t *
afw_function_execute_add_object(
    afw_function_execute_t *x);

/** @brief Function definition add_object_with_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_object_with_uri;

/**
 * @brief Adaptive Function `add_object_with_uri`
 * @param x function execute parameter.
 *
 * Add an adaptive object with a given URI.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function add_object_with_uri(
 *       uri: anyURI,
 *       object: object,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of object to add. If a URI begins with a single slash
 *       ('/'), it is the local object path. In the case of a local path, an
 *       optional preferred objectId of object can be including in URI which the
 *       adaptor may ignore.
 *
 *   object - (object) Object to add.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_add_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry. Property
 *       'objectId' is the objectId assigned by the adaptor.
 */
const afw_value_t *
afw_function_execute_add_object_with_uri(
    afw_function_execute_t *x);

/** @brief Function definition convert_AdaptiveQueryCriteria_to_query_string */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_convert_AdaptiveQueryCriteria_to_query_string;

/**
 * @brief Adaptive Function `convert_AdaptiveQueryCriteria_to_query_string`
 * @param x function execute parameter.
 *
 * This function converts an _AdaptiveQueryCriteria_ object to a query string.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function convert_AdaptiveQueryCriteria_to_query_string(
 *       queryCriteria: (object _AdaptiveQueryCriteria_),
 *       adaptorId?: string,
 *       objectType?: string,
 *       style?: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   queryCriteria - (object _AdaptiveQueryCriteria_) An object type
 *       _AdaptiveQueryCriteria_ object.
 *
 *   adaptorId - (optional string) This is the adaptorId of adaptor containing
 *       the objectType for validating and mapping this query. If not specified,
 *       no validation or mapping will occur.
 *
 *   objectType - (optional string) This is the objectType used in conjunction
 *       with the adaptorId parameter. This parameter is only allowed and is
 *       required if the adaptorId parameter is specified.
 *
 *   style - (optional integer) The style of the query string produced. All of
 *       the styles are appropriately url encoded.
 * 
 *       0 - 'name=op=value' where '=op=' will be '==', '!=', '=ge=', etc. with
 *       conjunctions '&' (and) and '|' (or). Parentheses are placed around each
 *       group of like conjunctions except for outer '&'. (default)
 * 
 *       1 - the same as 1 with '=gte=' instead of '=ge=', '=lte=' instead of
 *       '=le=', '=eq=' instead of '=', and '=ne=' instead of '!='.
 * 
 *       2 - similar to 1 with ';' for '&' and ',' for '|'.
 * 
 *       3 - comparisons 'op(name,value)' where 'op' will be 'eq', 'ne', 'ge',
 *       ..., plus conjunctions 'and(list)' and 'or(list)' where 'array' is a
 *       comma separated list of any comparison or conjunction.
 *
 * Returns:
 *
 *   (string) Query string representation of the query criteria.
 */
const afw_value_t *
afw_function_execute_convert_AdaptiveQueryCriteria_to_query_string(
    afw_function_execute_t *x);

/** @brief Function definition convert_query_string_to_AdaptiveQueryCriteria */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_convert_query_string_to_AdaptiveQueryCriteria;

/**
 * @brief Adaptive Function `convert_query_string_to_AdaptiveQueryCriteria`
 * @param x function execute parameter.
 *
 * This function converts a query string to an _AdaptiveQueryCriteria_ object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function convert_query_string_to_AdaptiveQueryCriteria(
 *       queryString: string,
 *       adaptorId?: string,
 *       objectType?: string
 *   ): (object _AdaptiveQueryCriteria_);
 * ```
 *
 * Parameters:
 *
 *   queryString - (string) The query string to convert.
 *
 *   adaptorId - (optional string) This is the adaptorId of adaptor containing
 *       the objectType for validating and mapping this query. If not specified,
 *       no validation or mapping will occur.
 *
 *   objectType - (optional string) This is the objectType used in conjunction
 *       with the adaptorId parameter. This parameter is only allowed and is
 *       required if the adaptorId parameter is specified.
 *
 * Returns:
 *
 *   (object _AdaptiveQueryCriteria_) An object type _AdaptiveQueryCriteria_
 *       object representing query string.
 */
const afw_value_t *
afw_function_execute_convert_query_string_to_AdaptiveQueryCriteria(
    afw_function_execute_t *x);

/** @brief Function definition delete_object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_delete_object;

/**
 * @brief Adaptive Function `delete_object`
 * @param x function execute parameter.
 *
 * Delete an adaptive object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function delete_object(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor containing object to delete.
 *
 *   objectType - (string) Id of adaptive object type of object to delete.
 *
 *   objectId - (string) Id of object to delete.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_delete_object
 * 
 *       where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_delete_object(
    afw_function_execute_t *x);

/** @brief Function definition delete_object_with_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_delete_object_with_uri;

/**
 * @brief Adaptive Function `delete_object_with_uri`
 * @param x function execute parameter.
 *
 * Delete an adaptive object with a given URI.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function delete_object_with_uri(
 *       uri: anyURI,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of object to delete. If a URI begins with a single slash
 *       ('/'), it is the local object path.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_delete_object
 * 
 *       where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_delete_object_with_uri(
    afw_function_execute_t *x);

/** @brief Function definition get_object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_get_object;

/**
 * @brief Adaptive Function `get_object`
 * @param x function execute parameter.
 *
 * Get an adaptive object from the adaptor, specified by adaptorId, objectType
 * and objectId. Optional view options and adaptor-specific options may be
 * supplied to influence how the object is returned.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function get_object(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor containing object to retrieve.
 *
 *   objectType - (string) Id of adaptive object type of object to retrieve.
 *
 *   objectId - (string) Id of object to retrieve.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_get_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object) Object retrieved or NULL if not found.
 */
const afw_value_t *
afw_function_execute_get_object(
    afw_function_execute_t *x);

/** @brief Function definition get_object_with_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_get_object_with_uri;

/**
 * @brief Adaptive Function `get_object_with_uri`
 * @param x function execute parameter.
 *
 * Get an object with a given URI.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function get_object_with_uri(
 *       uri: anyURI,
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of object to retrieve. If a URI begins with a single
 *       slash ('/'), it is the local object path.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_get_object
 * 
 *       where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object) Object retrieved or NULL if not found.
 */
const afw_value_t *
afw_function_execute_get_object_with_uri(
    afw_function_execute_t *x);

/** @brief Function definition modify_object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_modify_object;

/**
 * @brief Adaptive Function `modify_object`
 * @param x function execute parameter.
 *
 * Modify an adaptive object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function modify_object(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       entries: array,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor containing object to modify.
 *
 *   objectType - (string) Id of adaptive object type of object to modify.
 *
 *   objectId - (string) Id of object to modify.
 *
 *   entries - (array) List of modifications. Entries are of the form:
 * 
 *           [
 *               'add_value',
 *               'property name' or ['property name', ... ],
 *               value
 *           ]
 * 
 *           [
 *               'remove_property',
 *               'property name' or ['property name', ... ]
 *           ]
 * 
 *           [
 *               'remove_value',
 *               'property name' or ['property name', ... ],
 *               value
 *           ]
 * 
 *           [
 *               'set_property',
 *               'property name' or ['property name', ... ],
 *               value
 *           ].
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_modify_object(
    afw_function_execute_t *x);

/** @brief Function definition modify_object_with_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_modify_object_with_uri;

/**
 * @brief Adaptive Function `modify_object_with_uri`
 * @param x function execute parameter.
 *
 * Modify an adaptive object with a given URI.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function modify_object_with_uri(
 *       uri: anyURI,
 *       entries: array,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of object to modify. If a URI begins with a single slash
 *       ('/'), it is the local object path.
 *
 *   entries - (array) List of asserts and modifications. Entries are of the
 *       form:
 * 
 *           [
 *               'add_value',
 *               'property name' or ['property name', ... ],
 *               value
 *           ]
 * 
 *           [
 *               'remove_property',
 *               'property name' or ['property name', ... ]
 *           ]
 * 
 *           [
 *               'remove_value',
 *               'property name' or ['property name', ... ],
 *               value
 *           ]
 * 
 *           [
 *               'set_property',
 *               'property name' or ['property name', ... ],
 *               value
 *           ].
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_modify_object_with_uri(
    afw_function_execute_t *x);

/** @brief Function definition reconcile_object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_reconcile_object;

/**
 * @brief Adaptive Function `reconcile_object`
 * @param x function execute parameter.
 *
 * Reconcile an adaptive object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function reconcile_object(
 *       object: object,
 *       checkOnly?: boolean
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   object - (object) An object that has been retrieved with object options
 *       reconcilable, and whose properties have been modified. A modify_object
 *       request will be produced reflecting the difference between the original
 *       object and this unmodified object.
 *
 *   checkOnly - (optional boolean) Produce the modify_object request but don't
 *       execute it. The returned journal enter will contain the modify_object
 *       request.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_reconcile_object(
    afw_function_execute_t *x);

/** @brief Function definition replace_object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_object;

/**
 * @brief Adaptive Function `replace_object`
 * @param x function execute parameter.
 *
 * Replace an adaptive object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function replace_object(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       object: object,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor containing object to replace.
 *
 *   objectType - (string) Id of adaptive object type of object to replace.
 *
 *   objectId - (string) Id of object to replace.
 *
 *   object - (object) Replacement object.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_replace_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_replace_object(
    afw_function_execute_t *x);

/** @brief Function definition replace_object_with_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_object_with_uri;

/**
 * @brief Adaptive Function `replace_object_with_uri`
 * @param x function execute parameter.
 *
 * Replace an adaptive object with a given URI.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function replace_object_with_uri(
 *       uri: anyURI,
 *       object: object,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of object to replace. If a URI begins with a single
 *       slash ('/'), it is the local object path.
 *
 *   object - (object) Replacement object.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_replace_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_replace_object_with_uri(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects;

/**
 * @brief Adaptive Function `retrieve_objects`
 * @param x function execute parameter.
 *
 * This function retrieves adaptive objects from an adaptor, specified by
 * adaptorId, which match the type specified by objectType.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects(
 *       adaptorId: string,
 *       objectType: string,
 *       queryCriteria?: (object _AdaptiveQueryCriteria_),
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor containing objects to retrieve.
 *
 *   objectType - (string) Id of adaptive object type of objects to retrieve.
 *
 *   queryCriteria - (optional object _AdaptiveQueryCriteria_) This is the query
 *       criteria for objects to be retrieved. If not specified, all objects
 *       will be retrieved.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (array) This is the array of objects retrieved.
 */
const afw_value_t *
afw_function_execute_retrieve_objects(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects_to_callback */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_to_callback;

/**
 * @brief Adaptive Function `retrieve_objects_to_callback`
 * @param x function execute parameter.
 *
 * This function retrieves adaptive objects from an adaptor, specified by
 * adaptorId, which match the type specified by objectType.
 * 
 * Each object is passed to the callback as it's retrieved.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects_to_callback(
 *       objectCallback: (function (object: object, userData: any): boolean),
 *       userData: any,
 *       adaptorId: string,
 *       objectType: string,
 *       queryCriteria?: (object _AdaptiveQueryCriteria_),
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   objectCallback - (function (object: object, userData: any): boolean) If
 *       this is specified, this function is called once for each object
 *       retrieved instead of adding the object to the return array. Parameter
 *       object will be an object retrieved or undefined if there are no more
 *       objects. This function should return true if it wants to abort the
 *       retrieve request.
 *
 *   userData - (any dataType) This value is passed to the objectCallback
 *       function in the userData parameter.
 *
 *   adaptorId - (string) Id of adaptor containing objects to retrieve.
 *
 *   objectType - (string) Id of adaptive object type of objects to retrieve.
 *
 *   queryCriteria - (optional object _AdaptiveQueryCriteria_) This is the query
 *       criteria for objects to be retrieved. If not specified, all objects
 *       will be retrieved.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects_to_callback
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_retrieve_objects_to_callback(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects_to_response */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_to_response;

/**
 * @brief Adaptive Function `retrieve_objects_to_response`
 * @param x function execute parameter.
 *
 * This function retrieves adaptive objects from an adaptor, specified by
 * adaptorId, which match the type specified by objectType.
 * 
 * This function is only allowed when called during a request with content type
 * 'application/x-afw'. An '_AdaptiveResponse_' object is written to the
 * request's response as each object is retrieved. This '_AdaptiveResponse_'
 * object has a 'result' property containing the retrieved object and a
 * 'intermediate' property set to true.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects_to_response(
 *       adaptorId: string,
 *       objectType: string,
 *       queryCriteria?: (object _AdaptiveQueryCriteria_),
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor containing objects to retrieve.
 *
 *   objectType - (string) Id of adaptive object type of objects to retrieve.
 *
 *   queryCriteria - (optional object _AdaptiveQueryCriteria_) This is the query
 *       criteria for objects to be retrieved. If not specified, all objects
 *       will be retrieved.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_retrieve_objects_to_response(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects_to_stream */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_to_stream;

/**
 * @brief Adaptive Function `retrieve_objects_to_stream`
 * @param x function execute parameter.
 *
 * This function retrieves adaptive objects from an adaptor, specified by
 * adaptorId, which match the type specified by objectType.
 * 
 * Each object is written to the 'streamId' stream as it's retrieved.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects_to_stream(
 *       streamNumber: integer,
 *       adaptorId: string,
 *       objectType: string,
 *       queryCriteria?: (object _AdaptiveQueryCriteria_),
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) Stream number objects will be written to as they
 *       are retrieved.
 *
 *   adaptorId - (string) Id of adaptor containing objects to retrieve.
 *
 *   objectType - (string) Id of adaptive object type of objects to retrieve.
 *
 *   queryCriteria - (optional object _AdaptiveQueryCriteria_) This is the query
 *       criteria for objects to be retrieved. If not specified, all objects
 *       will be retrieved.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_retrieve_objects_to_stream(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects_with_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri;

/**
 * @brief Adaptive Function `retrieve_objects_with_uri`
 * @param x function execute parameter.
 *
 * Retrieve adaptive objects with a given URI.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects_with_uri(
 *       uri: anyURI,
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of objects to retrieve. If a URI begins with a single
 *       slash ('/'), it is the local object path. A query string can be
 *       specified.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (array) This is the array of objects retrieved.
 */
const afw_value_t *
afw_function_execute_retrieve_objects_with_uri(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects_with_uri_to_callback */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri_to_callback;

/**
 * @brief Adaptive Function `retrieve_objects_with_uri_to_callback`
 * @param x function execute parameter.
 *
 * Retrieve adaptive objects with a given URI.
 * 
 * Each object is passed to the callback as it's retrieved.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects_with_uri_to_callback(
 *       objectCallback: (function (object: object, userData: any): boolean),
 *       userData: any,
 *       uri: anyURI,
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   objectCallback - (function (object: object, userData: any): boolean) If
 *       this is specified, this function is called once for each object
 *       retrieved instead of adding the object to the return array. Parameter
 *       object will be an object retrieved or undefined if there are no more
 *       objects. This function should return true if it wants to abort the
 *       retrieve request.
 *
 *   userData - (any) This is the value passed to the objectCallback function in
 *       the userData parameter.
 *
 *   uri - (anyURI) URI of objects to retrieve. If a URI begins with a single
 *       slash ('/'), it is the local object path. A query string can be
 *       specified.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_retrieve_objects_with_uri_to_callback(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects_with_uri_to_response */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri_to_response;

/**
 * @brief Adaptive Function `retrieve_objects_with_uri_to_response`
 * @param x function execute parameter.
 *
 * This function retrieves adaptive objects with a given URI.
 * 
 * This function is only allowed when called during a request with content type
 * 'application/x-afw'. An '_AdaptiveResponse_' object is written to the
 * request's response as each object is retrieved. This '_AdaptiveResponse_'
 * object has a 'result' property containing the retrieved object and a
 * 'partial' property set to true.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects_with_uri_to_response(
 *       uri: anyURI,
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of objects to retrieve. If a URI begins with a single
 *       slash ('/'), it is the local object path. A query string can be
 *       specified.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_retrieve_objects_with_uri_to_response(
    afw_function_execute_t *x);

/** @brief Function definition retrieve_objects_with_uri_to_stream */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_retrieve_objects_with_uri_to_stream;

/**
 * @brief Adaptive Function `retrieve_objects_with_uri_to_stream`
 * @param x function execute parameter.
 *
 * This function retrieves adaptive objects with a given URI.
 * 
 * Each object is written to the 'streamId' stream as it's retrieved.
 * 
 * The optional queryCriteria is used to filter the adaptive objects returned.
 * Use the objectOptions parameter to influence how the objects are viewed.
 * 
 * Options, specific to the adaptorId, can be optionally supplied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function retrieve_objects_with_uri_to_stream(
 *       streamNumber: integer,
 *       uri: anyURI,
 *       options?: (object _AdaptiveObjectOptions_),
 *       adaptorTypeSpecific?: object
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) Stream number objects will be written to as they
 *       are retrieved.
 *
 *   uri - (anyURI) URI of objects to retrieve. If a URI begins with a single
 *       slash ('/'), it is the local object path. A query string can be
 *       specified.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object view options.
 *       See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more
 *       information.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_retrieve_objects
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_retrieve_objects_with_uri_to_stream(
    afw_function_execute_t *x);

/** @brief Function definition update_object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_update_object;

/**
 * @brief Adaptive Function `update_object`
 * @param x function execute parameter.
 *
 * Update an adaptive object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function update_object(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       object: object,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor containing object to update.
 *
 *   objectType - (string) Id of adaptive object type of object to update.
 *
 *   objectId - (string) Id of object to update.
 *
 *   object - (object) Object containing properties to replace in existing
 *       object. You can use object_modify instead to update properties of
 *       embedded objects and arrays, as well as to modify individual values of
 *       the object.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_update_object(
    afw_function_execute_t *x);

/** @brief Function definition update_object_with_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_update_object_with_uri;

/**
 * @brief Adaptive Function `update_object_with_uri`
 * @param x function execute parameter.
 *
 * Update an adaptive object with a given URI.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function update_object_with_uri(
 *       uri: anyURI,
 *       object: object,
 *       journal?: object,
 *       adaptorTypeSpecific?: object
 *   ): (object _AdaptiveJournalEntry_);
 * ```
 *
 * Parameters:
 *
 *   uri - (anyURI) URI of object to update. If a URI begins with a single slash
 *       ('/'), it is the local object path.
 *
 *   object - (object) Object containing properties to replace in existing
 *       object. You can use object_modify instead to update properties of
 *       embedded objects and arrays, as well as to modify individual values of
 *       the object.
 *
 *   journal - (optional object) The properties of this object will be added to
 *       the associated journal entry. Refer to
 *       /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to
 *       avoid and for ones that have specific semantics.
 *
 *   adaptorTypeSpecific - (optional object) This is an optional object
 *       parameter with an objectType determined by the adaptorType associated
 *       with the adaptorId parameter. If the adaptorType supports this
 *       parameter, adaptor afw will have an adaptive object type with an id of:
 * 
 *       _AdaptiveAdaptorTypeSpecific_${adaptorType}_modify_object
 * 
 *       Where ${adaptorType} is the adaptor type id.
 *
 * Returns:
 *
 *   (object _AdaptiveJournalEntry_) Resulting journal entry.
 */
const afw_value_t *
afw_function_execute_update_object_with_uri(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_administrative administrative functions
 *
 * administrative adaptive functions.
 *
 * @{
 */

/** @brief Function definition extension_load */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_extension_load;

/**
 * @brief Adaptive Function `extension_load`
 * @param x function execute parameter.
 *
 * Load an extension by its extension id if it is not already loaded. Loading an
 * AFW package's manifest extension will register the manifest of all extensions
 * in the package.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function extension_load(
 *       extension_id: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   extension_id - (string) This is the object id of a /afw/_AdaptiveManifest_/
 *       object.
 *
 * Returns:
 *
 *   (boolean) If false the extension was already loaded. If true, the extension
 *       was successfully loaded which might have caused side effects such as
 *       environment registry changes. An error is thrown if there is a problem.
 */
const afw_value_t *
afw_function_execute_extension_load(
    afw_function_execute_t *x);

/** @brief Function definition extension_load_by_module_path */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_extension_load_by_module_path;

/**
 * @brief Adaptive Function `extension_load_by_module_path`
 * @param x function execute parameter.
 *
 * Load an extension by its module path. Loading an AFW package's manifest
 * extension will register the manifest of all extensions in the package.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function extension_load_by_module_path(
 *       module_path: string
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   module_path - (string) This is the path to the dso containing the
 *       extension. If the extension is installed in the normal place, the
 *       library name without a file extension (.so) will suffice.
 *
 * Returns:
 *
 *   (string) The extension id of the extension loaded.
 */
const afw_value_t *
afw_function_execute_extension_load_by_module_path(
    afw_function_execute_t *x);

/** @brief Function definition flag_get_active */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_get_active;

/**
 * @brief Adaptive Function `flag_get_active`
 * @param x function execute parameter.
 *
 * Get an array of of the flagId of flags that are set in the current execution
 * context (xctx).
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function flag_get_active(
 *   
 *   ): (array string);
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (array string) This is an array of the flagId of flags that are set in the
 *       current execution context (xctx).
 */
const afw_value_t *
afw_function_execute_flag_get_active(
    afw_function_execute_t *x);

/** @brief Function definition flag_get_active_defaults */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_get_active_defaults;

/**
 * @brief Adaptive Function `flag_get_active_defaults`
 * @param x function execute parameter.
 *
 * Get an array of the flagId of flags that are set by default when a new
 * execution context (xctx) is created.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function flag_get_active_defaults(
 *   
 *   ): (array string);
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (array string) This is an array of the flagId of flags that are set by
 *       default when a new execution context (xctx) is created.
 */
const afw_value_t *
afw_function_execute_flag_get_active_defaults(
    afw_function_execute_t *x);

/** @brief Function definition flag_get_defaults */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_get_defaults;

/**
 * @brief Adaptive Function `flag_get_defaults`
 * @param x function execute parameter.
 *
 * Get the array of the flagId of flags that are used to determine the default
 * active flags when an execution context (xctx) is created. This array can
 * contain the flagId of flags that have not yet been registered. Each of these
 * flags and the flags they include are set as the active default flags.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function flag_get_defaults(
 *   
 *   ): (array string);
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (array string) This is an array of the flagId of flags used to determine
 *       the default active flags.
 */
const afw_value_t *
afw_function_execute_flag_get_defaults(
    afw_function_execute_t *x);

/** @brief Function definition flag_modify_defaults */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_modify_defaults;

/**
 * @brief Adaptive Function `flag_modify_defaults`
 * @param x function execute parameter.
 *
 * Add or remove flags from the array of the flagId of flags that are used to
 * determine the default active flags when an execution context (xctx) is
 * created. This array can contain the flagId of flags that have not yet been
 * registered. These flags and the flags they include are set as the active
 * default flags.
 * 
 * This change only lasts for the life of the current adaptive environment (e.g.
 * until the adaptive server or afw command ends). If you want the change to
 * persist, change the defaultFlags property in the application config.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function flag_modify_defaults(
 *       flagId: (array string),
 *       add?: boolean
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   flagId - (array string) The flagId of flags to be added or removed.
 *
 *   add - (optional boolean) Specify true to add and false to remove flags. If
 *       not specified, flags are added.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_flag_modify_defaults(
    afw_function_execute_t *x);

/** @brief Function definition flag_replace_defaults */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_replace_defaults;

/**
 * @brief Adaptive Function `flag_replace_defaults`
 * @param x function execute parameter.
 *
 * Completely replace the array of the flagId of flags that are used to
 * determine the default active flags when an execution context (xctx) is
 * created. This array can contain the flagId of flags that have not yet been
 * registered. These flags and the flags they include are set as the active
 * default flags.
 * 
 * This change only lasts for the life of the current adaptive environment (e.g.
 * until the adaptive server or afw command ends). If you want the change to
 * persist, change the defaultFlags property in the application config.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function flag_replace_defaults(
 *       flagId: (array string)
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   flagId - (array string) The array of the flagId of flags used to determine
 *       the default active flags.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_flag_replace_defaults(
    afw_function_execute_t *x);

/** @brief Function definition flag_set */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flag_set;

/**
 * @brief Adaptive Function `flag_set`
 * @param x function execute parameter.
 *
 * Set or unset one or more active xctx (request) flags.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function flag_set(
 *       flagId: (array string),
 *       setTo?: boolean
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   flagId - (array string) List of flagId of flags to set or unset.
 *
 *   setTo - (optional boolean) Specify true to set and false to unset. If not
 *       specified, flags are set.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_flag_set(
    afw_function_execute_t *x);

/** @brief Function definition registry_key_check */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_registry_key_check;

/**
 * @brief Adaptive Function `registry_key_check`
 * @param x function execute parameter.
 *
 * This will check to see if a registry key exists for a specified registry type
 * and optionally load it's associated extension if needed.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function registry_key_check(
 *       registryType: string,
 *       key: string,
 *       loadExtension?: boolean
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   registryType - (string) This is the registry type, which is the object id
 *       of a /afw/_AdaptiveEnvironmentRegistryType_/ object.
 *
 *   key - (string) This is a key to check for existence in the specified
 *       registryType.
 *
 *   loadExtension - (optional boolean) Specifying true for this optional
 *       parameter will cause the associated extension to be loaded if needed.
 *
 * Returns:
 *
 *   (boolean) If false the extension was already loaded. If true, the extension
 *       was successfully loaded which might have caused side effects such as
 *       environment registry changes. An error is thrown if there is a problem.
 */
const afw_value_t *
afw_function_execute_registry_key_check(
    afw_function_execute_t *x);

/** @brief Function definition service_get */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_get;

/**
 * @brief Adaptive Function `service_get`
 * @param x function execute parameter.
 *
 * Get a service object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function service_get(
 *       serviceId: string
 *   ): (object _AdaptiveService_);
 * ```
 *
 * Parameters:
 *
 *   serviceId - (string) The serviceId of the service.
 *
 * Returns:
 *
 *   (object _AdaptiveService_) _AdaptiveService_ object for the service which
 *       will contain the current status of the service. If there is an error,
 *       the status property value will be 'error' and 'statusMessage' contain
 *       an error message.
 */
const afw_value_t *
afw_function_execute_service_get(
    afw_function_execute_t *x);

/** @brief Function definition service_restart */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_restart;

/**
 * @brief Adaptive Function `service_restart`
 * @param x function execute parameter.
 *
 * Restart a service.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function service_restart(
 *       serviceId: string
 *   ): (object _AdaptiveService_);
 * ```
 *
 * Parameters:
 *
 *   serviceId - (string) The serviceId of the service to restart.
 *
 * Returns:
 *
 *   (object _AdaptiveService_) _AdaptiveService_ object for the service which
 *       will contain the current status of the service. If there is an error,
 *       the status property value will be 'error' and 'statusMessage' contain
 *       an error message.
 */
const afw_value_t *
afw_function_execute_service_restart(
    afw_function_execute_t *x);

/** @brief Function definition service_start */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_start;

/**
 * @brief Adaptive Function `service_start`
 * @param x function execute parameter.
 *
 * Start a service.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function service_start(
 *       serviceId: string
 *   ): (object _AdaptiveService_);
 * ```
 *
 * Parameters:
 *
 *   serviceId - (string) The serviceId of the service to start.
 *
 * Returns:
 *
 *   (object _AdaptiveService_) _AdaptiveService_ object for the service which
 *       will contain the current status of the service. If there is an error,
 *       the status property value will be 'error' and 'statusMessage' contain
 *       an error message.
 */
const afw_value_t *
afw_function_execute_service_start(
    afw_function_execute_t *x);

/** @brief Function definition service_stop */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_service_stop;

/**
 * @brief Adaptive Function `service_stop`
 * @param x function execute parameter.
 *
 * Stop a service.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function service_stop(
 *       serviceId: string
 *   ): (object _AdaptiveService_);
 * ```
 *
 * Parameters:
 *
 *   serviceId - (string) The serviceId of the service to stop.
 *
 * Returns:
 *
 *   (object _AdaptiveService_) _AdaptiveService_ object for the service which
 *       will contain the current status of the service. If there is an error,
 *       the status property value will be 'error' and 'statusMessage' contain
 *       an error message.
 */
const afw_value_t *
afw_function_execute_service_stop(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_anyURI anyURI functions
 *
 * anyURI adaptive functions.
 *
 * @{
 */

/** @brief Function definition anyURI */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_anyURI;

/**
 * @brief Adaptive Function `anyURI`
 * @param x function execute parameter.
 *
 * Converts value to data type anyURI returning anyURI result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function anyURI(
 *       value: any
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (anyURI) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition at_least_one_member_of<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_anyURI;

/**
 * @brief Adaptive Function `at_least_one_member_of<anyURI>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in anyURI array1 is in anyURI
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<anyURI>(
 *       array1: (array anyURI),
 *       array2: (array anyURI)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array anyURI) The first array.
 *
 *   array2 - (array anyURI) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_anyURI;

/**
 * @brief Adaptive Function `bag<anyURI>`
 * @param x function execute parameter.
 *
 * Takes any number of anyURI values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<anyURI>(
 *       ...values: (array of (array anyURI))
 *   ): (array anyURI);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array anyURI)
 *
 * Returns:
 *
 *   (array anyURI)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_anyURI;

/**
 * @brief Adaptive Function `bag_size<anyURI>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<anyURI>(
 *       value: (array anyURI)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array anyURI)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition ends_with<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ends_with_anyURI;

/**
 * @brief Adaptive Function `ends_with<anyURI>`
 * @param x function execute parameter.
 *
 * Checks whether anyURI value ends with a anyURI and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ends_with<anyURI>(
 *       value: anyURI,
 *       subString: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI)
 *
 *   subString - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ends_with()
 *
 * __________
 */

/** @brief Function definition eq<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_anyURI;

/**
 * @brief Adaptive Function `eq<anyURI>`
 * @param x function execute parameter.
 *
 * Determine if anyURI arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<anyURI>(
 *       arg1: anyURI,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_anyURI;

/**
 * @brief Adaptive Function `eqx<anyURI>`
 * @param x function execute parameter.
 *
 * Determine if for anyURI arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<anyURI>(
 *       arg1: anyURI,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_anyURI;

/**
 * @brief Adaptive Function `ge<anyURI>`
 * @param x function execute parameter.
 *
 * Checks for anyURI arg1 is greater than or equal to anyURI arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<anyURI>(
 *       arg1: anyURI,
 *       arg2: anyURI
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (anyURI)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_anyURI;

/**
 * @brief Adaptive Function `gt<anyURI>`
 * @param x function execute parameter.
 *
 * Checks for anyURI arg1 is greater than anyURI arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<anyURI>(
 *       arg1: anyURI,
 *       arg2: anyURI
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (anyURI)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition includes<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes_anyURI;

/**
 * @brief Adaptive Function `includes<anyURI>`
 * @param x function execute parameter.
 *
 * Checks whether the anyURI value includes a string and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function includes<anyURI>(
 *       searchString: anyURI,
 *       subString: string,
 *       position?: integer
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   searchString - (anyURI) The anyURI to search.
 *
 *   subString - (string) Substring to find.
 *
 *   position - (optional integer) Zero-based position in the search string to
 *       start search.
 *
 * Returns:
 *
 *   (boolean) Indicates if the substring is contained in the search string.
 *
 * Implemented by afw_function_execute_includes()
 *
 * __________
 */

/** @brief Function definition index_of<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_of_anyURI;

/**
 * @brief Adaptive Function `index_of<anyURI>`
 * @param x function execute parameter.
 *
 * Returns the zero-based index into anyURI value of subString. If subString is
 * not found, -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function index_of<anyURI>(
 *       value: anyURI,
 *       subString: string,
 *       startIndex?: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) The anyURI value to search.
 *
 *   subString - (string) Substring to search for.
 *
 *   startIndex - (optional integer) Optional start index for search if
 *       different than start of string.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by afw_function_execute_index_of()
 *
 * __________
 */

/** @brief Function definition intersection<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_anyURI;

/**
 * @brief Adaptive Function `intersection<anyURI>`
 * @param x function execute parameter.
 *
 * Returns an array of anyURI with the values that are common to both array of
 * anyURI array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<anyURI>(
 *       array1: (array anyURI),
 *       array2: (array anyURI)
 *   ): (array anyURI);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array anyURI) The first array.
 *
 *   array2 - (array anyURI) The second array.
 *
 * Returns:
 *
 *   (array anyURI)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_anyURI;

/**
 * @brief Adaptive Function `is<anyURI>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType anyURI and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<anyURI>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_anyURI;

/**
 * @brief Adaptive Function `is_in<anyURI>`
 * @param x function execute parameter.
 *
 * Checks whether anyURI value is in array of anyURI array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<anyURI>(
 *       value: anyURI,
 *       array: (array anyURI)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI)
 *
 *   array - (array anyURI)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition last_index_of<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_last_index_of_anyURI;

/**
 * @brief Adaptive Function `last_index_of<anyURI>`
 * @param x function execute parameter.
 *
 * Returns the zero-based index into anyURI value of the last occurrence of a
 * subString. If subString is not found, -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function last_index_of<anyURI>(
 *       value: anyURI,
 *       subString: string,
 *       startIndex?: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) The anyURI value to search.
 *
 *   subString - (string) Substring to search for.
 *
 *   startIndex - (optional integer) Optional start index for search if
 *       different than start of string.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by afw_function_execute_last_index_of()
 *
 * __________
 */

/** @brief Function definition le<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_anyURI;

/**
 * @brief Adaptive Function `le<anyURI>`
 * @param x function execute parameter.
 *
 * Checks for anyURI arg1 is less than or equal to anyURI arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<anyURI>(
 *       arg1: anyURI,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition length<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length_anyURI;

/**
 * @brief Adaptive Function `length<anyURI>`
 * @param x function execute parameter.
 *
 * This is a polymorphic function where anyURI can be any of the supported data
 * types. Return the integer number of entries in datatype array or codepoints
 * in others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function length<anyURI>(
 *       value: anyURI
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) Returns the number of entries in an array or code points
 *       in others.
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_length()
 *
 * __________
 */

/** @brief Function definition lt<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_anyURI;

/**
 * @brief Adaptive Function `lt<anyURI>`
 * @param x function execute parameter.
 *
 * Checks for anyURI arg1 is less that anyURI arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<anyURI>(
 *       arg1: anyURI,
 *       arg2: anyURI
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (anyURI)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_anyURI;

/**
 * @brief Adaptive Function `ne<anyURI>`
 * @param x function execute parameter.
 *
 * Determine if anyURI arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<anyURI>(
 *       arg1: anyURI,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_anyURI;

/**
 * @brief Adaptive Function `nex<anyURI>`
 * @param x function execute parameter.
 *
 * Determine if for anyURI arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<anyURI>(
 *       arg1: anyURI,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (anyURI)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_anyURI;

/**
 * @brief Adaptive Function `one_and_only<anyURI>`
 * @param x function execute parameter.
 *
 * This converts an array of anyURI values that contains one value to a single
 * anyURI value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<anyURI>(
 *       array: (array array)
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (anyURI)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition regexp_index_of<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_index_of_anyURI;

/**
 * @brief Adaptive Function `regexp_index_of<anyURI>`
 * @param x function execute parameter.
 *
 * Search anyURI value for a regular expression and return index. If not found,
 * -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_index_of<anyURI>(
 *       value: anyURI,
 *       regexp: string
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) The anyURI value to search.
 *
 *   regexp - (string) A regular expression to use for search.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by afw_function_execute_regexp_index_of()
 *
 * __________
 */

/** @brief Function definition regexp_match<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_anyURI;

/**
 * @brief Adaptive Function `regexp_match<anyURI>`
 * @param x function execute parameter.
 *
 * Checks whether anyURI value matches the regular expression regexp and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_match<anyURI>(
 *       value: anyURI,
 *       regexp: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI)
 *
 *   regexp - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_regexp_match()
 *
 * __________
 */

/** @brief Function definition regexp_replace<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_replace_anyURI;

/**
 * @brief Adaptive Function `regexp_replace<anyURI>`
 * @param x function execute parameter.
 *
 * Replace matched values for a regular expression in a anyURI value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_replace<anyURI>(
 *       value: anyURI,
 *       regexp: string,
 *       replacement: string,
 *       limit?: integer
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) The original anyURI value.
 *
 *   regexp - (string) A regular expression to use for search.
 *
 *   replacement - (string) The replacement string.
 *
 *   limit - (optional integer) This is the maximum times to replace. The
 *       default is 1. Specify -1 to replace all occurrences.
 *
 * Returns:
 *
 *   (anyURI) A anyURI value with the matched string(s) replaced.
 *
 * Implemented by afw_function_execute_regexp_replace()
 *
 * __________
 */

/** @brief Function definition repeat<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_repeat_anyURI;

/**
 * @brief Adaptive Function `repeat<anyURI>`
 * @param x function execute parameter.
 *
 * Repeat a anyURI value a specified number of times.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function repeat<anyURI>(
 *       value: anyURI,
 *       times: integer
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) The anyURI value to repeat.
 *
 *   times - (integer) The number of times to repeat the value.
 *
 * Returns:
 *
 *   (anyURI) The repeated anyURI value.
 *
 * Implemented by afw_function_execute_repeat()
 *
 * __________
 */

/** @brief Function definition replace<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_anyURI;

/**
 * @brief Adaptive Function `replace<anyURI>`
 * @param x function execute parameter.
 *
 * Replace string(s) in a anyURI value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function replace<anyURI>(
 *       value: anyURI,
 *       match: string,
 *       replacement: string,
 *       limit?: integer
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) The original anyURI value.
 *
 *   match - (string) The string to replace.
 *
 *   replacement - (string) The replacement string.
 *
 *   limit - (optional integer) This is the maximum times to replace. The
 *       default is 1. Specify -1 to replace all occurrences.
 *
 * Returns:
 *
 *   (anyURI) A anyURI value with the matched string(s) replaced.
 *
 * Implemented by afw_function_execute_replace()
 *
 * __________
 */

/** @brief Function definition set_equals<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_anyURI;

/**
 * @brief Adaptive Function `set_equals<anyURI>`
 * @param x function execute parameter.
 *
 * Returns boolean true if anyURI array1 and anyURI array2 are subsets of each
 * other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<anyURI>(
 *       array1: (array anyURI),
 *       array2: (array anyURI)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array anyURI)
 *
 *   array2 - (array anyURI)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition split<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_split_anyURI;

/**
 * @brief Adaptive Function `split<anyURI>`
 * @param x function execute parameter.
 *
 * Split anyURI value into an array of strings using a separator.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function split<anyURI>(
 *       value: anyURI,
 *       separator?: string,
 *       limit?: integer
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) The anyURI value to split.
 *
 *   separator - (optional string) The separator to use. If this is an empty
 *       string or separator is not specified, the value is split between
 *       characters.
 *
 *   limit - (optional integer) This is the maximum number of splits. Any
 *       remaining part of value is ignored.
 *
 * Returns:
 *
 *   (array) An array of strings.
 *
 * Implemented by afw_function_execute_split()
 *
 * __________
 */

/** @brief Function definition starts_with<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_starts_with_anyURI;

/**
 * @brief Adaptive Function `starts_with<anyURI>`
 * @param x function execute parameter.
 *
 * Checks whether anyURI value starts with a subString and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function starts_with<anyURI>(
 *       value: anyURI,
 *       subString: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI)
 *
 *   subString - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_starts_with()
 *
 * __________
 */

/** @brief Function definition subset<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_anyURI;

/**
 * @brief Adaptive Function `subset<anyURI>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in anyURI array1 are all in anyURI
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<anyURI>(
 *       array1: (array anyURI),
 *       array2: (array anyURI)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array anyURI) The first array.
 *
 *   array2 - (array anyURI) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition substring<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_substring_anyURI;

/**
 * @brief Adaptive Function `substring<anyURI>`
 * @param x function execute parameter.
 *
 * Returns the anyURI substring of value beginning at zero-based position
 * integer startIndex and ending at the position before integer endIndex.
 * Specify -1 or omitting endIndex to return up to end of anyURI.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function substring<anyURI>(
 *       string: anyURI,
 *       startIndex: integer,
 *       endIndex?: integer
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   string - (anyURI)
 *
 *   startIndex - (integer)
 *
 *   endIndex - (optional integer)
 *
 * Returns:
 *
 *   (anyURI)
 *
 * Errors thrown:
 *
 *   arg_error - startIndex or endIndex is out of range
 *
 * Implemented by afw_function_execute_substring()
 *
 * __________
 */

/** @brief Function definition to_string<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_anyURI;

/**
 * @brief Adaptive Function `to_string<anyURI>`
 * @param x function execute parameter.
 *
 * Converts anyURI value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<anyURI>(
 *       value: anyURI
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (anyURI) A anyURI value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_anyURI;

/**
 * @brief Adaptive Function `union<anyURI>`
 * @param x function execute parameter.
 *
 * Returns an array of anyURI contains all of the unique values in two or more
 * array of anyURI values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<anyURI>(
 *       arrays_1: (array anyURI),
 *       arrays_2: (array anyURI),
 *       ...arrays_rest: (array of (array anyURI))
 *   ): (array anyURI);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array anyURI) Two or more arrays.
 *
 * Returns:
 *
 *   (array anyURI)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @brief Function definition url_encode<anyURI> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_encode_anyURI;

/**
 * @brief Adaptive Function `url_encode<anyURI>`
 * @param x function execute parameter.
 *
 * URL encode a value or bag of values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function url_encode<anyURI>(
 *       unencoded: anyURI
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   unencoded - (anyURI) URL encode a single value. See the url_encode method
 *       for the data type of more details.
 *
 * Returns:
 *
 *   (string) URI encoded string.
 *
 * Implemented by afw_function_execute_url_encode()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_array array functions
 *
 * array adaptive functions.
 *
 * @{
 */

/** @brief Function definition add_entries */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_entries;

/**
 * @brief Adaptive Function `add_entries`
 * @param x function execute parameter.
 *
 * Add the entries of one or more arrays to another.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function add_entries(
 *       target: array,
 *       source_1: array,
 *       ...source_rest: (array of array)
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   target - (array) Target array. This array must not be immutable.
 *
 *   source - (1 or more array) Source array(s).
 *
 * Returns:
 *
 *   (array) The modified target array.
 */
const afw_value_t *
afw_function_execute_add_entries(
    afw_function_execute_t *x);

/** @brief Function definition array */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_array;

/**
 * @brief Adaptive Function `array`
 * @param x function execute parameter.
 *
 * Construct an array with 0 or more elements.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function array(
 *       ...values: (array of any)
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more any dataType) A value can refer to any adaptable value
 *       belonging to any data type or an array expression. In the case of an
 *       array expression, indicated by '...' followed by an expression that
 *       results in an array, every element within that array is included in the
 *       newly created array.
 *
 * Returns:
 *
 *   (array) The constructed array.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 */
const afw_value_t *
afw_function_execute_array(
    afw_function_execute_t *x);

/** @brief Function definition bag<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_array;

/**
 * @brief Adaptive Function `bag<array>`
 * @param x function execute parameter.
 *
 * Takes any number of array values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<array>(
 *       ...values: (array of (array array))
 *   ): (array array);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array array)
 *
 * Returns:
 *
 *   (array array)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_array;

/**
 * @brief Adaptive Function `bag_size<array>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<array>(
 *       value: (array array)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array array)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition clone<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_clone_array;

/**
 * @brief Adaptive Function `clone<array>`
 * @param x function execute parameter.
 *
 * Deep clone a array value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function clone<array>(
 *       value: array
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   value - (array) The array value to clone.
 *
 * Returns:
 *
 *   (array) The cloned array value.
 *
 * Implemented by afw_function_execute_clone()
 *
 * __________
 */

/** @brief Function definition eq<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_array;

/**
 * @brief Adaptive Function `eq<array>`
 * @param x function execute parameter.
 *
 * Determine if array arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<array>(
 *       arg1: array,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_array;

/**
 * @brief Adaptive Function `eqx<array>`
 * @param x function execute parameter.
 *
 * Determine if for array arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<array>(
 *       arg1: array,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_array;

/**
 * @brief Adaptive Function `ge<array>`
 * @param x function execute parameter.
 *
 * Checks for array arg1 is greater than or equal to array arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<array>(
 *       arg1: array,
 *       arg2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (array)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_array;

/**
 * @brief Adaptive Function `gt<array>`
 * @param x function execute parameter.
 *
 * Checks for array arg1 is greater than array arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<array>(
 *       arg1: array,
 *       arg2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (array)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition includes<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes_array;

/**
 * @brief Adaptive Function `includes<array>`
 * @param x function execute parameter.
 *
 * Checks whether or not an array contains any value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function includes<array>(
 *       array: array,
 *       searchElement: any,
 *       fromIndex?: integer
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array - (``<Type>``) The array to search.
 *
 *   searchElement - (any dataType) Element to find.
 *
 *   fromIndex - (optional integer) Index in the array to start search.
 *
 * Returns:
 *
 *   (boolean) Indicates if the element is found in array.
 *
 * Implemented by afw_function_execute_includes_array()
 *
 * __________
 */

/** @brief Function definition is<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_array;

/**
 * @brief Adaptive Function `is<array>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType array and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<array>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition join */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_join;

/**
 * @brief Adaptive Function `join`
 * @param x function execute parameter.
 *
 * Concatenate the string values of the elements of an array with a separator.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function join(
 *       value: array,
 *       separator?: string
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (array) An array of values (statements) of any data type.
 *
 *   separator - (optional string) The separator to use. If not specified, a
 *       comma (,) is used.
 *
 * Returns:
 *
 *   (string) Joined array values.
 */
const afw_value_t *
afw_function_execute_join(
    afw_function_execute_t *x);

/** @brief Function definition le<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_array;

/**
 * @brief Adaptive Function `le<array>`
 * @param x function execute parameter.
 *
 * Checks for array arg1 is less than or equal to array arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<array>(
 *       arg1: array,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition length<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length_array;

/**
 * @brief Adaptive Function `length<array>`
 * @param x function execute parameter.
 *
 * This is a polymorphic function where array can be any of the supported data
 * types. Return the integer number of entries in datatype array or codepoints
 * in others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function length<array>(
 *       value: array
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array) Returns the number of entries in an array or code points in
 *       others.
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_length()
 *
 * __________
 */

/** @brief Function definition lt<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_array;

/**
 * @brief Adaptive Function `lt<array>`
 * @param x function execute parameter.
 *
 * Checks for array arg1 is less that array arg2 and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<array>(
 *       arg1: array,
 *       arg2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (array)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_array;

/**
 * @brief Adaptive Function `ne<array>`
 * @param x function execute parameter.
 *
 * Determine if array arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<array>(
 *       arg1: array,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_array;

/**
 * @brief Adaptive Function `nex<array>`
 * @param x function execute parameter.
 *
 * Determine if for array arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<array>(
 *       arg1: array,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (array)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition reverse */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_reverse;

/**
 * @brief Adaptive Function `reverse`
 * @param x function execute parameter.
 *
 * Reverse the order of the elements in an array. If the array is typed, the
 * resulting array will be the same type.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function reverse(
 *       array: array
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   array - (array) An array to reverse.
 *
 * Returns:
 *
 *   (array) An array with elements reversed.
 */
const afw_value_t *
afw_function_execute_reverse(
    afw_function_execute_t *x);

/** @brief Function definition slice */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_slice;

/**
 * @brief Adaptive Function `slice`
 * @param x function execute parameter.
 *
 * This function extracts a consecutive slice of values from an array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function slice(
 *       array: array,
 *       startIndex?: integer,
 *       endIndex?: integer
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   array - (array) The array to slice.
 *
 *   startIndex - (optional integer) This is the zero based starting index. Use
 *       negative number to index from the end of the array. If not specified,
 *       an index of 0 is assumed.
 *
 *   endIndex - (optional integer) This is the zero based ending index. If
 *       positive, this is one more than the index of the last value to include
 *       in the array. If negative, the index is from the end of the array. If
 *       not specified, the slice is from startIndex up to and including the end
 *       of the array.
 *
 * Returns:
 *
 *   (array) An array containing the selected values. If all of the values are
 *       the same data type, the array will be an array of that data type.
 */
const afw_value_t *
afw_function_execute_slice(
    afw_function_execute_t *x);

/** @brief Function definition to_string<array> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_array;

/**
 * @brief Adaptive Function `to_string<array>`
 * @param x function execute parameter.
 *
 * Converts array value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<array>(
 *       value: array
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (array) A array value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_authorization authorization functions
 *
 * authorization adaptive functions.
 *
 * @{
 */

/** @brief Function definition authorization_check */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_authorization_check;

/**
 * @brief Adaptive Function `authorization_check`
 * @param x function execute parameter.
 *
 * This function can be used to check if the current subject has a given access
 * to the specified resource in the current environment.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function authorization_check(
 *       requestId: string,
 *       resourceId: string,
 *       actionId: string,
 *       object?: object,
 *       enforce?: boolean
 *   ): (object _AdaptiveAuthorizationResult_);
 * ```
 *
 * Parameters:
 *
 *   requestId - (string) This is a request id to associate with the
 *       authorization request. Variable current::requestId can be used to
 *       access this value in authorization policies.
 *
 *   resourceId - (string) This is the URI of the resource being checked.
 *       Variable current::resourceId can be used to access this value in
 *       authorization policies.
 *
 *   actionId - (string) This is the action that on the resource that's being
 *       checked.  Variable current::actionId can be used to access this value
 *       in authorization policies.
 *
 *   object - (optional object) Variable current::object can be used to access
 *       this value in authorization policies.
 *
 *   enforce - (optional boolean) This specifies whether an error is thrown if
 *       access is denied. If false or not specified, an error is not thrown and
 *       the decision can be checked in the returned object.
 *
 * Returns:
 *
 *   (object _AdaptiveAuthorizationResult_) The authorization result.
 */
const afw_value_t *
afw_function_execute_authorization_check(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_base64Binary base64Binary functions
 *
 * base64Binary adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_base64Binary;

/**
 * @brief Adaptive Function `at_least_one_member_of<base64Binary>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in base64Binary array1 is in
 * base64Binary array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<base64Binary>(
 *       array1: (array base64Binary),
 *       array2: (array base64Binary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array base64Binary) The first array.
 *
 *   array2 - (array base64Binary) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_base64Binary;

/**
 * @brief Adaptive Function `bag<base64Binary>`
 * @param x function execute parameter.
 *
 * Takes any number of base64Binary values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<base64Binary>(
 *       ...values: (array of (array base64Binary))
 *   ): (array base64Binary);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array base64Binary)
 *
 * Returns:
 *
 *   (array base64Binary)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_base64Binary;

/**
 * @brief Adaptive Function `bag_size<base64Binary>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<base64Binary>(
 *       value: (array base64Binary)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array base64Binary)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition base64Binary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_base64Binary;

/**
 * @brief Adaptive Function `base64Binary`
 * @param x function execute parameter.
 *
 * Converts value to data type base64Binary returning base64Binary result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function base64Binary(
 *       value: any
 *   ): base64Binary;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (base64Binary) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition decode_to_string<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decode_to_string_base64Binary;

/**
 * @brief Adaptive Function `decode_to_string<base64Binary>`
 * @param x function execute parameter.
 *
 * Decode base64Binary value to string. An error is thrown if decoded value is
 * not valid UTF-8.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function decode_to_string<base64Binary>(
 *       value: base64Binary
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (base64Binary) The base64Binary value to decode.
 *
 * Returns:
 *
 *   (string) The decoded string.
 */
const afw_value_t *
afw_function_execute_decode_to_string_base64Binary(
    afw_function_execute_t *x);

/** @brief Function definition eq<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_base64Binary;

/**
 * @brief Adaptive Function `eq<base64Binary>`
 * @param x function execute parameter.
 *
 * Determine if base64Binary arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_base64Binary;

/**
 * @brief Adaptive Function `eqx<base64Binary>`
 * @param x function execute parameter.
 *
 * Determine if for base64Binary arg1 is equal to the value and data type of
 * arg2 then return the boolean result. Use 'eq' ('==') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_base64Binary;

/**
 * @brief Adaptive Function `ge<base64Binary>`
 * @param x function execute parameter.
 *
 * Checks for base64Binary arg1 is greater than or equal to base64Binary arg2
 * and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: base64Binary
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (base64Binary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_base64Binary;

/**
 * @brief Adaptive Function `gt<base64Binary>`
 * @param x function execute parameter.
 *
 * Checks for base64Binary arg1 is greater than base64Binary arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: base64Binary
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (base64Binary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_base64Binary;

/**
 * @brief Adaptive Function `intersection<base64Binary>`
 * @param x function execute parameter.
 *
 * Returns an array of base64Binary with the values that are common to both
 * array of base64Binary array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<base64Binary>(
 *       array1: (array base64Binary),
 *       array2: (array base64Binary)
 *   ): (array base64Binary);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array base64Binary) The first array.
 *
 *   array2 - (array base64Binary) The second array.
 *
 * Returns:
 *
 *   (array base64Binary)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_base64Binary;

/**
 * @brief Adaptive Function `is<base64Binary>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType base64Binary and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<base64Binary>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_base64Binary;

/**
 * @brief Adaptive Function `is_in<base64Binary>`
 * @param x function execute parameter.
 *
 * Checks whether base64Binary value is in array of base64Binary array and
 * returns the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<base64Binary>(
 *       value: base64Binary,
 *       array: (array base64Binary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (base64Binary)
 *
 *   array - (array base64Binary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_base64Binary;

/**
 * @brief Adaptive Function `le<base64Binary>`
 * @param x function execute parameter.
 *
 * Checks for base64Binary arg1 is less than or equal to base64Binary arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_base64Binary;

/**
 * @brief Adaptive Function `lt<base64Binary>`
 * @param x function execute parameter.
 *
 * Checks for base64Binary arg1 is less that base64Binary arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: base64Binary
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (base64Binary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_base64Binary;

/**
 * @brief Adaptive Function `ne<base64Binary>`
 * @param x function execute parameter.
 *
 * Determine if base64Binary arg1 is not equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_base64Binary;

/**
 * @brief Adaptive Function `nex<base64Binary>`
 * @param x function execute parameter.
 *
 * Determine if for base64Binary arg1 is not equal to the value or data type of
 * arg2 then return the boolean result. Use 'ne' ('!=') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<base64Binary>(
 *       arg1: base64Binary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (base64Binary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_base64Binary;

/**
 * @brief Adaptive Function `one_and_only<base64Binary>`
 * @param x function execute parameter.
 *
 * This converts an array of base64Binary values that contains one value to a
 * single base64Binary value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<base64Binary>(
 *       array: (array array)
 *   ): base64Binary;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (base64Binary)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_base64Binary;

/**
 * @brief Adaptive Function `set_equals<base64Binary>`
 * @param x function execute parameter.
 *
 * Returns boolean true if base64Binary array1 and base64Binary array2 are
 * subsets of each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<base64Binary>(
 *       array1: (array base64Binary),
 *       array2: (array base64Binary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array base64Binary)
 *
 *   array2 - (array base64Binary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_base64Binary;

/**
 * @brief Adaptive Function `subset<base64Binary>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in base64Binary array1 are all in
 * base64Binary array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<base64Binary>(
 *       array1: (array base64Binary),
 *       array2: (array base64Binary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array base64Binary) The first array.
 *
 *   array2 - (array base64Binary) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition to_string<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_base64Binary;

/**
 * @brief Adaptive Function `to_string<base64Binary>`
 * @param x function execute parameter.
 *
 * Converts base64Binary value to string. For array values, the to_string()
 * value for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<base64Binary>(
 *       value: base64Binary
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (base64Binary) A base64Binary value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<base64Binary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_base64Binary;

/**
 * @brief Adaptive Function `union<base64Binary>`
 * @param x function execute parameter.
 *
 * Returns an array of base64Binary contains all of the unique values in two or
 * more array of base64Binary values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<base64Binary>(
 *       arrays_1: (array base64Binary),
 *       arrays_2: (array base64Binary),
 *       ...arrays_rest: (array of (array base64Binary))
 *   ): (array base64Binary);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array base64Binary) Two or more arrays.
 *
 * Returns:
 *
 *   (array base64Binary)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_boolean boolean functions
 *
 * boolean adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_boolean;

/**
 * @brief Adaptive Function `at_least_one_member_of<boolean>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in boolean array1 is in boolean
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<boolean>(
 *       array1: (array boolean),
 *       array2: (array boolean)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array boolean) The first array.
 *
 *   array2 - (array boolean) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_boolean;

/**
 * @brief Adaptive Function `bag<boolean>`
 * @param x function execute parameter.
 *
 * Takes any number of boolean values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<boolean>(
 *       ...values: (array of (array boolean))
 *   ): (array boolean);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array boolean)
 *
 * Returns:
 *
 *   (array boolean)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_boolean;

/**
 * @brief Adaptive Function `bag_size<boolean>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<boolean>(
 *       value: (array boolean)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array boolean)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition boolean */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_boolean;

/**
 * @brief Adaptive Function `boolean`
 * @param x function execute parameter.
 *
 * Converts value to data type boolean returning boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function boolean(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (boolean) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition eq<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_boolean;

/**
 * @brief Adaptive Function `eq<boolean>`
 * @param x function execute parameter.
 *
 * Determine if boolean arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<boolean>(
 *       arg1: boolean,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_boolean;

/**
 * @brief Adaptive Function `eqx<boolean>`
 * @param x function execute parameter.
 *
 * Determine if for boolean arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<boolean>(
 *       arg1: boolean,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_boolean;

/**
 * @brief Adaptive Function `ge<boolean>`
 * @param x function execute parameter.
 *
 * Checks for boolean arg1 is greater than or equal to boolean arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<boolean>(
 *       arg1: boolean,
 *       arg2: boolean
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (boolean)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_boolean;

/**
 * @brief Adaptive Function `gt<boolean>`
 * @param x function execute parameter.
 *
 * Checks for boolean arg1 is greater than boolean arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<boolean>(
 *       arg1: boolean,
 *       arg2: boolean
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (boolean)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_boolean;

/**
 * @brief Adaptive Function `intersection<boolean>`
 * @param x function execute parameter.
 *
 * Returns an array of boolean with the values that are common to both array of
 * boolean array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<boolean>(
 *       array1: (array boolean),
 *       array2: (array boolean)
 *   ): (array boolean);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array boolean) The first array.
 *
 *   array2 - (array boolean) The second array.
 *
 * Returns:
 *
 *   (array boolean)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_boolean;

/**
 * @brief Adaptive Function `is<boolean>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType boolean and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<boolean>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_boolean;

/**
 * @brief Adaptive Function `is_in<boolean>`
 * @param x function execute parameter.
 *
 * Checks whether boolean value is in array of boolean array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<boolean>(
 *       value: boolean,
 *       array: (array boolean)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (boolean)
 *
 *   array - (array boolean)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_boolean;

/**
 * @brief Adaptive Function `le<boolean>`
 * @param x function execute parameter.
 *
 * Checks for boolean arg1 is less than or equal to boolean arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<boolean>(
 *       arg1: boolean,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_boolean;

/**
 * @brief Adaptive Function `lt<boolean>`
 * @param x function execute parameter.
 *
 * Checks for boolean arg1 is less that boolean arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<boolean>(
 *       arg1: boolean,
 *       arg2: boolean
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (boolean)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_boolean;

/**
 * @brief Adaptive Function `ne<boolean>`
 * @param x function execute parameter.
 *
 * Determine if boolean arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<boolean>(
 *       arg1: boolean,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_boolean;

/**
 * @brief Adaptive Function `nex<boolean>`
 * @param x function execute parameter.
 *
 * Determine if for boolean arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<boolean>(
 *       arg1: boolean,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (boolean)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_boolean;

/**
 * @brief Adaptive Function `one_and_only<boolean>`
 * @param x function execute parameter.
 *
 * This converts an array of boolean values that contains one value to a single
 * boolean value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<boolean>(
 *       array: (array array)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_boolean;

/**
 * @brief Adaptive Function `set_equals<boolean>`
 * @param x function execute parameter.
 *
 * Returns boolean true if boolean array1 and boolean array2 are subsets of each
 * other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<boolean>(
 *       array1: (array boolean),
 *       array2: (array boolean)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array boolean)
 *
 *   array2 - (array boolean)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_boolean;

/**
 * @brief Adaptive Function `subset<boolean>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in boolean array1 are all in
 * boolean array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<boolean>(
 *       array1: (array boolean),
 *       array2: (array boolean)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array boolean) The first array.
 *
 *   array2 - (array boolean) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition to_string<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_boolean;

/**
 * @brief Adaptive Function `to_string<boolean>`
 * @param x function execute parameter.
 *
 * Converts boolean value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<boolean>(
 *       value: boolean
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (boolean) A boolean value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<boolean> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_boolean;

/**
 * @brief Adaptive Function `union<boolean>`
 * @param x function execute parameter.
 *
 * Returns an array of boolean contains all of the unique values in two or more
 * array of boolean values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<boolean>(
 *       arrays_1: (array boolean),
 *       arrays_2: (array boolean),
 *       ...arrays_rest: (array of (array boolean))
 *   ): (array boolean);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array boolean) Two or more arrays.
 *
 * Returns:
 *
 *   (array boolean)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_compiler_expression compiler_expression functions
 *
 * compiler_expression adaptive functions.
 *
 * @{
 */

/** @brief Function definition nullish_coalescing */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nullish_coalescing;

/**
 * @brief Adaptive Function `nullish_coalescing`
 * @param x function execute parameter.
 *
 * Returns the first value of values that is not null or undefined leaving the
 * remaining values unevaluated.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nullish_coalescing(
 *       values_1: any,
 *       values_2: any,
 *       ...values_rest: (array of any)
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   values - (2 or more any dataType)
 *
 * Returns:
 *
 *   (any dataType) The first value of values that is not null or undefined.
 */
const afw_value_t *
afw_function_execute_nullish_coalescing(
    afw_function_execute_t *x);

/** @brief Function definition optional_chaining */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_optional_chaining;

/**
 * @brief Adaptive Function `optional_chaining`
 * @param x function execute parameter.
 *
 * Returns undefined if arg1 is null or undefined without evaluating arg2, but
 * otherwise returns evaluated value of arg2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function optional_chaining(
 *       arg1: any,
 *       arg2: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (any dataType)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (any dataType) Undefined value if arg1 is null or undefined but otherwise
 *       evaluated arg2.
 */
const afw_value_t *
afw_function_execute_optional_chaining(
    afw_function_execute_t *x);

/** @brief Function definition void_operator */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_void_operator;

/**
 * @brief Adaptive Function `void_operator`
 * @param x function execute parameter.
 *
 * This is the support function for the void operator which evaluates value and
 * returns undefined.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function void_operator(
 *       value: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) This is the value to evaluate.
 *
 * Returns:
 *
 *   (any dataType) This always returns undefined.
 */
const afw_value_t *
afw_function_execute_void_operator(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_compiler_script compiler_script functions
 *
 * compiler_script adaptive functions.
 *
 * @{
 */

/** @brief Function definition assign */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_assign;

/**
 * @brief Adaptive Function `assign`
 * @param x function execute parameter.
 *
 * Assign a value to the innermost structured block definition of a variable. If
 * the variable is not defined, the variable is defined in the innermost
 * structured block. An error is thrown if not called from an array of values
 * (statements) in a structured function.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function assign(
 *       name: string,
 *       value: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   name - (string) Variable name.
 *
 *   value - (any dataType) This is the value to assign to the variable.
 *
 * Returns:
 *
 *   (any dataType) The value assigned.
 */
const afw_value_t *
afw_function_execute_assign(
    afw_function_execute_t *x);

/** @brief Function definition break */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_break;

/**
 * @brief Adaptive Function `break`
 * @param x function execute parameter.
 *
 * This is a special function that can be called to break out of the body of a
 * loop. If called outside of a loop body, an error is thrown.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function break(
 *       value?: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   value - (optional any dataType) The value to evaluate that the enclosing
 *       loop will return. If not specified, the last evaluated value or a null
 *       value will be returned.
 *
 * Returns:
 *
 *   (any dataType) This function returns from the body of a loop with the last
 *       evaluated value.
 */
const afw_value_t *
afw_function_execute_break(
    afw_function_execute_t *x);

/** @brief Function definition const */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_const;

/**
 * @brief Adaptive Function `const`
 * @param x function execute parameter.
 *
 * Define one or more statically scoped constants local to the current script
 * block with a permanent value. These constants can be accessed from the
 * current block and inner blocks, but can not be assigned a different value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function const(
 *       name: (array string),
 *       value: any,
 *       type?: (object _AdaptiveValueMeta_)
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   name - (array string) The name of one or more constants to defined in the
 *       current block.
 *
 *   value - (any dataType) This is the value of the constant(s).
 *
 *   type - (optional object _AdaptiveValueMeta_) The type of the constant(s).
 *
 * Returns:
 *
 *   (any dataType) The value assigned.
 */
const afw_value_t *
afw_function_execute_const(
    afw_function_execute_t *x);

/** @brief Function definition continue */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_continue;

/**
 * @brief Adaptive Function `continue`
 * @param x function execute parameter.
 *
 * This is a special function that can be called in the body of a loop function
 * to test the condition and, if true, start evaluating the body again. If
 * called outside of a loop body, an error is thrown.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function continue(
 *   
 *   ): any;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (any dataType) This function does not return.
 */
const afw_value_t *
afw_function_execute_continue(
    afw_function_execute_t *x);

/** @brief Function definition do_while */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_do_while;

/**
 * @brief Adaptive Function `do_while`
 * @param x function execute parameter.
 *
 * This creates a new structured block with a new nested variable scope.
 * 
 * This function will evaluate an array of values (statements) at least once
 * while a condition is true. See the related functions 'break', 'continue',
 * 'return' and 'throw'.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function do_while(
 *       condition: boolean,
 *       body: array
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   condition - (boolean) While this condition is true, the loop will continue.
 *       This is evaluated in the loop's scope.
 *
 *   body - (array) This is an array of values (statements) that are evaluated
 *       for each iteration of the loop. Each value in body is evaluated in
 *       order until the end of the array or until a 'break', 'continue',
 *       'return' or 'throw' function is encountered.
 *
 * Returns:
 *
 *   (any dataType) The last value evaluated in body or null if the body is
 *       empty.
 */
const afw_value_t *
afw_function_execute_do_while(
    afw_function_execute_t *x);

/** @brief Function definition for */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_for;

/**
 * @brief Adaptive Function `for`
 * @param x function execute parameter.
 *
 * This creates a new structured block with a new nested variable scope.
 * 
 * This function loops while condition is true. If the condition is false for
 * the first iteration, the loop returns a null value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function for(
 *       initial?: array,
 *       condition?: boolean,
 *       increment?: array,
 *       body?: array
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   initial - (optional array) This is an array of values (statements) to
 *       evaluate before the loop starts. The values will normally be a call to
 *       the 'assign' function.
 *
 *   condition - (optional boolean) While this condition is true, the loop will
 *       continue.
 *
 *   increment - (optional array) This is an array of values (statements) to
 *       evaluate after each iteration of the loop. The values will normally be
 *       a call to the 'assign' function.
 *
 *   body - (optional array) This is an array of values (statements) that are
 *       evaluated for each iteration of the loop. Each value in body is
 *       evaluated in order until the end of the array or until a 'break',
 *       'continue', 'return' or 'throw' function is encountered.
 *
 * Returns:
 *
 *   (any dataType) The last value evaluated in body or null if condition
 *       evaluates to false the first time.
 */
const afw_value_t *
afw_function_execute_for(
    afw_function_execute_t *x);

/** @brief Function definition for_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_for_of;

/**
 * @brief Adaptive Function `for_of`
 * @param x function execute parameter.
 *
 * This creates a new structured block with a new nested variable scope.
 * 
 * This function will evaluate an array of values (statements) while a condition
 * is true with initial and increment values. The condition is tested at the
 * beginning of the loop. If the condition is false for the first iteration, the
 * loop returns a null value. This supports for-of statement.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function for_of(
 *       name: (array string),
 *       value: any,
 *       body?: array
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   name - (array string) Variable name(s).
 *
 *   value - (any dataType) Any array, object or single value.
 *
 *   body - (optional array) This is an array of values (statements) that are
 *       evaluated for each iteration of the loop. Each value in body is
 *       evaluated in order until the end of the array or until a 'break',
 *       'continue', 'return' or 'throw' function is encountered.
 *
 * Returns:
 *
 *   (any dataType) The last value evaluated in body or null if condition
 *       evaluates to false the first time.
 */
const afw_value_t *
afw_function_execute_for_of(
    afw_function_execute_t *x);

/** @brief Function definition if */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_if;

/**
 * @brief Adaptive Function `if`
 * @param x function execute parameter.
 *
 * Evaluate one of two different values depending on test condition.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function if(
 *       condition: boolean,
 *       then: array,
 *       else?: array
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   condition - (boolean) If true, parameter 'then' is evaluated for result. If
 *       false, parameter 'else' is evaluated.
 *
 *   then - (array) This is the body of a structured block that is evaluated if
 *       'condition' is true. See the 'body' parameter of the 'block' function
 *       for information on how the body is processed.
 *
 *   else - (optional array) This is the body of a structured block that is
 *       evaluated if 'condition' is false. If not specified and condition is
 *       false, a null value is returned. See the 'body' parameter of the
 *       'block' function for information on how the body is processed.
 *
 * Returns:
 *
 *   (any dataType) The result of evaluating 'then' or 'else'.
 */
const afw_value_t *
afw_function_execute_if(
    afw_function_execute_t *x);

/** @brief Function definition let */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_let;

/**
 * @brief Adaptive Function `let`
 * @param x function execute parameter.
 *
 * Declare one or more statically scoped variable locations local to the current
 * script block and optionally assign them an initial value. These variables can
 * be accessed and assigned different values from the current block and inner
 * blocks.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function let(
 *       name: (array string),
 *       value?: any,
 *       type?: (object _AdaptiveValueMeta_)
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   name - (array string) The name of one or more variables to declared in the
 *       current block.
 *
 *   value - (optional any dataType) This is the initial value of the
 *       variable(s). If not specified, the variable will have a value of
 *       undefined.
 *
 *   type - (optional object _AdaptiveValueMeta_) The type of the variable(s).
 *
 * Returns:
 *
 *   (any dataType) The value assigned.
 */
const afw_value_t *
afw_function_execute_let(
    afw_function_execute_t *x);

/** @brief Function definition rethrow */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_rethrow;

/**
 * @brief Adaptive Function `rethrow`
 * @param x function execute parameter.
 *
 * This is a special function that can be called to rethrow an error inside of a
 * catch block. If called outside of a catch body, an error is thrown.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function rethrow(
 *   
 *   ): any;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (any dataType) This function rethrows the current error in a catch block.
 */
const afw_value_t *
afw_function_execute_rethrow(
    afw_function_execute_t *x);

/** @brief Function definition return */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_return;

/**
 * @brief Adaptive Function `return`
 * @param x function execute parameter.
 *
 * Return from the outermost structured block. If the expression of a lambda
 * function is a block function, this will effectively return from the lambda
 * function. If called outside of a structured block, an error is thrown.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function return(
 *       value?: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   value - (optional any dataType) The value to evaluate that the outermost
 *       block will return. If not specified, the last evaluated value or a null
 *       value will be returned.
 *
 * Returns:
 *
 *   (any dataType) This function returns from the outermost structured block
 *       with the last evaluated value.
 */
const afw_value_t *
afw_function_execute_return(
    afw_function_execute_t *x);

/** @brief Function definition switch */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_switch;

/**
 * @brief Adaptive Function `switch`
 * @param x function execute parameter.
 *
 * Support for switch statement.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function switch(
 *       predicate: (function (any value1: any, value2: any): boolean),
 *       value1: any,
 *       case_clause_1: any,
 *       case_clause_2: any,
 *       ...case_clause_rest: (array of any)
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (any value1: any, value2: any): boolean) The
 *       predicate is passed two parameters and must return a boolean. The first
 *       parameter passed is the evaluated value of the value1 parameter and the
 *       second is the value2 from a case clause. This predicate will often be
 *       'eqx' to use the exactly equal function but can also be any other
 *       function such as 'regexp_match' or a lambda function.
 *
 *   value1 - (any dataType) The first parameter passed to the predicate.
 *
 *   case_clause - (2 or more any dataType) This is one or more case clauses
 *       which are pairs of a value2 parameter followed by a statement list or
 *       undefined parameter. One value2 can be undefined to indicate the
 *       default case clause.
 * 
 *       For the first value2 that is undefined or calling the predicate returns
 *       true, the statement list followed by any statement lists of subsequent
 *       case clauses are executed until a break or return is encountered. The
 *       predicate is called with value1 and the case clause's value2.
 *
 * Returns:
 *
 *   (any dataType)
 */
const afw_value_t *
afw_function_execute_switch(
    afw_function_execute_t *x);

/** @brief Function definition throw */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_throw;

/**
 * @brief Adaptive Function `throw`
 * @param x function execute parameter.
 *
 * This throws an error that can be caught by a try/catch block. An error object
 * of object type _AdaptiveError_ will be available in the catch block. Its 'id'
 * property will be set to 'throw'. The other properties set based on the
 * parameters specified and where this function is called.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function throw(
 *       message: string,
 *       additional?: any
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   message - (string) This is the message that will be included in the
 *       _AdaptiveError_ error object available in the catch block.
 *
 *   additional - (optional any dataType) Optional additional information that
 *       will be available as a 'additional' property in the error object.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_throw(
    afw_function_execute_t *x);

/** @brief Function definition try */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_try;

/**
 * @brief Adaptive Function `try`
 * @param x function execute parameter.
 *
 * This creates a new structured block with a new nested variable scope.
 * 
 * This function will evaluate the body statements. If an error is thrown and
 * there is an optional catch, the error will be 'caught' and the associated
 * statements will be evaluated. The optional finally statements are always
 * evaluated after the body and catch statements. See the related functions
 * 'break', 'continue', 'return' and 'throw'.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function try(
 *       body: array,
 *       finally?: array,
 *       catch?: array,
 *       error?: (object _AdaptiveObjectType_)
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   body - (array) This is an array of values (statements) that are evaluated.
 *       Each value in body is evaluated in order until the end of the list or
 *       until a 'break', 'continue', 'return' or 'throw' function is
 *       encountered.
 *
 *   finally - (optional array) This is an array of values (statements) that are
 *       evaluated after the try and catch statements even if an error occurs.
 *       Each value in body is evaluated in order until the end of the list or
 *       until a 'break', 'continue', 'return' or 'throw' function is
 *       encountered.
 *
 *   catch - (optional array) This is an array of values (statements) that are
 *       evaluated when an error is thrown while evaluating the body. Each value
 *       in body is evaluated in order until the end of the list or until a
 *       'break', 'continue', 'return' or 'throw' function is encountered.
 *
 *   error - (optional object _AdaptiveObjectType_) The error object thrown.
 *       This is only available in the catch block. See adaptive object type
 *       _AdaptiveObjectType_ for details.
 *
 * Returns:
 *
 *   (any dataType) The last value evaluated in body.
 */
const afw_value_t *
afw_function_execute_try(
    afw_function_execute_t *x);

/** @brief Function definition while */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_while;

/**
 * @brief Adaptive Function `while`
 * @param x function execute parameter.
 *
 * This creates a new structured block with a new nested variable scope.
 * 
 * This function will evaluate an array of values (statements) while a condition
 * is true. The condition is tested at the beginning of the loop. If the
 * condition is false for the first iteration, the loop returns a null value.
 * See the related functions 'break', 'continue', 'return' and 'throw'.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function while(
 *       condition: boolean,
 *       body: array
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   condition - (boolean) While this condition is true, the loop will continue.
 *       This is evaluated in the loop's scope.
 *
 *   body - (array) This is an array of values (statements) that are evaluated
 *       for each iteration of the loop. Each value in body is evaluated in
 *       order until the end of the list or until a 'break', 'continue',
 *       'return' or 'throw' function is encountered.
 *
 * Returns:
 *
 *   (any dataType) The last value evaluated in body or null if condition
 *       evaluates to false the first time.
 */
const afw_value_t *
afw_function_execute_while(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_compiler compiler functions
 *
 * compiler adaptive functions.
 *
 * @{
 */

/** @brief Function definition assert */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_assert;

/**
 * @brief Adaptive Function `assert`
 * @param x function execute parameter.
 *
 * Assert that a value is true. If not, an assertion_failed error is thrown.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function assert(
 *       assertion: boolean,
 *       reason?: string
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   assertion - (boolean) This is the assertion to make. If not true, an
 *       assertion_failed error is thrown.
 *
 *   reason - (optional string) This is an optional reason to include in the
 *       assertion_failed message.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_assert(
    afw_function_execute_t *x);

/** @brief Function definition decompile */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decompile;

/**
 * @brief Adaptive Function `decompile`
 * @param x function execute parameter.
 *
 * Decompile an adaptive value to string.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function decompile(
 *       value: any,
 *       whitespace?: any
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to decompile.
 *
 *   whitespace - (optional any dataType) Add whitespace for readability if
 *       present and not 0. This parameter can be an integer between 0 and 10 or
 *       a string that is used for indentation. If 0 is specified, no whitespace
 *       is added to the resulting string. If 1 through 10 is specified, that
 *       number of spaces is used.
 *
 * Returns:
 *
 *   (string) Decompiled value.
 */
const afw_value_t *
afw_function_execute_decompile(
    afw_function_execute_t *x);

/** @brief Function definition evaluate_value */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_value;

/**
 * @brief Adaptive Function `evaluate_value`
 * @param x function execute parameter.
 *
 * Evaluate an adaptive value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function evaluate_value(
 *       value: any,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType)
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (any dataType) Evaluated adaptive value.
 */
const afw_value_t *
afw_function_execute_evaluate_value(
    afw_function_execute_t *x);

/** @brief Function definition evaluate_with_retry */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_with_retry;

/**
 * @brief Adaptive Function `evaluate_with_retry`
 * @param x function execute parameter.
 *
 * Evaluate a value and retry up to a limit if an exception occurs.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function evaluate_with_retry(
 *       value: any,
 *       limit: integer
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to evaluated.
 *
 *   limit - (integer) Maximum number to retry if an exception occurs.
 *
 * Returns:
 *
 *   (any dataType) Evaluated value.
 */
const afw_value_t *
afw_function_execute_evaluate_with_retry(
    afw_function_execute_t *x);

/** @brief Function definition qualifier */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_qualifier;

/**
 * @brief Adaptive Function `qualifier`
 * @param x function execute parameter.
 *
 * This function allows the active variables for a qualifier to be accessed as
 * the properties of an object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function qualifier(
 *       qualifier: string,
 *       forTesting?: boolean
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   qualifier - (string) This is the qualifier whose variables are to be
 *       accessed as properties of the returned object.
 *
 *   forTesting - (optional boolean) If specified and true, the object returned
 *       will be suitable to pass as the additionalUntrustedQualifiedVariables
 *       parameter of evaluate*() functions. This is intended for testing
 *       purposes and should not be used in production.
 *
 * Returns:
 *
 *   (object) Each property is the name of a variable with the value influenced
 *       by the forTesting property.
 */
const afw_value_t *
afw_function_execute_qualifier(
    afw_function_execute_t *x);

/** @brief Function definition qualifiers */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_qualifiers;

/**
 * @brief Adaptive Function `qualifiers`
 * @param x function execute parameter.
 *
 * This function allows the active qualifiers to be accessed as properties of an
 * object. The value of each of these properties is an object whose properties
 * are the variables for the corresponding qualifier.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function qualifiers(
 *       forTesting?: boolean
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   forTesting - (optional boolean) If specified and true, the object returned
 *       will be suitable to pass as the additionalUntrustedQualifiedVariables
 *       parameter of evaluate*() functions. This is intended for testing
 *       purposes and should not be used in production.
 *
 * Returns:
 *
 *   (object) Each property is the name of a qualifier with a value that is an
 *       object whose properties are the variables of that qualifier. The value
 *       of the variable properties is influenced by the forTesting property.
 */
const afw_value_t *
afw_function_execute_qualifiers(
    afw_function_execute_t *x);

/** @brief Function definition safe_evaluate */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_safe_evaluate;

/**
 * @brief Adaptive Function `safe_evaluate`
 * @param x function execute parameter.
 *
 * Return the evaluated adaptive value. If an exception occurs, return evaluated
 * error instead.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function safe_evaluate(
 *       value: any,
 *       error: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to evaluated.
 *
 *   error - (any dataType) Value to evaluate and return if exception occurs. If
 *       an error occurs evaluating this value, the exception will continue.
 *
 * Returns:
 *
 *   (any dataType) Evaluated adaptive value or error value.
 */
const afw_value_t *
afw_function_execute_safe_evaluate(
    afw_function_execute_t *x);

/** @brief Function definition stringify */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_stringify;

/**
 * @brief Adaptive Function `stringify`
 * @param x function execute parameter.
 *
 * Evaluate and decompile an adaptive value to string. For most values this has
 * the effect of producing a string containing json.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function stringify(
 *       value: any,
 *       replacer?: any,
 *       whitespace?: any
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to stringify.
 *
 *   replacer - (optional any dataType) Optional replacer function.
 *
 *   whitespace - (optional any dataType) Add whitespace for readability if
 *       present and not 0. This parameter can be an integer between 0 and 10 or
 *       a string that is used for indentation. If 0 is specified, no whitespace
 *       is added to the resulting string. If 1 through 10 is specified, that
 *       number of spaces is used.
 *
 * Returns:
 *
 *   (string) Evaluated and decompiled value.
 */
const afw_value_t *
afw_function_execute_stringify(
    afw_function_execute_t *x);

/** @brief Function definition test_script */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_script;

/**
 * @brief Adaptive Function `test_script`
 * @param x function execute parameter.
 *
 * Compile and evaluate an adaptive script and compare the results to an
 * expected value. Return object with the test's results.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function test_script(
 *       id: string,
 *       description: string,
 *       script: string,
 *       expected?: any,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   id - (string) Id of test.
 *
 *   description - (string) Description of test.
 *
 *   script - (string) Script to compile and evaluate.
 *
 *   expected - (optional any dataType) Expected result.
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (object) Test results.
 */
const afw_value_t *
afw_function_execute_test_script(
    afw_function_execute_t *x);

/** @brief Function definition test_template */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_template;

/**
 * @brief Adaptive Function `test_template`
 * @param x function execute parameter.
 *
 * Compile and evaluate an adaptive template and compare the results to an
 * expected value. Return object with the test's results.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function test_template(
 *       id: string,
 *       description: string,
 *       template: string,
 *       expected?: any,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   id - (string) Id of test.
 *
 *   description - (string) Description of test.
 *
 *   template - (string) Template to compile and evaluate.
 *
 *   expected - (optional any dataType) Expected evaluated result.
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (object) Test results.
 */
const afw_value_t *
afw_function_execute_test_template(
    afw_function_execute_t *x);

/** @brief Function definition test_value */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_test_value;

/**
 * @brief Adaptive Function `test_value`
 * @param x function execute parameter.
 *
 * Evaluate an adaptive value and compare it to an expected value. Return object
 * with the test's results.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function test_value(
 *       id: string,
 *       description: string,
 *       value: string,
 *       expected?: any,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   id - (string) Id of test.
 *
 *   description - (string) Description of test.
 *
 *   value - (string) Value to evaluate.
 *
 *   expected - (optional any dataType) Expected result.
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (object) Test results.
 */
const afw_value_t *
afw_function_execute_test_value(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_dateTime dateTime functions
 *
 * dateTime adaptive functions.
 *
 * @{
 */

/** @brief Function definition add_dayTimeDuration<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_dayTimeDuration_dateTime;

/**
 * @brief Adaptive Function `add_dayTimeDuration<dateTime>`
 * @param x function execute parameter.
 *
 * Add dateTime arg1 to dayTimeDuration arg2 and return the dateTime result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function add_dayTimeDuration<dateTime>(
 *       arg1: dateTime,
 *       arg2: dayTimeDuration
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (dayTimeDuration)
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_add_dayTimeDuration_dateTime(
    afw_function_execute_t *x);

/** @brief Function definition add_yearMonthDuration<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_yearMonthDuration_dateTime;

/**
 * @brief Adaptive Function `add_yearMonthDuration<dateTime>`
 * @param x function execute parameter.
 *
 * Add dateTime arg1 to yearMonthDuration arg2 and return the dateTime result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function add_yearMonthDuration<dateTime>(
 *       arg1: dateTime,
 *       arg2: yearMonthDuration
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_add_yearMonthDuration_dateTime(
    afw_function_execute_t *x);

/** @brief Function definition at_least_one_member_of<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_dateTime;

/**
 * @brief Adaptive Function `at_least_one_member_of<dateTime>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in dateTime array1 is in dateTime
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<dateTime>(
 *       array1: (array dateTime),
 *       array2: (array dateTime)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dateTime) The first array.
 *
 *   array2 - (array dateTime) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_dateTime;

/**
 * @brief Adaptive Function `bag<dateTime>`
 * @param x function execute parameter.
 *
 * Takes any number of dateTime values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<dateTime>(
 *       ...values: (array of (array dateTime))
 *   ): (array dateTime);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array dateTime)
 *
 * Returns:
 *
 *   (array dateTime)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_dateTime;

/**
 * @brief Adaptive Function `bag_size<dateTime>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<dateTime>(
 *       value: (array dateTime)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array dateTime)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition dateTime */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_dateTime;

/**
 * @brief Adaptive Function `dateTime`
 * @param x function execute parameter.
 *
 * Converts value to data type dateTime returning dateTime result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function dateTime(
 *       value: any
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (dateTime) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition eq<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_dateTime;

/**
 * @brief Adaptive Function `eq<dateTime>`
 * @param x function execute parameter.
 *
 * Determine if dateTime arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<dateTime>(
 *       arg1: dateTime,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_dateTime;

/**
 * @brief Adaptive Function `eqx<dateTime>`
 * @param x function execute parameter.
 *
 * Determine if for dateTime arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<dateTime>(
 *       arg1: dateTime,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_dateTime;

/**
 * @brief Adaptive Function `ge<dateTime>`
 * @param x function execute parameter.
 *
 * Checks for dateTime arg1 is greater than or equal to dateTime arg2 and return
 * the boolean result.
 * 
 * If a dateTime value does not include a time-zone value, then the local
 * time-zone value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<dateTime>(
 *       arg1: dateTime,
 *       arg2: dateTime
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (dateTime)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_dateTime;

/**
 * @brief Adaptive Function `gt<dateTime>`
 * @param x function execute parameter.
 *
 * Checks for dateTime arg1 is greater than dateTime arg2 and return the boolean
 * result.
 * 
 * If a dateTime value does not include a time-zone value, then the local
 * time-zone value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<dateTime>(
 *       arg1: dateTime,
 *       arg2: dateTime
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (dateTime)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_dateTime;

/**
 * @brief Adaptive Function `intersection<dateTime>`
 * @param x function execute parameter.
 *
 * Returns an array of dateTime with the values that are common to both array of
 * dateTime array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<dateTime>(
 *       array1: (array dateTime),
 *       array2: (array dateTime)
 *   ): (array dateTime);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dateTime) The first array.
 *
 *   array2 - (array dateTime) The second array.
 *
 * Returns:
 *
 *   (array dateTime)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_dateTime;

/**
 * @brief Adaptive Function `is<dateTime>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType dateTime and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<dateTime>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_dateTime;

/**
 * @brief Adaptive Function `is_in<dateTime>`
 * @param x function execute parameter.
 *
 * Checks whether dateTime value is in array of dateTime array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<dateTime>(
 *       value: dateTime,
 *       array: (array dateTime)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (dateTime)
 *
 *   array - (array dateTime)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_dateTime;

/**
 * @brief Adaptive Function `le<dateTime>`
 * @param x function execute parameter.
 *
 * Checks for dateTime arg1 is less than or equal to dateTime arg2 and return
 * the boolean result.
 * 
 * If a dateTime value does not include a time-zone value, then the local
 * time-zone value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<dateTime>(
 *       arg1: dateTime,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_dateTime;

/**
 * @brief Adaptive Function `lt<dateTime>`
 * @param x function execute parameter.
 *
 * Checks for dateTime arg1 is less that dateTime arg2 and return the boolean
 * result.
 * 
 * If a dateTime value does not include a time-zone value, then the local
 * time-zone value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<dateTime>(
 *       arg1: dateTime,
 *       arg2: dateTime
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (dateTime)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition max<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_dateTime;

/**
 * @brief Adaptive Function `max<dateTime>`
 * @param x function execute parameter.
 *
 * Return the dateTime value that is greater than or equal to the others.
 * 
 * If a dateTime value does not include a time-zone value, then the local
 * time-zone value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function max<dateTime>(
 *       values_1: dateTime,
 *       ...values_rest: (array of dateTime)
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more dateTime)
 *
 * Returns:
 *
 *   (dateTime)
 *
 * Implemented by afw_function_execute_max()
 *
 * __________
 */

/** @brief Function definition min<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_dateTime;

/**
 * @brief Adaptive Function `min<dateTime>`
 * @param x function execute parameter.
 *
 * Return the dateTime value that is less than or equal to the others.
 * 
 * If a dateTime value does not include a time-zone value, then the local
 * time-zone value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function min<dateTime>(
 *       values_1: dateTime,
 *       ...values_rest: (array of dateTime)
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more dateTime)
 *
 * Returns:
 *
 *   (dateTime)
 *
 * Implemented by afw_function_execute_min()
 *
 * __________
 */

/** @brief Function definition ne<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_dateTime;

/**
 * @brief Adaptive Function `ne<dateTime>`
 * @param x function execute parameter.
 *
 * Determine if dateTime arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<dateTime>(
 *       arg1: dateTime,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_dateTime;

/**
 * @brief Adaptive Function `nex<dateTime>`
 * @param x function execute parameter.
 *
 * Determine if for dateTime arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<dateTime>(
 *       arg1: dateTime,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_dateTime;

/**
 * @brief Adaptive Function `one_and_only<dateTime>`
 * @param x function execute parameter.
 *
 * This converts an array of dateTime values that contains one value to a single
 * dateTime value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<dateTime>(
 *       array: (array array)
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (dateTime)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_dateTime;

/**
 * @brief Adaptive Function `set_equals<dateTime>`
 * @param x function execute parameter.
 *
 * Returns boolean true if dateTime array1 and dateTime array2 are subsets of
 * each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<dateTime>(
 *       array1: (array dateTime),
 *       array2: (array dateTime)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dateTime)
 *
 *   array2 - (array dateTime)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_dateTime;

/**
 * @brief Adaptive Function `subset<dateTime>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in dateTime array1 are all in
 * dateTime array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<dateTime>(
 *       array1: (array dateTime),
 *       array2: (array dateTime)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dateTime) The first array.
 *
 *   array2 - (array dateTime) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition subtract_dayTimeDuration<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_dayTimeDuration_dateTime;

/**
 * @brief Adaptive Function `subtract_dayTimeDuration<dateTime>`
 * @param x function execute parameter.
 *
 * Subtract dayTimeDuration arg2 from dateTime arg1 and return the dateTime
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subtract_dayTimeDuration<dateTime>(
 *       arg1: dateTime,
 *       arg2: dayTimeDuration
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (dayTimeDuration)
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_subtract_dayTimeDuration_dateTime(
    afw_function_execute_t *x);

/** @brief Function definition subtract_yearMonthDuration<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_yearMonthDuration_dateTime;

/**
 * @brief Adaptive Function `subtract_yearMonthDuration<dateTime>`
 * @param x function execute parameter.
 *
 * Subtract yearMonthDuration arg2 from dateTime arg1 and return the dateTime
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subtract_yearMonthDuration<dateTime>(
 *       arg1: dateTime,
 *       arg2: yearMonthDuration
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dateTime)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_subtract_yearMonthDuration_dateTime(
    afw_function_execute_t *x);

/** @brief Function definition to_string<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_dateTime;

/**
 * @brief Adaptive Function `to_string<dateTime>`
 * @param x function execute parameter.
 *
 * Converts dateTime value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<dateTime>(
 *       value: dateTime
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (dateTime) A dateTime value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<dateTime> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_dateTime;

/**
 * @brief Adaptive Function `union<dateTime>`
 * @param x function execute parameter.
 *
 * Returns an array of dateTime contains all of the unique values in two or more
 * array of dateTime values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<dateTime>(
 *       arrays_1: (array dateTime),
 *       arrays_2: (array dateTime),
 *       ...arrays_rest: (array of (array dateTime))
 *   ): (array dateTime);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array dateTime) Two or more arrays.
 *
 * Returns:
 *
 *   (array dateTime)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_date date functions
 *
 * date adaptive functions.
 *
 * @{
 */

/** @brief Function definition add_yearMonthDuration<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_yearMonthDuration_date;

/**
 * @brief Adaptive Function `add_yearMonthDuration<date>`
 * @param x function execute parameter.
 *
 * Add date arg1 to yearMonthDuration arg2 and return the date result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function add_yearMonthDuration<date>(
 *       arg1: date,
 *       arg2: yearMonthDuration
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (date)
 */
const afw_value_t *
afw_function_execute_add_yearMonthDuration_date(
    afw_function_execute_t *x);

/** @brief Function definition at_least_one_member_of<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_date;

/**
 * @brief Adaptive Function `at_least_one_member_of<date>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in date array1 is in date array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<date>(
 *       array1: (array date),
 *       array2: (array date)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array date) The first array.
 *
 *   array2 - (array date) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_date;

/**
 * @brief Adaptive Function `bag<date>`
 * @param x function execute parameter.
 *
 * Takes any number of date values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<date>(
 *       ...values: (array of (array date))
 *   ): (array date);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array date)
 *
 * Returns:
 *
 *   (array date)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_date;

/**
 * @brief Adaptive Function `bag_size<date>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<date>(
 *       value: (array date)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array date)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition date */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_date;

/**
 * @brief Adaptive Function `date`
 * @param x function execute parameter.
 *
 * Converts value to data type date returning date result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function date(
 *       value: any
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (date) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition eq<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_date;

/**
 * @brief Adaptive Function `eq<date>`
 * @param x function execute parameter.
 *
 * Determine if date arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<date>(
 *       arg1: date,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_date;

/**
 * @brief Adaptive Function `eqx<date>`
 * @param x function execute parameter.
 *
 * Determine if for date arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<date>(
 *       arg1: date,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_date;

/**
 * @brief Adaptive Function `ge<date>`
 * @param x function execute parameter.
 *
 * Checks for date arg1 is greater than or equal to date arg2 and return the
 * boolean result.
 * 
 * If a date value does not include a time-zone value, then the local time-zone
 * value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<date>(
 *       arg1: date,
 *       arg2: date
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (date)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_date;

/**
 * @brief Adaptive Function `gt<date>`
 * @param x function execute parameter.
 *
 * Checks for date arg1 is greater than date arg2 and return the boolean result.
 * 
 * If a date value does not include a time-zone value, then the local time-zone
 * value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<date>(
 *       arg1: date,
 *       arg2: date
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (date)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_date;

/**
 * @brief Adaptive Function `intersection<date>`
 * @param x function execute parameter.
 *
 * Returns an array of date with the values that are common to both array of
 * date array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<date>(
 *       array1: (array date),
 *       array2: (array date)
 *   ): (array date);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array date) The first array.
 *
 *   array2 - (array date) The second array.
 *
 * Returns:
 *
 *   (array date)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_date;

/**
 * @brief Adaptive Function `is<date>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType date and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<date>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_date;

/**
 * @brief Adaptive Function `is_in<date>`
 * @param x function execute parameter.
 *
 * Checks whether date value is in array of date array and returns the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<date>(
 *       value: date,
 *       array: (array date)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (date)
 *
 *   array - (array date)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_date;

/**
 * @brief Adaptive Function `le<date>`
 * @param x function execute parameter.
 *
 * Checks for date arg1 is less than or equal to date arg2 and return the
 * boolean result.
 * 
 * If a date value does not include a time-zone value, then the local time-zone
 * value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<date>(
 *       arg1: date,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_date;

/**
 * @brief Adaptive Function `lt<date>`
 * @param x function execute parameter.
 *
 * Checks for date arg1 is less that date arg2 and return the boolean result.
 * 
 * If a date value does not include a time-zone value, then the local time-zone
 * value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<date>(
 *       arg1: date,
 *       arg2: date
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (date)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition max<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_date;

/**
 * @brief Adaptive Function `max<date>`
 * @param x function execute parameter.
 *
 * Return the date value that is greater than or equal to the others..
 * 
 * If a date value does not include a time-zone value, then the local time-zone
 * value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function max<date>(
 *       values_1: date,
 *       ...values_rest: (array of date)
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more date)
 *
 * Returns:
 *
 *   (date)
 *
 * Implemented by afw_function_execute_max()
 *
 * __________
 */

/** @brief Function definition min<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_date;

/**
 * @brief Adaptive Function `min<date>`
 * @param x function execute parameter.
 *
 * Return the date value that is less than or equal to the others..
 * 
 * If a date value does not include a time-zone value, then the local time-zone
 * value will be assigned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function min<date>(
 *       values_1: date,
 *       ...values_rest: (array of date)
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more date)
 *
 * Returns:
 *
 *   (date)
 *
 * Implemented by afw_function_execute_min()
 *
 * __________
 */

/** @brief Function definition ne<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_date;

/**
 * @brief Adaptive Function `ne<date>`
 * @param x function execute parameter.
 *
 * Determine if date arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<date>(
 *       arg1: date,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_date;

/**
 * @brief Adaptive Function `nex<date>`
 * @param x function execute parameter.
 *
 * Determine if for date arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<date>(
 *       arg1: date,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_date;

/**
 * @brief Adaptive Function `one_and_only<date>`
 * @param x function execute parameter.
 *
 * This converts an array of date values that contains one value to a single
 * date value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<date>(
 *       array: (array array)
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (date)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_date;

/**
 * @brief Adaptive Function `set_equals<date>`
 * @param x function execute parameter.
 *
 * Returns boolean true if date array1 and date array2 are subsets of each other
 * and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<date>(
 *       array1: (array date),
 *       array2: (array date)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array date)
 *
 *   array2 - (array date)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_date;

/**
 * @brief Adaptive Function `subset<date>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in date array1 are all in date
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<date>(
 *       array1: (array date),
 *       array2: (array date)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array date) The first array.
 *
 *   array2 - (array date) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition subtract_yearMonthDuration<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_yearMonthDuration_date;

/**
 * @brief Adaptive Function `subtract_yearMonthDuration<date>`
 * @param x function execute parameter.
 *
 * Subtract yearMonthDuration arg2 from date arg1 and return the date result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subtract_yearMonthDuration<date>(
 *       arg1: date,
 *       arg2: yearMonthDuration
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (date)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (date)
 */
const afw_value_t *
afw_function_execute_subtract_yearMonthDuration_date(
    afw_function_execute_t *x);

/** @brief Function definition to_string<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_date;

/**
 * @brief Adaptive Function `to_string<date>`
 * @param x function execute parameter.
 *
 * Converts date value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<date>(
 *       value: date
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (date) A date value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<date> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_date;

/**
 * @brief Adaptive Function `union<date>`
 * @param x function execute parameter.
 *
 * Returns an array of date contains all of the unique values in two or more
 * array of date values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<date>(
 *       arrays_1: (array date),
 *       arrays_2: (array date),
 *       ...arrays_rest: (array of (array date))
 *   ): (array date);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array date) Two or more arrays.
 *
 * Returns:
 *
 *   (array date)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_dayTimeDuration dayTimeDuration functions
 *
 * dayTimeDuration adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_dayTimeDuration;

/**
 * @brief Adaptive Function `at_least_one_member_of<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in dayTimeDuration array1 is in
 * dayTimeDuration array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<dayTimeDuration>(
 *       array1: (array dayTimeDuration),
 *       array2: (array dayTimeDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dayTimeDuration) The first array.
 *
 *   array2 - (array dayTimeDuration) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_dayTimeDuration;

/**
 * @brief Adaptive Function `bag<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Takes any number of dayTimeDuration values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<dayTimeDuration>(
 *       ...values: (array of (array dayTimeDuration))
 *   ): (array dayTimeDuration);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array dayTimeDuration)
 *
 * Returns:
 *
 *   (array dayTimeDuration)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_dayTimeDuration;

/**
 * @brief Adaptive Function `bag_size<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<dayTimeDuration>(
 *       value: (array dayTimeDuration)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array dayTimeDuration)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition dayTimeDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_dayTimeDuration;

/**
 * @brief Adaptive Function `dayTimeDuration`
 * @param x function execute parameter.
 *
 * Converts value to data type dayTimeDuration returning dayTimeDuration result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function dayTimeDuration(
 *       value: any
 *   ): dayTimeDuration;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (dayTimeDuration) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition eq<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_dayTimeDuration;

/**
 * @brief Adaptive Function `eq<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Determine if dayTimeDuration arg1 is equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'eqx' ('===')
 * instead if you want false to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_dayTimeDuration;

/**
 * @brief Adaptive Function `eqx<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Determine if for dayTimeDuration arg1 is equal to the value and data type of
 * arg2 then return the boolean result. Use 'eq' ('==') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_dayTimeDuration;

/**
 * @brief Adaptive Function `ge<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Checks for dayTimeDuration arg1 is greater than or equal to dayTimeDuration
 * arg2 and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: dayTimeDuration
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (dayTimeDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_dayTimeDuration;

/**
 * @brief Adaptive Function `gt<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Checks for dayTimeDuration arg1 is greater than dayTimeDuration arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: dayTimeDuration
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (dayTimeDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_dayTimeDuration;

/**
 * @brief Adaptive Function `intersection<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Returns an array of dayTimeDuration with the values that are common to both
 * array of dayTimeDuration array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<dayTimeDuration>(
 *       array1: (array dayTimeDuration),
 *       array2: (array dayTimeDuration)
 *   ): (array dayTimeDuration);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dayTimeDuration) The first array.
 *
 *   array2 - (array dayTimeDuration) The second array.
 *
 * Returns:
 *
 *   (array dayTimeDuration)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_dayTimeDuration;

/**
 * @brief Adaptive Function `is<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType dayTimeDuration and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<dayTimeDuration>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_dayTimeDuration;

/**
 * @brief Adaptive Function `is_in<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Checks whether dayTimeDuration value is in array of dayTimeDuration array and
 * returns the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<dayTimeDuration>(
 *       value: dayTimeDuration,
 *       array: (array dayTimeDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (dayTimeDuration)
 *
 *   array - (array dayTimeDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_dayTimeDuration;

/**
 * @brief Adaptive Function `le<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Checks for dayTimeDuration arg1 is less than or equal to dayTimeDuration arg2
 * and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_dayTimeDuration;

/**
 * @brief Adaptive Function `lt<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Checks for dayTimeDuration arg1 is less that dayTimeDuration arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: dayTimeDuration
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (dayTimeDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_dayTimeDuration;

/**
 * @brief Adaptive Function `ne<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Determine if dayTimeDuration arg1 is not equal to the value of arg2 converted
 * to the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_dayTimeDuration;

/**
 * @brief Adaptive Function `nex<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Determine if for dayTimeDuration arg1 is not equal to the value or data type
 * of arg2 then return the boolean result. Use 'ne' ('!=') instead if you want
 * arg2 to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<dayTimeDuration>(
 *       arg1: dayTimeDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dayTimeDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_dayTimeDuration;

/**
 * @brief Adaptive Function `one_and_only<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * This converts an array of dayTimeDuration values that contains one value to a
 * single dayTimeDuration value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<dayTimeDuration>(
 *       array: (array array)
 *   ): dayTimeDuration;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (dayTimeDuration)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_dayTimeDuration;

/**
 * @brief Adaptive Function `set_equals<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Returns boolean true if dayTimeDuration array1 and dayTimeDuration array2 are
 * subsets of each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<dayTimeDuration>(
 *       array1: (array dayTimeDuration),
 *       array2: (array dayTimeDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dayTimeDuration)
 *
 *   array2 - (array dayTimeDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_dayTimeDuration;

/**
 * @brief Adaptive Function `subset<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in dayTimeDuration array1 are all
 * in dayTimeDuration array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<dayTimeDuration>(
 *       array1: (array dayTimeDuration),
 *       array2: (array dayTimeDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array dayTimeDuration) The first array.
 *
 *   array2 - (array dayTimeDuration) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition to_string<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_dayTimeDuration;

/**
 * @brief Adaptive Function `to_string<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Converts dayTimeDuration value to string. For array values, the to_string()
 * value for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<dayTimeDuration>(
 *       value: dayTimeDuration
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (dayTimeDuration) A dayTimeDuration value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<dayTimeDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_dayTimeDuration;

/**
 * @brief Adaptive Function `union<dayTimeDuration>`
 * @param x function execute parameter.
 *
 * Returns an array of dayTimeDuration contains all of the unique values in two
 * or more array of dayTimeDuration values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<dayTimeDuration>(
 *       arrays_1: (array dayTimeDuration),
 *       arrays_2: (array dayTimeDuration),
 *       ...arrays_rest: (array of (array dayTimeDuration))
 *   ): (array dayTimeDuration);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array dayTimeDuration) Two or more arrays.
 *
 * Returns:
 *
 *   (array dayTimeDuration)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_dnsName dnsName functions
 *
 * dnsName adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_dnsName;

/**
 * @brief Adaptive Function `bag<dnsName>`
 * @param x function execute parameter.
 *
 * Takes any number of dnsName values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<dnsName>(
 *       ...values: (array of (array dnsName))
 *   ): (array dnsName);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array dnsName)
 *
 * Returns:
 *
 *   (array dnsName)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_dnsName;

/**
 * @brief Adaptive Function `bag_size<dnsName>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<dnsName>(
 *       value: (array dnsName)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array dnsName)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition dnsName */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_dnsName;

/**
 * @brief Adaptive Function `dnsName`
 * @param x function execute parameter.
 *
 * Converts value to data type dnsName returning dnsName result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function dnsName(
 *       value: any
 *   ): dnsName;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (dnsName) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition eq<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_dnsName;

/**
 * @brief Adaptive Function `eq<dnsName>`
 * @param x function execute parameter.
 *
 * Determine if dnsName arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<dnsName>(
 *       arg1: dnsName,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_dnsName;

/**
 * @brief Adaptive Function `eqx<dnsName>`
 * @param x function execute parameter.
 *
 * Determine if for dnsName arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<dnsName>(
 *       arg1: dnsName,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_dnsName;

/**
 * @brief Adaptive Function `ge<dnsName>`
 * @param x function execute parameter.
 *
 * Checks for dnsName arg1 is greater than or equal to dnsName arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<dnsName>(
 *       arg1: dnsName,
 *       arg2: dnsName
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (dnsName)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_dnsName;

/**
 * @brief Adaptive Function `gt<dnsName>`
 * @param x function execute parameter.
 *
 * Checks for dnsName arg1 is greater than dnsName arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<dnsName>(
 *       arg1: dnsName,
 *       arg2: dnsName
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (dnsName)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_dnsName;

/**
 * @brief Adaptive Function `is<dnsName>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType dnsName and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<dnsName>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_dnsName;

/**
 * @brief Adaptive Function `is_in<dnsName>`
 * @param x function execute parameter.
 *
 * Checks whether dnsName value is in array of dnsName array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<dnsName>(
 *       value: dnsName,
 *       array: (array dnsName)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (dnsName)
 *
 *   array - (array dnsName)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_dnsName;

/**
 * @brief Adaptive Function `le<dnsName>`
 * @param x function execute parameter.
 *
 * Checks for dnsName arg1 is less than or equal to dnsName arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<dnsName>(
 *       arg1: dnsName,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_dnsName;

/**
 * @brief Adaptive Function `lt<dnsName>`
 * @param x function execute parameter.
 *
 * Checks for dnsName arg1 is less that dnsName arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<dnsName>(
 *       arg1: dnsName,
 *       arg2: dnsName
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (dnsName)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_dnsName;

/**
 * @brief Adaptive Function `ne<dnsName>`
 * @param x function execute parameter.
 *
 * Determine if dnsName arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<dnsName>(
 *       arg1: dnsName,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_dnsName;

/**
 * @brief Adaptive Function `nex<dnsName>`
 * @param x function execute parameter.
 *
 * Determine if for dnsName arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<dnsName>(
 *       arg1: dnsName,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (dnsName)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_dnsName;

/**
 * @brief Adaptive Function `one_and_only<dnsName>`
 * @param x function execute parameter.
 *
 * This converts an array of dnsName values that contains one value to a single
 * dnsName value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<dnsName>(
 *       array: (array array)
 *   ): dnsName;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (dnsName)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition regexp_match<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_dnsName;

/**
 * @brief Adaptive Function `regexp_match<dnsName>`
 * @param x function execute parameter.
 *
 * Checks whether dnsName value matches the regular expression regexp and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_match<dnsName>(
 *       value: dnsName,
 *       regexp: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (dnsName)
 *
 *   regexp - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_regexp_match()
 *
 * __________
 */

/** @brief Function definition to_string<dnsName> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_dnsName;

/**
 * @brief Adaptive Function `to_string<dnsName>`
 * @param x function execute parameter.
 *
 * Converts dnsName value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<dnsName>(
 *       value: dnsName
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (dnsName) A dnsName value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_double double functions
 *
 * double adaptive functions.
 *
 * @{
 */

/** @brief Function definition abs<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_abs_double;

/**
 * @brief Adaptive Function `abs<double>`
 * @param x function execute parameter.
 *
 * Compute the absolute value of the double value and return the double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function abs<double>(
 *       value: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   value - (double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_abs_double(
    afw_function_execute_t *x);

/** @brief Function definition add<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_double;

/**
 * @brief Adaptive Function `add<double>`
 * @param x function execute parameter.
 *
 * Add 2 or more double values and return the double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function add<double>(
 *       values_1: double,
 *       values_2: double,
 *       ...values_rest: (array of double)
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   values - (2 or more double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_add_double(
    afw_function_execute_t *x);

/** @brief Function definition at_least_one_member_of<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_double;

/**
 * @brief Adaptive Function `at_least_one_member_of<double>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in double array1 is in double
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<double>(
 *       array1: (array double),
 *       array2: (array double)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array double) The first array.
 *
 *   array2 - (array double) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_double;

/**
 * @brief Adaptive Function `bag<double>`
 * @param x function execute parameter.
 *
 * Takes any number of double values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<double>(
 *       ...values: (array of (array double))
 *   ): (array double);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array double)
 *
 * Returns:
 *
 *   (array double)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_double;

/**
 * @brief Adaptive Function `bag_size<double>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<double>(
 *       value: (array double)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array double)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition ceil<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ceil_double;

/**
 * @brief Adaptive Function `ceil<double>`
 * @param x function execute parameter.
 *
 * Determine the smallest integer that is greater then or equal to the double
 * value and return the double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ceil<double>(
 *       value: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   value - (double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_ceil_double(
    afw_function_execute_t *x);

/** @brief Function definition divide<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_divide_double;

/**
 * @brief Adaptive Function `divide<double>`
 * @param x function execute parameter.
 *
 * Divide double dividend by double divisor and return the double quotient.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function divide<double>(
 *       dividend: double,
 *       divisor: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   dividend - (double)
 *
 *   divisor - (double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_divide_double(
    afw_function_execute_t *x);

/** @brief Function definition double */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_double;

/**
 * @brief Adaptive Function `double`
 * @param x function execute parameter.
 *
 * Converts value to data type double returning double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function double(
 *       value: any
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (double) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition eq<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_double;

/**
 * @brief Adaptive Function `eq<double>`
 * @param x function execute parameter.
 *
 * Determine if double arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<double>(
 *       arg1: double,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_double;

/**
 * @brief Adaptive Function `eqx<double>`
 * @param x function execute parameter.
 *
 * Determine if for double arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<double>(
 *       arg1: double,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition floor<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_floor_double;

/**
 * @brief Adaptive Function `floor<double>`
 * @param x function execute parameter.
 *
 * Determine the largest integer that is smaller then or equal to the double
 * value and return the double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function floor<double>(
 *       number: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   number - (double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_floor_double(
    afw_function_execute_t *x);

/** @brief Function definition ge<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_double;

/**
 * @brief Adaptive Function `ge<double>`
 * @param x function execute parameter.
 *
 * Checks for double arg1 is greater than or equal to double arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<double>(
 *       arg1: double,
 *       arg2: double
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (double)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_double;

/**
 * @brief Adaptive Function `gt<double>`
 * @param x function execute parameter.
 *
 * Checks for double arg1 is greater than double arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<double>(
 *       arg1: double,
 *       arg2: double
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (double)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_double;

/**
 * @brief Adaptive Function `intersection<double>`
 * @param x function execute parameter.
 *
 * Returns an array of double with the values that are common to both array of
 * double array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<double>(
 *       array1: (array double),
 *       array2: (array double)
 *   ): (array double);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array double) The first array.
 *
 *   array2 - (array double) The second array.
 *
 * Returns:
 *
 *   (array double)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is_NaN */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_NaN;

/**
 * @brief Adaptive Function `is_NaN`
 * @param x function execute parameter.
 *
 * Checks if the argument 'number' is not a number(NaN) and returns the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_NaN(
 *       number: double
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   number - (double) Number to check.
 *
 * Returns:
 *
 *   (boolean) True if the argument 'number' is not a number.
 */
const afw_value_t *
afw_function_execute_is_NaN(
    afw_function_execute_t *x);

/** @brief Function definition is<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_double;

/**
 * @brief Adaptive Function `is<double>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType double and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<double>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_finite */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_finite;

/**
 * @brief Adaptive Function `is_finite`
 * @param x function execute parameter.
 *
 * Checks if the argument 'number' is finite and returns the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_finite(
 *       number: double
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   number - (double) Number to check.
 *
 * Returns:
 *
 *   (boolean) True if the argument 'number' is finite.
 */
const afw_value_t *
afw_function_execute_is_finite(
    afw_function_execute_t *x);

/** @brief Function definition is_in<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_double;

/**
 * @brief Adaptive Function `is_in<double>`
 * @param x function execute parameter.
 *
 * Checks whether double value is in array of double array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<double>(
 *       value: double,
 *       array: (array double)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (double)
 *
 *   array - (array double)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_double;

/**
 * @brief Adaptive Function `le<double>`
 * @param x function execute parameter.
 *
 * Checks for double arg1 is less than or equal to double arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<double>(
 *       arg1: double,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_double;

/**
 * @brief Adaptive Function `lt<double>`
 * @param x function execute parameter.
 *
 * Checks for double arg1 is less that double arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<double>(
 *       arg1: double,
 *       arg2: double
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (double)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition max<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_double;

/**
 * @brief Adaptive Function `max<double>`
 * @param x function execute parameter.
 *
 * Return the double value that is greater than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function max<double>(
 *       values_1: double,
 *       ...values_rest: (array of double)
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more double)
 *
 * Returns:
 *
 *   (double)
 *
 * Implemented by afw_function_execute_max()
 *
 * __________
 */

/** @brief Function definition min<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_double;

/**
 * @brief Adaptive Function `min<double>`
 * @param x function execute parameter.
 *
 * Return the double value that is less than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function min<double>(
 *       values_1: double,
 *       ...values_rest: (array of double)
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more double)
 *
 * Returns:
 *
 *   (double)
 *
 * Implemented by afw_function_execute_min()
 *
 * __________
 */

/** @brief Function definition multiply<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_multiply_double;

/**
 * @brief Adaptive Function `multiply<double>`
 * @param x function execute parameter.
 *
 * Multiply 2 or more double values and return the double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function multiply<double>(
 *       values_1: double,
 *       values_2: double,
 *       ...values_rest: (array of double)
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   values - (2 or more double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_multiply_double(
    afw_function_execute_t *x);

/** @brief Function definition ne<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_double;

/**
 * @brief Adaptive Function `ne<double>`
 * @param x function execute parameter.
 *
 * Determine if double arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<double>(
 *       arg1: double,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition negative<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_negative_double;

/**
 * @brief Adaptive Function `negative<double>`
 * @param x function execute parameter.
 *
 * Return negative of double value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function negative<double>(
 *       value: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   value - (double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_negative_double(
    afw_function_execute_t *x);

/** @brief Function definition nex<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_double;

/**
 * @brief Adaptive Function `nex<double>`
 * @param x function execute parameter.
 *
 * Determine if for double arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<double>(
 *       arg1: double,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_double;

/**
 * @brief Adaptive Function `one_and_only<double>`
 * @param x function execute parameter.
 *
 * This converts an array of double values that contains one value to a single
 * double value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<double>(
 *       array: (array array)
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (double)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition pow<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_pow_double;

/**
 * @brief Adaptive Function `pow<double>`
 * @param x function execute parameter.
 *
 * This returns the value of base raised to a power. Multiple exponents can be
 * specified to raise the previous exponent to the power of the latter exponent.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function pow<double>(
 *       base: double,
 *       exponent_1: double,
 *       ...exponent_rest: (array of double)
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   base - (double) Base value.
 *
 *   exponent - (1 or more double) Exponent value.
 *
 * Returns:
 *
 *   (double) Base raised to the power.
 */
const afw_value_t *
afw_function_execute_pow_double(
    afw_function_execute_t *x);

/** @brief Function definition round<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_round_double;

/**
 * @brief Adaptive Function `round<double>`
 * @param x function execute parameter.
 *
 * Determine the integer closest to double value and return the double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function round<double>(
 *       number: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   number - (double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_round_double(
    afw_function_execute_t *x);

/** @brief Function definition set_equals<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_double;

/**
 * @brief Adaptive Function `set_equals<double>`
 * @param x function execute parameter.
 *
 * Returns boolean true if double array1 and double array2 are subsets of each
 * other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<double>(
 *       array1: (array double),
 *       array2: (array double)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array double)
 *
 *   array2 - (array double)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_double;

/**
 * @brief Adaptive Function `subset<double>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in double array1 are all in double
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<double>(
 *       array1: (array double),
 *       array2: (array double)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array double) The first array.
 *
 *   array2 - (array double) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition subtract<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_double;

/**
 * @brief Adaptive Function `subtract<double>`
 * @param x function execute parameter.
 *
 * Subtract double arg2 from double arg1 and return the double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subtract<double>(
 *       arg1: double,
 *       arg2: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (double)
 *
 *   arg2 - (double)
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_subtract_double(
    afw_function_execute_t *x);

/** @brief Function definition to_integer<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_integer_double;

/**
 * @brief Adaptive Function `to_integer<double>`
 * @param x function execute parameter.
 *
 * Truncate double value to a whole number and returns integer result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_integer<double>(
 *       value: double
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (double)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_to_integer_double()
 *
 * __________
 */

/** @brief Function definition to_string<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_double;

/**
 * @brief Adaptive Function `to_string<double>`
 * @param x function execute parameter.
 *
 * Converts double value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<double>(
 *       value: double
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (double) A double value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<double> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_double;

/**
 * @brief Adaptive Function `union<double>`
 * @param x function execute parameter.
 *
 * Returns an array of double contains all of the unique values in two or more
 * array of double values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<double>(
 *       arrays_1: (array double),
 *       arrays_2: (array double),
 *       ...arrays_rest: (array of (array double))
 *   ): (array double);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array double) Two or more arrays.
 *
 * Returns:
 *
 *   (array double)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_function function functions
 *
 * function adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_function;

/**
 * @brief Adaptive Function `bag<function>`
 * @param x function execute parameter.
 *
 * Takes any number of function values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<function>(
 *       ...values: (array of (array function))
 *   ): (array function);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array function)
 *
 * Returns:
 *
 *   (array function)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_function;

/**
 * @brief Adaptive Function `bag_size<function>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<function>(
 *       value: (array function)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array function)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition eq<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_function;

/**
 * @brief Adaptive Function `eq<function>`
 * @param x function execute parameter.
 *
 * Determine if function arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<function>(
 *       arg1: function,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_function;

/**
 * @brief Adaptive Function `eqx<function>`
 * @param x function execute parameter.
 *
 * Determine if for function arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<function>(
 *       arg1: function,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition function */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_function;

/**
 * @brief Adaptive Function `function`
 * @param x function execute parameter.
 *
 * Converts value to data type function returning function result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function function(
 *       value: any
 *   ): function;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (function) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition ge<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_function;

/**
 * @brief Adaptive Function `ge<function>`
 * @param x function execute parameter.
 *
 * Checks for function arg1 is greater than or equal to function arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<function>(
 *       arg1: function,
 *       arg2: function
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (function)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_function;

/**
 * @brief Adaptive Function `gt<function>`
 * @param x function execute parameter.
 *
 * Checks for function arg1 is greater than function arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<function>(
 *       arg1: function,
 *       arg2: function
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (function)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_function;

/**
 * @brief Adaptive Function `is<function>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType function and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<function>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_function;

/**
 * @brief Adaptive Function `le<function>`
 * @param x function execute parameter.
 *
 * Checks for function arg1 is less than or equal to function arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<function>(
 *       arg1: function,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_function;

/**
 * @brief Adaptive Function `lt<function>`
 * @param x function execute parameter.
 *
 * Checks for function arg1 is less that function arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<function>(
 *       arg1: function,
 *       arg2: function
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (function)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_function;

/**
 * @brief Adaptive Function `ne<function>`
 * @param x function execute parameter.
 *
 * Determine if function arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<function>(
 *       arg1: function,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<function> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_function;

/**
 * @brief Adaptive Function `nex<function>`
 * @param x function execute parameter.
 *
 * Determine if for function arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<function>(
 *       arg1: function,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (function)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_hexBinary hexBinary functions
 *
 * hexBinary adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_hexBinary;

/**
 * @brief Adaptive Function `at_least_one_member_of<hexBinary>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in hexBinary array1 is in
 * hexBinary array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<hexBinary>(
 *       array1: (array hexBinary),
 *       array2: (array hexBinary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array hexBinary) The first array.
 *
 *   array2 - (array hexBinary) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_hexBinary;

/**
 * @brief Adaptive Function `bag<hexBinary>`
 * @param x function execute parameter.
 *
 * Takes any number of hexBinary values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<hexBinary>(
 *       ...values: (array of (array hexBinary))
 *   ): (array hexBinary);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array hexBinary)
 *
 * Returns:
 *
 *   (array hexBinary)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_hexBinary;

/**
 * @brief Adaptive Function `bag_size<hexBinary>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<hexBinary>(
 *       value: (array hexBinary)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array hexBinary)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition decode_to_string<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decode_to_string_hexBinary;

/**
 * @brief Adaptive Function `decode_to_string<hexBinary>`
 * @param x function execute parameter.
 *
 * Decode hexBinary value to string. An error is thrown if decoded value is not
 * valid UTF-8.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function decode_to_string<hexBinary>(
 *       value: hexBinary
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (hexBinary) The hexBinary value to decode.
 *
 * Returns:
 *
 *   (string) The decoded string.
 */
const afw_value_t *
afw_function_execute_decode_to_string_hexBinary(
    afw_function_execute_t *x);

/** @brief Function definition eq<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_hexBinary;

/**
 * @brief Adaptive Function `eq<hexBinary>`
 * @param x function execute parameter.
 *
 * Determine if hexBinary arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_hexBinary;

/**
 * @brief Adaptive Function `eqx<hexBinary>`
 * @param x function execute parameter.
 *
 * Determine if for hexBinary arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_hexBinary;

/**
 * @brief Adaptive Function `ge<hexBinary>`
 * @param x function execute parameter.
 *
 * Checks for hexBinary arg1 is greater than or equal to hexBinary arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: hexBinary
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (hexBinary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_hexBinary;

/**
 * @brief Adaptive Function `gt<hexBinary>`
 * @param x function execute parameter.
 *
 * Checks for hexBinary arg1 is greater than hexBinary arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: hexBinary
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (hexBinary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition hexBinary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_hexBinary;

/**
 * @brief Adaptive Function `hexBinary`
 * @param x function execute parameter.
 *
 * Converts value to data type hexBinary returning hexBinary result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function hexBinary(
 *       value: any
 *   ): hexBinary;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (hexBinary) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition intersection<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_hexBinary;

/**
 * @brief Adaptive Function `intersection<hexBinary>`
 * @param x function execute parameter.
 *
 * Returns an array of hexBinary with the values that are common to both array
 * of hexBinary array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<hexBinary>(
 *       array1: (array hexBinary),
 *       array2: (array hexBinary)
 *   ): (array hexBinary);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array hexBinary) The first array.
 *
 *   array2 - (array hexBinary) The second array.
 *
 * Returns:
 *
 *   (array hexBinary)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_hexBinary;

/**
 * @brief Adaptive Function `is<hexBinary>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType hexBinary and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<hexBinary>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_hexBinary;

/**
 * @brief Adaptive Function `is_in<hexBinary>`
 * @param x function execute parameter.
 *
 * Checks whether hexBinary value is in array of hexBinary array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<hexBinary>(
 *       value: hexBinary,
 *       array: (array hexBinary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (hexBinary)
 *
 *   array - (array hexBinary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition le<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_hexBinary;

/**
 * @brief Adaptive Function `le<hexBinary>`
 * @param x function execute parameter.
 *
 * Checks for hexBinary arg1 is less than or equal to hexBinary arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_hexBinary;

/**
 * @brief Adaptive Function `lt<hexBinary>`
 * @param x function execute parameter.
 *
 * Checks for hexBinary arg1 is less that hexBinary arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: hexBinary
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (hexBinary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_hexBinary;

/**
 * @brief Adaptive Function `ne<hexBinary>`
 * @param x function execute parameter.
 *
 * Determine if hexBinary arg1 is not equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_hexBinary;

/**
 * @brief Adaptive Function `nex<hexBinary>`
 * @param x function execute parameter.
 *
 * Determine if for hexBinary arg1 is not equal to the value or data type of
 * arg2 then return the boolean result. Use 'ne' ('!=') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<hexBinary>(
 *       arg1: hexBinary,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (hexBinary)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_hexBinary;

/**
 * @brief Adaptive Function `one_and_only<hexBinary>`
 * @param x function execute parameter.
 *
 * This converts an array of hexBinary values that contains one value to a
 * single hexBinary value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<hexBinary>(
 *       array: (array array)
 *   ): hexBinary;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (hexBinary)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_hexBinary;

/**
 * @brief Adaptive Function `set_equals<hexBinary>`
 * @param x function execute parameter.
 *
 * Returns boolean true if hexBinary array1 and hexBinary array2 are subsets of
 * each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<hexBinary>(
 *       array1: (array hexBinary),
 *       array2: (array hexBinary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array hexBinary)
 *
 *   array2 - (array hexBinary)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_hexBinary;

/**
 * @brief Adaptive Function `subset<hexBinary>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in hexBinary array1 are all in
 * hexBinary array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<hexBinary>(
 *       array1: (array hexBinary),
 *       array2: (array hexBinary)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array hexBinary) The first array.
 *
 *   array2 - (array hexBinary) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition to_string<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_hexBinary;

/**
 * @brief Adaptive Function `to_string<hexBinary>`
 * @param x function execute parameter.
 *
 * Converts hexBinary value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<hexBinary>(
 *       value: hexBinary
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (hexBinary) A hexBinary value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<hexBinary> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_hexBinary;

/**
 * @brief Adaptive Function `union<hexBinary>`
 * @param x function execute parameter.
 *
 * Returns an array of hexBinary contains all of the unique values in two or
 * more array of hexBinary values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<hexBinary>(
 *       arrays_1: (array hexBinary),
 *       arrays_2: (array hexBinary),
 *       ...arrays_rest: (array of (array hexBinary))
 *   ): (array hexBinary);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array hexBinary) Two or more arrays.
 *
 * Returns:
 *
 *   (array hexBinary)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_higher_order_array higher_order_array functions
 *
 * higher_order_array adaptive functions.
 *
 * @{
 */

/** @brief Function definition all_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_all_of;

/**
 * @brief Adaptive Function `all_of`
 * @param x function execute parameter.
 *
 * Returns true if all values in an array pass the predicate test.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function all_of(
 *       predicate: (function (... values: any): boolean),
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (... values: any): boolean) This function is called
 *       for each value in the first array in values or until false is returned.
 *       If no calls return false, the result is true.
 *
 *   values - (1 or more any dataType) These are the parameters passed to
 *       predicate with the exception that the first array is passed one value
 *       at a time. At least one array is required.
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_all_of(
    afw_function_execute_t *x);

/** @brief Function definition all_of_all */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_all_of_all;

/**
 * @brief Adaptive Function `all_of_all`
 * @param x function execute parameter.
 *
 * Returns true if the result of calling predicate with all of the combination
 * of values from array1 and array2 returns true.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function all_of_all(
 *       predicate: (function (any value1: any, value2: any): boolean),
 *       array1: array,
 *       array2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (any value1: any, value2: any): boolean) The
 *       predicate is passed two parameters, the first is a value from array1
 *       and the second is a value from array2.
 *
 *   array1 - (array)
 *
 *   array2 - (array)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_all_of_all(
    afw_function_execute_t *x);

/** @brief Function definition all_of_any */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_all_of_any;

/**
 * @brief Adaptive Function `all_of_any`
 * @param x function execute parameter.
 *
 * This function returns true if the result of calling predicate with all of the
 * combination of values from array1 and any of the values of array2 returns
 * true.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function all_of_any(
 *       predicate: (function (value1: any, value2: any): boolean),
 *       array1: array,
 *       array2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (value1: any, value2: any): boolean) The predicate is
 *       passed two parameters, the first is a value from array1 and the second
 *       is a value from array2.
 *
 *   array1 - (array)
 *
 *   array2 - (array)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_all_of_any(
    afw_function_execute_t *x);

/** @brief Function definition any_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_any_of;

/**
 * @brief Adaptive Function `any_of`
 * @param x function execute parameter.
 *
 * Returns true if any value in an array pass the predicate test.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function any_of(
 *       predicate: (function (... values: any): boolean),
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (... values: any): boolean) This function is called
 *       for each value in the first array in values or until true is returned.
 *       If no calls return true, the result is false.
 *
 *   values - (1 or more any dataType) These are the parameters passed to
 *       predicate with the exception that the first array is passed one value
 *       at a time. At least one array is required.
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_any_of(
    afw_function_execute_t *x);

/** @brief Function definition any_of_all */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_any_of_all;

/**
 * @brief Adaptive Function `any_of_all`
 * @param x function execute parameter.
 *
 * Returns true if the result of calling predicate with all of the combination
 * of values from array2 and any of the values of array1 returns true.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function any_of_all(
 *       predicate: (function (value1: any, value2: any):boolean),
 *       array1: array,
 *       array2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (value1: any, value2: any):boolean) The predicate is
 *       passed two parameters, the first is a value from array1 and the second
 *       is a value from array2.
 *
 *   array1 - (array)
 *
 *   array2 - (array)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_any_of_all(
    afw_function_execute_t *x);

/** @brief Function definition any_of_any */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_any_of_any;

/**
 * @brief Adaptive Function `any_of_any`
 * @param x function execute parameter.
 *
 * This function returns true if the result of calling predicate with any of the
 * combination of values from array1 and array2 returns true.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function any_of_any(
 *       predicate: (function (value1: any, value2: any): boolean),
 *       array1: array,
 *       array2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (value1: any, value2: any): boolean) The predicate is
 *       passed two parameters, the first is a value from array1 and the second
 *       is a value from array2.
 *
 *   array1 - (array)
 *
 *   array2 - (array)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_any_of_any(
    afw_function_execute_t *x);

/** @brief Function definition filter */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_filter;

/**
 * @brief Adaptive Function `filter`
 * @param x function execute parameter.
 *
 * This produces an array containing only values from another array that pass a
 * predicate test.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function filter(
 *       predicate: (function (... values: any): boolean),
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (... values: any): boolean) This is a boolean
 *       function that is called to determine if an array entry should be
 *       included in the returned array.
 *
 *   values - (1 or more any dataType) These are the values passed to the
 *       predicate with the exception that the first array is passed as the
 *       single current value from the array. At least one array is required.
 *
 * Returns:
 *
 *   (array) This is the resulting filtered array.
 */
const afw_value_t *
afw_function_execute_filter(
    afw_function_execute_t *x);

/** @brief Function definition find */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_find;

/**
 * @brief Adaptive Function `find`
 * @param x function execute parameter.
 *
 * The predicate is called for each value in the first array in values until
 * true is returned, then that value is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function find(
 *       predicate: (function (... values: any): boolean),
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   predicate - (function (... values: any): boolean) This is a boolean
 *       function that is called to determine if an array entry passes the test.
 *
 *   values - (1 or more any dataType) These are the values passed to the
 *       predicate with the exception that the first array is passed as the
 *       single current value from the array. At least one array is required.
 *
 * Returns:
 *
 *   (any dataType) The first value that passes the test is returned.
 */
const afw_value_t *
afw_function_execute_find(
    afw_function_execute_t *x);

/** @brief Function definition map */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_map;

/**
 * @brief Adaptive Function `map`
 * @param x function execute parameter.
 *
 * This function creates an array of the results of calling functor with each
 * value of the first array in values
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function map(
 *       functor: (function (... values: any): any),
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   functor - (function (... values: any): any)
 *
 *   values - (1 or more any dataType) These are the parameters passed to
 *       functor with the exception that the first array is passed one value at
 *       a time. At least one array is required.
 *
 * Returns:
 *
 *   (array)
 */
const afw_value_t *
afw_function_execute_map(
    afw_function_execute_t *x);

/** @brief Function definition reduce */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_reduce;

/**
 * @brief Adaptive Function `reduce`
 * @param x function execute parameter.
 *
 * Reduce calls functor for each value in array with two parameters, accumulator
 * and value, and must return a value of any dataType. Parameter accumulator is
 * the reduce() accumulator parameter value on first call and the return value
 * of previous functor() call on subsequent calls. The dataType of the return
 * value should normally be the same as accumulator, but this is not required.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function reduce(
 *       functor: (function (accumulator: any, value: any): any),
 *       accumulator: any,
 *       array: array
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   functor - (function (accumulator: any, value: any): any) This function is
 *       called for each value in an array. The returned value is passed as the
 *       accumulator parameter on the next call to functor().
 *
 *   accumulator - (any dataType) This is an initial accumulator value passed to
 *       functor(). Normally, the dataType of accumulator will be the dataTape
 *       for the reduce() return value, but this is not required.
 *
 *   array - (array) This is an array to be reduced.
 *
 * Returns:
 *
 *   (any dataType) This is the final return value from functor() or the
 *       accumulator parameter value if array is empty.
 */
const afw_value_t *
afw_function_execute_reduce(
    afw_function_execute_t *x);

/** @brief Function definition sort */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_sort;

/**
 * @brief Adaptive Function `sort`
 * @param x function execute parameter.
 *
 * This produces an array with values sorted based on result of compareFunction.
 * The compareFunction is passed two values from the array and must return an
 * integer less than 0 if the first value is less than the second value, 0 if
 * they are equal, and a integer greater than 0 if the first value is greater
 * than the second value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function sort(
 *       compareFunction: (function (value1: any, value2: any): integer),
 *       array: array
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   compareFunction - (function (value1: any, value2: any): integer) This
 *       function is called with two value from array.
 *
 *   array - (array) This is the array to sort.
 *
 * Returns:
 *
 *   (array) This the the resulting sorted array.
 */
const afw_value_t *
afw_function_execute_sort(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_ia5String ia5String functions
 *
 * ia5String adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_ia5String;

/**
 * @brief Adaptive Function `bag<ia5String>`
 * @param x function execute parameter.
 *
 * Takes any number of ia5String values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<ia5String>(
 *       ...values: (array of (array ia5String))
 *   ): (array ia5String);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array ia5String)
 *
 * Returns:
 *
 *   (array ia5String)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_ia5String;

/**
 * @brief Adaptive Function `bag_size<ia5String>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<ia5String>(
 *       value: (array ia5String)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array ia5String)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition eq<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ia5String;

/**
 * @brief Adaptive Function `eq<ia5String>`
 * @param x function execute parameter.
 *
 * Determine if ia5String arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<ia5String>(
 *       arg1: ia5String,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_ia5String;

/**
 * @brief Adaptive Function `eqx<ia5String>`
 * @param x function execute parameter.
 *
 * Determine if for ia5String arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<ia5String>(
 *       arg1: ia5String,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_ia5String;

/**
 * @brief Adaptive Function `ge<ia5String>`
 * @param x function execute parameter.
 *
 * Checks for ia5String arg1 is greater than or equal to ia5String arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<ia5String>(
 *       arg1: ia5String,
 *       arg2: ia5String
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (ia5String)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_ia5String;

/**
 * @brief Adaptive Function `gt<ia5String>`
 * @param x function execute parameter.
 *
 * Checks for ia5String arg1 is greater than ia5String arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<ia5String>(
 *       arg1: ia5String,
 *       arg2: ia5String
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (ia5String)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition ia5String */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ia5String;

/**
 * @brief Adaptive Function `ia5String`
 * @param x function execute parameter.
 *
 * Converts value to data type ia5String returning ia5String result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ia5String(
 *       value: any
 *   ): ia5String;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (ia5String) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition is<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_ia5String;

/**
 * @brief Adaptive Function `is<ia5String>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType ia5String and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<ia5String>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_ia5String;

/**
 * @brief Adaptive Function `le<ia5String>`
 * @param x function execute parameter.
 *
 * Checks for ia5String arg1 is less than or equal to ia5String arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<ia5String>(
 *       arg1: ia5String,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_ia5String;

/**
 * @brief Adaptive Function `lt<ia5String>`
 * @param x function execute parameter.
 *
 * Checks for ia5String arg1 is less that ia5String arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<ia5String>(
 *       arg1: ia5String,
 *       arg2: ia5String
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (ia5String)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_ia5String;

/**
 * @brief Adaptive Function `ne<ia5String>`
 * @param x function execute parameter.
 *
 * Determine if ia5String arg1 is not equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<ia5String>(
 *       arg1: ia5String,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_ia5String;

/**
 * @brief Adaptive Function `nex<ia5String>`
 * @param x function execute parameter.
 *
 * Determine if for ia5String arg1 is not equal to the value or data type of
 * arg2 then return the boolean result. Use 'ne' ('!=') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<ia5String>(
 *       arg1: ia5String,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ia5String)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition to_string<ia5String> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_ia5String;

/**
 * @brief Adaptive Function `to_string<ia5String>`
 * @param x function execute parameter.
 *
 * Converts ia5String value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<ia5String>(
 *       value: ia5String
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (ia5String) A ia5String value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_indexes indexes functions
 *
 * indexes adaptive functions.
 *
 * @{
 */

/** @brief Function definition index_create */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_create;

/**
 * @brief Adaptive Function `index_create`
 * @param x function execute parameter.
 *
 * Create an index definition.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function index_create(
 *       adaptorId: string,
 *       key: string,
 *       value?: string,
 *       objectType?: string,
 *       filter?: string,
 *       options?: string,
 *       retroactive?: boolean,
 *       test?: boolean
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   key - (string) Name of the property index to be created.
 *
 *   value - (optional string) Expression to calculate the index value(s).
 *
 *   objectType - (optional string) Object Type(s) this index may apply to.
 *
 *   filter - (optional string) Expression to determine if this index applies to
 *       a particular object.
 *
 *   options - (optional string) Indexing options.
 *
 *   retroactive - (optional boolean) Retroactively generate indexes for
 *       existing objects.
 *
 *   test - (optional boolean) Test create (don't actually perform).
 *
 * Returns:
 *
 *   (object) Object response from the indexing process.
 */
const afw_value_t *
afw_function_execute_index_create(
    afw_function_execute_t *x);

/** @brief Function definition index_list */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_list;

/**
 * @brief Adaptive Function `index_list`
 * @param x function execute parameter.
 *
 * List property indexes
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function index_list(
 *       adaptorId: string,
 *       objectType?: string
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   objectType - (optional string) Id of adaptive object type indexes.
 *
 * Returns:
 *
 *   (object) Object response from the index repair process.
 */
const afw_value_t *
afw_function_execute_index_list(
    afw_function_execute_t *x);

/** @brief Function definition index_remove */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_remove;

/**
 * @brief Adaptive Function `index_remove`
 * @param x function execute parameter.
 *
 * Remove an index definition.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function index_remove(
 *       adaptorId: string,
 *       key: string
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   key - (string) The index key to be removed.
 *
 * Returns:
 *
 *   (object) Object response from the indexing process.
 */
const afw_value_t *
afw_function_execute_index_remove(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_integer integer functions
 *
 * integer adaptive functions.
 *
 * @{
 */

/** @brief Function definition abs<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_abs_integer;

/**
 * @brief Adaptive Function `abs<integer>`
 * @param x function execute parameter.
 *
 * Compute the absolute value of the integer value and return the integer
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function abs<integer>(
 *       value: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (integer)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_abs_integer(
    afw_function_execute_t *x);

/** @brief Function definition add<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_integer;

/**
 * @brief Adaptive Function `add<integer>`
 * @param x function execute parameter.
 *
 * Add 2 or more integer values and return the integer result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function add<integer>(
 *       values_1: integer,
 *       values_2: integer,
 *       ...values_rest: (array of integer)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   values - (2 or more integer)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_add_integer(
    afw_function_execute_t *x);

/** @brief Function definition at_least_one_member_of<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_integer;

/**
 * @brief Adaptive Function `at_least_one_member_of<integer>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in integer array1 is in integer
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<integer>(
 *       array1: (array integer),
 *       array2: (array integer)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array integer) The first array.
 *
 *   array2 - (array integer) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_integer;

/**
 * @brief Adaptive Function `bag<integer>`
 * @param x function execute parameter.
 *
 * Takes any number of integer values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<integer>(
 *       ...values: (array of (array integer))
 *   ): (array integer);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array integer)
 *
 * Returns:
 *
 *   (array integer)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_integer;

/**
 * @brief Adaptive Function `bag_size<integer>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<integer>(
 *       value: (array integer)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array integer)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition divide<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_divide_integer;

/**
 * @brief Adaptive Function `divide<integer>`
 * @param x function execute parameter.
 *
 * Divide integer dividend by integer divisor and return the integer quotient.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function divide<integer>(
 *       dividend: integer,
 *       divisor: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   dividend - (integer)
 *
 *   divisor - (integer)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_divide_integer(
    afw_function_execute_t *x);

/** @brief Function definition eq<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_integer;

/**
 * @brief Adaptive Function `eq<integer>`
 * @param x function execute parameter.
 *
 * Determine if integer arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<integer>(
 *       arg1: integer,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_integer;

/**
 * @brief Adaptive Function `eqx<integer>`
 * @param x function execute parameter.
 *
 * Determine if for integer arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<integer>(
 *       arg1: integer,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_integer;

/**
 * @brief Adaptive Function `ge<integer>`
 * @param x function execute parameter.
 *
 * Checks for integer arg1 is greater than or equal to integer arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<integer>(
 *       arg1: integer,
 *       arg2: integer
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (integer)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_integer;

/**
 * @brief Adaptive Function `gt<integer>`
 * @param x function execute parameter.
 *
 * Checks for integer arg1 is greater than integer arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<integer>(
 *       arg1: integer,
 *       arg2: integer
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (integer)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition integer */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_integer;

/**
 * @brief Adaptive Function `integer`
 * @param x function execute parameter.
 *
 * Converts value to data type integer returning integer result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function integer(
 *       value: any
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (integer) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition intersection<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_integer;

/**
 * @brief Adaptive Function `intersection<integer>`
 * @param x function execute parameter.
 *
 * Returns an array of integer with the values that are common to both array of
 * integer array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<integer>(
 *       array1: (array integer),
 *       array2: (array integer)
 *   ): (array integer);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array integer) The first array.
 *
 *   array2 - (array integer) The second array.
 *
 * Returns:
 *
 *   (array integer)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is_in<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_integer;

/**
 * @brief Adaptive Function `is_in<integer>`
 * @param x function execute parameter.
 *
 * Checks whether integer value is in array of integer array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<integer>(
 *       value: integer,
 *       array: (array integer)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (integer)
 *
 *   array - (array integer)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition is<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_integer;

/**
 * @brief Adaptive Function `is<integer>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType integer and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<integer>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_integer;

/**
 * @brief Adaptive Function `le<integer>`
 * @param x function execute parameter.
 *
 * Checks for integer arg1 is less than or equal to integer arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<integer>(
 *       arg1: integer,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_integer;

/**
 * @brief Adaptive Function `lt<integer>`
 * @param x function execute parameter.
 *
 * Checks for integer arg1 is less that integer arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<integer>(
 *       arg1: integer,
 *       arg2: integer
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (integer)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition max<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_integer;

/**
 * @brief Adaptive Function `max<integer>`
 * @param x function execute parameter.
 *
 * Return the integer value that is greater than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function max<integer>(
 *       values_1: integer,
 *       ...values_rest: (array of integer)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more integer)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_max()
 *
 * __________
 */

/** @brief Function definition min<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_integer;

/**
 * @brief Adaptive Function `min<integer>`
 * @param x function execute parameter.
 *
 * Return the integer value that is less than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function min<integer>(
 *       values_1: integer,
 *       ...values_rest: (array of integer)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more integer)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_min()
 *
 * __________
 */

/** @brief Function definition mod<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_mod_integer;

/**
 * @brief Adaptive Function `mod<integer>`
 * @param x function execute parameter.
 *
 * Divide integer dividend by integer divisor and return the integer remainder.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function mod<integer>(
 *       dividend: integer,
 *       divisor: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   dividend - (integer)
 *
 *   divisor - (integer)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_mod_integer(
    afw_function_execute_t *x);

/** @brief Function definition multiply<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_multiply_integer;

/**
 * @brief Adaptive Function `multiply<integer>`
 * @param x function execute parameter.
 *
 * Multiply 2 or more integer values and return the integer result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function multiply<integer>(
 *       values_1: integer,
 *       values_2: integer,
 *       ...values_rest: (array of integer)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   values - (2 or more integer)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_multiply_integer(
    afw_function_execute_t *x);

/** @brief Function definition ne<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_integer;

/**
 * @brief Adaptive Function `ne<integer>`
 * @param x function execute parameter.
 *
 * Determine if integer arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<integer>(
 *       arg1: integer,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition negative<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_negative_integer;

/**
 * @brief Adaptive Function `negative<integer>`
 * @param x function execute parameter.
 *
 * Return negative of integer value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function negative<integer>(
 *       value: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (integer)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_negative_integer(
    afw_function_execute_t *x);

/** @brief Function definition nex<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_integer;

/**
 * @brief Adaptive Function `nex<integer>`
 * @param x function execute parameter.
 *
 * Determine if for integer arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<integer>(
 *       arg1: integer,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_integer;

/**
 * @brief Adaptive Function `one_and_only<integer>`
 * @param x function execute parameter.
 *
 * This converts an array of integer values that contains one value to a single
 * integer value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<integer>(
 *       array: (array array)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (integer)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_integer;

/**
 * @brief Adaptive Function `set_equals<integer>`
 * @param x function execute parameter.
 *
 * Returns boolean true if integer array1 and integer array2 are subsets of each
 * other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<integer>(
 *       array1: (array integer),
 *       array2: (array integer)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array integer)
 *
 *   array2 - (array integer)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_integer;

/**
 * @brief Adaptive Function `subset<integer>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in integer array1 are all in
 * integer array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<integer>(
 *       array1: (array integer),
 *       array2: (array integer)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array integer) The first array.
 *
 *   array2 - (array integer) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition subtract<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_integer;

/**
 * @brief Adaptive Function `subtract<integer>`
 * @param x function execute parameter.
 *
 * Subtract integer arg2 from integer arg1 and return the integer result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subtract<integer>(
 *       arg1: integer,
 *       arg2: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (integer)
 *
 *   arg2 - (integer)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_subtract_integer(
    afw_function_execute_t *x);

/** @brief Function definition to_double<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_double_integer;

/**
 * @brief Adaptive Function `to_double<integer>`
 * @param x function execute parameter.
 *
 * Converts integer value to double and returns double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_double<integer>(
 *       value: integer
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   value - (integer)
 *
 * Returns:
 *
 *   (double)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_to_double_integer()
 *
 * __________
 */

/** @brief Function definition to_string<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_integer;

/**
 * @brief Adaptive Function `to_string<integer>`
 * @param x function execute parameter.
 *
 * Converts integer value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<integer>(
 *       value: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (integer) A integer value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<integer> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_integer;

/**
 * @brief Adaptive Function `union<integer>`
 * @param x function execute parameter.
 *
 * Returns an array of integer contains all of the unique values in two or more
 * array of integer values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<integer>(
 *       arrays_1: (array integer),
 *       arrays_2: (array integer),
 *       ...arrays_rest: (array of (array integer))
 *   ): (array integer);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array integer) Two or more arrays.
 *
 * Returns:
 *
 *   (array integer)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_ipAddress ipAddress functions
 *
 * ipAddress adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_ipAddress;

/**
 * @brief Adaptive Function `bag<ipAddress>`
 * @param x function execute parameter.
 *
 * Takes any number of ipAddress values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<ipAddress>(
 *       ...values: (array of (array ipAddress))
 *   ): (array ipAddress);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array ipAddress)
 *
 * Returns:
 *
 *   (array ipAddress)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_ipAddress;

/**
 * @brief Adaptive Function `bag_size<ipAddress>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<ipAddress>(
 *       value: (array ipAddress)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array ipAddress)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition eq<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ipAddress;

/**
 * @brief Adaptive Function `eq<ipAddress>`
 * @param x function execute parameter.
 *
 * Determine if ipAddress arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_ipAddress;

/**
 * @brief Adaptive Function `eqx<ipAddress>`
 * @param x function execute parameter.
 *
 * Determine if for ipAddress arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_ipAddress;

/**
 * @brief Adaptive Function `ge<ipAddress>`
 * @param x function execute parameter.
 *
 * Checks for ipAddress arg1 is greater than or equal to ipAddress arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: ipAddress
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (ipAddress)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_ipAddress;

/**
 * @brief Adaptive Function `gt<ipAddress>`
 * @param x function execute parameter.
 *
 * Checks for ipAddress arg1 is greater than ipAddress arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: ipAddress
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (ipAddress)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition ipAddress */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ipAddress;

/**
 * @brief Adaptive Function `ipAddress`
 * @param x function execute parameter.
 *
 * Converts value to data type ipAddress returning ipAddress result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ipAddress(
 *       value: any
 *   ): ipAddress;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (ipAddress) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition is_in<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_ipAddress;

/**
 * @brief Adaptive Function `is_in<ipAddress>`
 * @param x function execute parameter.
 *
 * Checks whether ipAddress value is in array of ipAddress array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<ipAddress>(
 *       value: ipAddress,
 *       array: (array ipAddress)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (ipAddress)
 *
 *   array - (array ipAddress)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition is<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_ipAddress;

/**
 * @brief Adaptive Function `is<ipAddress>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType ipAddress and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<ipAddress>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_ipAddress;

/**
 * @brief Adaptive Function `le<ipAddress>`
 * @param x function execute parameter.
 *
 * Checks for ipAddress arg1 is less than or equal to ipAddress arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_ipAddress;

/**
 * @brief Adaptive Function `lt<ipAddress>`
 * @param x function execute parameter.
 *
 * Checks for ipAddress arg1 is less that ipAddress arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: ipAddress
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (ipAddress)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_ipAddress;

/**
 * @brief Adaptive Function `ne<ipAddress>`
 * @param x function execute parameter.
 *
 * Determine if ipAddress arg1 is not equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_ipAddress;

/**
 * @brief Adaptive Function `nex<ipAddress>`
 * @param x function execute parameter.
 *
 * Determine if for ipAddress arg1 is not equal to the value or data type of
 * arg2 then return the boolean result. Use 'ne' ('!=') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<ipAddress>(
 *       arg1: ipAddress,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (ipAddress)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_ipAddress;

/**
 * @brief Adaptive Function `one_and_only<ipAddress>`
 * @param x function execute parameter.
 *
 * This converts an array of ipAddress values that contains one value to a
 * single ipAddress value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<ipAddress>(
 *       array: (array array)
 *   ): ipAddress;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (ipAddress)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition regexp_match<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_ipAddress;

/**
 * @brief Adaptive Function `regexp_match<ipAddress>`
 * @param x function execute parameter.
 *
 * Checks whether ipAddress value matches the regular expression regexp and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_match<ipAddress>(
 *       value: ipAddress,
 *       regexp: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (ipAddress)
 *
 *   regexp - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_regexp_match()
 *
 * __________
 */

/** @brief Function definition to_string<ipAddress> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_ipAddress;

/**
 * @brief Adaptive Function `to_string<ipAddress>`
 * @param x function execute parameter.
 *
 * Converts ipAddress value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<ipAddress>(
 *       value: ipAddress
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (ipAddress) A ipAddress value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_journal journal functions
 *
 * journal adaptive functions.
 *
 * @{
 */

/** @brief Function definition journal_advance_cursor_for_consumer */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_advance_cursor_for_consumer;

/**
 * @brief Adaptive Function `journal_advance_cursor_for_consumer`
 * @param x function execute parameter.
 *
 * Update the advance cursor for a consumer referenced by the consumerId
 * parameter. The limit parameter specifies the maximum number of entries to
 * scan for an applicable entry for consumer before returning. NULL is always
 * returned.
 * 
 * There are no response properties set by this function.
 * 
 * The properties of the _AdaptiveProvisioningPeer_ object associated with the
 * consumer_id are used in the following way:
 * 
 * The consumerFilter expression is used to determine if an entry is applicable.
 * 
 * Journal entries are scanned beginning at the entry at the cursor in the
 * advanceCursor property. If the advanceCursor property is not present, the
 * scan begins after the cursor in currentCursor. If neither are present, the
 * scan begins at the start of the journal.
 * 
 * If an new applicable entry is found or if the limit is met, the advanceCursor
 * property is set to the currently scanned entry's cursor.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function journal_advance_cursor_for_consumer(
 *       adaptorId: string,
 *       consumerId: string,
 *       limit?: integer
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   consumerId - (string) The consumerId property value of the associated
 *       _AdaptiveProvisioningPeer_ object.
 *
 *   limit - (optional integer) The maximum number of entries that will be
 *       scanned for an entry where the consumerFilter expression in the
 *       associated _AdaptiveProvisioningPeer_ object evaluates to true.
 *
 * Returns:
 *
 *   (object) Response object.
 */
const afw_value_t *
afw_function_execute_journal_advance_cursor_for_consumer(
    afw_function_execute_t *x);

/** @brief Function definition journal_get_by_cursor */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_by_cursor;

/**
 * @brief Adaptive Function `journal_get_by_cursor`
 * @param x function execute parameter.
 *
 * Get journal entry specified by entry_cursor parameter.
 * 
 * This option will set response properties 'entry' and 'cursor' if there is an
 * entry to retrieve. If an entry with the supplied cursor does not exist, a
 * not_found error is thrown.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function journal_get_by_cursor(
 *       adaptorId: string,
 *       cursor: string
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   cursor - (string) Journal entry cursor.
 *
 * Returns:
 *
 *   (object) Response object.
 */
const afw_value_t *
afw_function_execute_journal_get_by_cursor(
    afw_function_execute_t *x);

/** @brief Function definition journal_get_first */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_first;

/**
 * @brief Adaptive Function `journal_get_first`
 * @param x function execute parameter.
 *
 * Get first journal entry.
 * 
 * This option will set response properties 'entry' and 'cursor' if there is a
 * first entry to return.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function journal_get_first(
 *       adaptorId: string
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 * Returns:
 *
 *   (object) Response object.
 */
const afw_value_t *
afw_function_execute_journal_get_first(
    afw_function_execute_t *x);

/** @brief Function definition journal_get_next_after_cursor */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_next_after_cursor;

/**
 * @brief Adaptive Function `journal_get_next_after_cursor`
 * @param x function execute parameter.
 *
 * Get the next journal entry after the one specified by the entry_cursor
 * parameter.
 * 
 * This option will set response properties 'entry' and 'cursor' if there is a
 * next entry to retrieve.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function journal_get_next_after_cursor(
 *       adaptorId: string,
 *       cursor: string
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   cursor - (string) Journal entry cursor.
 *
 * Returns:
 *
 *   (object) Response object.
 */
const afw_value_t *
afw_function_execute_journal_get_next_after_cursor(
    afw_function_execute_t *x);

/** @brief Function definition journal_get_next_for_consumer */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_next_for_consumer;

/**
 * @brief Adaptive Function `journal_get_next_for_consumer`
 * @param x function execute parameter.
 *
 * Get the next journal entry for a consumer referenced by the consumer_id
 * parameter. The entry_cursor parameter is ignored. The limit parameter
 * specifies the maximum number of entries to scan for an applicable entry for
 * consumer before returning.
 * 
 *  This option will set response properties 'entry' and 'entryCursor' if an
 * applicable entry is retrieved. Property 'reissue' will be set as described
 * below.
 * 
 * The properties of the _AdaptiveProvisioningPeer_ object associated with the
 * consumer_id are used in the following way:
 * 
 * The consumerFilter expression is used to determine if an entry is applicable.
 * 
 * If consumeCursor property exists, return that entry at that cursor again
 * immediately with a 'reissue' property added and set to true.
 * 
 * Journal entries are scanned beginning at the entry at the cursor in the
 * advanceCursor property. If the advanceCursor property is not present, the
 * scan begins after the cursor in currentCursor. If neither are present, the
 * scan begins at the start of the journal.
 * 
 * If an applicable entry is found, properties consumeStart and consumeCursor
 * are set, advanceCursor is removed, and the entry is returned. Method
 * mark_entry_consumed() will remove these properties.
 * 
 * If no applicable entry is found, advanceCursor is set to the last entry
 * scanned.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function journal_get_next_for_consumer(
 *       adaptorId: string,
 *       consumerId: string,
 *       limit?: integer
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   consumerId - (string) The consumerId property value of the associated
 *       _AdaptiveProvisioningPeer_ object.
 *
 *   limit - (optional integer) The maximum number of entries that will be
 *       scanned for an entry where the consumerFilter expression in the
 *       associated _AdaptiveProvisioningPeer_ object evaluates to true.
 *
 * Returns:
 *
 *   (object) Response object.
 */
const afw_value_t *
afw_function_execute_journal_get_next_for_consumer(
    afw_function_execute_t *x);

/** @brief Function definition journal_get_next_for_consumer_after_cursor */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_get_next_for_consumer_after_cursor;

/**
 * @brief Adaptive Function `journal_get_next_for_consumer_after_cursor`
 * @param x function execute parameter.
 *
 * Get the next journal entry for a consumer referenced by the consumer_id after
 * the one specified by the entry_cursor parameter. The limit parameter
 * specifies the maximum number of entries to scan for an applicable entry for
 * consumer before returning.
 * 
 * This option will set response properties 'entry' and 'cursor' if an
 * applicable entry is retrieved.
 * 
 * The properties of the _AdaptiveProvisioningPeer_ object associated with the
 * consumer_id are used in the following way:
 * 
 * The consumerFilter expression is used to determine if an entry is applicable.
 * 
 * Unlike option get_next_for_consumer, no other properties are referenced or
 * modified.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function journal_get_next_for_consumer_after_cursor(
 *       adaptorId: string,
 *       consumerId: string,
 *       cursor: string,
 *       limit?: integer
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   consumerId - (string) The consumerId property value of the associated
 *       _AdaptiveProvisioningPeer_ object.
 *
 *   cursor - (string) Journal entry cursor.
 *
 *   limit - (optional integer) The maximum number of entries that will be
 *       scanned for an entry where the consumerFilter expression in the
 *       associated _AdaptiveProvisioningPeer_ object evaluates to true.
 *
 * Returns:
 *
 *   (object) Response object.
 */
const afw_value_t *
afw_function_execute_journal_get_next_for_consumer_after_cursor(
    afw_function_execute_t *x);

/** @brief Function definition journal_mark_consumed */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_journal_mark_consumed;

/**
 * @brief Adaptive Function `journal_mark_consumed`
 * @param x function execute parameter.
 *
 * Mark a journal entry returned by get_next_for_consumer() as consumed.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function journal_mark_consumed(
 *       adaptorId: string,
 *       consumerId: string,
 *       cursor: string
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) Id of adaptor.
 *
 *   consumerId - (string) The consumerId property value of the associated
 *       _AdaptiveProvisioningPeer_ object.
 *
 *   cursor - (string) Journal entry cursor.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_journal_mark_consumed(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_json json functions
 *
 * json adaptive functions.
 *
 * @{
 */

/** @brief Function definition compile<json> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_json;

/**
 * @brief Adaptive Function `compile<json>`
 * @param x function execute parameter.
 *
 * Compile json value and return either an unevaluated adaptive value or a
 * string containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compile<json>(
 *       source: json,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (json) json string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_compile_json(
    afw_function_execute_t *x);

/** @brief Function definition json */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_json;

/**
 * @brief Adaptive Function `json`
 * @param x function execute parameter.
 *
 * Converts value to data type json returning json result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function json(
 *       value: any
 *   ): json;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (json) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_logical logical functions
 *
 * logical adaptive functions.
 *
 * @{
 */

/** @brief Function definition and */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_and;

/**
 * @brief Adaptive Function `and`
 * @param x function execute parameter.
 *
 * Evaluates 0 or more boolean conditions returning boolean true if there are no
 * conditions and boolean false if any condition evaluate to false. All
 * conditions after the first false remain unevaluated.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function and(
 *       ...conditions: (array of boolean)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   conditions - (0 or more boolean)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_and(
    afw_function_execute_t *x);

/** @brief Function definition n_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_n_of;

/**
 * @brief Adaptive Function `n_of`
 * @param x function execute parameter.
 *
 * integer n specifies the number of boolean conditions that follow that must
 * evaluate to true for boolean true to be returned. If n is 0, true is
 * returned. Once n conditions evaluate to true, true is returned and the
 * remaining conditions remain unevaluated.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function n_of(
 *       n: integer,
 *       ...conditions: (array of boolean)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   n - (integer)
 *
 *   conditions - (0 or more boolean)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   arg_error - there are less than n conditions
 */
const afw_value_t *
afw_function_execute_n_of(
    afw_function_execute_t *x);

/** @brief Function definition not */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_not;

/**
 * @brief Adaptive Function `not`
 * @param x function execute parameter.
 *
 * Evaluates boolean condition returning boolean true if condition evaluates to
 * false and false if condition evaluates to true.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function not(
 *       condition: boolean
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   condition - (boolean)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_not(
    afw_function_execute_t *x);

/** @brief Function definition or */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_or;

/**
 * @brief Adaptive Function `or`
 * @param x function execute parameter.
 *
 * Evaluates 0 or more boolean conditions returning boolean false if there are
 * no conditions and boolean true if any condition evaluate to true. All
 * conditions after the first true remain unevaluated.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function or(
 *       ...conditions: (array of boolean)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   conditions - (0 or more boolean)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_or(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_miscellaneous miscellaneous functions
 *
 * miscellaneous adaptive functions.
 *
 * @{
 */

/** @brief Function definition compare_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compare_uri;

/**
 * @brief Adaptive Function `compare_uri`
 * @param x function execute parameter.
 *
 * Compare two URIs.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compare_uri(
 *       uri1: string,
 *       uri2: string,
 *       isValuePath?: boolean,
 *       currentPath?: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   uri1 - (string) First URI for compare. This URI can not contain an asterisk
 *       ('*').
 *
 *   uri2 - (string) Second URI for compare. This URI can contain asterisk ('*')
 *       for substitution if isValuePath is true and currentPath2 is specified.
 *
 *   isValuePath - (optional boolean) The URIs are adaptive value paths. If one
 *       of the URIs begins with a single slash '/', both must, and each URI
 *       will be parsed as an adaptive value path (example:
 *       /adaptorId/objectType/objectId.propertyNames).
 *
 *   currentPath - (optional string) If isValuePath is true, this is the current
 *       path that is used to resolve a relative path in the URIs. If
 *       isValuePath is not true, this parameter is ignored.
 *
 * Returns:
 *
 *   (boolean) Result of comparison.
 */
const afw_value_t *
afw_function_execute_compare_uri(
    afw_function_execute_t *x);

/** @brief Function definition debug */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_debug;

/**
 * @brief Adaptive Function `debug`
 * @param x function execute parameter.
 *
 * Conditionally, based on the detail parameter, write a value as a string to
 * the debug file descriptor (usually stderr).
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function debug(
 *       value: any,
 *       detail?: boolean
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) This is the value that will be converted to its
 *       string representation and written. An undefined value is represented by
 *       'undefined'.
 *
 *   detail - (optional boolean) If true, the string will only written if the
 *       debug:function_active:detail flag is on. If false or not specified, the
 *       string will only written if the debug:function_active flag is on.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_debug(
    afw_function_execute_t *x);

/** @brief Function definition execution_start_time_local */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_execution_start_time_local;

/**
 * @brief Adaptive Function `execution_start_time_local`
 * @param x function execute parameter.
 *
 * Return local dateTime when the execution context was created. This will
 * usually be the start of request time.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function execution_start_time_local(
 *   
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_execution_start_time_local(
    afw_function_execute_t *x);

/** @brief Function definition execution_start_time_utc */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_execution_start_time_utc;

/**
 * @brief Adaptive Function `execution_start_time_utc`
 * @param x function execute parameter.
 *
 * Return UTC dateTime when the execution context was created. This will usually
 * be the start of request time.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function execution_start_time_utc(
 *   
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_execution_start_time_utc(
    afw_function_execute_t *x);

/** @brief Function definition generate_uuid */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_generate_uuid;

/**
 * @brief Adaptive Function `generate_uuid`
 * @param x function execute parameter.
 *
 * Generate a UUID.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function generate_uuid(
 *   
 *   ): string;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (string)
 */
const afw_value_t *
afw_function_execute_generate_uuid(
    afw_function_execute_t *x);

/** @brief Function definition is_defined */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_defined;

/**
 * @brief Adaptive Function `is_defined`
 * @param x function execute parameter.
 *
 * Test value returning boolean True if it is not undefined.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_defined(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean) True if value is not undefined.
 */
const afw_value_t *
afw_function_execute_is_defined(
    afw_function_execute_t *x);

/** @brief Function definition is_nullish */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_nullish;

/**
 * @brief Adaptive Function `is_nullish`
 * @param x function execute parameter.
 *
 * Test value returning boolean True if it is null or undefined.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_nullish(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean) True if value is null or undefined.
 */
const afw_value_t *
afw_function_execute_is_nullish(
    afw_function_execute_t *x);

/** @brief Function definition log */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_log;

/**
 * @brief Adaptive Function `log`
 * @param x function execute parameter.
 *
 * Evaluate and convert value to String and log it.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function log(
 *       value: any
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to log.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_log(
    afw_function_execute_t *x);

/** @brief Function definition now_local */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_now_local;

/**
 * @brief Adaptive Function `now_local`
 * @param x function execute parameter.
 *
 * Return current local dateTime.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function now_local(
 *   
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_now_local(
    afw_function_execute_t *x);

/** @brief Function definition now_utc */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_now_utc;

/**
 * @brief Adaptive Function `now_utc`
 * @param x function execute parameter.
 *
 * Return current UTC dateTime.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function now_utc(
 *   
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (dateTime)
 */
const afw_value_t *
afw_function_execute_now_utc(
    afw_function_execute_t *x);

/** @brief Function definition parse_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_parse_uri;

/**
 * @brief Adaptive Function `parse_uri`
 * @param x function execute parameter.
 *
 * Parse a URI.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function parse_uri(
 *       uri: string,
 *       isValuePath?: boolean,
 *       currentPath?: string
 *   ): (object _AdaptiveParsedURI_);
 * ```
 *
 * Parameters:
 *
 *   uri - (string) URI to parse.
 *
 *   isValuePath - (optional boolean) The URI is an adaptive value path. If the
 *       path begins with a single slash '/', the URI will be parsed as an
 *       adaptive value path (example:
 *       /adaptorId/objectType/objectId.propertyNames).
 *
 *   currentPath - (optional string) If isValuePath is true, this is the current
 *       path that is used to resolve relative paths. If isValuePath is not
 *       true, this parameter is ignored.
 *
 * Returns:
 *
 *   (object _AdaptiveParsedURI_) Object with results of parse.
 */
const afw_value_t *
afw_function_execute_parse_uri(
    afw_function_execute_t *x);

/** @brief Function definition perform */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_perform;

/**
 * @brief Adaptive Function `perform`
 * @param x function execute parameter.
 *
 * Perform actions right away.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function perform(
 *       request: (object _AdaptiveActions_)
 *   ): (object _AdaptiveResponse_);
 * ```
 *
 * Parameters:
 *
 *   request - (object _AdaptiveActions_) See
 *       /afw/_AdaptiveObjectType_/_AdaptiveActions_ for more information.
 *
 * Returns:
 *
 *   (object _AdaptiveResponse_) Response object.
 */
const afw_value_t *
afw_function_execute_perform(
    afw_function_execute_t *x);

/** @brief Function definition trace */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_trace;

/**
 * @brief Adaptive Function `trace`
 * @param x function execute parameter.
 *
 * Write a value to a trace log.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function trace(
 *       value: any,
 *       filter?: boolean,
 *       number?: integer
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) This is the value that will be converted to its
 *       string representation and written the trace log. An undefined value is
 *       represented by 'undefined'.
 *
 *   filter - (optional boolean) If this optional filter is false, nothing will
 *       be written to the trace log. The default is true.
 *
 *   number - (optional integer) This is an optional number between 1 and 8 that
 *       is appended to 'trace' to identify the trace log. The default is 1.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_trace(
    afw_function_execute_t *x);

/** @brief Function definition variable_exists */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_variable_exists;

/**
 * @brief Adaptive Function `variable_exists`
 * @param x function execute parameter.
 *
 * Return the true if the named variable exists.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function variable_exists(
 *       name: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   name - (string) Name of variable to check. The name can optionally be
 *       preceded with a qualifier followed by '::'.
 *
 * Returns:
 *
 *   (boolean) True if variable exists.
 */
const afw_value_t *
afw_function_execute_variable_exists(
    afw_function_execute_t *x);

/** @brief Function definition variable_get */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_variable_get;

/**
 * @brief Adaptive Function `variable_get`
 * @param x function execute parameter.
 *
 * Return the value of a variable. If variable is not available, return a
 * default or null value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function variable_get(
 *       name: string,
 *       defaultValue?: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   name - (string) Name of variable to get. The name can optionally be
 *       preceded with a qualifier followed by '::'.
 *
 *   defaultValue - (optional any dataType) The default value of variable if it
 *       does not exist in object. If not specified, null value is the default.
 *
 * Returns:
 *
 *   (any dataType) Evaluated variable value or default.
 */
const afw_value_t *
afw_function_execute_variable_get(
    afw_function_execute_t *x);

/** @brief Function definition variable_is_not_null */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_variable_is_not_null;

/**
 * @brief Adaptive Function `variable_is_not_null`
 * @param x function execute parameter.
 *
 * Return the true if the named variable exists and is not null.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function variable_is_not_null(
 *       name: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   name - (string) Name of variable to check. The name can optionally be
 *       preceded with a qualifier followed by '::'.
 *
 * Returns:
 *
 *   (boolean) True if variable exists and is not null.
 */
const afw_value_t *
afw_function_execute_variable_is_not_null(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_model model functions
 *
 * model adaptive functions.
 *
 * @{
 */

/** @brief Function definition model_default_add_object_action */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_add_object_action;

/**
 * @brief Adaptive Function `model_default_add_object_action`
 * @param x function execute parameter.
 *
 * This function returns a _AdaptiveAction_ object for the default action
 * performed if a onAdd parameter is not specified on the associated
 * _AdaptiveModelObjectType_. The action is not performed, but be aware that
 * functions called while producing the _AdaptiveAction_ object may cause side
 * effects. This function can be called as part of a onAdd expression or for
 * testing.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function model_default_add_object_action(
 *       adaptorId: string,
 *       objectType: string,
 *       object: object,
 *       objectId?: string,
 *       modelId?: string,
 *       context?: (object _AdaptiveContextType_)
 *   ): (object _AdaptiveAction_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) This is the adaptorId of a model adaptor. Variable
 *       custom::adaptorId can be used to access this value in model
 *       expressions.
 *
 *   objectType - (string) This is the adaptive object type of object being
 *       added. Variable custom::objectType can be used to access this value in
 *       model expressions.
 *
 *   object - (object) This is the object to add. Variable custom::object can be
 *       used to access this value in model expressions.
 *
 *   objectId - (optional string) This is the optional preferred objectId of
 *       object to add. The adaptor may ignore this. Variable custom::objectId
 *       can be used to access this value in model expressions.
 *
 *   modelId - (optional string) This specifics a modelId of model to use for
 *       producing results. If not specified, the adaptor's current model will
 *       be used.
 *
 *   context - (optional object _AdaptiveContextType_) This specifies additional
 *       context information available to model expressions.
 *
 * Returns:
 *
 *   (object _AdaptiveAction_) The default action object.
 */
const afw_value_t *
afw_function_execute_model_default_add_object_action(
    afw_function_execute_t *x);

/** @brief Function definition model_default_delete_object_action */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_delete_object_action;

/**
 * @brief Adaptive Function `model_default_delete_object_action`
 * @param x function execute parameter.
 *
 * This function returns a _AdaptiveAction_ object for the default action
 * performed if a onDeleteObject parameter is not specified on the associated
 * _AdaptiveModelObjectType_. The action is not performed, but be aware that
 * functions called while producing the _AdaptiveAction_ object may cause side
 * effects. This function can be called as part of a onDelete expression or for
 * testing.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function model_default_delete_object_action(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       modelId?: string,
 *       context?: (object _AdaptiveContextType_)
 *   ): (object _AdaptiveAction_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) This is the adaptorId of a model adaptor. Variable
 *       custom::adaptorId can be used to access this value in model
 *       expressions.
 *
 *   objectType - (string) This is the adaptive object type of object being
 *       deleted. Variable custom::objectType can be used to access this value
 *       in model expressions.
 *
 *   objectId - (string) This is the objectId of object to delete. Variable
 *       custom::object can be used to access this value in model expressions.
 *
 *   modelId - (optional string) This specifics a modelId of model to use for
 *       producing results. If not specified, the adaptor's current model will
 *       be used.
 *
 *   context - (optional object _AdaptiveContextType_) This specifies additional
 *       context information available to model expressions.
 *
 * Returns:
 *
 *   (object _AdaptiveAction_) The default action object.
 */
const afw_value_t *
afw_function_execute_model_default_delete_object_action(
    afw_function_execute_t *x);

/** @brief Function definition model_default_modify_object_action */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_modify_object_action;

/**
 * @brief Adaptive Function `model_default_modify_object_action`
 * @param x function execute parameter.
 *
 * This function returns a _AdaptiveAction_ object for the default action
 * performed if a onModifyObject parameter is not specified on the associated
 * _AdaptiveModelObjectType_. The action is not performed, but be aware that
 * functions called while producing the _AdaptiveAction_ object may cause side
 * effects. This function can be called as part of a onModify expression or for
 * testing.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function model_default_modify_object_action(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       entries: array,
 *       modelId?: string,
 *       context?: (object _AdaptiveContextType_)
 *   ): (object _AdaptiveAction_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) This is the adaptorId of a model adaptor. Variable
 *       custom::adaptorId can be used to access this value in model
 *       expressions.
 *
 *   objectType - (string) This is the adaptive object type of object being
 *       modified. Variable custom::objectType can be used to access this value
 *       in model expressions.
 *
 *   objectId - (string) This is the objectId of object to modify. Variable
 *       custom::objectId can be used to access this value in model expressions.
 *
 *   entries - (array) This is an array of modifications. Variable
 *       custom::actions can be used to access this value in model expressions.
 *       Entries are of the form:
 * 
 *           [
 *               'add_value',
 *               'property name' or ['property name', ... ],
 *               value
 *           ]
 * 
 *           [
 *               'remove_property',
 *               'property name' or ['property name', ... ]
 *           ]
 * 
 *           [
 *               'remove_value',
 *               'property name' or ['property name', ... ],
 *               value
 *           ]
 * 
 *           [
 *               'set_property',
 *               'property name' or ['property name', ... ],
 *               value
 *           ].
 *
 *   modelId - (optional string) This specifics a modelId of model to use for
 *       producing results. If not specified, the adaptor's current model will
 *       be used.
 *
 *   context - (optional object _AdaptiveContextType_) This specifies additional
 *       context information available to model expressions.
 *
 * Returns:
 *
 *   (object _AdaptiveAction_) The default action object.
 */
const afw_value_t *
afw_function_execute_model_default_modify_object_action(
    afw_function_execute_t *x);

/** @brief Function definition model_default_replace_object_action */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_default_replace_object_action;

/**
 * @brief Adaptive Function `model_default_replace_object_action`
 * @param x function execute parameter.
 *
 * This function returns a _AdaptiveAction_ object for the default action
 * performed if a onReplaceObject parameter is not specified on the associated
 * _AdaptiveModelObjectType_. The action is not performed, but be aware that
 * functions called while producing the _AdaptiveAction_ object may cause side
 * effects. This function can be called as part of a onReplace expression or for
 * testing.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function model_default_replace_object_action(
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string,
 *       object: object,
 *       modelId?: string,
 *       context?: (object _AdaptiveContextType_)
 *   ): (object _AdaptiveAction_);
 * ```
 *
 * Parameters:
 *
 *   adaptorId - (string) This is the adaptorId of a model adaptor. Variable
 *       custom::adaptorId can be used to access this value in model
 *       expressions.
 *
 *   objectType - (string) This is the adaptive object type of object being
 *       replaced. Variable custom::objectType can be used to access this value
 *       in model expressions.
 *
 *   objectId - (string) The objectId of object to replace. Variable
 *       custom::objectId can be used to access this value in model expressions.
 *
 *   object - (object) This is the object to replace. Variable custom::object
 *       can be used to access this value in model expressions.
 *
 *   modelId - (optional string) This specifics a modelId of model to use for
 *       producing results. If not specified, the adaptor's current model will
 *       be used.
 *
 *   context - (optional object _AdaptiveContextType_) This specifies additional
 *       context information available to model expressions.
 *
 * Returns:
 *
 *   (object _AdaptiveAction_) The default action object.
 */
const afw_value_t *
afw_function_execute_model_default_replace_object_action(
    afw_function_execute_t *x);

/** @brief Function definition model_mapBackObject_signature */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_mapBackObject_signature;

/**
 * @brief Adaptive Function `model_mapBackObject_signature`
 * @param x function execute parameter.
 *
 * This is the function signature for current:mapBackObject used by onGetObjects
 * and onRetrieveObjects. Calling this directly will throw a 'Do not call
 * directly' error.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function model_mapBackObject_signature(
 *       mappedObject: object
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   mappedObject - (object) This is the object to map back.
 *
 * Returns:
 *
 *   (object) This is the mappedObject mapped back from mapped adaptor object.
 */
const afw_value_t *
afw_function_execute_model_mapBackObject_signature(
    afw_function_execute_t *x);

/** @brief Function definition model_mapObject_signature */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_mapObject_signature;

/**
 * @brief Adaptive Function `model_mapObject_signature`
 * @param x function execute parameter.
 *
 * This is the function signature for current:mapObject used by onAddObject.
 * onDeleteObject, onModifyObject, and onReplaceObject. Calling this directly
 * will throw a 'Do not call directly' error.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function model_mapObject_signature(
 *       object: object
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   object - (object) This is the object to map.
 *
 * Returns:
 *
 *   (object) This is the object mapped to mappedAdaptor object.
 */
const afw_value_t *
afw_function_execute_model_mapObject_signature(
    afw_function_execute_t *x);

/** @brief Function definition model_returnObject_signature */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_model_returnObject_signature;

/**
 * @brief Adaptive Function `model_returnObject_signature`
 * @param x function execute parameter.
 *
 * This is the function signature for current:returnObject used by onGetObjects
 * and onRetrieveObjects. Calling this directly will throw a 'Do not call
 * directly' error.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function model_returnObject_signature(
 *       object: object,
 *       userData?: boolean
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   object - (object) This is the object to return.
 *
 *   userData - (optional boolean) If this is present and true, the object will
 *       be mapped its mapped adaptor's object type to the model adaptor's
 *       object type.
 *
 * Returns:
 *
 *   (boolean) This will return true if no more objects can be returned for any
 *       reason including a limit exceeded, connection closed, or server
 *       stopping.
 */
const afw_value_t *
afw_function_execute_model_returnObject_signature(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_null null functions
 *
 * null adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<null> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_null;

/**
 * @brief Adaptive Function `bag<null>`
 * @param x function execute parameter.
 *
 * Takes any number of null values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<null>(
 *       ...values: (array of (array null))
 *   ): (array null);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array null)
 *
 * Returns:
 *
 *   (array null)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<null> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_null;

/**
 * @brief Adaptive Function `bag_size<null>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<null>(
 *       value: (array null)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array null)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition is<null> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_null;

/**
 * @brief Adaptive Function `is<null>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType null and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<null>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition null */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_null;

/**
 * @brief Adaptive Function `null`
 * @param x function execute parameter.
 *
 * Converts value to data type null returning null result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function null(
 *       value: any
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (void) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_string<null> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_null;

/**
 * @brief Adaptive Function `to_string<null>`
 * @param x function execute parameter.
 *
 * Converts null value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<null>(
 *       value: null
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (null) A null value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_objectId objectId functions
 *
 * objectId adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_objectId;

/**
 * @brief Adaptive Function `bag<objectId>`
 * @param x function execute parameter.
 *
 * Takes any number of objectId values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<objectId>(
 *       ...values: (array of (array objectId))
 *   ): (array objectId);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array objectId)
 *
 * Returns:
 *
 *   (array objectId)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_objectId;

/**
 * @brief Adaptive Function `bag_size<objectId>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<objectId>(
 *       value: (array objectId)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array objectId)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition eq<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_objectId;

/**
 * @brief Adaptive Function `eq<objectId>`
 * @param x function execute parameter.
 *
 * Determine if objectId arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<objectId>(
 *       arg1: objectId,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_objectId;

/**
 * @brief Adaptive Function `eqx<objectId>`
 * @param x function execute parameter.
 *
 * Determine if for objectId arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<objectId>(
 *       arg1: objectId,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_objectId;

/**
 * @brief Adaptive Function `ge<objectId>`
 * @param x function execute parameter.
 *
 * Checks for objectId arg1 is greater than or equal to objectId arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<objectId>(
 *       arg1: objectId,
 *       arg2: objectId
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (objectId)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_objectId;

/**
 * @brief Adaptive Function `gt<objectId>`
 * @param x function execute parameter.
 *
 * Checks for objectId arg1 is greater than objectId arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<objectId>(
 *       arg1: objectId,
 *       arg2: objectId
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (objectId)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_objectId;

/**
 * @brief Adaptive Function `is<objectId>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType objectId and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<objectId>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_objectId;

/**
 * @brief Adaptive Function `le<objectId>`
 * @param x function execute parameter.
 *
 * Checks for objectId arg1 is less than or equal to objectId arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<objectId>(
 *       arg1: objectId,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_objectId;

/**
 * @brief Adaptive Function `lt<objectId>`
 * @param x function execute parameter.
 *
 * Checks for objectId arg1 is less that objectId arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<objectId>(
 *       arg1: objectId,
 *       arg2: objectId
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (objectId)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_objectId;

/**
 * @brief Adaptive Function `ne<objectId>`
 * @param x function execute parameter.
 *
 * Determine if objectId arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<objectId>(
 *       arg1: objectId,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_objectId;

/**
 * @brief Adaptive Function `nex<objectId>`
 * @param x function execute parameter.
 *
 * Determine if for objectId arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<objectId>(
 *       arg1: objectId,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectId)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition objectId */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_objectId;

/**
 * @brief Adaptive Function `objectId`
 * @param x function execute parameter.
 *
 * Converts value to data type objectId returning objectId result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function objectId(
 *       value: any
 *   ): objectId;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (objectId) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_string<objectId> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_objectId;

/**
 * @brief Adaptive Function `to_string<objectId>`
 * @param x function execute parameter.
 *
 * Converts objectId value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<objectId>(
 *       value: objectId
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (objectId) A objectId value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_objectPath objectPath functions
 *
 * objectPath adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_objectPath;

/**
 * @brief Adaptive Function `bag<objectPath>`
 * @param x function execute parameter.
 *
 * Takes any number of objectPath values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<objectPath>(
 *       ...values: (array of (array objectPath))
 *   ): (array objectPath);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array objectPath)
 *
 * Returns:
 *
 *   (array objectPath)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_objectPath;

/**
 * @brief Adaptive Function `bag_size<objectPath>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<objectPath>(
 *       value: (array objectPath)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array objectPath)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition eq<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_objectPath;

/**
 * @brief Adaptive Function `eq<objectPath>`
 * @param x function execute parameter.
 *
 * Determine if objectPath arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<objectPath>(
 *       arg1: objectPath,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_objectPath;

/**
 * @brief Adaptive Function `eqx<objectPath>`
 * @param x function execute parameter.
 *
 * Determine if for objectPath arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<objectPath>(
 *       arg1: objectPath,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_objectPath;

/**
 * @brief Adaptive Function `ge<objectPath>`
 * @param x function execute parameter.
 *
 * Checks for objectPath arg1 is greater than or equal to objectPath arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<objectPath>(
 *       arg1: objectPath,
 *       arg2: objectPath
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (objectPath)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_objectPath;

/**
 * @brief Adaptive Function `gt<objectPath>`
 * @param x function execute parameter.
 *
 * Checks for objectPath arg1 is greater than objectPath arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<objectPath>(
 *       arg1: objectPath,
 *       arg2: objectPath
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (objectPath)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_objectPath;

/**
 * @brief Adaptive Function `is<objectPath>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType objectPath and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<objectPath>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_objectPath;

/**
 * @brief Adaptive Function `le<objectPath>`
 * @param x function execute parameter.
 *
 * Checks for objectPath arg1 is less than or equal to objectPath arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<objectPath>(
 *       arg1: objectPath,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_objectPath;

/**
 * @brief Adaptive Function `lt<objectPath>`
 * @param x function execute parameter.
 *
 * Checks for objectPath arg1 is less that objectPath arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<objectPath>(
 *       arg1: objectPath,
 *       arg2: objectPath
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (objectPath)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_objectPath;

/**
 * @brief Adaptive Function `ne<objectPath>`
 * @param x function execute parameter.
 *
 * Determine if objectPath arg1 is not equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<objectPath>(
 *       arg1: objectPath,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_objectPath;

/**
 * @brief Adaptive Function `nex<objectPath>`
 * @param x function execute parameter.
 *
 * Determine if for objectPath arg1 is not equal to the value or data type of
 * arg2 then return the boolean result. Use 'ne' ('!=') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<objectPath>(
 *       arg1: objectPath,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (objectPath)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition objectPath */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_objectPath;

/**
 * @brief Adaptive Function `objectPath`
 * @param x function execute parameter.
 *
 * Converts value to data type objectPath returning objectPath result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function objectPath(
 *       value: any
 *   ): objectPath;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (objectPath) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_string<objectPath> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_objectPath;

/**
 * @brief Adaptive Function `to_string<objectPath>`
 * @param x function execute parameter.
 *
 * Converts objectPath value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<objectPath>(
 *       value: objectPath
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (objectPath) A objectPath value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_object object functions
 *
 * object adaptive functions.
 *
 * @{
 */

/** @brief Function definition add_properties */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_properties;

/**
 * @brief Adaptive Function `add_properties`
 * @param x function execute parameter.
 *
 * Add the properties of one object to another replacing existing properties by
 * the same name.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function add_properties(
 *       target: object,
 *       source_1: object,
 *       ...source_rest: (array of object)
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   target - (object) Target object or undefined if result will only contain
 *       the properties of source objects. The object must be mutable, if
 *       specified.
 *
 *   source - (1 or more object) Source object(s).
 *
 * Returns:
 *
 *   (object) The resulting object.
 */
const afw_value_t *
afw_function_execute_add_properties(
    afw_function_execute_t *x);

/** @brief Function definition apply_object_options */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_apply_object_options;

/**
 * @brief Adaptive Function `apply_object_options`
 * @param x function execute parameter.
 *
 * This will return an object with the specified object options applied.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function apply_object_options(
 *       object: object,
 *       options?: (object _AdaptiveObjectOptions_)
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   object - (object) Object used to produce result.
 *
 *   options - (optional object _AdaptiveObjectOptions_) Object options. See
 *       /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.
 *
 * Returns:
 *
 *   (object) This is an object with object options applied.
 */
const afw_value_t *
afw_function_execute_apply_object_options(
    afw_function_execute_t *x);

/** @brief Function definition bag<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_object;

/**
 * @brief Adaptive Function `bag<object>`
 * @param x function execute parameter.
 *
 * Takes any number of object values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<object>(
 *       ...values: (array of (array object))
 *   ): (array object);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array object)
 *
 * Returns:
 *
 *   (array object)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_object;

/**
 * @brief Adaptive Function `bag_size<object>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<object>(
 *       value: (array object)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array object)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition clone<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_clone_object;

/**
 * @brief Adaptive Function `clone<object>`
 * @param x function execute parameter.
 *
 * Deep clone a object value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function clone<object>(
 *       value: object
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   value - (object) The object value to clone.
 *
 * Returns:
 *
 *   (object) The cloned object value.
 *
 * Implemented by afw_function_execute_clone()
 *
 * __________
 */

/** @brief Function definition eq<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_object;

/**
 * @brief Adaptive Function `eq<object>`
 * @param x function execute parameter.
 *
 * Determine if object arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<object>(
 *       arg1: object,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_object;

/**
 * @brief Adaptive Function `eqx<object>`
 * @param x function execute parameter.
 *
 * Determine if for object arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<object>(
 *       arg1: object,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_object;

/**
 * @brief Adaptive Function `ge<object>`
 * @param x function execute parameter.
 *
 * Checks for object arg1 is greater than or equal to object arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<object>(
 *       arg1: object,
 *       arg2: object
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (object)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_object;

/**
 * @brief Adaptive Function `gt<object>`
 * @param x function execute parameter.
 *
 * Checks for object arg1 is greater than object arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<object>(
 *       arg1: object,
 *       arg2: object
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (object)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_object;

/**
 * @brief Adaptive Function `is<object>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType object and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<object>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_object;

/**
 * @brief Adaptive Function `le<object>`
 * @param x function execute parameter.
 *
 * Checks for object arg1 is less than or equal to object arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<object>(
 *       arg1: object,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition local_object_meta_set_ids */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_local_object_meta_set_ids;

/**
 * @brief Adaptive Function `local_object_meta_set_ids`
 * @param x function execute parameter.
 *
 * This is used to set the ids in a local mutable object. The ids are used to
 * construct a local path.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function local_object_meta_set_ids(
 *       object: object,
 *       adaptorId: string,
 *       objectType: string,
 *       objectId: string
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   object - (object) Object to set ids in.
 *
 *   adaptorId - (string) Adaptor id for object.
 *
 *   objectType - (string) Object type id for object.
 *
 *   objectId - (string) Object id for object.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_local_object_meta_set_ids(
    afw_function_execute_t *x);

/** @brief Function definition lt<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_object;

/**
 * @brief Adaptive Function `lt<object>`
 * @param x function execute parameter.
 *
 * Checks for object arg1 is less that object arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<object>(
 *       arg1: object,
 *       arg2: object
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (object)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_object;

/**
 * @brief Adaptive Function `ne<object>`
 * @param x function execute parameter.
 *
 * Determine if object arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<object>(
 *       arg1: object,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_object;

/**
 * @brief Adaptive Function `nex<object>`
 * @param x function execute parameter.
 *
 * Determine if for object arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<object>(
 *       arg1: object,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (object)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition object */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_object;

/**
 * @brief Adaptive Function `object`
 * @param x function execute parameter.
 *
 * Converts value to data type object returning object result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function object(
 *       value: any
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (object) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition property_delete */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_delete;

/**
 * @brief Adaptive Function `property_delete`
 * @param x function execute parameter.
 *
 * Delete a property in an object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function property_delete(
 *       object: object,
 *       name: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   object - (object) This is the object to delete property from.
 *
 *   name - (string) This is a name of the property to delete.
 *
 * Returns:
 *
 *   (boolean) True if object had the property and it was deleted.
 */
const afw_value_t *
afw_function_execute_property_delete(
    afw_function_execute_t *x);

/** @brief Function definition property_delete_by_reference */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_delete_by_reference;

/**
 * @brief Adaptive Function `property_delete_by_reference`
 * @param x function execute parameter.
 *
 * Delete a property from an object by reference.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function property_delete_by_reference(
 *       reference: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   reference - (any dataType) This is a reference to the object property to
 *       delete.
 *
 * Returns:
 *
 *   (boolean) True if object had the property and it was deleted.
 */
const afw_value_t *
afw_function_execute_property_delete_by_reference(
    afw_function_execute_t *x);

/** @brief Function definition property_exists */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_exists;

/**
 * @brief Adaptive Function `property_exists`
 * @param x function execute parameter.
 *
 * Return true if the named property exists in an object.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function property_exists(
 *       object: object,
 *       name: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   object - (object) Object to get property from.
 *
 *   name - (string) Name of property to check.
 *
 * Returns:
 *
 *   (boolean) True if object has named property.
 */
const afw_value_t *
afw_function_execute_property_exists(
    afw_function_execute_t *x);

/** @brief Function definition property_get */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_get;

/**
 * @brief Adaptive Function `property_get`
 * @param x function execute parameter.
 *
 * Return the value of a property of an object. If property is not available,
 * return a default or null value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function property_get(
 *       object: object,
 *       name: string,
 *       defaultValue?: any
 *   ): any;
 * ```
 *
 * Parameters:
 *
 *   object - (object) Object to get property from.
 *
 *   name - (string) Name of property to get.
 *
 *   defaultValue - (optional any dataType) The default value of property if it
 *       does not exist in object. If not specified, null value is the default.
 *
 * Returns:
 *
 *   (any dataType) Evaluated property value or default.
 */
const afw_value_t *
afw_function_execute_property_get(
    afw_function_execute_t *x);

/** @brief Function definition property_is_not_null */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_property_is_not_null;

/**
 * @brief Adaptive Function `property_is_not_null`
 * @param x function execute parameter.
 *
 * Return true if the named property exists in an object and is not null.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function property_is_not_null(
 *       object: object,
 *       name: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   object - (object) Object to get property from.
 *
 *   name - (string) Name of property to check.
 *
 * Returns:
 *
 *   (boolean) True if object has named property that is not null.
 */
const afw_value_t *
afw_function_execute_property_is_not_null(
    afw_function_execute_t *x);

/** @brief Function definition to_string<object> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_object;

/**
 * @brief Adaptive Function `to_string<object>`
 * @param x function execute parameter.
 *
 * Converts object value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<object>(
 *       value: object
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (object) A object value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_password password functions
 *
 * password adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_password;

/**
 * @brief Adaptive Function `bag<password>`
 * @param x function execute parameter.
 *
 * Takes any number of password values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<password>(
 *       ...values: (array of (array password))
 *   ): (array password);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array password)
 *
 * Returns:
 *
 *   (array password)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_password;

/**
 * @brief Adaptive Function `bag_size<password>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<password>(
 *       value: (array password)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array password)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition eq<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_password;

/**
 * @brief Adaptive Function `eq<password>`
 * @param x function execute parameter.
 *
 * Determine if password arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<password>(
 *       arg1: password,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_password;

/**
 * @brief Adaptive Function `eqx<password>`
 * @param x function execute parameter.
 *
 * Determine if for password arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<password>(
 *       arg1: password,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_password;

/**
 * @brief Adaptive Function `ge<password>`
 * @param x function execute parameter.
 *
 * Checks for password arg1 is greater than or equal to password arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<password>(
 *       arg1: password,
 *       arg2: password
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (password)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_password;

/**
 * @brief Adaptive Function `gt<password>`
 * @param x function execute parameter.
 *
 * Checks for password arg1 is greater than password arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<password>(
 *       arg1: password,
 *       arg2: password
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (password)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_password;

/**
 * @brief Adaptive Function `is<password>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType password and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<password>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_password;

/**
 * @brief Adaptive Function `le<password>`
 * @param x function execute parameter.
 *
 * Checks for password arg1 is less than or equal to password arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<password>(
 *       arg1: password,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_password;

/**
 * @brief Adaptive Function `lt<password>`
 * @param x function execute parameter.
 *
 * Checks for password arg1 is less that password arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<password>(
 *       arg1: password,
 *       arg2: password
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (password)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_password;

/**
 * @brief Adaptive Function `ne<password>`
 * @param x function execute parameter.
 *
 * Determine if password arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<password>(
 *       arg1: password,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_password;

/**
 * @brief Adaptive Function `nex<password>`
 * @param x function execute parameter.
 *
 * Determine if for password arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<password>(
 *       arg1: password,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (password)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition password */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_password;

/**
 * @brief Adaptive Function `password`
 * @param x function execute parameter.
 *
 * Converts value to data type password returning password result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function password(
 *       value: any
 *   ): password;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (password) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_string<password> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_password;

/**
 * @brief Adaptive Function `to_string<password>`
 * @param x function execute parameter.
 *
 * Converts password value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<password>(
 *       value: password
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (password) A password value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_polymorphic polymorphic functions
 *
 * polymorphic adaptive functions.
 *
 * @{
 */

/** @brief Function definition abs */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_abs;

/**
 * @brief Adaptive Function `abs`
 * @param x function execute parameter.
 *
 * Compute the absolute value of the `<dataType>` value and return the
 * `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double, integer.
 *
 * Declaration:
 *
 * ```
 *   function abs <dataType>(
 *       value: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition add */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add;

/**
 * @brief Adaptive Function `add`
 * @param x function execute parameter.
 *
 * Add 2 or more `<dataType>` values and return the `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double, integer, string.
 *
 * Declaration:
 *
 * ```
 *   function add <dataType>(
 *       values_1: dataType,
 *       values_2: dataType,
 *       ...values_rest: (array of dataType)
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   values - (2 or more ``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition add_dayTimeDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_dayTimeDuration;

/**
 * @brief Adaptive Function `add_dayTimeDuration`
 * @param x function execute parameter.
 *
 * Add `<dataType>` arg1 to dayTimeDuration arg2 and return the `<dataType>`
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   dateTime.
 *
 * Declaration:
 *
 * ```
 *   function add_dayTimeDuration <dataType>(
 *       arg1: dataType,
 *       arg2: dayTimeDuration
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (dayTimeDuration)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition add_yearMonthDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_yearMonthDuration;

/**
 * @brief Adaptive Function `add_yearMonthDuration`
 * @param x function execute parameter.
 *
 * Add `<dataType>` arg1 to yearMonthDuration arg2 and return the `<dataType>`
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   date, dateTime.
 *
 * Declaration:
 *
 * ```
 *   function add_yearMonthDuration <dataType>(
 *       arg1: dataType,
 *       arg2: yearMonthDuration
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition at_least_one_member_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of;

/**
 * @brief Adaptive Function `at_least_one_member_of`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in `<dataType>` array1 is in
 * `<dataType>` array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double,
 *   hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of <dataType>(
 *       array1: array,
 *       array2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array ``<Type>``) The first array.
 *
 *   array2 - (array ``<Type>``) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition bag */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag;

/**
 * @brief Adaptive Function `bag`
 * @param x function execute parameter.
 *
 * Takes any number of `<dataType>` values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress, null,
 *   object, objectId, objectPath, password, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function bag <dataType>(
 *       ...values: (array of array)
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array ``<Type>``)
 *
 * Returns:
 *
 *   (array ``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition bag_size */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size;

/**
 * @brief Adaptive Function `bag_size`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress, null,
 *   object, objectId, objectPath, password, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function bag_size <dataType>(
 *       value: array
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array ``<Type>``)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition ceil */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ceil;

/**
 * @brief Adaptive Function `ceil`
 * @param x function execute parameter.
 *
 * Determine the smallest integer that is greater then or equal to the
 * `<dataType>` value and return the `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double.
 *
 * Declaration:
 *
 * ```
 *   function ceil <dataType>(
 *       value: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition clone */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_clone;

/**
 * @brief Adaptive Function `clone`
 * @param x function execute parameter.
 *
 * Deep clone a `<dataType>` value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   array, object.
 *
 * Declaration:
 *
 * ```
 *   function clone <dataType>(
 *       value: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to clone.
 *
 * Returns:
 *
 *   (``<Type>``) The cloned `<dataType>` value.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition compile */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile;

/**
 * @brief Adaptive Function `compile`
 * @param x function execute parameter.
 *
 * Compile `<dataType>` value and return either an unevaluated adaptive value or
 * a string containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   json, regexp, relaxed_json, script, template, xml, xpathExpression.
 *
 * Declaration:
 *
 * ```
 *   function compile <dataType>(
 *       source: dataType,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (``<Type>``) `<dataType>` string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition decode_to_string */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_decode_to_string;

/**
 * @brief Adaptive Function `decode_to_string`
 * @param x function execute parameter.
 *
 * Decode `<dataType>` value to string. An error is thrown if decoded value is
 * not valid UTF-8.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   base64Binary, hexBinary.
 *
 * Declaration:
 *
 * ```
 *   function decode_to_string <dataType>(
 *       value: dataType
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to decode.
 *
 * Returns:
 *
 *   (string) The decoded string.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition divide */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_divide;

/**
 * @brief Adaptive Function `divide`
 * @param x function execute parameter.
 *
 * Divide `<dataType>` dividend by `<dataType>` divisor and return the
 * `<dataType>` quotient.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double, integer.
 *
 * Declaration:
 *
 * ```
 *   function divide <dataType>(
 *       dividend: dataType,
 *       divisor: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   dividend - (``<Type>``)
 *
 *   divisor - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition encode_as_base64Binary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_base64Binary;

/**
 * @brief Adaptive Function `encode_as_base64Binary`
 * @param x function execute parameter.
 *
 * Encode a value as a base64Binary. The effect is to create a base64Binary
 * value with an internal value of the value passed.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function encode_as_base64Binary <dataType>(
 *       value: dataType
 *   ): base64Binary;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to encode.
 *
 * Returns:
 *
 *   (base64Binary) A base64Binary value.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition encode_as_hexBinary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_hexBinary;

/**
 * @brief Adaptive Function `encode_as_hexBinary`
 * @param x function execute parameter.
 *
 * Encode a value as a hexBinary. The effect is to create a hexBinary value with
 * an internal value of the value passed.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function encode_as_hexBinary <dataType>(
 *       value: dataType
 *   ): hexBinary;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to encode.
 *
 * Returns:
 *
 *   (hexBinary) A hexBinary value.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition ends_with */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ends_with;

/**
 * @brief Adaptive Function `ends_with`
 * @param x function execute parameter.
 *
 * Checks whether `<dataType>` value ends with a `<dataType>` and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function ends_with <dataType>(
 *       value: dataType,
 *       subString: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 *   subString - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition eq */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq;

/**
 * @brief Adaptive Function `eq`
 * @param x function execute parameter.
 *
 * Determine if `<dataType>` arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, regexp, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function eq <dataType>(
 *       arg1: dataType,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eq_ignore_case */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ignore_case;

/**
 * @brief Adaptive Function `eq_ignore_case`
 * @param x function execute parameter.
 *
 * Checks for `<dataType>` arg1 is equal to `<dataType>` arg2 ignoring case and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function eq_ignore_case <dataType>(
 *       arg1: dataType,
 *       arg2: dataType
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition eqx */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx;

/**
 * @brief Adaptive Function `eqx`
 * @param x function execute parameter.
 *
 * Determine if for `<dataType>` arg1 is equal to the value and data type of
 * arg2 then return the boolean result. Use 'eq' ('==') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, regexp, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function eqx <dataType>(
 *       arg1: dataType,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition evaluate */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate;

/**
 * @brief Adaptive Function `evaluate`
 * @param x function execute parameter.
 *
 * Compile and evaluate `<dataType>` value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Supported `<dataType>`:
 *
 *   script, template, xpathExpression.
 *
 * Declaration:
 *
 * ```
 *   function evaluate <dataType>(
 *       source: dataType,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (``<Type>``) `<dataType>` string to compile and evaluate.
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (unevaluated)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition floor */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_floor;

/**
 * @brief Adaptive Function `floor`
 * @param x function execute parameter.
 *
 * Determine the largest integer that is smaller then or equal to the
 * `<dataType>` value and return the `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double.
 *
 * Declaration:
 *
 * ```
 *   function floor <dataType>(
 *       number: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   number - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition ge */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge;

/**
 * @brief Adaptive Function `ge`
 * @param x function execute parameter.
 *
 * Checks for `<dataType>` arg1 is greater than or equal to `<dataType>` arg2
 * and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, regexp, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function ge <dataType>(
 *       arg1: dataType,
 *       arg2: dataType
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition gt */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt;

/**
 * @brief Adaptive Function `gt`
 * @param x function execute parameter.
 *
 * Checks for `<dataType>` arg1 is greater than `<dataType>` arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, regexp, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function gt <dataType>(
 *       arg1: dataType,
 *       arg2: dataType
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition in_range */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_in_range;

/**
 * @brief Adaptive Function `in_range`
 * @param x function execute parameter.
 *
 * Checks if `<dataType>` is between startTime and endTime, inclusive.
 * Regardless of endTime value, it is always considered to be equal to, but less
 * than 24 hours greater than startTime. If no `<dataType>` zone is specified
 * for `<dataType>,` the default `<dataType>` zone is used. If no `<dataType>`
 * zone is specified for startTime or endTime, the `<dataType>` zone of
 * `<dataType>` is used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   time.
 *
 * Declaration:
 *
 * ```
 *   function in_range <dataType>(
 *       time: dataType,
 *       startTime: dataType,
 *       endTime: dataType
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   time - (``<Type>``)
 *
 *   startTime - (``<Type>``)
 *
 *   endTime - (``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition includes */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes;

/**
 * @brief Adaptive Function `includes`
 * @param x function execute parameter.
 *
 * Checks whether the `<dataType>` value includes a string and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, string.
 *
 * Declaration:
 *
 * ```
 *   function includes <dataType>(
 *       searchString: dataType,
 *       subString: string,
 *       position?: integer
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   searchString - (``<Type>``) The `<dataType>` to search.
 *
 *   subString - (string) Substring to find.
 *
 *   position - (optional integer) Zero-based position in the search string to
 *       start search.
 *
 * Returns:
 *
 *   (boolean) Indicates if the substring is contained in the search string.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition index_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_of;

/**
 * @brief Adaptive Function `index_of`
 * @param x function execute parameter.
 *
 * Returns the zero-based index into `<dataType>` value of subString. If
 * subString is not found, -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function index_of <dataType>(
 *       value: dataType,
 *       subString: string,
 *       startIndex?: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to search.
 *
 *   subString - (string) Substring to search for.
 *
 *   startIndex - (optional integer) Optional start index for search if
 *       different than start of string.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition intersection */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection;

/**
 * @brief Adaptive Function `intersection`
 * @param x function execute parameter.
 *
 * Returns an array of `<dataType>` with the values that are common to both
 * array of `<dataType>` array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double,
 *   hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function intersection <dataType>(
 *       array1: array,
 *       array2: array
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array ``<Type>``) The first array.
 *
 *   array2 - (array ``<Type>``) The second array.
 *
 * Returns:
 *
 *   (array ``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition is */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is;

/**
 * @brief Adaptive Function `is`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType `<dataType>` and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress, null,
 *   object, objectId, objectPath, password, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration, unevaluated.
 *
 * Declaration:
 *
 * ```
 *   function is <dataType>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition is_in */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in;

/**
 * @brief Adaptive Function `is_in`
 * @param x function execute parameter.
 *
 * Checks whether `<dataType>` value is in array of `<dataType>` array and
 * returns the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName,
 *   double, hexBinary, integer, ipAddress, rfc822Name, string, time, x500Name,
 *   yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function is_in <dataType>(
 *       value: dataType,
 *       array: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 *   array - (array ``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition last_index_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_last_index_of;

/**
 * @brief Adaptive Function `last_index_of`
 * @param x function execute parameter.
 *
 * Returns the zero-based index into `<dataType>` value of the last occurrence
 * of a subString. If subString is not found, -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function last_index_of <dataType>(
 *       value: dataType,
 *       subString: string,
 *       startIndex?: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to search.
 *
 *   subString - (string) Substring to search for.
 *
 *   startIndex - (optional integer) Optional start index for search if
 *       different than start of string.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition le */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le;

/**
 * @brief Adaptive Function `le`
 * @param x function execute parameter.
 *
 * Checks for `<dataType>` arg1 is less than or equal to `<dataType>` arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, regexp, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function le <dataType>(
 *       arg1: dataType,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition length */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length;

/**
 * @brief Adaptive Function `length`
 * @param x function execute parameter.
 *
 * This is a polymorphic function where `<dataType>` can be any of the supported
 * data types. Return the integer number of entries in datatype array or
 * codepoints in others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, string.
 *
 * Declaration:
 *
 * ```
 *   function length <dataType>(
 *       value: dataType
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) Returns the number of entries in an array or code
 *       points in others.
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition lt */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt;

/**
 * @brief Adaptive Function `lt`
 * @param x function execute parameter.
 *
 * Checks for `<dataType>` arg1 is less that `<dataType>` arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, regexp, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function lt <dataType>(
 *       arg1: dataType,
 *       arg2: dataType
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition match */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_match;

/**
 * @brief Adaptive Function `match`
 * @param x function execute parameter.
 *
 * Returns true if arg1 matches some terminal sequence of RDNs from arg2 when
 * compared using `equal_<dataType>`.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   rfc822Name, x500Name.
 *
 * Declaration:
 *
 * ```
 *   function match <dataType>(
 *       arg1: dataType,
 *       arg2: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition max */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max;

/**
 * @brief Adaptive Function `max`
 * @param x function execute parameter.
 *
 * Return the `<dataType>` value that is greater than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   date, dateTime, double, integer, string, time.
 *
 * Declaration:
 *
 * ```
 *   function max <dataType>(
 *       values_1: dataType,
 *       ...values_rest: (array of dataType)
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more ``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition min */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min;

/**
 * @brief Adaptive Function `min`
 * @param x function execute parameter.
 *
 * Return the `<dataType>` value that is less than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   date, dateTime, double, integer, string, time.
 *
 * Declaration:
 *
 * ```
 *   function min <dataType>(
 *       values_1: dataType,
 *       ...values_rest: (array of dataType)
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more ``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition mod */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_mod;

/**
 * @brief Adaptive Function `mod`
 * @param x function execute parameter.
 *
 * Divide `<dataType>` dividend by `<dataType>` divisor and return the
 * `<dataType>` remainder.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   integer.
 *
 * Declaration:
 *
 * ```
 *   function mod <dataType>(
 *       dividend: dataType,
 *       divisor: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   dividend - (``<Type>``)
 *
 *   divisor - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition multiply */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_multiply;

/**
 * @brief Adaptive Function `multiply`
 * @param x function execute parameter.
 *
 * Multiply 2 or more `<dataType>` values and return the `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double, integer.
 *
 * Declaration:
 *
 * ```
 *   function multiply <dataType>(
 *       values_1: dataType,
 *       values_2: dataType,
 *       ...values_rest: (array of dataType)
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   values - (2 or more ``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition ne */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne;

/**
 * @brief Adaptive Function `ne`
 * @param x function execute parameter.
 *
 * Determine if `<dataType>` arg1 is not equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, regexp, rfc822Name, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function ne <dataType>(
 *       arg1: dataType,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition negative */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_negative;

/**
 * @brief Adaptive Function `negative`
 * @param x function execute parameter.
 *
 * Return negative of `<dataType>` value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double, integer.
 *
 * Declaration:
 *
 * ```
 *   function negative <dataType>(
 *       value: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition nex */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex;

/**
 * @brief Adaptive Function `nex`
 * @param x function execute parameter.
 *
 * Determine if for `<dataType>` arg1 is not equal to the value or data type of
 * arg2 then return the boolean result. Use 'ne' ('!=') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, function, hexBinary, ia5String, integer, ipAddress,
 *   object, objectId, objectPath, password, rfc822Name, regexp, script, string,
 *   template, time, x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function nex <dataType>(
 *       arg1: dataType,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition normalize_space */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_space;

/**
 * @brief Adaptive Function `normalize_space`
 * @param x function execute parameter.
 *
 * Remove whitespace from the beginning and end of a `<dataType>` value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function normalize_space <dataType>(
 *       string: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   string - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition normalize_to_lower_case */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_to_lower_case;

/**
 * @brief Adaptive Function `normalize_to_lower_case`
 * @param x function execute parameter.
 *
 * Normalize `<dataType>` value to lower case and returns `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function normalize_to_lower_case <dataType>(
 *       string: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   string - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition one_and_only */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only;

/**
 * @brief Adaptive Function `one_and_only`
 * @param x function execute parameter.
 *
 * This converts an array of `<dataType>` values that contains one value to a
 * single `<dataType>` value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName,
 *   double, hexBinary, integer, ipAddress, rfc822Name, string, time, x500Name,
 *   yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only <dataType>(
 *       array: (array array)
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition pow */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_pow;

/**
 * @brief Adaptive Function `pow`
 * @param x function execute parameter.
 *
 * This returns the value of base raised to a power. Multiple exponents can be
 * specified to raise the previous exponent to the power of the latter exponent.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double.
 *
 * Declaration:
 *
 * ```
 *   function pow <dataType>(
 *       base: dataType,
 *       exponent_1: dataType,
 *       ...exponent_rest: (array of dataType)
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   base - (``<Type>``) Base value.
 *
 *   exponent - (1 or more ``<Type>``) Exponent value.
 *
 * Returns:
 *
 *   (``<Type>``) Base raised to the power.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition regexp_index_of */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_index_of;

/**
 * @brief Adaptive Function `regexp_index_of`
 * @param x function execute parameter.
 *
 * Search `<dataType>` value for a regular expression and return index. If not
 * found, -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function regexp_index_of <dataType>(
 *       value: dataType,
 *       regexp: string
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to search.
 *
 *   regexp - (string) A regular expression to use for search.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition regexp_match */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match;

/**
 * @brief Adaptive Function `regexp_match`
 * @param x function execute parameter.
 *
 * Checks whether `<dataType>` value matches the regular expression regexp and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, dnsName, ipAddress, rfc822Name, string, x500Name.
 *
 * Declaration:
 *
 * ```
 *   function regexp_match <dataType>(
 *       value: dataType,
 *       regexp: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 *   regexp - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition regexp_replace */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_replace;

/**
 * @brief Adaptive Function `regexp_replace`
 * @param x function execute parameter.
 *
 * Replace matched values for a regular expression in a `<dataType>` value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function regexp_replace <dataType>(
 *       value: dataType,
 *       regexp: string,
 *       replacement: string,
 *       limit?: integer
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The original `<dataType>` value.
 *
 *   regexp - (string) A regular expression to use for search.
 *
 *   replacement - (string) The replacement string.
 *
 *   limit - (optional integer) This is the maximum times to replace. The
 *       default is 1. Specify -1 to replace all occurrences.
 *
 * Returns:
 *
 *   (``<Type>``) A `<dataType>` value with the matched string(s) replaced.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition repeat */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_repeat;

/**
 * @brief Adaptive Function `repeat`
 * @param x function execute parameter.
 *
 * Repeat a `<dataType>` value a specified number of times.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function repeat <dataType>(
 *       value: dataType,
 *       times: integer
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to repeat.
 *
 *   times - (integer) The number of times to repeat the value.
 *
 * Returns:
 *
 *   (``<Type>``) The repeated `<dataType>` value.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition replace */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace;

/**
 * @brief Adaptive Function `replace`
 * @param x function execute parameter.
 *
 * Replace string(s) in a `<dataType>` value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function replace <dataType>(
 *       value: dataType,
 *       match: string,
 *       replacement: string,
 *       limit?: integer
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The original `<dataType>` value.
 *
 *   match - (string) The string to replace.
 *
 *   replacement - (string) The replacement string.
 *
 *   limit - (optional integer) This is the maximum times to replace. The
 *       default is 1. Specify -1 to replace all occurrences.
 *
 * Returns:
 *
 *   (``<Type>``) A `<dataType>` value with the matched string(s) replaced.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition round */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_round;

/**
 * @brief Adaptive Function `round`
 * @param x function execute parameter.
 *
 * Determine the integer closest to `<dataType>` value and return the
 * `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double.
 *
 * Declaration:
 *
 * ```
 *   function round <dataType>(
 *       number: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   number - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition set_equals */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals;

/**
 * @brief Adaptive Function `set_equals`
 * @param x function execute parameter.
 *
 * Returns boolean true if `<dataType>` array1 and `<dataType>` array2 are
 * subsets of each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double,
 *   hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function set_equals <dataType>(
 *       array1: array,
 *       array2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array ``<Type>``)
 *
 *   array2 - (array ``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition split */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_split;

/**
 * @brief Adaptive Function `split`
 * @param x function execute parameter.
 *
 * Split `<dataType>` value into an array of strings using a separator.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function split <dataType>(
 *       value: dataType,
 *       separator?: string,
 *       limit?: integer
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) The `<dataType>` value to split.
 *
 *   separator - (optional string) The separator to use. If this is an empty
 *       string or separator is not specified, the value is split between
 *       characters.
 *
 *   limit - (optional integer) This is the maximum number of splits. Any
 *       remaining part of value is ignored.
 *
 * Returns:
 *
 *   (array) An array of strings.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition starts_with */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_starts_with;

/**
 * @brief Adaptive Function `starts_with`
 * @param x function execute parameter.
 *
 * Checks whether `<dataType>` value starts with a subString and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function starts_with <dataType>(
 *       value: dataType,
 *       subString: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 *   subString - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition subset */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset;

/**
 * @brief Adaptive Function `subset`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in `<dataType>` array1 are all in
 * `<dataType>` array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double,
 *   hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function subset <dataType>(
 *       array1: array,
 *       array2: array
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array ``<Type>``) The first array.
 *
 *   array2 - (array ``<Type>``) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition substring */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_substring;

/**
 * @brief Adaptive Function `substring`
 * @param x function execute parameter.
 *
 * Returns the `<dataType>` substring of value beginning at zero-based position
 * integer startIndex and ending at the position before integer endIndex.
 * Specify -1 or omitting endIndex to return up to end of `<dataType>`.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, string.
 *
 * Declaration:
 *
 * ```
 *   function substring <dataType>(
 *       string: dataType,
 *       startIndex: integer,
 *       endIndex?: integer
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   string - (``<Type>``)
 *
 *   startIndex - (integer)
 *
 *   endIndex - (optional integer)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Errors thrown:
 *
 *   arg_error - startIndex or endIndex is out of range
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition subtract */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract;

/**
 * @brief Adaptive Function `subtract`
 * @param x function execute parameter.
 *
 * Subtract `<dataType>` arg2 from `<dataType>` arg1 and return the `<dataType>`
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double, integer.
 *
 * Declaration:
 *
 * ```
 *   function subtract <dataType>(
 *       arg1: dataType,
 *       arg2: dataType
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (``<Type>``)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition subtract_dayTimeDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_dayTimeDuration;

/**
 * @brief Adaptive Function `subtract_dayTimeDuration`
 * @param x function execute parameter.
 *
 * Subtract dayTimeDuration arg2 from `<dataType>` arg1 and return the
 * `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   dateTime.
 *
 * Declaration:
 *
 * ```
 *   function subtract_dayTimeDuration <dataType>(
 *       arg1: dataType,
 *       arg2: dayTimeDuration
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (dayTimeDuration)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition subtract_yearMonthDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subtract_yearMonthDuration;

/**
 * @brief Adaptive Function `subtract_yearMonthDuration`
 * @param x function execute parameter.
 *
 * Subtract yearMonthDuration arg2 from `<dataType>` arg1 and return the
 * `<dataType>` result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   date, dateTime.
 *
 * Declaration:
 *
 * ```
 *   function subtract_yearMonthDuration <dataType>(
 *       arg1: dataType,
 *       arg2: yearMonthDuration
 *   ): dataType;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (``<Type>``)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_anyURI */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_anyURI;

/**
 * @brief Adaptive Function `to_anyURI`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to anyURI.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_anyURI <dataType>(
 *       value: dataType
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (anyURI)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_boolean */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_boolean;

/**
 * @brief Adaptive Function `to_boolean`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to boolean.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_boolean <dataType>(
 *       value: dataType
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_date */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_date;

/**
 * @brief Adaptive Function `to_date`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to date.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_date <dataType>(
 *       value: dataType
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (date)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_dateTime */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dateTime;

/**
 * @brief Adaptive Function `to_dateTime`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to dateTime.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_dateTime <dataType>(
 *       value: dataType
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (dateTime)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_dayTimeDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dayTimeDuration;

/**
 * @brief Adaptive Function `to_dayTimeDuration`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to dayTimeDuration.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_dayTimeDuration <dataType>(
 *       value: dataType
 *   ): dayTimeDuration;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (dayTimeDuration)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_dnsName */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dnsName;

/**
 * @brief Adaptive Function `to_dnsName`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to dnsName.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_dnsName <dataType>(
 *       value: dataType
 *   ): dnsName;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (dnsName)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_double */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_double;

/**
 * @brief Adaptive Function `to_double`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to double and returns double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   integer, string.
 *
 * Declaration:
 *
 * ```
 *   function to_double <dataType>(
 *       value: dataType
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (double)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_integer */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_integer;

/**
 * @brief Adaptive Function `to_integer`
 * @param x function execute parameter.
 *
 * Truncate `<dataType>` value to a whole number and returns integer result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   double, string.
 *
 * Declaration:
 *
 * ```
 *   function to_integer <dataType>(
 *       value: dataType
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_ipAddress */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_ipAddress;

/**
 * @brief Adaptive Function `to_ipAddress`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to ipAddress.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_ipAddress <dataType>(
 *       value: dataType
 *   ): ipAddress;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (ipAddress)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_rfc822Name */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_rfc822Name;

/**
 * @brief Adaptive Function `to_rfc822Name`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to rfc822Name.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_rfc822Name <dataType>(
 *       value: dataType
 *   ): rfc822Name;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (rfc822Name)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_string */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string;

/**
 * @brief Adaptive Function `to_string`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to string. For array values, the to_string()
 * value for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, array, base64Binary, boolean, date, dateTime, dayTimeDuration,
 *   dnsName, double, hexBinary, ia5String, integer, ipAddress, null, object,
 *   objectId, objectPath, password, rfc822Name, string, template, time,
 *   x500Name, xpathExpression, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function to_string <dataType>(
 *       value: dataType
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``) A `<dataType>` value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_time */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_time;

/**
 * @brief Adaptive Function `to_time`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to time.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_time <dataType>(
 *       value: dataType
 *   ): time;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (time)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_x500Name */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_x500Name;

/**
 * @brief Adaptive Function `to_x500Name`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to x500Name.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_x500Name <dataType>(
 *       value: dataType
 *   ): x500Name;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (x500Name)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition to_yearMonthDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_yearMonthDuration;

/**
 * @brief Adaptive Function `to_yearMonthDuration`
 * @param x function execute parameter.
 *
 * Converts `<dataType>` value to yearMonthDuration.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string.
 *
 * Declaration:
 *
 * ```
 *   function to_yearMonthDuration <dataType>(
 *       value: dataType
 *   ): yearMonthDuration;
 * ```
 *
 * Parameters:
 *
 *   value - (``<Type>``)
 *
 * Returns:
 *
 *   (yearMonthDuration)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition union */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union;

/**
 * @brief Adaptive Function `union`
 * @param x function execute parameter.
 *
 * Returns an array of `<dataType>` contains all of the unique values in two or
 * more array of `<dataType>` values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double,
 *   hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.
 *
 * Declaration:
 *
 * ```
 *   function union <dataType>(
 *       arrays_1: array,
 *       arrays_2: array,
 *       ...arrays_rest: (array of array)
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array ``<Type>``) Two or more arrays.
 *
 * Returns:
 *
 *   (array ``<Type>``)
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @brief Function definition url_encode */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_encode;

/**
 * @brief Adaptive Function `url_encode`
 * @param x function execute parameter.
 *
 * URL encode a value or bag of values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Supported `<dataType>`:
 *
 *   string, anyURI.
 *
 * Declaration:
 *
 * ```
 *   function url_encode <dataType>(
 *       unencoded: dataType
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   unencoded - (``<Type>``) URL encode a single value. See the url_encode
 *       method for the data type of more details.
 *
 * Returns:
 *
 *   (string) URI encoded string.
 *
 * Implemented by AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_random random functions
 *
 * random adaptive functions.
 *
 * @{
 */

/** @brief Function definition random_base64Binary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_base64Binary;

/**
 * @brief Adaptive Function `random_base64Binary`
 * @param x function execute parameter.
 *
 * This returns a specified number of random octets as dataType base64Binary.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function random_base64Binary(
 *       numberOfOctets: integer
 *   ): base64Binary;
 * ```
 *
 * Parameters:
 *
 *   numberOfOctets - (integer) The number of random octets to generate.
 *
 * Returns:
 *
 *   (base64Binary)
 */
const afw_value_t *
afw_function_execute_random_base64Binary(
    afw_function_execute_t *x);

/** @brief Function definition random_digits */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_digits;

/**
 * @brief Adaptive Function `random_digits`
 * @param x function execute parameter.
 *
 * Generate a string containing a specified number of random decimal digits.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function random_digits(
 *       numberOfDigits: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   numberOfDigits - (integer) The number (1-18) of digits to generate.
 *
 * Returns:
 *
 *   (string)
 */
const afw_value_t *
afw_function_execute_random_digits(
    afw_function_execute_t *x);

/** @brief Function definition random_hexBinary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_hexBinary;

/**
 * @brief Adaptive Function `random_hexBinary`
 * @param x function execute parameter.
 *
 * This returns a specified number of random octets as dataType hexBinary.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function random_hexBinary(
 *       numberOfOctets: integer
 *   ): hexBinary;
 * ```
 *
 * Parameters:
 *
 *   numberOfOctets - (integer) The number of random octets to generate.
 *
 * Returns:
 *
 *   (hexBinary)
 */
const afw_value_t *
afw_function_execute_random_hexBinary(
    afw_function_execute_t *x);

/** @brief Function definition random_integer */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_integer;

/**
 * @brief Adaptive Function `random_integer`
 * @param x function execute parameter.
 *
 * This returns a random integer between specified values inclusive.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function random_integer(
 *       min: integer,
 *       max: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   min - (integer) Minimum integer inclusive.
 *
 *   max - (integer) Maximum integer inclusive.
 *
 * Returns:
 *
 *   (integer) A random integer.
 */
const afw_value_t *
afw_function_execute_random_integer(
    afw_function_execute_t *x);

/** @brief Function definition random_number */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_random_number;

/**
 * @brief Adaptive Function `random_number`
 * @param x function execute parameter.
 *
 * This returns a random double between specified values
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function random_number(
 *       min?: double,
 *       max?: double
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   min - (optional double) Minimum double inclusive. The default is 0.0.
 *
 *   max - (optional double) Maximum double exclusive. The default is 1.0.
 *
 * Returns:
 *
 *   (double)
 */
const afw_value_t *
afw_function_execute_random_number(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_regexp regexp functions
 *
 * regexp adaptive functions.
 *
 * @{
 */

/** @brief Function definition compile<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_regexp;

/**
 * @brief Adaptive Function `compile<regexp>`
 * @param x function execute parameter.
 *
 * Compile regexp value and return either an unevaluated adaptive value or a
 * string containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compile<regexp>(
 *       source: regexp,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (regexp) regexp string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_compile_regexp(
    afw_function_execute_t *x);

/** @brief Function definition eq<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_regexp;

/**
 * @brief Adaptive Function `eq<regexp>`
 * @param x function execute parameter.
 *
 * Determine if regexp arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<regexp>(
 *       arg1: regexp,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_regexp;

/**
 * @brief Adaptive Function `eqx<regexp>`
 * @param x function execute parameter.
 *
 * Determine if for regexp arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<regexp>(
 *       arg1: regexp,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_regexp;

/**
 * @brief Adaptive Function `ge<regexp>`
 * @param x function execute parameter.
 *
 * Checks for regexp arg1 is greater than or equal to regexp arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<regexp>(
 *       arg1: regexp,
 *       arg2: regexp
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (regexp)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_regexp;

/**
 * @brief Adaptive Function `gt<regexp>`
 * @param x function execute parameter.
 *
 * Checks for regexp arg1 is greater than regexp arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<regexp>(
 *       arg1: regexp,
 *       arg2: regexp
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (regexp)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition le<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_regexp;

/**
 * @brief Adaptive Function `le<regexp>`
 * @param x function execute parameter.
 *
 * Checks for regexp arg1 is less than or equal to regexp arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<regexp>(
 *       arg1: regexp,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_regexp;

/**
 * @brief Adaptive Function `lt<regexp>`
 * @param x function execute parameter.
 *
 * Checks for regexp arg1 is less that regexp arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<regexp>(
 *       arg1: regexp,
 *       arg2: regexp
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (regexp)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_regexp;

/**
 * @brief Adaptive Function `ne<regexp>`
 * @param x function execute parameter.
 *
 * Determine if regexp arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<regexp>(
 *       arg1: regexp,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<regexp> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_regexp;

/**
 * @brief Adaptive Function `nex<regexp>`
 * @param x function execute parameter.
 *
 * Determine if for regexp arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<regexp>(
 *       arg1: regexp,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (regexp)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition regexp */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp;

/**
 * @brief Adaptive Function `regexp`
 * @param x function execute parameter.
 *
 * Converts value to data type regexp returning regexp result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp(
 *       value: any
 *   ): regexp;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (regexp) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_relaxed_json relaxed_json functions
 *
 * relaxed_json adaptive functions.
 *
 * @{
 */

/** @brief Function definition compile<relaxed_json> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_relaxed_json;

/**
 * @brief Adaptive Function `compile<relaxed_json>`
 * @param x function execute parameter.
 *
 * Compile relaxed_json value and return either an unevaluated adaptive value or
 * a string containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compile<relaxed_json>(
 *       source: relaxed_json,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (relaxed_json) relaxed_json string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_compile_relaxed_json(
    afw_function_execute_t *x);

/** @brief Function definition relaxed_json */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_relaxed_json;

/**
 * @brief Adaptive Function `relaxed_json`
 * @param x function execute parameter.
 *
 * Converts value to data type relaxed_json returning relaxed_json result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function relaxed_json(
 *       value: any
 *   ): relaxed_json;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (relaxed_json) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_rfc822Name rfc822Name functions
 *
 * rfc822Name adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_rfc822Name;

/**
 * @brief Adaptive Function `at_least_one_member_of<rfc822Name>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in rfc822Name array1 is in
 * rfc822Name array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<rfc822Name>(
 *       array1: (array rfc822Name),
 *       array2: (array rfc822Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array rfc822Name) The first array.
 *
 *   array2 - (array rfc822Name) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_rfc822Name;

/**
 * @brief Adaptive Function `bag<rfc822Name>`
 * @param x function execute parameter.
 *
 * Takes any number of rfc822Name values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<rfc822Name>(
 *       ...values: (array of (array rfc822Name))
 *   ): (array rfc822Name);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array rfc822Name)
 *
 * Returns:
 *
 *   (array rfc822Name)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_rfc822Name;

/**
 * @brief Adaptive Function `bag_size<rfc822Name>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<rfc822Name>(
 *       value: (array rfc822Name)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array rfc822Name)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition eq<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_rfc822Name;

/**
 * @brief Adaptive Function `eq<rfc822Name>`
 * @param x function execute parameter.
 *
 * Determine if rfc822Name arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_rfc822Name;

/**
 * @brief Adaptive Function `eqx<rfc822Name>`
 * @param x function execute parameter.
 *
 * Determine if for rfc822Name arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_rfc822Name;

/**
 * @brief Adaptive Function `ge<rfc822Name>`
 * @param x function execute parameter.
 *
 * Checks for rfc822Name arg1 is greater than or equal to rfc822Name arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: rfc822Name
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (rfc822Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_rfc822Name;

/**
 * @brief Adaptive Function `gt<rfc822Name>`
 * @param x function execute parameter.
 *
 * Checks for rfc822Name arg1 is greater than rfc822Name arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: rfc822Name
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (rfc822Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_rfc822Name;

/**
 * @brief Adaptive Function `intersection<rfc822Name>`
 * @param x function execute parameter.
 *
 * Returns an array of rfc822Name with the values that are common to both array
 * of rfc822Name array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<rfc822Name>(
 *       array1: (array rfc822Name),
 *       array2: (array rfc822Name)
 *   ): (array rfc822Name);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array rfc822Name) The first array.
 *
 *   array2 - (array rfc822Name) The second array.
 *
 * Returns:
 *
 *   (array rfc822Name)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is_in<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_rfc822Name;

/**
 * @brief Adaptive Function `is_in<rfc822Name>`
 * @param x function execute parameter.
 *
 * Checks whether rfc822Name value is in array of rfc822Name array and returns
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<rfc822Name>(
 *       value: rfc822Name,
 *       array: (array rfc822Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (rfc822Name)
 *
 *   array - (array rfc822Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition is<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_rfc822Name;

/**
 * @brief Adaptive Function `is<rfc822Name>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType rfc822Name and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<rfc822Name>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_rfc822Name;

/**
 * @brief Adaptive Function `le<rfc822Name>`
 * @param x function execute parameter.
 *
 * Checks for rfc822Name arg1 is less than or equal to rfc822Name arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_rfc822Name;

/**
 * @brief Adaptive Function `lt<rfc822Name>`
 * @param x function execute parameter.
 *
 * Checks for rfc822Name arg1 is less that rfc822Name arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: rfc822Name
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (rfc822Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition match<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_match_rfc822Name;

/**
 * @brief Adaptive Function `match<rfc822Name>`
 * @param x function execute parameter.
 *
 * Returns true if arg1 matches some terminal sequence of RDNs from arg2 when
 * compared using equal_rfc822Name.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function match<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (string)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_match_rfc822Name(
    afw_function_execute_t *x);

/** @brief Function definition ne<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_rfc822Name;

/**
 * @brief Adaptive Function `ne<rfc822Name>`
 * @param x function execute parameter.
 *
 * Determine if rfc822Name arg1 is not equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_rfc822Name;

/**
 * @brief Adaptive Function `nex<rfc822Name>`
 * @param x function execute parameter.
 *
 * Determine if for rfc822Name arg1 is not equal to the value or data type of
 * arg2 then return the boolean result. Use 'ne' ('!=') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<rfc822Name>(
 *       arg1: rfc822Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (rfc822Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_rfc822Name;

/**
 * @brief Adaptive Function `one_and_only<rfc822Name>`
 * @param x function execute parameter.
 *
 * This converts an array of rfc822Name values that contains one value to a
 * single rfc822Name value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<rfc822Name>(
 *       array: (array array)
 *   ): rfc822Name;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (rfc822Name)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition regexp_match<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_rfc822Name;

/**
 * @brief Adaptive Function `regexp_match<rfc822Name>`
 * @param x function execute parameter.
 *
 * Checks whether rfc822Name value matches the regular expression regexp and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_match<rfc822Name>(
 *       value: rfc822Name,
 *       regexp: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (rfc822Name)
 *
 *   regexp - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_regexp_match()
 *
 * __________
 */

/** @brief Function definition rfc822Name */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_rfc822Name;

/**
 * @brief Adaptive Function `rfc822Name`
 * @param x function execute parameter.
 *
 * Converts value to data type rfc822Name returning rfc822Name result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function rfc822Name(
 *       value: any
 *   ): rfc822Name;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (rfc822Name) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition set_equals<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_rfc822Name;

/**
 * @brief Adaptive Function `set_equals<rfc822Name>`
 * @param x function execute parameter.
 *
 * Returns boolean true if rfc822Name array1 and rfc822Name array2 are subsets
 * of each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<rfc822Name>(
 *       array1: (array rfc822Name),
 *       array2: (array rfc822Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array rfc822Name)
 *
 *   array2 - (array rfc822Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_rfc822Name;

/**
 * @brief Adaptive Function `subset<rfc822Name>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in rfc822Name array1 are all in
 * rfc822Name array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<rfc822Name>(
 *       array1: (array rfc822Name),
 *       array2: (array rfc822Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array rfc822Name) The first array.
 *
 *   array2 - (array rfc822Name) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition to_string<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_rfc822Name;

/**
 * @brief Adaptive Function `to_string<rfc822Name>`
 * @param x function execute parameter.
 *
 * Converts rfc822Name value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<rfc822Name>(
 *       value: rfc822Name
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (rfc822Name) A rfc822Name value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<rfc822Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_rfc822Name;

/**
 * @brief Adaptive Function `union<rfc822Name>`
 * @param x function execute parameter.
 *
 * Returns an array of rfc822Name contains all of the unique values in two or
 * more array of rfc822Name values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<rfc822Name>(
 *       arrays_1: (array rfc822Name),
 *       arrays_2: (array rfc822Name),
 *       ...arrays_rest: (array of (array rfc822Name))
 *   ): (array rfc822Name);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array rfc822Name) Two or more arrays.
 *
 * Returns:
 *
 *   (array rfc822Name)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_script script functions
 *
 * script adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_script;

/**
 * @brief Adaptive Function `bag<script>`
 * @param x function execute parameter.
 *
 * Takes any number of script values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<script>(
 *       ...values: (array of (array script))
 *   ): (array script);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array script)
 *
 * Returns:
 *
 *   (array script)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition bag_size<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_script;

/**
 * @brief Adaptive Function `bag_size<script>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<script>(
 *       value: (array script)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array script)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition compile<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_script;

/**
 * @brief Adaptive Function `compile<script>`
 * @param x function execute parameter.
 *
 * Compile script value and return either an unevaluated adaptive value or a
 * string containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compile<script>(
 *       source: script,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (script) script string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_compile_script(
    afw_function_execute_t *x);

/** @brief Function definition eq<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_script;

/**
 * @brief Adaptive Function `eq<script>`
 * @param x function execute parameter.
 *
 * Determine if script arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<script>(
 *       arg1: script,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_script;

/**
 * @brief Adaptive Function `eqx<script>`
 * @param x function execute parameter.
 *
 * Determine if for script arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<script>(
 *       arg1: script,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition evaluate<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_script;

/**
 * @brief Adaptive Function `evaluate<script>`
 * @param x function execute parameter.
 *
 * Compile and evaluate script value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function evaluate<script>(
 *       source: script,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (script) script string to compile and evaluate.
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_evaluate_script(
    afw_function_execute_t *x);

/** @brief Function definition ge<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_script;

/**
 * @brief Adaptive Function `ge<script>`
 * @param x function execute parameter.
 *
 * Checks for script arg1 is greater than or equal to script arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<script>(
 *       arg1: script,
 *       arg2: script
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (script)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_script;

/**
 * @brief Adaptive Function `gt<script>`
 * @param x function execute parameter.
 *
 * Checks for script arg1 is greater than script arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<script>(
 *       arg1: script,
 *       arg2: script
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (script)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_script;

/**
 * @brief Adaptive Function `is<script>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType script and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<script>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_script;

/**
 * @brief Adaptive Function `le<script>`
 * @param x function execute parameter.
 *
 * Checks for script arg1 is less than or equal to script arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<script>(
 *       arg1: script,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_script;

/**
 * @brief Adaptive Function `lt<script>`
 * @param x function execute parameter.
 *
 * Checks for script arg1 is less that script arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<script>(
 *       arg1: script,
 *       arg2: script
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (script)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_script;

/**
 * @brief Adaptive Function `ne<script>`
 * @param x function execute parameter.
 *
 * Determine if script arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<script>(
 *       arg1: script,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<script> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_script;

/**
 * @brief Adaptive Function `nex<script>`
 * @param x function execute parameter.
 *
 * Determine if for script arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<script>(
 *       arg1: script,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (script)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition script */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_script;

/**
 * @brief Adaptive Function `script`
 * @param x function execute parameter.
 *
 * Converts value to data type script returning script result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function script(
 *       value: any
 *   ): script;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (script) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_stream stream functions
 *
 * stream adaptive functions.
 *
 * @{
 */

/** @brief Function definition close */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_close;

/**
 * @brief Adaptive Function `close`
 * @param x function execute parameter.
 *
 * This will close an open stream
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function close(
 *       streamNumber: integer
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) The streamNumber for the stream to close.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_close(
    afw_function_execute_t *x);

/** @brief Function definition flush */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_flush;

/**
 * @brief Adaptive Function `flush`
 * @param x function execute parameter.
 *
 * Write the content of the stream's buffers to its destination.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function flush(
 *       streamNumber: integer
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) The streamNumber for the stream to flush.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_flush(
    afw_function_execute_t *x);

/** @brief Function definition get_stream_error */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_get_stream_error;

/**
 * @brief Adaptive Function `get_stream_error`
 * @param x function execute parameter.
 *
 * Get the most recent stream error.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function get_stream_error(
 *   
 *   ): string;
 * ```
 *
 * Parameters:
 *
 * Returns:
 *
 *   (string) The most recent stream error.
 */
const afw_value_t *
afw_function_execute_get_stream_error(
    afw_function_execute_t *x);

/** @brief Function definition open_file */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_open_file;

/**
 * @brief Adaptive Function `open_file`
 * @param x function execute parameter.
 *
 * This will open a file stream.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function open_file(
 *       streamId: string,
 *       path: string,
 *       mode: string,
 *       autoFlush?: boolean
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   streamId - (string) This is the streamId that will be associated with this
 *       open file stream.
 *
 *   path - (string) This is the path to the file to open. The rootDirectory of
 *       the path is defined in the application object.
 *
 *   mode - (string) This is the access mode string. Values can be:
 *         r - Open an existing file text file for read.
 *         w - Open a text file for writing. If the file does not exist, it will
 *       be created.
 *         a - Open a text file for writing additional data to the end. If the
 *       file does not exist, it will be created.
 *         r+ - Open a text file for both reading and writing.
 *         w+ - Open a text file for both reading and writing. If the file
 *       exists, it will be overwritten. If the file does not exist, it will be
 *       created.
 *         a+ - Open a text file for both reading and writing. Reading will
 *       begin at the start of the file while writing will be appended to the
 *       end.
 * 
 *       All of these modes expect data type string. If you are using data type
 *       base64Binary or hexBinary you can use corresponding binary modes, 'rb',
 *       'wb', 'ab', 'rb+', 'r+b', 'wb+', 'w+b', 'ab+', and 'a+b'.
 *
 *   autoFlush - (optional boolean) If specified and true, this will
 *       automatically flush the stream's buffers after every write.
 *
 * Returns:
 *
 *   (integer) The streamNumber for the streamId or -1 if there was an error.
 *       Use get_stream_error() for error information.
 */
const afw_value_t *
afw_function_execute_open_file(
    afw_function_execute_t *x);

/** @brief Function definition open_response */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_open_response;

/**
 * @brief Adaptive Function `open_response`
 * @param x function execute parameter.
 *
 * This will open a response text write-only stream that will be written to the
 * http response.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function open_response(
 *       streamId: string,
 *       autoFlush?: boolean
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   streamId - (string) This is the streamId that will be associated with this
 *       open response stream.
 *
 *   autoFlush - (optional boolean) If specified and true, this will
 *       automatically flush the stream's buffers after every write.
 *
 * Returns:
 *
 *   (integer) The streamNumber for the streamId or -1 if there was an error.
 *       Use get_stream_error() for error information.
 */
const afw_value_t *
afw_function_execute_open_response(
    afw_function_execute_t *x);

/** @brief Function definition open_uri */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_open_uri;

/**
 * @brief Adaptive Function `open_uri`
 * @param x function execute parameter.
 *
 * This will open a read or write stream for a URI.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function open_uri(
 *       streamId: string,
 *       uri: string,
 *       mode: string,
 *       autoFlush?: boolean
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   streamId - (string) This is the streamId that will be associated with this
 *       open URI stream.
 *
 *   uri - (string) This is the URI of the stream to open.
 *
 *   mode - (string) This is the access mode string. Values can be 'r' for read
 *       or 'w' for write.
 *
 *   autoFlush - (optional boolean) If specified and true, this will
 *       automatically flush the stream's buffers after every write.
 *
 * Returns:
 *
 *   (integer) The streamNumber for the streamId or -1 if there was an error.
 *       Use get_stream_error() for error information.
 */
const afw_value_t *
afw_function_execute_open_uri(
    afw_function_execute_t *x);

/** @brief Function definition print */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_print;

/**
 * @brief Adaptive Function `print`
 * @param x function execute parameter.
 *
 * Evaluate and convert 0 or more values to its string value, then write them to
 * stdout. An undefined value is represented by 'undefined'.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function print(
 *       ...values: (array of any)
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more any dataType) Values to print.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_print(
    afw_function_execute_t *x);

/** @brief Function definition println */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_println;

/**
 * @brief Adaptive Function `println`
 * @param x function execute parameter.
 *
 * Evaluate and convert 0 or more values to their string value, then write them
 * to stdout. A newline character ('\n') is written after the last value. An
 * undefined value is represented by 'undefined'.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function println(
 *       ...value: (array of any)
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   value - (0 or more any dataType) Values to print.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_println(
    afw_function_execute_t *x);

/** @brief Function definition read */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_read;

/**
 * @brief Adaptive Function `read`
 * @param x function execute parameter.
 *
 * Read a UTF-8 text stream up to a specified number of octets. The stream must
 * contain valid UTF-8 or an error is thrown.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function read(
 *       streamNumber: integer,
 *       n: any
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) Stream number.
 *
 *   n - (any dataType) The maximum number of octets to read.
 *
 * Returns:
 *
 *   (string) The UTF-8 string read. Check the size of this value to determine
 *       the actual number of octets read.
 */
const afw_value_t *
afw_function_execute_read(
    afw_function_execute_t *x);

/** @brief Function definition read_to_base64Binary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_read_to_base64Binary;

/**
 * @brief Adaptive Function `read_to_base64Binary`
 * @param x function execute parameter.
 *
 * Read a stream up to a specified number of octets. The result will be the
 * internal memory of a base64Binary value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function read_to_base64Binary(
 *       streamNumber: integer,
 *       n: any
 *   ): base64Binary;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) Stream number.
 *
 *   n - (any dataType) The maximum number of octets to read.
 *
 * Returns:
 *
 *   (base64Binary) The base64Binary value read. Check the size of this value to
 *       determine the actual number of octets read.
 */
const afw_value_t *
afw_function_execute_read_to_base64Binary(
    afw_function_execute_t *x);

/** @brief Function definition read_to_hexBinary */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_read_to_hexBinary;

/**
 * @brief Adaptive Function `read_to_hexBinary`
 * @param x function execute parameter.
 *
 * Read a stream up to a specified number of octets. The result will be the
 * internal memory of a hexBinary value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function read_to_hexBinary(
 *       streamNumber: integer,
 *       n: any
 *   ): hexBinary;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) Stream number.
 *
 *   n - (any dataType) The maximum number of octets to read.
 *
 * Returns:
 *
 *   (hexBinary) The hexBinary value read. Check the size of this value to
 *       determine the actual number of octets read.
 */
const afw_value_t *
afw_function_execute_read_to_hexBinary(
    afw_function_execute_t *x);

/** @brief Function definition readln */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_readln;

/**
 * @brief Adaptive Function `readln`
 * @param x function execute parameter.
 *
 * Read a UTF-8 text stream line. The stream must contain valid UTF-8 or an
 * error is thrown.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function readln(
 *       streamNumber: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) Stream number.
 *
 * Returns:
 *
 *   (string) The UTF-8 string read.
 */
const afw_value_t *
afw_function_execute_readln(
    afw_function_execute_t *x);

/** @brief Function definition stream */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_stream;

/**
 * @brief Adaptive Function `stream`
 * @param x function execute parameter.
 *
 * This will return the streamNumber for a streamId. This function useful to
 * obtain the number of the automatically opened standard streams 'console',
 * 'stderr' and 'stdout' as well and any other open stream.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function stream(
 *       streamId: string
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   streamId - (string) The id of a stream.
 *
 * Returns:
 *
 *   (integer) The streamNumber for the streamId or -1 if there was an error.
 *       Use get_stream_error() for error information.
 */
const afw_value_t *
afw_function_execute_stream(
    afw_function_execute_t *x);

/** @brief Function definition write */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_write;

/**
 * @brief Adaptive Function `write`
 * @param x function execute parameter.
 *
 * Evaluate and convert 0 or more values to its string value, then write them to
 * stream. An value with an undefined value is represented by 'undefined'.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function write(
 *       streamNumber: integer,
 *       ...value: (array of any)
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) The streamNumber for the stream to write.
 *
 *   value - (0 or more any) Values to write as their string value.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_write(
    afw_function_execute_t *x);

/** @brief Function definition write_internal */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_write_internal;

/**
 * @brief Adaptive Function `write_internal`
 * @param x function execute parameter.
 *
 * Write a value's internal memory. This is especially useful for writing data
 * type base64Binary and hexBinary.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function write_internal(
 *       streamNumber: integer,
 *       value: any
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) The streamNumber for the stream to write.
 *
 *   value - (any) The internal memory of this value is written.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_write_internal(
    afw_function_execute_t *x);

/** @brief Function definition writeln */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_writeln;

/**
 * @brief Adaptive Function `writeln`
 * @param x function execute parameter.
 *
 * Evaluate and convert 0 or more values to its string value, then write them to
 * stream. A newline character ('\n') is written after the last value. An
 * undefined value is represented by 'undefined'.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters and has side effects.
 *
 * Declaration:
 *
 * ```
 *   function writeln(
 *       streamNumber: integer,
 *       ...value: (array of any)
 *   ): void;
 * ```
 *
 * Parameters:
 *
 *   streamNumber - (integer) The streamNumber for the stream to write.
 *
 *   value - (0 or more any dataType) Values to write.
 *
 * Returns:
 *
 *   (void)
 */
const afw_value_t *
afw_function_execute_writeln(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_string string functions
 *
 * string adaptive functions.
 *
 * @{
 */

/** @brief Function definition add<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_add_string;

/**
 * @brief Adaptive Function `add<string>`
 * @param x function execute parameter.
 *
 * Add (concatenate) a string with 1 or more values of any data type converted
 * to their string value and return the string result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function add<string>(
 *       string: string,
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   string - (string)
 *
 *   values - (1 or more any dataType)
 *
 * Returns:
 *
 *   (string)
 */
const afw_value_t *
afw_function_execute_add_string(
    afw_function_execute_t *x);

/** @brief Function definition at_least_one_member_of<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_string;

/**
 * @brief Adaptive Function `at_least_one_member_of<string>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in string array1 is in string
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<string>(
 *       array1: (array string),
 *       array2: (array string)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array string) The first array.
 *
 *   array2 - (array string) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag_size<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_string;

/**
 * @brief Adaptive Function `bag_size<string>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<string>(
 *       value: (array string)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array string)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition bag<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_string;

/**
 * @brief Adaptive Function `bag<string>`
 * @param x function execute parameter.
 *
 * Takes any number of string values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<string>(
 *       ...values: (array of (array string))
 *   ): (array string);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array string)
 *
 * Returns:
 *
 *   (array string)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition concat */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_concat;

/**
 * @brief Adaptive Function `concat`
 * @param x function execute parameter.
 *
 * Convert two or more values of any data type to string and return the
 * concatenated result. A value with an undefined value is represented by
 * 'undefined'.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function concat(
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more any dataType) Value to convert.
 *
 * Returns:
 *
 *   (string) The concatenated string values.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 */
const afw_value_t *
afw_function_execute_concat(
    afw_function_execute_t *x);

/** @brief Function definition encode_as_base64Binary<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_base64Binary_string;

/**
 * @brief Adaptive Function `encode_as_base64Binary<string>`
 * @param x function execute parameter.
 *
 * Encode a value as a base64Binary. The effect is to create a base64Binary
 * value with an internal value of the value passed.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function encode_as_base64Binary<string>(
 *       value: string
 *   ): base64Binary;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The string value to encode.
 *
 * Returns:
 *
 *   (base64Binary) A base64Binary value.
 *
 * Implemented by afw_function_execute_encode_as_base64Binary()
 *
 * __________
 */

/** @brief Function definition encode_as_hexBinary<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_encode_as_hexBinary_string;

/**
 * @brief Adaptive Function `encode_as_hexBinary<string>`
 * @param x function execute parameter.
 *
 * Encode a value as a hexBinary. The effect is to create a hexBinary value with
 * an internal value of the value passed.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function encode_as_hexBinary<string>(
 *       value: string
 *   ): hexBinary;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The string value to encode.
 *
 * Returns:
 *
 *   (hexBinary) A hexBinary value.
 *
 * Implemented by afw_function_execute_encode_as_hexBinary()
 *
 * __________
 */

/** @brief Function definition ends_with<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ends_with_string;

/**
 * @brief Adaptive Function `ends_with<string>`
 * @param x function execute parameter.
 *
 * Checks whether string value ends with a string and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ends_with<string>(
 *       value: string,
 *       subString: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 *   subString - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ends_with()
 *
 * __________
 */

/** @brief Function definition eq_ignore_case<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_ignore_case_string;

/**
 * @brief Adaptive Function `eq_ignore_case<string>`
 * @param x function execute parameter.
 *
 * Checks for string arg1 is equal to string arg2 ignoring case and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq_ignore_case<string>(
 *       arg1: string,
 *       arg2: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (string)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_eq_ignore_case_string(
    afw_function_execute_t *x);

/** @brief Function definition eq<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_string;

/**
 * @brief Adaptive Function `eq<string>`
 * @param x function execute parameter.
 *
 * Determine if string arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<string>(
 *       arg1: string,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_string;

/**
 * @brief Adaptive Function `eqx<string>`
 * @param x function execute parameter.
 *
 * Determine if for string arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<string>(
 *       arg1: string,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_string;

/**
 * @brief Adaptive Function `ge<string>`
 * @param x function execute parameter.
 *
 * Checks for string arg1 is greater than or equal to string arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<string>(
 *       arg1: string,
 *       arg2: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_string;

/**
 * @brief Adaptive Function `gt<string>`
 * @param x function execute parameter.
 *
 * Checks for string arg1 is greater than string arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<string>(
 *       arg1: string,
 *       arg2: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition includes<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_includes_string;

/**
 * @brief Adaptive Function `includes<string>`
 * @param x function execute parameter.
 *
 * Checks whether the string value includes a string and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function includes<string>(
 *       searchString: string,
 *       subString: string,
 *       position?: integer
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   searchString - (string) The string to search.
 *
 *   subString - (string) Substring to find.
 *
 *   position - (optional integer) Zero-based position in the search string to
 *       start search.
 *
 * Returns:
 *
 *   (boolean) Indicates if the substring is contained in the search string.
 *
 * Implemented by afw_function_execute_includes()
 *
 * __________
 */

/** @brief Function definition index_of<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_index_of_string;

/**
 * @brief Adaptive Function `index_of<string>`
 * @param x function execute parameter.
 *
 * Returns the zero-based index into string value of subString. If subString is
 * not found, -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function index_of<string>(
 *       value: string,
 *       subString: string,
 *       startIndex?: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The string value to search.
 *
 *   subString - (string) Substring to search for.
 *
 *   startIndex - (optional integer) Optional start index for search if
 *       different than start of string.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by afw_function_execute_index_of()
 *
 * __________
 */

/** @brief Function definition intersection<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_string;

/**
 * @brief Adaptive Function `intersection<string>`
 * @param x function execute parameter.
 *
 * Returns an array of string with the values that are common to both array of
 * string array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<string>(
 *       array1: (array string),
 *       array2: (array string)
 *   ): (array string);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array string) The first array.
 *
 *   array2 - (array string) The second array.
 *
 * Returns:
 *
 *   (array string)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is_in<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_string;

/**
 * @brief Adaptive Function `is_in<string>`
 * @param x function execute parameter.
 *
 * Checks whether string value is in array of string array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<string>(
 *       value: string,
 *       array: (array string)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 *   array - (array string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition is<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_string;

/**
 * @brief Adaptive Function `is<string>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType string and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<string>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition last_index_of<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_last_index_of_string;

/**
 * @brief Adaptive Function `last_index_of<string>`
 * @param x function execute parameter.
 *
 * Returns the zero-based index into string value of the last occurrence of a
 * subString. If subString is not found, -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function last_index_of<string>(
 *       value: string,
 *       subString: string,
 *       startIndex?: integer
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The string value to search.
 *
 *   subString - (string) Substring to search for.
 *
 *   startIndex - (optional integer) Optional start index for search if
 *       different than start of string.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by afw_function_execute_last_index_of()
 *
 * __________
 */

/** @brief Function definition le<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_string;

/**
 * @brief Adaptive Function `le<string>`
 * @param x function execute parameter.
 *
 * Checks for string arg1 is less than or equal to string arg2 and return the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<string>(
 *       arg1: string,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition length<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_length_string;

/**
 * @brief Adaptive Function `length<string>`
 * @param x function execute parameter.
 *
 * This is a polymorphic function where string can be any of the supported data
 * types. Return the integer number of entries in datatype array or codepoints
 * in others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function length<string>(
 *       value: string
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (string) Returns the number of entries in an array or code points
 *       in others.
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_length()
 *
 * __________
 */

/** @brief Function definition lt<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_string;

/**
 * @brief Adaptive Function `lt<string>`
 * @param x function execute parameter.
 *
 * Checks for string arg1 is less that string arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<string>(
 *       arg1: string,
 *       arg2: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition max<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_string;

/**
 * @brief Adaptive Function `max<string>`
 * @param x function execute parameter.
 *
 * Return the string value that is greater than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function max<string>(
 *       values_1: string,
 *       ...values_rest: (array of string)
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more string)
 *
 * Returns:
 *
 *   (string)
 *
 * Implemented by afw_function_execute_max()
 *
 * __________
 */

/** @brief Function definition min<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_string;

/**
 * @brief Adaptive Function `min<string>`
 * @param x function execute parameter.
 *
 * Return the string value that is less than or equal to the others.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function min<string>(
 *       values_1: string,
 *       ...values_rest: (array of string)
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more string)
 *
 * Returns:
 *
 *   (string)
 *
 * Implemented by afw_function_execute_min()
 *
 * __________
 */

/** @brief Function definition ne<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_string;

/**
 * @brief Adaptive Function `ne<string>`
 * @param x function execute parameter.
 *
 * Determine if string arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<string>(
 *       arg1: string,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_string;

/**
 * @brief Adaptive Function `nex<string>`
 * @param x function execute parameter.
 *
 * Determine if for string arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<string>(
 *       arg1: string,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (string)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition normalize_space<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_space_string;

/**
 * @brief Adaptive Function `normalize_space<string>`
 * @param x function execute parameter.
 *
 * Remove whitespace from the beginning and end of a string value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function normalize_space<string>(
 *       string: string
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   string - (string)
 *
 * Returns:
 *
 *   (string)
 */
const afw_value_t *
afw_function_execute_normalize_space_string(
    afw_function_execute_t *x);

/** @brief Function definition normalize_to_lower_case<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_normalize_to_lower_case_string;

/**
 * @brief Adaptive Function `normalize_to_lower_case<string>`
 * @param x function execute parameter.
 *
 * Normalize string value to lower case and returns string result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function normalize_to_lower_case<string>(
 *       string: string
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   string - (string)
 *
 * Returns:
 *
 *   (string)
 */
const afw_value_t *
afw_function_execute_normalize_to_lower_case_string(
    afw_function_execute_t *x);

/** @brief Function definition one_and_only<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_string;

/**
 * @brief Adaptive Function `one_and_only<string>`
 * @param x function execute parameter.
 *
 * This converts an array of string values that contains one value to a single
 * string value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<string>(
 *       array: (array array)
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (string)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition regexp_index_of<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_index_of_string;

/**
 * @brief Adaptive Function `regexp_index_of<string>`
 * @param x function execute parameter.
 *
 * Search string value for a regular expression and return index. If not found,
 * -1 is returned.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_index_of<string>(
 *       value: string,
 *       regexp: string
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The string value to search.
 *
 *   regexp - (string) A regular expression to use for search.
 *
 * Returns:
 *
 *   (integer) Zero-based index of subString or -1 if not found.
 *
 * Implemented by afw_function_execute_regexp_index_of()
 *
 * __________
 */

/** @brief Function definition regexp_match<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_string;

/**
 * @brief Adaptive Function `regexp_match<string>`
 * @param x function execute parameter.
 *
 * Checks whether string value matches the regular expression regexp and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_match<string>(
 *       value: string,
 *       regexp: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 *   regexp - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_regexp_match()
 *
 * __________
 */

/** @brief Function definition regexp_replace<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_replace_string;

/**
 * @brief Adaptive Function `regexp_replace<string>`
 * @param x function execute parameter.
 *
 * Replace matched values for a regular expression in a string value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_replace<string>(
 *       value: string,
 *       regexp: string,
 *       replacement: string,
 *       limit?: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The original string value.
 *
 *   regexp - (string) A regular expression to use for search.
 *
 *   replacement - (string) The replacement string.
 *
 *   limit - (optional integer) This is the maximum times to replace. The
 *       default is 1. Specify -1 to replace all occurrences.
 *
 * Returns:
 *
 *   (string) A string value with the matched string(s) replaced.
 *
 * Implemented by afw_function_execute_regexp_replace()
 *
 * __________
 */

/** @brief Function definition repeat<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_repeat_string;

/**
 * @brief Adaptive Function `repeat<string>`
 * @param x function execute parameter.
 *
 * Repeat a string value a specified number of times.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function repeat<string>(
 *       value: string,
 *       times: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The string value to repeat.
 *
 *   times - (integer) The number of times to repeat the value.
 *
 * Returns:
 *
 *   (string) The repeated string value.
 *
 * Implemented by afw_function_execute_repeat()
 *
 * __________
 */

/** @brief Function definition replace<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_replace_string;

/**
 * @brief Adaptive Function `replace<string>`
 * @param x function execute parameter.
 *
 * Replace string(s) in a string value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function replace<string>(
 *       value: string,
 *       match: string,
 *       replacement: string,
 *       limit?: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The original string value.
 *
 *   match - (string) The string to replace.
 *
 *   replacement - (string) The replacement string.
 *
 *   limit - (optional integer) This is the maximum times to replace. The
 *       default is 1. Specify -1 to replace all occurrences.
 *
 * Returns:
 *
 *   (string) A string value with the matched string(s) replaced.
 *
 * Implemented by afw_function_execute_replace()
 *
 * __________
 */

/** @brief Function definition set_equals<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_string;

/**
 * @brief Adaptive Function `set_equals<string>`
 * @param x function execute parameter.
 *
 * Returns boolean true if string array1 and string array2 are subsets of each
 * other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<string>(
 *       array1: (array string),
 *       array2: (array string)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array string)
 *
 *   array2 - (array string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition split<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_split_string;

/**
 * @brief Adaptive Function `split<string>`
 * @param x function execute parameter.
 *
 * Split string value into an array of strings using a separator.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function split<string>(
 *       value: string,
 *       separator?: string,
 *       limit?: integer
 *   ): array;
 * ```
 *
 * Parameters:
 *
 *   value - (string) The string value to split.
 *
 *   separator - (optional string) The separator to use. If this is an empty
 *       string or separator is not specified, the value is split between
 *       characters.
 *
 *   limit - (optional integer) This is the maximum number of splits. Any
 *       remaining part of value is ignored.
 *
 * Returns:
 *
 *   (array) An array of strings.
 *
 * Implemented by afw_function_execute_split()
 *
 * __________
 */

/** @brief Function definition starts_with<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_starts_with_string;

/**
 * @brief Adaptive Function `starts_with<string>`
 * @param x function execute parameter.
 *
 * Checks whether string value starts with a subString and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function starts_with<string>(
 *       value: string,
 *       subString: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 *   subString - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_starts_with()
 *
 * __________
 */

/** @brief Function definition string */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_string;

/**
 * @brief Adaptive Function `string`
 * @param x function execute parameter.
 *
 * Convert one or more values of any data type to string and return the
 * concatenated result. A value with an undefined value is represented by
 * 'undefined'.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function string(
 *       values_1: any,
 *       ...values_rest: (array of any)
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more any dataType) Value to convert.
 *
 * Returns:
 *
 *   (string) The concatenated string values.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 */
const afw_value_t *
afw_function_execute_string(
    afw_function_execute_t *x);

/** @brief Function definition subset<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_string;

/**
 * @brief Adaptive Function `subset<string>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in string array1 are all in string
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<string>(
 *       array1: (array string),
 *       array2: (array string)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array string) The first array.
 *
 *   array2 - (array string) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition substring<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_substring_string;

/**
 * @brief Adaptive Function `substring<string>`
 * @param x function execute parameter.
 *
 * Returns the string substring of value beginning at zero-based position
 * integer startIndex and ending at the position before integer endIndex.
 * Specify -1 or omitting endIndex to return up to end of string.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function substring<string>(
 *       string: string,
 *       startIndex: integer,
 *       endIndex?: integer
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   string - (string)
 *
 *   startIndex - (integer)
 *
 *   endIndex - (optional integer)
 *
 * Returns:
 *
 *   (string)
 *
 * Errors thrown:
 *
 *   arg_error - startIndex or endIndex is out of range
 *
 * Implemented by afw_function_execute_substring()
 *
 * __________
 */

/** @brief Function definition to_anyURI<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_anyURI_string;

/**
 * @brief Adaptive Function `to_anyURI<string>`
 * @param x function execute parameter.
 *
 * Converts string value to anyURI.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_anyURI<string>(
 *       value: string
 *   ): anyURI;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (anyURI)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_boolean<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_boolean_string;

/**
 * @brief Adaptive Function `to_boolean<string>`
 * @param x function execute parameter.
 *
 * Converts string value to boolean.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_boolean<string>(
 *       value: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_dateTime<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dateTime_string;

/**
 * @brief Adaptive Function `to_dateTime<string>`
 * @param x function execute parameter.
 *
 * Converts string value to dateTime.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_dateTime<string>(
 *       value: string
 *   ): dateTime;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (dateTime)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_date<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_date_string;

/**
 * @brief Adaptive Function `to_date<string>`
 * @param x function execute parameter.
 *
 * Converts string value to date.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_date<string>(
 *       value: string
 *   ): date;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (date)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_dayTimeDuration<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dayTimeDuration_string;

/**
 * @brief Adaptive Function `to_dayTimeDuration<string>`
 * @param x function execute parameter.
 *
 * Converts string value to dayTimeDuration.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_dayTimeDuration<string>(
 *       value: string
 *   ): dayTimeDuration;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (dayTimeDuration)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_dnsName<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_dnsName_string;

/**
 * @brief Adaptive Function `to_dnsName<string>`
 * @param x function execute parameter.
 *
 * Converts string value to dnsName.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_dnsName<string>(
 *       value: string
 *   ): dnsName;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (dnsName)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_double<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_double_string;

/**
 * @brief Adaptive Function `to_double<string>`
 * @param x function execute parameter.
 *
 * Converts string value to double and returns double result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_double<string>(
 *       value: string
 *   ): double;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (double)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_integer<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_integer_string;

/**
 * @brief Adaptive Function `to_integer<string>`
 * @param x function execute parameter.
 *
 * Truncate string value to a whole number and returns integer result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_integer<string>(
 *       value: string
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_ipAddress<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_ipAddress_string;

/**
 * @brief Adaptive Function `to_ipAddress<string>`
 * @param x function execute parameter.
 *
 * Converts string value to ipAddress.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_ipAddress<string>(
 *       value: string
 *   ): ipAddress;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (ipAddress)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_rfc822Name<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_rfc822Name_string;

/**
 * @brief Adaptive Function `to_rfc822Name<string>`
 * @param x function execute parameter.
 *
 * Converts string value to rfc822Name.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_rfc822Name<string>(
 *       value: string
 *   ): rfc822Name;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (rfc822Name)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_string<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_string;

/**
 * @brief Adaptive Function `to_string<string>`
 * @param x function execute parameter.
 *
 * Converts string value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<string>(
 *       value: string
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (string) A string value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_time<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_time_string;

/**
 * @brief Adaptive Function `to_time<string>`
 * @param x function execute parameter.
 *
 * Converts string value to time.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_time<string>(
 *       value: string
 *   ): time;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (time)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_x500Name<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_x500Name_string;

/**
 * @brief Adaptive Function `to_x500Name<string>`
 * @param x function execute parameter.
 *
 * Converts string value to x500Name.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_x500Name<string>(
 *       value: string
 *   ): x500Name;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (x500Name)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_yearMonthDuration<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_yearMonthDuration_string;

/**
 * @brief Adaptive Function `to_yearMonthDuration<string>`
 * @param x function execute parameter.
 *
 * Converts string value to yearMonthDuration.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_yearMonthDuration<string>(
 *       value: string
 *   ): yearMonthDuration;
 * ```
 *
 * Parameters:
 *
 *   value - (string)
 *
 * Returns:
 *
 *   (yearMonthDuration)
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_string;

/**
 * @brief Adaptive Function `union<string>`
 * @param x function execute parameter.
 *
 * Returns an array of string contains all of the unique values in two or more
 * array of string values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<string>(
 *       arrays_1: (array string),
 *       arrays_2: (array string),
 *       ...arrays_rest: (array of (array string))
 *   ): (array string);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array string) Two or more arrays.
 *
 * Returns:
 *
 *   (array string)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @brief Function definition url_decode */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_decode;

/**
 * @brief Adaptive Function `url_decode`
 * @param x function execute parameter.
 *
 * URL decode a value or bag of values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function url_decode(
 *       encoded: string
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   encoded - (string) URL decode a single string or a bag of string.
 *
 * Returns:
 *
 *   (string) A string or bag of strings.
 */
const afw_value_t *
afw_function_execute_url_decode(
    afw_function_execute_t *x);

/** @brief Function definition url_encode<string> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_url_encode_string;

/**
 * @brief Adaptive Function `url_encode<string>`
 * @param x function execute parameter.
 *
 * URL encode a value or bag of values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function url_encode<string>(
 *       unencoded: string
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   unencoded - (string) URL encode a single value. See the url_encode method
 *       for the data type of more details.
 *
 * Returns:
 *
 *   (string) URI encoded string.
 *
 * Implemented by afw_function_execute_url_encode()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_template template functions
 *
 * template adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag_size<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_template;

/**
 * @brief Adaptive Function `bag_size<template>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<template>(
 *       value: (array template)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array template)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition bag<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_template;

/**
 * @brief Adaptive Function `bag<template>`
 * @param x function execute parameter.
 *
 * Takes any number of template values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<template>(
 *       ...values: (array of (array template))
 *   ): (array template);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array template)
 *
 * Returns:
 *
 *   (array template)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition compile<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_template;

/**
 * @brief Adaptive Function `compile<template>`
 * @param x function execute parameter.
 *
 * Compile template value and return either an unevaluated adaptive value or a
 * string containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compile<template>(
 *       source: template,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (template) template string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_compile_template(
    afw_function_execute_t *x);

/** @brief Function definition eq<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_template;

/**
 * @brief Adaptive Function `eq<template>`
 * @param x function execute parameter.
 *
 * Determine if template arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<template>(
 *       arg1: template,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_template;

/**
 * @brief Adaptive Function `eqx<template>`
 * @param x function execute parameter.
 *
 * Determine if for template arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<template>(
 *       arg1: template,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition evaluate<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_template;

/**
 * @brief Adaptive Function `evaluate<template>`
 * @param x function execute parameter.
 *
 * Compile and evaluate template value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function evaluate<template>(
 *       source: template,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (template) template string to compile and evaluate.
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_evaluate_template(
    afw_function_execute_t *x);

/** @brief Function definition ge<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_template;

/**
 * @brief Adaptive Function `ge<template>`
 * @param x function execute parameter.
 *
 * Checks for template arg1 is greater than or equal to template arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<template>(
 *       arg1: template,
 *       arg2: template
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (template)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_template;

/**
 * @brief Adaptive Function `gt<template>`
 * @param x function execute parameter.
 *
 * Checks for template arg1 is greater than template arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<template>(
 *       arg1: template,
 *       arg2: template
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (template)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_template;

/**
 * @brief Adaptive Function `is<template>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType template and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<template>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_template;

/**
 * @brief Adaptive Function `le<template>`
 * @param x function execute parameter.
 *
 * Checks for template arg1 is less than or equal to template arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<template>(
 *       arg1: template,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_template;

/**
 * @brief Adaptive Function `lt<template>`
 * @param x function execute parameter.
 *
 * Checks for template arg1 is less that template arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<template>(
 *       arg1: template,
 *       arg2: template
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (template)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_template;

/**
 * @brief Adaptive Function `ne<template>`
 * @param x function execute parameter.
 *
 * Determine if template arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<template>(
 *       arg1: template,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_template;

/**
 * @brief Adaptive Function `nex<template>`
 * @param x function execute parameter.
 *
 * Determine if for template arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<template>(
 *       arg1: template,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (template)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition template */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_template;

/**
 * @brief Adaptive Function `template`
 * @param x function execute parameter.
 *
 * Converts value to data type template returning template result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function template(
 *       value: any
 *   ): template;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (template) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_string<template> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_template;

/**
 * @brief Adaptive Function `to_string<template>`
 * @param x function execute parameter.
 *
 * Converts template value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<template>(
 *       value: template
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (template) A template value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_time time functions
 *
 * time adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_time;

/**
 * @brief Adaptive Function `at_least_one_member_of<time>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in time array1 is in time array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<time>(
 *       array1: (array time),
 *       array2: (array time)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array time) The first array.
 *
 *   array2 - (array time) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag_size<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_time;

/**
 * @brief Adaptive Function `bag_size<time>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<time>(
 *       value: (array time)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array time)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition bag<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_time;

/**
 * @brief Adaptive Function `bag<time>`
 * @param x function execute parameter.
 *
 * Takes any number of time values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<time>(
 *       ...values: (array of (array time))
 *   ): (array time);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array time)
 *
 * Returns:
 *
 *   (array time)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition eq<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_time;

/**
 * @brief Adaptive Function `eq<time>`
 * @param x function execute parameter.
 *
 * Determine if time arg1 is equal to the value of arg2 converted to the data
 * type of arg1 then return the boolean result. Use 'eqx' ('===') instead if you
 * want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<time>(
 *       arg1: time,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_time;

/**
 * @brief Adaptive Function `eqx<time>`
 * @param x function execute parameter.
 *
 * Determine if for time arg1 is equal to the value and data type of arg2 then
 * return the boolean result. Use 'eq' ('==') instead if you want arg2 to be
 * converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<time>(
 *       arg1: time,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_time;

/**
 * @brief Adaptive Function `ge<time>`
 * @param x function execute parameter.
 *
 * Checks for time arg1 is greater than or equal to time arg2 and return the
 * boolean result.
 * 
 * It is illegal to compare a time that includes a time-zone value with one that
 * does not. In such cases, the `in_range<time>` function should be used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<time>(
 *       arg1: time,
 *       arg2: time
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (time)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_time;

/**
 * @brief Adaptive Function `gt<time>`
 * @param x function execute parameter.
 *
 * Checks for time arg1 is greater than time arg2 and return the boolean result.
 * 
 * It is illegal to compare a time that includes a time-zone value with one that
 * does not. In such cases, the `in_range<time>` function should be used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<time>(
 *       arg1: time,
 *       arg2: time
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (time)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition in_range<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_in_range_time;

/**
 * @brief Adaptive Function `in_range<time>`
 * @param x function execute parameter.
 *
 * Checks if time is between startTime and endTime, inclusive. Regardless of
 * endTime value, it is always considered to be equal to, but less than 24 hours
 * greater than startTime. If no time zone is specified for time, the default
 * time zone is used. If no time zone is specified for startTime or endTime, the
 * time zone of time is used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function in_range<time>(
 *       time: time,
 *       startTime: time,
 *       endTime: time
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   time - (time)
 *
 *   startTime - (time)
 *
 *   endTime - (time)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_in_range_time(
    afw_function_execute_t *x);

/** @brief Function definition intersection<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_time;

/**
 * @brief Adaptive Function `intersection<time>`
 * @param x function execute parameter.
 *
 * Returns an array of time with the values that are common to both array of
 * time array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<time>(
 *       array1: (array time),
 *       array2: (array time)
 *   ): (array time);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array time) The first array.
 *
 *   array2 - (array time) The second array.
 *
 * Returns:
 *
 *   (array time)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is_in<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_time;

/**
 * @brief Adaptive Function `is_in<time>`
 * @param x function execute parameter.
 *
 * Checks whether time value is in array of time array and returns the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<time>(
 *       value: time,
 *       array: (array time)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (time)
 *
 *   array - (array time)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition is<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_time;

/**
 * @brief Adaptive Function `is<time>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType time and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<time>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_time;

/**
 * @brief Adaptive Function `le<time>`
 * @param x function execute parameter.
 *
 * Checks for time arg1 is less than or equal to time arg2 and return the
 * boolean result.
 * 
 * It is illegal to compare a time that includes a time-zone value with one that
 * does not. In such cases, the `in_range<time>` function should be used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<time>(
 *       arg1: time,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_time;

/**
 * @brief Adaptive Function `lt<time>`
 * @param x function execute parameter.
 *
 * Checks for time arg1 is less that time arg2 and return the boolean result.
 * 
 * It is illegal to compare a time that includes a time-zone value with one that
 * does not. In such cases, the `in_range<time>` function should be used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<time>(
 *       arg1: time,
 *       arg2: time
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (time)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition max<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_max_time;

/**
 * @brief Adaptive Function `max<time>`
 * @param x function execute parameter.
 *
 * Return the time value that is greater than or equal to the others.
 * 
 * It is illegal to compare a time that includes a time-zone value with one that
 * does not. In such cases, the `in_range<time>` function should be used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function max<time>(
 *       values_1: time,
 *       ...values_rest: (array of time)
 *   ): time;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more time)
 *
 * Returns:
 *
 *   (time)
 *
 * Implemented by afw_function_execute_max()
 *
 * __________
 */

/** @brief Function definition min<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_min_time;

/**
 * @brief Adaptive Function `min<time>`
 * @param x function execute parameter.
 *
 * Return the time value that is less than or equal to the others.
 * 
 * It is illegal to compare a time that includes a time-zone value with one that
 * does not. In such cases, the `in_range<time>` function should be used.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function min<time>(
 *       values_1: time,
 *       ...values_rest: (array of time)
 *   ): time;
 * ```
 *
 * Parameters:
 *
 *   values - (1 or more time)
 *
 * Returns:
 *
 *   (time)
 *
 * Implemented by afw_function_execute_min()
 *
 * __________
 */

/** @brief Function definition ne<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_time;

/**
 * @brief Adaptive Function `ne<time>`
 * @param x function execute parameter.
 *
 * Determine if time arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<time>(
 *       arg1: time,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_time;

/**
 * @brief Adaptive Function `nex<time>`
 * @param x function execute parameter.
 *
 * Determine if for time arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<time>(
 *       arg1: time,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (time)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_time;

/**
 * @brief Adaptive Function `one_and_only<time>`
 * @param x function execute parameter.
 *
 * This converts an array of time values that contains one value to a single
 * time value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<time>(
 *       array: (array array)
 *   ): time;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (time)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_time;

/**
 * @brief Adaptive Function `set_equals<time>`
 * @param x function execute parameter.
 *
 * Returns boolean true if time array1 and time array2 are subsets of each other
 * and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<time>(
 *       array1: (array time),
 *       array2: (array time)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array time)
 *
 *   array2 - (array time)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_time;

/**
 * @brief Adaptive Function `subset<time>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in time array1 are all in time
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<time>(
 *       array1: (array time),
 *       array2: (array time)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array time) The first array.
 *
 *   array2 - (array time) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition time */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_time;

/**
 * @brief Adaptive Function `time`
 * @param x function execute parameter.
 *
 * Converts value to data type time returning time result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function time(
 *       value: any
 *   ): time;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (time) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition to_string<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_time;

/**
 * @brief Adaptive Function `to_string<time>`
 * @param x function execute parameter.
 *
 * Converts time value to string. For array values, the to_string() value for
 * each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<time>(
 *       value: time
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (time) A time value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<time> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_time;

/**
 * @brief Adaptive Function `union<time>`
 * @param x function execute parameter.
 *
 * Returns an array of time contains all of the unique values in two or more
 * array of time values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<time>(
 *       arrays_1: (array time),
 *       arrays_2: (array time),
 *       ...arrays_rest: (array of (array time))
 *   ): (array time);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array time) Two or more arrays.
 *
 * Returns:
 *
 *   (array time)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_unevaluated unevaluated functions
 *
 * unevaluated adaptive functions.
 *
 * @{
 */

/** @brief Function definition is<unevaluated> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_unevaluated;

/**
 * @brief Adaptive Function `is<unevaluated>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType unevaluated and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<unevaluated>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_value value functions
 *
 * value adaptive functions.
 *
 * @{
 */

/** @brief Function definition meta */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_meta;

/**
 * @brief Adaptive Function `meta`
 * @param x function execute parameter.
 *
 * This function returns an object containing meta information for an adaptive
 * value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function meta(
 *       value: any
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) This is the adaptive value whose meta object is to
 *       be returned.
 *
 * Returns:
 *
 *   (object) An object containing the meta information for the adaptive value.
 *       The objectType of this object is normally _AdaptiveValueMeta_ or one of
 *       its descendants.
 */
const afw_value_t *
afw_function_execute_meta(
    afw_function_execute_t *x);

/** @brief Function definition metas */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_metas;

/**
 * @brief Adaptive Function `metas`
 * @param x function execute parameter.
 *
 * This function returns an array of the result of calling meta() for each value
 * in an array or object adaptive value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function metas(
 *       value: any
 *   ): object;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) This is an adaptive array or object.
 *
 * Returns:
 *
 *   (object) An array containing the result of calling meta() of each value in
 *       array or object adaptive value.
 */
const afw_value_t *
afw_function_execute_metas(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_x500Name x500Name functions
 *
 * x500Name adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_x500Name;

/**
 * @brief Adaptive Function `at_least_one_member_of<x500Name>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in x500Name array1 is in x500Name
 * array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<x500Name>(
 *       array1: (array x500Name),
 *       array2: (array x500Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array x500Name) The first array.
 *
 *   array2 - (array x500Name) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag_size<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_x500Name;

/**
 * @brief Adaptive Function `bag_size<x500Name>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<x500Name>(
 *       value: (array x500Name)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array x500Name)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition bag<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_x500Name;

/**
 * @brief Adaptive Function `bag<x500Name>`
 * @param x function execute parameter.
 *
 * Takes any number of x500Name values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<x500Name>(
 *       ...values: (array of (array x500Name))
 *   ): (array x500Name);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array x500Name)
 *
 * Returns:
 *
 *   (array x500Name)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition eq<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_x500Name;

/**
 * @brief Adaptive Function `eq<x500Name>`
 * @param x function execute parameter.
 *
 * Determine if x500Name arg1 is equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'eqx' ('===') instead
 * if you want false to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<x500Name>(
 *       arg1: x500Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_x500Name;

/**
 * @brief Adaptive Function `eqx<x500Name>`
 * @param x function execute parameter.
 *
 * Determine if for x500Name arg1 is equal to the value and data type of arg2
 * then return the boolean result. Use 'eq' ('==') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<x500Name>(
 *       arg1: x500Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_x500Name;

/**
 * @brief Adaptive Function `ge<x500Name>`
 * @param x function execute parameter.
 *
 * Checks for x500Name arg1 is greater than or equal to x500Name arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<x500Name>(
 *       arg1: x500Name,
 *       arg2: x500Name
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (x500Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_x500Name;

/**
 * @brief Adaptive Function `gt<x500Name>`
 * @param x function execute parameter.
 *
 * Checks for x500Name arg1 is greater than x500Name arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<x500Name>(
 *       arg1: x500Name,
 *       arg2: x500Name
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (x500Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_x500Name;

/**
 * @brief Adaptive Function `intersection<x500Name>`
 * @param x function execute parameter.
 *
 * Returns an array of x500Name with the values that are common to both array of
 * x500Name array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<x500Name>(
 *       array1: (array x500Name),
 *       array2: (array x500Name)
 *   ): (array x500Name);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array x500Name) The first array.
 *
 *   array2 - (array x500Name) The second array.
 *
 * Returns:
 *
 *   (array x500Name)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is_in<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_x500Name;

/**
 * @brief Adaptive Function `is_in<x500Name>`
 * @param x function execute parameter.
 *
 * Checks whether x500Name value is in array of x500Name array and returns the
 * boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<x500Name>(
 *       value: x500Name,
 *       array: (array x500Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (x500Name)
 *
 *   array - (array x500Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition is<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_x500Name;

/**
 * @brief Adaptive Function `is<x500Name>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType x500Name and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<x500Name>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_x500Name;

/**
 * @brief Adaptive Function `le<x500Name>`
 * @param x function execute parameter.
 *
 * Checks for x500Name arg1 is less than or equal to x500Name arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<x500Name>(
 *       arg1: x500Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_x500Name;

/**
 * @brief Adaptive Function `lt<x500Name>`
 * @param x function execute parameter.
 *
 * Checks for x500Name arg1 is less that x500Name arg2 and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<x500Name>(
 *       arg1: x500Name,
 *       arg2: x500Name
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (x500Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition match<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_match_x500Name;

/**
 * @brief Adaptive Function `match<x500Name>`
 * @param x function execute parameter.
 *
 * Returns true if arg1 matches some terminal sequence of RDNs from arg2 when
 * compared using equal_x500Name.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function match<x500Name>(
 *       arg1: x500Name,
 *       arg2: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (string)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_match_x500Name(
    afw_function_execute_t *x);

/** @brief Function definition ne<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_x500Name;

/**
 * @brief Adaptive Function `ne<x500Name>`
 * @param x function execute parameter.
 *
 * Determine if x500Name arg1 is not equal to the value of arg2 converted to the
 * data type of arg1 then return the boolean result. Use 'nex' ('!==') instead
 * if you want true to be returned if arg1 and arg2's data type don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<x500Name>(
 *       arg1: x500Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_x500Name;

/**
 * @brief Adaptive Function `nex<x500Name>`
 * @param x function execute parameter.
 *
 * Determine if for x500Name arg1 is not equal to the value or data type of arg2
 * then return the boolean result. Use 'ne' ('!=') instead if you want arg2 to
 * be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<x500Name>(
 *       arg1: x500Name,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (x500Name)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_x500Name;

/**
 * @brief Adaptive Function `one_and_only<x500Name>`
 * @param x function execute parameter.
 *
 * This converts an array of x500Name values that contains one value to a single
 * x500Name value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<x500Name>(
 *       array: (array array)
 *   ): x500Name;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (x500Name)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition regexp_match<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_regexp_match_x500Name;

/**
 * @brief Adaptive Function `regexp_match<x500Name>`
 * @param x function execute parameter.
 *
 * Checks whether x500Name value matches the regular expression regexp and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function regexp_match<x500Name>(
 *       value: x500Name,
 *       regexp: string
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (x500Name)
 *
 *   regexp - (string)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_regexp_match()
 *
 * __________
 */

/** @brief Function definition set_equals<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_x500Name;

/**
 * @brief Adaptive Function `set_equals<x500Name>`
 * @param x function execute parameter.
 *
 * Returns boolean true if x500Name array1 and x500Name array2 are subsets of
 * each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<x500Name>(
 *       array1: (array x500Name),
 *       array2: (array x500Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array x500Name)
 *
 *   array2 - (array x500Name)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_x500Name;

/**
 * @brief Adaptive Function `subset<x500Name>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in x500Name array1 are all in
 * x500Name array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<x500Name>(
 *       array1: (array x500Name),
 *       array2: (array x500Name)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array x500Name) The first array.
 *
 *   array2 - (array x500Name) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition to_string<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_x500Name;

/**
 * @brief Adaptive Function `to_string<x500Name>`
 * @param x function execute parameter.
 *
 * Converts x500Name value to string. For array values, the to_string() value
 * for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<x500Name>(
 *       value: x500Name
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (x500Name) A x500Name value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<x500Name> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_x500Name;

/**
 * @brief Adaptive Function `union<x500Name>`
 * @param x function execute parameter.
 *
 * Returns an array of x500Name contains all of the unique values in two or more
 * array of x500Name values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<x500Name>(
 *       arrays_1: (array x500Name),
 *       arrays_2: (array x500Name),
 *       ...arrays_rest: (array of (array x500Name))
 *   ): (array x500Name);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array x500Name) Two or more arrays.
 *
 * Returns:
 *
 *   (array x500Name)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @brief Function definition x500Name */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_x500Name;

/**
 * @brief Adaptive Function `x500Name`
 * @param x function execute parameter.
 *
 * Converts value to data type x500Name returning x500Name result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function x500Name(
 *       value: any
 *   ): x500Name;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (x500Name) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_xml xml functions
 *
 * xml adaptive functions.
 *
 * @{
 */

/** @brief Function definition compile<xml> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_xml;

/**
 * @brief Adaptive Function `compile<xml>`
 * @param x function execute parameter.
 *
 * Compile xml value and return either an unevaluated adaptive value or a string
 * containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compile<xml>(
 *       source: xml,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (xml) xml string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_compile_xml(
    afw_function_execute_t *x);

/** @brief Function definition xml */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xml;

/**
 * @brief Adaptive Function `xml`
 * @param x function execute parameter.
 *
 * Converts value to data type xml returning xml result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function xml(
 *       value: any
 *   ): xml;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (xml) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @} */


/** @addtogroup afw_functions_xpathExpression xpathExpression functions
 *
 * xpathExpression adaptive functions.
 *
 * @{
 */

/** @brief Function definition bag_size<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_xpathExpression;

/**
 * @brief Adaptive Function `bag_size<xpathExpression>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<xpathExpression>(
 *       value: (array xpathExpression)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array xpathExpression)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition bag<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_xpathExpression;

/**
 * @brief Adaptive Function `bag<xpathExpression>`
 * @param x function execute parameter.
 *
 * Takes any number of xpathExpression values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<xpathExpression>(
 *       ...values: (array of (array xpathExpression))
 *   ): (array xpathExpression);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array xpathExpression)
 *
 * Returns:
 *
 *   (array xpathExpression)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition compile<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_compile_xpathExpression;

/**
 * @brief Adaptive Function `compile<xpathExpression>`
 * @param x function execute parameter.
 *
 * Compile xpathExpression value and return either an unevaluated adaptive value
 * or a string containing the compiler listing.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function compile<xpathExpression>(
 *       source: xpathExpression,
 *       listing?: any
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (xpathExpression) xpathExpression string to compile.
 *
 *   listing - (optional any dataType) If specified, a compiler listing is
 *       produced instead of an unevaluated compiled value.
 * 
 *       This parameter can be an integer between 0 and 10 of a string that is
 *       used for indentation. If 0 is specified, no whitespace is added to the
 *       resulting string. If 1 through 10 is specified, that number of spaces
 *       is used.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_compile_xpathExpression(
    afw_function_execute_t *x);

/** @brief Function definition eq<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_xpathExpression;

/**
 * @brief Adaptive Function `eq<xpathExpression>`
 * @param x function execute parameter.
 *
 * Determine if xpathExpression arg1 is equal to the value of arg2 converted to
 * the data type of arg1 then return the boolean result. Use 'eqx' ('===')
 * instead if you want false to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_xpathExpression;

/**
 * @brief Adaptive Function `eqx<xpathExpression>`
 * @param x function execute parameter.
 *
 * Determine if for xpathExpression arg1 is equal to the value and data type of
 * arg2 then return the boolean result. Use 'eq' ('==') instead if you want arg2
 * to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition evaluate<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_evaluate_xpathExpression;

/**
 * @brief Adaptive Function `evaluate<xpathExpression>`
 * @param x function execute parameter.
 *
 * Compile and evaluate xpathExpression value.
 *
 * This function is not pure, so it may return a different result
 * given exactly the same parameters.
 *
 * Declaration:
 *
 * ```
 *   function evaluate<xpathExpression>(
 *       source: xpathExpression,
 *       additionalUntrustedQualifiedVariables?: (object _AdaptiveTemplatePropertiesObjects_)
 *   ): unevaluated;
 * ```
 *
 * Parameters:
 *
 *   source - (xpathExpression) xpathExpression string to compile and evaluate.
 *
 *   additionalUntrustedQualifiedVariables - (optional object
 *       _AdaptiveTemplatePropertiesObjects_) This parameter supplies additional
 *       qualified variables that can be accessed during evaluation. These
 *       variables will not be used by anything that needs to ensure its
 *       qualified variables must come from a trusted source, such as
 *       authorization. This parameter is intended to be used for testing only
 *       and should not be used for anything running in production.
 *
 * Returns:
 *
 *   (unevaluated)
 */
const afw_value_t *
afw_function_execute_evaluate_xpathExpression(
    afw_function_execute_t *x);

/** @brief Function definition ge<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_xpathExpression;

/**
 * @brief Adaptive Function `ge<xpathExpression>`
 * @param x function execute parameter.
 *
 * Checks for xpathExpression arg1 is greater than or equal to xpathExpression
 * arg2 and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: xpathExpression
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (xpathExpression)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_xpathExpression;

/**
 * @brief Adaptive Function `gt<xpathExpression>`
 * @param x function execute parameter.
 *
 * Checks for xpathExpression arg1 is greater than xpathExpression arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: xpathExpression
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (xpathExpression)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition is<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_xpathExpression;

/**
 * @brief Adaptive Function `is<xpathExpression>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType xpathExpression and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<xpathExpression>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_xpathExpression;

/**
 * @brief Adaptive Function `le<xpathExpression>`
 * @param x function execute parameter.
 *
 * Checks for xpathExpression arg1 is less than or equal to xpathExpression arg2
 * and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_xpathExpression;

/**
 * @brief Adaptive Function `lt<xpathExpression>`
 * @param x function execute parameter.
 *
 * Checks for xpathExpression arg1 is less that xpathExpression arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: xpathExpression
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (xpathExpression)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_xpathExpression;

/**
 * @brief Adaptive Function `ne<xpathExpression>`
 * @param x function execute parameter.
 *
 * Determine if xpathExpression arg1 is not equal to the value of arg2 converted
 * to the data type of arg1 then return the boolean result. Use 'nex' ('!==')
 * instead if you want true to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_xpathExpression;

/**
 * @brief Adaptive Function `nex<xpathExpression>`
 * @param x function execute parameter.
 *
 * Determine if for xpathExpression arg1 is not equal to the value or data type
 * of arg2 then return the boolean result. Use 'ne' ('!=') instead if you want
 * arg2 to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<xpathExpression>(
 *       arg1: xpathExpression,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition to_string<xpathExpression> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_xpathExpression;

/**
 * @brief Adaptive Function `to_string<xpathExpression>`
 * @param x function execute parameter.
 *
 * Converts xpathExpression value to string. For array values, the to_string()
 * value for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<xpathExpression>(
 *       value: xpathExpression
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (xpathExpression) A xpathExpression value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition xpathExpression */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpathExpression;

/**
 * @brief Adaptive Function `xpathExpression`
 * @param x function execute parameter.
 *
 * Converts value to data type xpathExpression returning xpathExpression result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function xpathExpression(
 *       value: any
 *   ): xpathExpression;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (xpathExpression) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition xpath_node_count */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpath_node_count;

/**
 * @brief Adaptive Function `xpath_node_count`
 * @param x function execute parameter.
 *
 * The number of nodes in a node-set.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function xpath_node_count(
 *       nodeset: xpathExpression
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   nodeset - (xpathExpression)
 *
 * Returns:
 *
 *   (integer)
 */
const afw_value_t *
afw_function_execute_xpath_node_count(
    afw_function_execute_t *x);

/** @brief Function definition xpath_node_eq */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpath_node_eq;

/**
 * @brief Adaptive Function `xpath_node_eq`
 * @param x function execute parameter.
 *
 * Checks for xpathExpression arg1 is equal to xpathExpression arg2 and return
 * the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function xpath_node_eq(
 *       arg1: xpathExpression,
 *       arg2: xpathExpression
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (xpathExpression)
 *
 *   arg2 - (xpathExpression)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_xpath_node_eq(
    afw_function_execute_t *x);

/** @brief Function definition xpath_node_match */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_xpath_node_match;

/**
 * @brief Adaptive Function `xpath_node_match`
 * @param x function execute parameter.
 *
 * Returns true if any of the nodes matched by nodeset1 are equal to any of the
 * nodes matched by nodeset2 or their corresponding children.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function xpath_node_match(
 *       nodeset2: xpathExpression,
 *       arg2: xpathExpression
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   nodeset2 - (xpathExpression)
 *
 *   arg2 - (xpathExpression)
 *
 * Returns:
 *
 *   (boolean)
 */
const afw_value_t *
afw_function_execute_xpath_node_match(
    afw_function_execute_t *x);

/** @} */


/** @addtogroup afw_functions_yearMonthDuration yearMonthDuration functions
 *
 * yearMonthDuration adaptive functions.
 *
 * @{
 */

/** @brief Function definition at_least_one_member_of<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_at_least_one_member_of_yearMonthDuration;

/**
 * @brief Adaptive Function `at_least_one_member_of<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Returns boolean true if at least one value in yearMonthDuration array1 is in
 * yearMonthDuration array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function at_least_one_member_of<yearMonthDuration>(
 *       array1: (array yearMonthDuration),
 *       array2: (array yearMonthDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array yearMonthDuration) The first array.
 *
 *   array2 - (array yearMonthDuration) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_at_least_one_member_of()
 *
 * __________
 */

/** @brief Function definition bag_size<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_size_yearMonthDuration;

/**
 * @brief Adaptive Function `bag_size<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * This returns the integer number of values in array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag_size<yearMonthDuration>(
 *       value: (array yearMonthDuration)
 *   ): integer;
 * ```
 *
 * Parameters:
 *
 *   value - (array yearMonthDuration)
 *
 * Returns:
 *
 *   (integer)
 *
 * Implemented by afw_function_execute_bag_size()
 *
 * __________
 */

/** @brief Function definition bag<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_bag_yearMonthDuration;

/**
 * @brief Adaptive Function `bag<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Takes any number of yearMonthDuration values and returns an array of array.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function bag<yearMonthDuration>(
 *       ...values: (array of (array yearMonthDuration))
 *   ): (array yearMonthDuration);
 * ```
 *
 * Parameters:
 *
 *   values - (0 or more array yearMonthDuration)
 *
 * Returns:
 *
 *   (array yearMonthDuration)
 *
 * Implemented by afw_function_execute_bag()
 *
 * __________
 */

/** @brief Function definition eq<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eq_yearMonthDuration;

/**
 * @brief Adaptive Function `eq<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Determine if yearMonthDuration arg1 is equal to the value of arg2 converted
 * to the data type of arg1 then return the boolean result. Use 'eqx' ('===')
 * instead if you want false to be returned if arg1 and arg2's data type don't
 * match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eq<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_eq()
 *
 * __________
 */

/** @brief Function definition eqx<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_eqx_yearMonthDuration;

/**
 * @brief Adaptive Function `eqx<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Determine if for yearMonthDuration arg1 is equal to the value and data type
 * of arg2 then return the boolean result. Use 'eq' ('==') instead if you want
 * arg2 to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function eqx<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_eqx()
 *
 * __________
 */

/** @brief Function definition ge<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ge_yearMonthDuration;

/**
 * @brief Adaptive Function `ge<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Checks for yearMonthDuration arg1 is greater than or equal to
 * yearMonthDuration arg2 and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ge<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: yearMonthDuration
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_ge()
 *
 * __________
 */

/** @brief Function definition gt<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_gt_yearMonthDuration;

/**
 * @brief Adaptive Function `gt<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Checks for yearMonthDuration arg1 is greater than yearMonthDuration arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function gt<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: yearMonthDuration
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_gt()
 *
 * __________
 */

/** @brief Function definition intersection<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_intersection_yearMonthDuration;

/**
 * @brief Adaptive Function `intersection<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Returns an array of yearMonthDuration with the values that are common to both
 * array of yearMonthDuration array1 and array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function intersection<yearMonthDuration>(
 *       array1: (array yearMonthDuration),
 *       array2: (array yearMonthDuration)
 *   ): (array yearMonthDuration);
 * ```
 *
 * Parameters:
 *
 *   array1 - (array yearMonthDuration) The first array.
 *
 *   array2 - (array yearMonthDuration) The second array.
 *
 * Returns:
 *
 *   (array yearMonthDuration)
 *
 * Implemented by afw_function_execute_intersection()
 *
 * __________
 */

/** @brief Function definition is_in<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_in_yearMonthDuration;

/**
 * @brief Adaptive Function `is_in<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Checks whether yearMonthDuration value is in array of yearMonthDuration array
 * and returns the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is_in<yearMonthDuration>(
 *       value: yearMonthDuration,
 *       array: (array yearMonthDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (yearMonthDuration)
 *
 *   array - (array yearMonthDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is_in()
 *
 * __________
 */

/** @brief Function definition is<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_is_yearMonthDuration;

/**
 * @brief Adaptive Function `is<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Checks whether value is dataType yearMonthDuration and return the boolean
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function is<yearMonthDuration>(
 *       value: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to check.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_is()
 *
 * __________
 */

/** @brief Function definition le<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_le_yearMonthDuration;

/**
 * @brief Adaptive Function `le<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Checks for yearMonthDuration arg1 is less than or equal to yearMonthDuration
 * arg2 and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function le<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_le()
 *
 * __________
 */

/** @brief Function definition lt<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_lt_yearMonthDuration;

/**
 * @brief Adaptive Function `lt<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Checks for yearMonthDuration arg1 is less that yearMonthDuration arg2 and
 * return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function lt<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: yearMonthDuration
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (yearMonthDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_lt()
 *
 * __________
 */

/** @brief Function definition ne<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_ne_yearMonthDuration;

/**
 * @brief Adaptive Function `ne<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Determine if yearMonthDuration arg1 is not equal to the value of arg2
 * converted to the data type of arg1 then return the boolean result. Use 'nex'
 * ('!==') instead if you want true to be returned if arg1 and arg2's data type
 * don't match.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function ne<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Errors thrown:
 *
 *   conversion - arg2 cannot be converted to the data type of arg1.
 *
 * Implemented by afw_function_execute_ne()
 *
 * __________
 */

/** @brief Function definition nex<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_nex_yearMonthDuration;

/**
 * @brief Adaptive Function `nex<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Determine if for yearMonthDuration arg1 is not equal to the value or data
 * type of arg2 then return the boolean result. Use 'ne' ('!=') instead if you
 * want arg2 to be converted to the data type of arg1 before comparison.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function nex<yearMonthDuration>(
 *       arg1: yearMonthDuration,
 *       arg2: any
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   arg1 - (yearMonthDuration)
 *
 *   arg2 - (any dataType)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_nex()
 *
 * __________
 */

/** @brief Function definition one_and_only<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_one_and_only_yearMonthDuration;

/**
 * @brief Adaptive Function `one_and_only<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * This converts an array of yearMonthDuration values that contains one value to
 * a single yearMonthDuration value.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function one_and_only<yearMonthDuration>(
 *       array: (array array)
 *   ): yearMonthDuration;
 * ```
 *
 * Parameters:
 *
 *   array - (array array)
 *
 * Returns:
 *
 *   (yearMonthDuration)
 *
 * Errors thrown:
 *
 *   arg_error - array does not contain exactly one value
 *
 * Implemented by afw_function_execute_one_and_only()
 *
 * __________
 */

/** @brief Function definition set_equals<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_set_equals_yearMonthDuration;

/**
 * @brief Adaptive Function `set_equals<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Returns boolean true if yearMonthDuration array1 and yearMonthDuration array2
 * are subsets of each other and return the boolean result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function set_equals<yearMonthDuration>(
 *       array1: (array yearMonthDuration),
 *       array2: (array yearMonthDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array yearMonthDuration)
 *
 *   array2 - (array yearMonthDuration)
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_set_equals()
 *
 * __________
 */

/** @brief Function definition subset<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_subset_yearMonthDuration;

/**
 * @brief Adaptive Function `subset<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Returns boolean true if the unique values in yearMonthDuration array1 are all
 * in yearMonthDuration array2.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function subset<yearMonthDuration>(
 *       array1: (array yearMonthDuration),
 *       array2: (array yearMonthDuration)
 *   ): boolean;
 * ```
 *
 * Parameters:
 *
 *   array1 - (array yearMonthDuration) The first array.
 *
 *   array2 - (array yearMonthDuration) The second array.
 *
 * Returns:
 *
 *   (boolean)
 *
 * Implemented by afw_function_execute_subset()
 *
 * __________
 */

/** @brief Function definition to_string<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_to_string_yearMonthDuration;

/**
 * @brief Adaptive Function `to_string<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Converts yearMonthDuration value to string. For array values, the to_string()
 * value for each entry is returned separated with commas.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function to_string<yearMonthDuration>(
 *       value: yearMonthDuration
 *   ): string;
 * ```
 *
 * Parameters:
 *
 *   value - (yearMonthDuration) A yearMonthDuration value.
 *
 * Returns:
 *
 *   (string) The string representation of the value.
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/** @brief Function definition union<yearMonthDuration> */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_union_yearMonthDuration;

/**
 * @brief Adaptive Function `union<yearMonthDuration>`
 * @param x function execute parameter.
 *
 * Returns an array of yearMonthDuration contains all of the unique values in
 * two or more array of yearMonthDuration values.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function union<yearMonthDuration>(
 *       arrays_1: (array yearMonthDuration),
 *       arrays_2: (array yearMonthDuration),
 *       ...arrays_rest: (array of (array yearMonthDuration))
 *   ): (array yearMonthDuration);
 * ```
 *
 * Parameters:
 *
 *   arrays - (2 or more array yearMonthDuration) Two or more arrays.
 *
 * Returns:
 *
 *   (array yearMonthDuration)
 *
 * Implemented by afw_function_execute_union()
 *
 * __________
 */

/** @brief Function definition yearMonthDuration */
AFW_DECLARE_INTERNAL_CONST_DATA(afw_value_function_definition_t)
afw_function_definition_yearMonthDuration;

/**
 * @brief Adaptive Function `yearMonthDuration`
 * @param x function execute parameter.
 *
 * Converts value to data type yearMonthDuration returning yearMonthDuration
 * result.
 *
 * This function is pure, so it will always return the same result
 * given exactly the same parameters and has no side effects.
 *
 * Declaration:
 *
 * ```
 *   function yearMonthDuration(
 *       value: any
 *   ): yearMonthDuration;
 * ```
 *
 * Parameters:
 *
 *   value - (any dataType) Value to convert.
 *
 * Returns:
 *
 *   (yearMonthDuration) Converted value.
 *
 * Errors thrown:
 *
 *   cast_error - value could not be converted
 *
 * Implemented by afw_function_execute_convert()
 *
 * __________
 */

/**
 * @brief Data type method id map for afw_
 */
#define AFW_DATA_TYPE_METHOD_ID_MAP(XX)                                        \
    XX(at_least_one_member_of)                                                 \
    XX(bag)                                                                    \
    XX(bag_size)                                                               \
    XX(ends_with)                                                              \
    XX(eq)                                                                     \
    XX(eqx)                                                                    \
    XX(ge)                                                                     \
    XX(gt)                                                                     \
    XX(includes)                                                               \
    XX(index_of)                                                               \
    XX(intersection)                                                           \
    XX(is)                                                                     \
    XX(is_in)                                                                  \
    XX(last_index_of)                                                          \
    XX(le)                                                                     \
    XX(length)                                                                 \
    XX(lt)                                                                     \
    XX(ne)                                                                     \
    XX(nex)                                                                    \
    XX(one_and_only)                                                           \
    XX(regexp_index_of)                                                        \
    XX(regexp_match)                                                           \
    XX(regexp_replace)                                                         \
    XX(repeat)                                                                 \
    XX(replace)                                                                \
    XX(set_equals)                                                             \
    XX(split)                                                                  \
    XX(starts_with)                                                            \
    XX(subset)                                                                 \
    XX(substring)                                                              \
    XX(to_string)                                                              \
    XX(union)                                                                  \
    XX(url_encode)                                                             \
    XX(clone)                                                                  \
    XX(join)                                                                   \
    XX(reverse)                                                                \
    XX(decode_to_string)                                                       \
    XX(add_dayTimeDuration)                                                    \
    XX(add_yearMonthDuration)                                                  \
    XX(max)                                                                    \
    XX(min)                                                                    \
    XX(subtract_dayTimeDuration)                                               \
    XX(subtract_yearMonthDuration)                                             \
    XX(abs)                                                                    \
    XX(add)                                                                    \
    XX(ceil)                                                                   \
    XX(divide)                                                                 \
    XX(floor)                                                                  \
    XX(multiply)                                                               \
    XX(negative)                                                               \
    XX(pow)                                                                    \
    XX(round)                                                                  \
    XX(subtract)                                                               \
    XX(to_integer)                                                             \
    XX(mod)                                                                    \
    XX(to_double)                                                              \
    XX(compile)                                                                \
    XX(encode_as_base64Binary)                                                 \
    XX(encode_as_hexBinary)                                                    \
    XX(eq_ignore_case)                                                         \
    XX(evaluate)                                                               \
    XX(in_range)                                                               \
    XX(match)                                                                  \
    XX(normalize_space)                                                        \
    XX(normalize_to_lower_case)                                                \
    XX(to_anyURI)                                                              \
    XX(to_boolean)                                                             \
    XX(to_date)                                                                \
    XX(to_dateTime)                                                            \
    XX(to_dayTimeDuration)                                                     \
    XX(to_dnsName)                                                             \
    XX(to_ipAddress)                                                           \
    XX(to_rfc822Name)                                                          \
    XX(to_time)                                                                \
    XX(to_x500Name)                                                            \
    XX(to_yearMonthDuration)                                                   \
    XX(url_decode)                                                             \


/**
 * @brief Data type method number enum for afw_
 *
 * Warning: Do not use these directly outside of core since their value may
 *          change between builds.
 */
typedef enum afw_data_type_method_number_e {
    afw_data_type_method_number_unassigned = 0,
#define XX(id) afw_data_type_method_number_ ## id,
    AFW_DATA_TYPE_METHOD_ID_MAP(XX)
#undef XX
    afw_data_type_method_number__max
} afw_data_type_method_number_t;

/**
 * @brief Function implementation function AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING
 *
 * Implementation for functions:
 *
 * abs
 * add
 * add_dayTimeDuration
 * add_yearMonthDuration
 * at_least_one_member_of
 * bag
 * bag_size
 * ceil
 * clone
 * compile
 * decode_to_string
 * divide
 * encode_as_base64Binary
 * encode_as_hexBinary
 * ends_with
 * eq_ignore_case
 * evaluate
 * floor
 * ge
 * gt
 * in_range
 * includes
 * index_of
 * intersection
 * is_in
 * last_index_of
 * le
 * length
 * lt
 * match
 * max
 * min
 * mod
 * multiply
 * negative
 * normalize_space
 * normalize_to_lower_case
 * one_and_only
 * pow
 * regexp_index_of
 * regexp_match
 * regexp_replace
 * repeat
 * replace
 * round
 * set_equals
 * split
 * starts_with
 * subset
 * substring
 * subtract
 * subtract_dayTimeDuration
 * subtract_yearMonthDuration
 * to_anyURI
 * to_boolean
 * to_date
 * to_dateTime
 * to_dayTimeDuration
 * to_dnsName
 * to_double
 * to_integer
 * to_ipAddress
 * to_rfc822Name
 * to_string
 * to_time
 * to_x500Name
 * to_yearMonthDuration
 * union
 * url_encode
 *
 * This execute function is represented by NULL and is handled by standard 
 * polymorphic function handling in the afw_value_call_built_in_function
 * optional_evaluate() method.
 */

/**
 * @brief Function implementation function afw_function_execute_at_least_one_member_of
 *
 * Implementation for functions:
 *
 * at_least_one_member_of<anyURI>
 * at_least_one_member_of<base64Binary>
 * at_least_one_member_of<boolean>
 * at_least_one_member_of<dateTime>
 * at_least_one_member_of<date>
 * at_least_one_member_of<dayTimeDuration>
 * at_least_one_member_of<double>
 * at_least_one_member_of<hexBinary>
 * at_least_one_member_of<integer>
 * at_least_one_member_of<rfc822Name>
 * at_least_one_member_of<string>
 * at_least_one_member_of<time>
 * at_least_one_member_of<x500Name>
 * at_least_one_member_of<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_at_least_one_member_of(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_bag
 *
 * Implementation for functions:
 *
 * bag<anyURI>
 * bag<array>
 * bag<base64Binary>
 * bag<boolean>
 * bag<dateTime>
 * bag<date>
 * bag<dayTimeDuration>
 * bag<dnsName>
 * bag<double>
 * bag<function>
 * bag<hexBinary>
 * bag<ia5String>
 * bag<integer>
 * bag<ipAddress>
 * bag<null>
 * bag<objectId>
 * bag<objectPath>
 * bag<object>
 * bag<password>
 * bag<rfc822Name>
 * bag<script>
 * bag<string>
 * bag<template>
 * bag<time>
 * bag<x500Name>
 * bag<xpathExpression>
 * bag<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_bag(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_bag_size
 *
 * Implementation for functions:
 *
 * bag_size<anyURI>
 * bag_size<array>
 * bag_size<base64Binary>
 * bag_size<boolean>
 * bag_size<dateTime>
 * bag_size<date>
 * bag_size<dayTimeDuration>
 * bag_size<dnsName>
 * bag_size<double>
 * bag_size<function>
 * bag_size<hexBinary>
 * bag_size<ia5String>
 * bag_size<integer>
 * bag_size<ipAddress>
 * bag_size<null>
 * bag_size<objectId>
 * bag_size<objectPath>
 * bag_size<object>
 * bag_size<password>
 * bag_size<rfc822Name>
 * bag_size<script>
 * bag_size<string>
 * bag_size<template>
 * bag_size<time>
 * bag_size<x500Name>
 * bag_size<xpathExpression>
 * bag_size<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_bag_size(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_clone
 *
 * Implementation for functions:
 *
 * clone<array>
 * clone<object>
 */
const afw_value_t *
afw_function_execute_clone(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_convert
 *
 * Implementation for functions:
 *
 * anyURI
 * to_string<anyURI>
 * to_string<array>
 * base64Binary
 * to_string<base64Binary>
 * boolean
 * to_string<boolean>
 * dateTime
 * to_string<dateTime>
 * date
 * to_string<date>
 * dayTimeDuration
 * to_string<dayTimeDuration>
 * dnsName
 * to_string<dnsName>
 * double
 * to_string<double>
 * function
 * hexBinary
 * to_string<hexBinary>
 * ia5String
 * to_string<ia5String>
 * integer
 * to_string<integer>
 * ipAddress
 * to_string<ipAddress>
 * json
 * null
 * to_string<null>
 * objectId
 * to_string<objectId>
 * objectPath
 * to_string<objectPath>
 * object
 * to_string<object>
 * password
 * to_string<password>
 * regexp
 * relaxed_json
 * rfc822Name
 * to_string<rfc822Name>
 * script
 * to_anyURI<string>
 * to_boolean<string>
 * to_dateTime<string>
 * to_date<string>
 * to_dayTimeDuration<string>
 * to_dnsName<string>
 * to_double<string>
 * to_integer<string>
 * to_ipAddress<string>
 * to_rfc822Name<string>
 * to_string<string>
 * to_time<string>
 * to_x500Name<string>
 * to_yearMonthDuration<string>
 * template
 * to_string<template>
 * time
 * to_string<time>
 * to_string<x500Name>
 * x500Name
 * xml
 * to_string<xpathExpression>
 * xpathExpression
 * to_string<yearMonthDuration>
 * yearMonthDuration
 */
const afw_value_t *
afw_function_execute_convert(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_encode_as_base64Binary
 *
 * Implementation for functions:
 *
 * encode_as_base64Binary<string>
 */
const afw_value_t *
afw_function_execute_encode_as_base64Binary(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_encode_as_hexBinary
 *
 * Implementation for functions:
 *
 * encode_as_hexBinary<string>
 */
const afw_value_t *
afw_function_execute_encode_as_hexBinary(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_ends_with
 *
 * Implementation for functions:
 *
 * ends_with<anyURI>
 * ends_with<string>
 */
const afw_value_t *
afw_function_execute_ends_with(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_eq
 *
 * Implementation for functions:
 *
 * eq<anyURI>
 * eq<array>
 * eq<base64Binary>
 * eq<boolean>
 * eq<dateTime>
 * eq<date>
 * eq<dayTimeDuration>
 * eq<dnsName>
 * eq<double>
 * eq<function>
 * eq<hexBinary>
 * eq<ia5String>
 * eq<integer>
 * eq<ipAddress>
 * eq<objectId>
 * eq<objectPath>
 * eq<object>
 * eq<password>
 * eq
 * eq<regexp>
 * eq<rfc822Name>
 * eq<script>
 * eq<string>
 * eq<template>
 * eq<time>
 * eq<x500Name>
 * eq<xpathExpression>
 * eq<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_eq(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_eqx
 *
 * Implementation for functions:
 *
 * eqx<anyURI>
 * eqx<array>
 * eqx<base64Binary>
 * eqx<boolean>
 * eqx<dateTime>
 * eqx<date>
 * eqx<dayTimeDuration>
 * eqx<dnsName>
 * eqx<double>
 * eqx<function>
 * eqx<hexBinary>
 * eqx<ia5String>
 * eqx<integer>
 * eqx<ipAddress>
 * eqx<objectId>
 * eqx<objectPath>
 * eqx<object>
 * eqx<password>
 * eqx
 * eqx<regexp>
 * eqx<rfc822Name>
 * eqx<script>
 * eqx<string>
 * eqx<template>
 * eqx<time>
 * eqx<x500Name>
 * eqx<xpathExpression>
 * eqx<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_eqx(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_ge
 *
 * Implementation for functions:
 *
 * ge<anyURI>
 * ge<array>
 * ge<base64Binary>
 * ge<boolean>
 * ge<dateTime>
 * ge<date>
 * ge<dayTimeDuration>
 * ge<dnsName>
 * ge<double>
 * ge<function>
 * ge<hexBinary>
 * ge<ia5String>
 * ge<integer>
 * ge<ipAddress>
 * ge<objectId>
 * ge<objectPath>
 * ge<object>
 * ge<password>
 * ge<regexp>
 * ge<rfc822Name>
 * ge<script>
 * ge<string>
 * ge<template>
 * ge<time>
 * ge<x500Name>
 * ge<xpathExpression>
 * ge<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_ge(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_gt
 *
 * Implementation for functions:
 *
 * gt<anyURI>
 * gt<array>
 * gt<base64Binary>
 * gt<boolean>
 * gt<dateTime>
 * gt<date>
 * gt<dayTimeDuration>
 * gt<dnsName>
 * gt<double>
 * gt<function>
 * gt<hexBinary>
 * gt<ia5String>
 * gt<integer>
 * gt<ipAddress>
 * gt<objectId>
 * gt<objectPath>
 * gt<object>
 * gt<password>
 * gt<regexp>
 * gt<rfc822Name>
 * gt<script>
 * gt<string>
 * gt<template>
 * gt<time>
 * gt<x500Name>
 * gt<xpathExpression>
 * gt<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_gt(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_includes
 *
 * Implementation for functions:
 *
 * includes<anyURI>
 * includes<string>
 */
const afw_value_t *
afw_function_execute_includes(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_includes_array
 *
 * Implementation for functions:
 *
 * includes<array>
 */
const afw_value_t *
afw_function_execute_includes_array(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_index_of
 *
 * Implementation for functions:
 *
 * index_of<anyURI>
 * index_of<string>
 */
const afw_value_t *
afw_function_execute_index_of(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_intersection
 *
 * Implementation for functions:
 *
 * intersection<anyURI>
 * intersection<base64Binary>
 * intersection<boolean>
 * intersection<dateTime>
 * intersection<date>
 * intersection<dayTimeDuration>
 * intersection<double>
 * intersection<hexBinary>
 * intersection<integer>
 * intersection<rfc822Name>
 * intersection<string>
 * intersection<time>
 * intersection<x500Name>
 * intersection<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_intersection(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_is
 *
 * Implementation for functions:
 *
 * is<anyURI>
 * is<array>
 * is<base64Binary>
 * is<boolean>
 * is<dateTime>
 * is<date>
 * is<dayTimeDuration>
 * is<dnsName>
 * is<double>
 * is<function>
 * is<hexBinary>
 * is<ia5String>
 * is<integer>
 * is<ipAddress>
 * is<null>
 * is<objectId>
 * is<objectPath>
 * is<object>
 * is<password>
 * is
 * is<rfc822Name>
 * is<script>
 * is<string>
 * is<template>
 * is<time>
 * is<unevaluated>
 * is<x500Name>
 * is<xpathExpression>
 * is<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_is(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_is_in
 *
 * Implementation for functions:
 *
 * is_in<anyURI>
 * is_in<base64Binary>
 * is_in<boolean>
 * is_in<dateTime>
 * is_in<date>
 * is_in<dayTimeDuration>
 * is_in<dnsName>
 * is_in<double>
 * is_in<hexBinary>
 * is_in<integer>
 * is_in<ipAddress>
 * is_in<rfc822Name>
 * is_in<string>
 * is_in<time>
 * is_in<x500Name>
 * is_in<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_is_in(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_last_index_of
 *
 * Implementation for functions:
 *
 * last_index_of<anyURI>
 * last_index_of<string>
 */
const afw_value_t *
afw_function_execute_last_index_of(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_le
 *
 * Implementation for functions:
 *
 * le<anyURI>
 * le<array>
 * le<base64Binary>
 * le<boolean>
 * le<dateTime>
 * le<date>
 * le<dayTimeDuration>
 * le<dnsName>
 * le<double>
 * le<function>
 * le<hexBinary>
 * le<ia5String>
 * le<integer>
 * le<ipAddress>
 * le<objectId>
 * le<objectPath>
 * le<object>
 * le<password>
 * le<regexp>
 * le<rfc822Name>
 * le<script>
 * le<string>
 * le<template>
 * le<time>
 * le<x500Name>
 * le<xpathExpression>
 * le<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_le(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_length
 *
 * Implementation for functions:
 *
 * length<anyURI>
 * length<array>
 * length<string>
 */
const afw_value_t *
afw_function_execute_length(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_lt
 *
 * Implementation for functions:
 *
 * lt<anyURI>
 * lt<array>
 * lt<base64Binary>
 * lt<boolean>
 * lt<dateTime>
 * lt<date>
 * lt<dayTimeDuration>
 * lt<dnsName>
 * lt<double>
 * lt<function>
 * lt<hexBinary>
 * lt<ia5String>
 * lt<integer>
 * lt<ipAddress>
 * lt<objectId>
 * lt<objectPath>
 * lt<object>
 * lt<password>
 * lt<regexp>
 * lt<rfc822Name>
 * lt<script>
 * lt<string>
 * lt<template>
 * lt<time>
 * lt<x500Name>
 * lt<xpathExpression>
 * lt<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_lt(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_max
 *
 * Implementation for functions:
 *
 * max<dateTime>
 * max<date>
 * max<double>
 * max<integer>
 * max<string>
 * max<time>
 */
const afw_value_t *
afw_function_execute_max(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_min
 *
 * Implementation for functions:
 *
 * min<dateTime>
 * min<date>
 * min<double>
 * min<integer>
 * min<string>
 * min<time>
 */
const afw_value_t *
afw_function_execute_min(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_ne
 *
 * Implementation for functions:
 *
 * ne<anyURI>
 * ne<array>
 * ne<base64Binary>
 * ne<boolean>
 * ne<dateTime>
 * ne<date>
 * ne<dayTimeDuration>
 * ne<dnsName>
 * ne<double>
 * ne<function>
 * ne<hexBinary>
 * ne<ia5String>
 * ne<integer>
 * ne<ipAddress>
 * ne<objectId>
 * ne<objectPath>
 * ne<object>
 * ne<password>
 * ne
 * ne<regexp>
 * ne<rfc822Name>
 * ne<script>
 * ne<string>
 * ne<template>
 * ne<time>
 * ne<x500Name>
 * ne<xpathExpression>
 * ne<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_ne(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_nex
 *
 * Implementation for functions:
 *
 * nex<anyURI>
 * nex<array>
 * nex<base64Binary>
 * nex<boolean>
 * nex<dateTime>
 * nex<date>
 * nex<dayTimeDuration>
 * nex<dnsName>
 * nex<double>
 * nex<function>
 * nex<hexBinary>
 * nex<ia5String>
 * nex<integer>
 * nex<ipAddress>
 * nex<objectId>
 * nex<objectPath>
 * nex<object>
 * nex<password>
 * nex
 * nex<regexp>
 * nex<rfc822Name>
 * nex<script>
 * nex<string>
 * nex<template>
 * nex<time>
 * nex<x500Name>
 * nex<xpathExpression>
 * nex<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_nex(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_one_and_only
 *
 * Implementation for functions:
 *
 * one_and_only<anyURI>
 * one_and_only<base64Binary>
 * one_and_only<boolean>
 * one_and_only<dateTime>
 * one_and_only<date>
 * one_and_only<dayTimeDuration>
 * one_and_only<dnsName>
 * one_and_only<double>
 * one_and_only<hexBinary>
 * one_and_only<integer>
 * one_and_only<ipAddress>
 * one_and_only<rfc822Name>
 * one_and_only<string>
 * one_and_only<time>
 * one_and_only<x500Name>
 * one_and_only<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_one_and_only(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_regexp_index_of
 *
 * Implementation for functions:
 *
 * regexp_index_of<anyURI>
 * regexp_index_of<string>
 */
const afw_value_t *
afw_function_execute_regexp_index_of(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_regexp_match
 *
 * Implementation for functions:
 *
 * regexp_match<anyURI>
 * regexp_match<dnsName>
 * regexp_match<ipAddress>
 * regexp_match<rfc822Name>
 * regexp_match<string>
 * regexp_match<x500Name>
 */
const afw_value_t *
afw_function_execute_regexp_match(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_regexp_replace
 *
 * Implementation for functions:
 *
 * regexp_replace<anyURI>
 * regexp_replace<string>
 */
const afw_value_t *
afw_function_execute_regexp_replace(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_repeat
 *
 * Implementation for functions:
 *
 * repeat<anyURI>
 * repeat<string>
 */
const afw_value_t *
afw_function_execute_repeat(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_replace
 *
 * Implementation for functions:
 *
 * replace<anyURI>
 * replace<string>
 */
const afw_value_t *
afw_function_execute_replace(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_set_equals
 *
 * Implementation for functions:
 *
 * set_equals<anyURI>
 * set_equals<base64Binary>
 * set_equals<boolean>
 * set_equals<dateTime>
 * set_equals<date>
 * set_equals<dayTimeDuration>
 * set_equals<double>
 * set_equals<hexBinary>
 * set_equals<integer>
 * set_equals<rfc822Name>
 * set_equals<string>
 * set_equals<time>
 * set_equals<x500Name>
 * set_equals<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_set_equals(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_split
 *
 * Implementation for functions:
 *
 * split<anyURI>
 * split<string>
 */
const afw_value_t *
afw_function_execute_split(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_starts_with
 *
 * Implementation for functions:
 *
 * starts_with<anyURI>
 * starts_with<string>
 */
const afw_value_t *
afw_function_execute_starts_with(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_subset
 *
 * Implementation for functions:
 *
 * subset<anyURI>
 * subset<base64Binary>
 * subset<boolean>
 * subset<dateTime>
 * subset<date>
 * subset<dayTimeDuration>
 * subset<double>
 * subset<hexBinary>
 * subset<integer>
 * subset<rfc822Name>
 * subset<string>
 * subset<time>
 * subset<x500Name>
 * subset<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_subset(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_substring
 *
 * Implementation for functions:
 *
 * substring<anyURI>
 * substring<string>
 */
const afw_value_t *
afw_function_execute_substring(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_to_double_integer
 *
 * Implementation for functions:
 *
 * to_double<integer>
 */
const afw_value_t *
afw_function_execute_to_double_integer(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_to_integer_double
 *
 * Implementation for functions:
 *
 * to_integer<double>
 */
const afw_value_t *
afw_function_execute_to_integer_double(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_union
 *
 * Implementation for functions:
 *
 * union<anyURI>
 * union<base64Binary>
 * union<boolean>
 * union<dateTime>
 * union<date>
 * union<dayTimeDuration>
 * union<double>
 * union<hexBinary>
 * union<integer>
 * union<rfc822Name>
 * union<string>
 * union<time>
 * union<x500Name>
 * union<yearMonthDuration>
 */
const afw_value_t *
afw_function_execute_union(
    afw_function_execute_t *x);

/**
 * @brief Function implementation function afw_function_execute_url_encode
 *
 * Implementation for functions:
 *
 * url_encode<anyURI>
 * url_encode<string>
 */
const afw_value_t *
afw_function_execute_url_encode(
    afw_function_execute_t *x);

/** @} */

/** @} */
/** @} */


#endif /* __AFW_FUNCTION_BINDINGS_H__ */
