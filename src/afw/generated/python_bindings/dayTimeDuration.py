# -*- coding: utf-8 -*-

# Generated by afwdev generate afw

import requests
import json

def at_least_one_member_of_dayTimeDuration(session, array1, array2):
    '''
    Checks for at least one value in common

    Returns boolean true if at least one value in dayTimeDuration array1 is
    in dayTimeDuration array2.

    Parameters:

        array1 (array): The first array.

        array2 (array): The second array.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "at_least_one_member_of<dayTimeDuration>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_dayTimeDuration(session, values=None):
    '''
    Makes an array from values

    Takes any number of dayTimeDuration values and returns an array of array.

    Parameters:

        values (array):

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "bag<dayTimeDuration>"
    }

    if values != None:
        action['values'] = values

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_size_dayTimeDuration(session, value):
    '''
    Returns the number of values in a bag

    This returns the integer number of values in array.

    Parameters:

        value (array):

    Returns:
    integer: 
    '''

    request = session.Request()

    action = {
        "function": "bag_size<dayTimeDuration>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def dayTimeDuration(session, value):
    '''
    Convert to data type dateTimeDuration

    Converts value to data type dayTimeDuration returning dayTimeDuration
    result.

    Parameters:

        value (): Value to convert

    Returns:
    dayTimeDuration: Converted value
    '''

    request = session.Request()

    action = {
        "function": "dayTimeDuration",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for equal

    Determine if dayTimeDuration arg1 is equal to the value of arg2 converted
    to the data type of arg1 then return the boolean result. Use 'eqx'
    ('===') instead if you want false to be returned if arg1 and arg2's data
    type don't match.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eq<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eqx_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for equal and type

    Determine if for dayTimeDuration arg1 is equal to the value and data type
    of arg2 then return the boolean result. Use 'eq' ('==') instead if you
    want arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eqx<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ge_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for greater than or equal

    Checks for dayTimeDuration arg1 is greater than or equal to
    dayTimeDuration arg2 and return the boolean result.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 (dayTimeDuration):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ge<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def gt_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for greater than

    Checks for dayTimeDuration arg1 is greater than dayTimeDuration arg2 and
    return the boolean result.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 (dayTimeDuration):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "gt<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def intersection_dayTimeDuration(session, array1, array2):
    '''
    Returns intersection of two arrays

    Returns an array of dayTimeDuration with the values that are common to
    both array of dayTimeDuration array1 and array2.

    Parameters:

        array1 (array): The first array.

        array2 (array): The second array.

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "intersection<dayTimeDuration>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_dayTimeDuration(session, value):
    '''
    Checks whether value is dataType dayTimeDuration

    Checks whether value is dataType dayTimeDuration and return the boolean
    result.

    Parameters:

        value (): Value to check

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is<dayTimeDuration>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_in_dayTimeDuration(session, value, array):
    '''
    Checks whether a value is in an array

    Checks whether dayTimeDuration value is in array of dayTimeDuration array
    and returns the boolean result.

    Parameters:

        value (dayTimeDuration):

        array (array):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is_in<dayTimeDuration>",
        "value": value,
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def le_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for less than or equal

    Checks for dayTimeDuration arg1 is less than or equal to dayTimeDuration
    arg2 and return the boolean result.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "le<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def lt_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for less than

    Checks for dayTimeDuration arg1 is less that dayTimeDuration arg2 and
    return the boolean result.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 (dayTimeDuration):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "lt<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ne_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for not equal

    Determine if dayTimeDuration arg1 is not equal to the value of arg2
    converted to the data type of arg1 then return the boolean result. Use
    'nex' ('!==') instead if you want true to be returned if arg1 and arg2's
    data type don't match.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ne<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def nex_dayTimeDuration(session, arg1, arg2):
    '''
    Checks for not equal value or type

    Determine if for dayTimeDuration arg1 is not equal to the value or data
    type of arg2 then return the boolean result. Use 'ne' ('!=') instead if
    you want arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 (dayTimeDuration):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "nex<dayTimeDuration>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def one_and_only_dayTimeDuration(session, array):
    '''
    Converts a one value array to a dayTimeDuration value

    This converts an array of dayTimeDuration values that contains one value
    to a single dayTimeDuration value.

    Parameters:

        array (array):

    Returns:
    dayTimeDuration: 
    '''

    request = session.Request()

    action = {
        "function": "one_and_only<dayTimeDuration>",
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def set_equals_dayTimeDuration(session, array1, array2):
    '''
    Checks whether two arrays are subsets of each other

    Returns boolean true if dayTimeDuration array1 and dayTimeDuration array2
    are subsets of each other and return the boolean result.

    Parameters:

        array1 (array):

        array2 (array):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "set_equals<dayTimeDuration>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subset_dayTimeDuration(session, array1, array2):
    '''
    Determines if the first array is a subset of second array

    Returns boolean true if the unique values in dayTimeDuration array1 are
    all in dayTimeDuration array2.

    Parameters:

        array1 (array): The first array.

        array2 (array): The second array.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "subset<dayTimeDuration>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_string_dayTimeDuration(session, value):
    '''
    Converts value to string

    Converts dayTimeDuration value to string. For array values, the
    to_string() value for each entry is returned separated with commas.

    Parameters:

        value (dayTimeDuration): A dayTimeDuration value.

    Returns:
    string: The string representation of the value.
    '''

    request = session.Request()

    action = {
        "function": "to_string<dayTimeDuration>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def union_dayTimeDuration(session, arrays):
    '''
    Returns union of two or more string arrays

    Returns an array of dayTimeDuration contains all of the unique values in
    two or more array of dayTimeDuration values.

    Parameters:

        arrays (array): Two or more arrays.

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "union<dayTimeDuration>",
        "arrays": arrays
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

