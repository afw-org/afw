# -*- coding: utf-8 -*-

# Generated by afwdev generate afw

import requests
import json

def abs(session, value):
    '''
    Absolute value

    Compute the absolute value of the `<dataType>` value and return the
    `<dataType>` result.

    Parameters:

        value ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "abs",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def add(session, values):
    '''
    Add

    Add 2 or more `<dataType>` values and return the `<dataType>` result.

    Parameters:

        values ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "add",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def add_dayTimeDuration(session, arg1, arg2):
    '''
    Add duration

    Add `<dataType>` arg1 to dayTimeDuration arg2 and return the `<dataType>`
    result.

    Parameters:

        arg1 ():

        arg2 (dayTimeDuration):

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "add_dayTimeDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def add_yearMonthDuration(session, arg1, arg2):
    '''
    Add duration

    Add `<dataType>` arg1 to yearMonthDuration arg2 and return the
    `<dataType>` result.

    Parameters:

        arg1 ():

        arg2 (yearMonthDuration):

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "add_yearMonthDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def at_least_one_member_of(session, list1, list2):
    '''
    Checks for at least one value in common

    Returns boolean true if at least one value in `<dataType>` list1 is in
    `<dataType>` list2.

    Parameters:

        list1 (array): The first array.

        list2 (array): The second array.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "at_least_one_member_of",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag(session, values=None):
    '''
    Makes an array from values

    Takes any number of `<dataType>` values and returns an array of array.

    Parameters:

        values (array):

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "bag"
    }

    if values != None:
        action['values'] = values

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_size(session, value):
    '''
    Returns the number of values in a bag

    This returns the integer number of values in array.

    Parameters:

        value (array):

    Returns:
    integer: 
    '''

    request = session.Request()

    action = {
        "function": "bag_size",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ceil(session, value):
    '''
    Round upward to nearest integer

    Determine the smallest integer that is greater then or equal to the
    `<dataType>` value and return the `<dataType>` result.

    Parameters:

        value ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "ceil",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def clone(session, value):
    '''
    Clone <dataType> value

    Deep clone a `<dataType>` value.

    Parameters:

        value (): The `<dataType>` value to clone.

    Returns:
    None: The cloned <dataType> value.
    '''

    request = session.Request()

    action = {
        "function": "clone",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def compile(session, source, listing=None):
    '''
    Compile <dataType> value

    Compile `<dataType>` value and return either an unevaluated adaptive
    value or a string containing the compiler listing.

    Parameters:

        source (): `<dataType>` string to compile

        listing (): If specified, a compiler listing is produced instead of
        an unevaluated expression value.
        
        This parameter can be an integer between 0 and 10 of a string that is
        used for indentation. If 0 is specified, no whitespace is added to
        the resulting string. If 1 through 10 is specified, that number of
        spaces is used.

    Returns:
    unevaluated: 
    '''

    request = session.Request()

    action = {
        "function": "compile",
        "source": source
    }

    if listing != None:
        action['listing'] = listing

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def decode_to_string(session, value):
    '''
    Decode <dataType> to string

    Decode `<dataType>` value to string. An error is thrown if decoded value
    is not valid UTF-8.

    Parameters:

        value (): The `<dataType>` value to decode.

    Returns:
    string: The decoded string.
    '''

    request = session.Request()

    action = {
        "function": "decode_to_string",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def divide(session, dividend, divisor):
    '''
    Divide numbers

    Divide `<dataType>` dividend by `<dataType>` divisor and return the
    `<dataType>` quotient.

    Parameters:

        dividend ():

        divisor ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "divide",
        "dividend": dividend,
        "divisor": divisor
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def encode_as_base64Binary(session, value):
    '''
    Encode to a base64Binary value

    Encode a value as a base64Binary. The effect is to create a base64Binary
    value with an internal value of the value passed.

    Parameters:

        value (): The `<dataType>` value to encode.

    Returns:
    base64Binary: A base64Binary value.
    '''

    request = session.Request()

    action = {
        "function": "encode_as_base64Binary",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def encode_as_hexBinary(session, value):
    '''
    Encode to a hexBinary value

    Encode a value as a hexBinary. The effect is to create a hexBinary value
    with an internal value of the value passed.

    Parameters:

        value (): The `<dataType>` value to encode.

    Returns:
    hexBinary: A hexBinary value.
    '''

    request = session.Request()

    action = {
        "function": "encode_as_hexBinary",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ends_with(session, value, subString):
    '''
    Checks whether value ends with a string

    Checks whether `<dataType>` value ends with a `<dataType>` and return the
    boolean result.

    Parameters:

        value ():

        subString (string):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ends_with",
        "value": value,
        "subString": subString
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq(session, arg1, arg2):
    '''
    Checks for equal

    Determine if `<dataType>` arg1 is equal to the value of arg2 converted to
    the data type of arg1 then return the boolean result. Use 'eqx' ('===')
    instead if you want false to be returned if arg1 and arg2's data type
    don't match.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eq",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq_ignore_case(session, arg1, arg2):
    '''
    Checks for equal ignoring case

    Checks for `<dataType>` arg1 is equal to `<dataType>` arg2 ignoring case
    and return the boolean result.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eq_ignore_case",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eqx(session, arg1, arg2):
    '''
    Checks for equal and type

    Determine if for `<dataType>` arg1 is equal to the value and data type of
    arg2 then return the boolean result. Use 'eq' ('==') instead if you want
    arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eqx",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def evaluate(session, source, additionalUntrustedQualifiedVariables=None):
    '''
    Evaluate <dataType> value

    Compile and evaluate `<dataType>` value.

    Parameters:

        source (): `<dataType>` string to compile and evaluate

        additionalUntrustedQualifiedVariables (object): This parameter
        supplies additional qualified variables that can be accessed during
        evaluation. These variables will not be used by anything that needs
        to ensure its qualified variables must come from a trusted source,
        such as authorization. This parameter is intended to be used for
        testing only and should not be used for anything running in
        production.

    Returns:
    unevaluated: 
    '''

    request = session.Request()

    action = {
        "function": "evaluate",
        "source": source
    }

    if additionalUntrustedQualifiedVariables != None:
        action['additionalUntrustedQualifiedVariables'] = additionalUntrustedQualifiedVariables

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def floor(session, number):
    '''
    Round downwards to nearest integer

    Determine the largest integer that is smaller then or equal to the
    `<dataType>` value and return the `<dataType>` result.

    Parameters:

        number ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "floor",
        "number": number
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ge(session, arg1, arg2):
    '''
    Checks for greater than or equal

    Checks for `<dataType>` arg1 is greater than or equal to `<dataType>`
    arg2 and return the boolean result.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ge",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def gt(session, arg1, arg2):
    '''
    Checks for greater than

    Checks for `<dataType>` arg1 is greater than `<dataType>` arg2 and return
    the boolean result.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "gt",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def in_range(session, time, startTime, endTime):
    '''
    Checks if time in range

    Checks if `<dataType>` is between startTime and endTime, inclusive.
    Regardless of endTime value, it is always considered to be equal to, but
    less than 24 hours greater than startTime. If no `<dataType>` zone is
    specified for `<dataType>,` the default `<dataType>` zone is used. If no
    `<dataType>` zone is specified for startTime or endTime, the `<dataType>`
    zone of `<dataType>` is used.

    Parameters:

        time ():

        startTime ():

        endTime ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "in_range",
        "time": time,
        "startTime": startTime,
        "endTime": endTime
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def includes(session, searchString, subString, position=None):
    '''
    Checks whether the <dataType> value includes a string

    Checks whether the `<dataType>` value includes a string and return the
    boolean result.

    Parameters:

        searchString (): The `<dataType>` to search.

        subString (string): Substring to find.

        position (integer): Zero-based position in the search string to start
        search.

    Returns:
    boolean: Indicates if the substring is contained in the search string.
    '''

    request = session.Request()

    action = {
        "function": "includes",
        "searchString": searchString,
        "subString": subString
    }

    if position != None:
        action['position'] = position

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def index_of(session, value, subString, startIndex=None):
    '''
    Returns index of first occurrence

    Returns the zero-based index into `<dataType>` value of subString. If
    subString is not found, -1 is returned.

    Parameters:

        value (): The `<dataType>` value to search.

        subString (string): Substring to search for.

        startIndex (integer): Optional start index for search if different
        than start of string.

    Returns:
    integer: Zero-based index of subString or -1 if not found.
    '''

    request = session.Request()

    action = {
        "function": "index_of",
        "value": value,
        "subString": subString
    }

    if startIndex != None:
        action['startIndex'] = startIndex

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def intersection(session, list1, list2):
    '''
    Returns intersection of two lists

    Returns an array of `<dataType>` with the values that are common to both
    array of `<dataType>` list1 and list2.

    Parameters:

        list1 (array): The first array.

        list2 (array): The second array.

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "intersection",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_(session, value):
    '''
    Checks whether value is dataType <dataType>

    Checks whether value is dataType `<dataType>` and return the boolean
    result.

    Parameters:

        value (): Value to check

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_in(session, value, array):
    '''
    Checks whether a value is in an array

    Checks whether `<dataType>` value is in array of `<dataType>` array and
    returns the boolean result.

    Parameters:

        value ():

        array (array):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is_in",
        "value": value,
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def last_index_of(session, value, subString, startIndex=None):
    '''
    Returns index of last occurrence

    Returns the zero-based index into `<dataType>` value of the last
    occurrence of a subString. If subString is not found, -1 is returned.

    Parameters:

        value (): The `<dataType>` value to search.

        subString (string): Substring to search for.

        startIndex (integer): Optional start index for search if different
        than start of string.

    Returns:
    integer: Zero-based index of subString or -1 if not found.
    '''

    request = session.Request()

    action = {
        "function": "last_index_of",
        "value": value,
        "subString": subString
    }

    if startIndex != None:
        action['startIndex'] = startIndex

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def le(session, arg1, arg2):
    '''
    Checks for less than or equal

    Checks for `<dataType>` arg1 is less than or equal to `<dataType>` arg2
    and return the boolean result.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "le",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def length(session, value):
    '''
    Returns number of codepoints or entries in value

    This is a polymorphic function where `<dataType>` can be any of the
    supported data types. Return the integer number of entries in datatype
    array or codepoints in others.

    Parameters:

        value (): Returns the number of entries in an array or code points in
        others.

    Returns:
    integer: 
    '''

    request = session.Request()

    action = {
        "function": "length",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def lt(session, arg1, arg2):
    '''
    Checks for less than

    Checks for `<dataType>` arg1 is less that `<dataType>` arg2 and return
    the boolean result.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "lt",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def match(session, arg1, arg2):
    '''
    Checks if x500Name matches

    Returns true if arg1 matches some terminal sequence of RDNs from arg2
    when compared using `equal_<dataType>`.

    Parameters:

        arg1 ():

        arg2 (string):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "match",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def max(session, values):
    '''
    Maximum value

    Return the `<dataType>` value that is greater than or equal to the
    others.

    Parameters:

        values ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "max",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def min(session, values):
    '''
    Minimum value

    Return the `<dataType>` value that is less than or equal to the others.

    Parameters:

        values ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "min",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def mod(session, dividend, divisor):
    '''
    Remainder of dividing numbers

    Divide `<dataType>` dividend by `<dataType>` divisor and return the
    `<dataType>` remainder.

    Parameters:

        dividend ():

        divisor ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "mod",
        "dividend": dividend,
        "divisor": divisor
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def multiply(session, values):
    '''
    Multiply numbers

    Multiply 2 or more `<dataType>` values and return the `<dataType>`
    result.

    Parameters:

        values ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "multiply",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ne(session, arg1, arg2):
    '''
    Checks for not equal

    Determine if `<dataType>` arg1 is not equal to the value of arg2
    converted to the data type of arg1 then return the boolean result. Use
    'nex' ('!==') instead if you want true to be returned if arg1 and arg2's
    data type don't match.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ne",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def negative(session, value):
    '''
    Negative of a number

    Return negative of `<dataType>` value.

    Parameters:

        value ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "negative",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def nex(session, arg1, arg2):
    '''
    Checks for not equal value or type

    Determine if for `<dataType>` arg1 is not equal to the value or data type
    of arg2 then return the boolean result. Use 'ne' ('!=') instead if you
    want arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "nex",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def normalize_space(session, string):
    '''
    Trims whitespace from beginning and end

    Remove whitespace from the beginning and end of a `<dataType>` value.

    Parameters:

        string ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "normalize_space",
        "string": string
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def normalize_to_lower_case(session, string):
    '''
    Converts to lower case

    Normalize `<dataType>` value to lower case and returns `<dataType>`
    result.

    Parameters:

        string ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "normalize_to_lower_case",
        "string": string
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def one_and_only(session, array):
    '''
    Converts a one value array to a <dataType> value

    This converts an array of `<dataType>` values that contains one value to
    a single `<dataType>` value.

    Parameters:

        array (array):

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "one_and_only",
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def pow(session, base, exponent):
    '''
    Base raised to a power

    This returns the value of base raised to a power. Multiple exponents can
    be specified to raise the previous exponent to the power of the latter
    exponent.

    Parameters:

        base (): Base value.

        exponent (): Exponent value.

    Returns:
    None: Base raised to the power.
    '''

    request = session.Request()

    action = {
        "function": "pow",
        "base": base,
        "exponent": exponent
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def regexp_index_of(session, value, regexp):
    '''
    Returns index of first match of regular expression

    Search `<dataType>` value for a regular expression and return index. If
    not found, -1 is returned.

    Parameters:

        value (): The `<dataType>` value to search.

        regexp (string): A regular expression to use for search.

    Returns:
    integer: Zero-based index of subString or -1 if not found.
    '''

    request = session.Request()

    action = {
        "function": "regexp_index_of",
        "value": value,
        "regexp": regexp
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def regexp_match(session, value, regexp):
    '''
    Search for a match using a regular expression

    Checks whether `<dataType>` value matches the regular expression regexp
    and return the boolean result.

    Parameters:

        value ():

        regexp (string):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "regexp_match",
        "value": value,
        "regexp": regexp
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def regexp_replace(session, value, regexp, replacement, limit=None):
    '''
    Replace strings matching a regular expression

    Replace matched values for a regular expression in a `<dataType>` value.

    Parameters:

        value (): The original `<dataType>` value.

        regexp (string): A regular expression to use for search.

        replacement (string): The replacement string.

        limit (integer): This is the maximum times to replace. The default is
        1. Specify -1 to replace all occurrences.

    Returns:
    None: A <dataType> value with the matched string(s) replaced.
    '''

    request = session.Request()

    action = {
        "function": "regexp_replace",
        "value": value,
        "regexp": regexp,
        "replacement": replacement
    }

    if limit != None:
        action['limit'] = limit

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def repeat(session, value, times):
    '''
    Returns a repeated value

    Repeat a `<dataType>` value a specified number of times.

    Parameters:

        value (): The `<dataType>` value to repeat.

        times (integer): The number of times to repeat the value.

    Returns:
    None: The repeated <dataType> value.
    '''

    request = session.Request()

    action = {
        "function": "repeat",
        "value": value,
        "times": times
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def replace(session, value, match, replacement, limit=None):
    '''
    Replace strings

    Replace string(s) in a `<dataType>` value.

    Parameters:

        value (): The original `<dataType>` value.

        match (string): The string to replace.

        replacement (string): The replacement string.

        limit (integer): This is the maximum times to replace. The default is
        1. Specify -1 to replace all occurrences.

    Returns:
    None: A <dataType> value with the matched string(s) replaced.
    '''

    request = session.Request()

    action = {
        "function": "replace",
        "value": value,
        "match": match,
        "replacement": replacement
    }

    if limit != None:
        action['limit'] = limit

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def round(session, number):
    '''
    Round to nearest integer

    Determine the integer closest to `<dataType>` value and return the
    `<dataType>` result.

    Parameters:

        number ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "round",
        "number": number
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def set_equals(session, list1, list2):
    '''
    Checks whether two lists are subsets of each other

    Returns boolean true if `<dataType>` list1 and `<dataType>` list2 are
    subsets of each other and return the boolean result.

    Parameters:

        list1 (array):

        list2 (array):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "set_equals",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def split(session, value, separator=None, limit=None):
    '''
    Split at a separator

    Split `<dataType>` value into an array of strings using a separator.

    Parameters:

        value (): The `<dataType>` value to split.

        separator (string): The separator to use. If this is an empty string
        or separator is not specified, the value is split between characters.

        limit (integer): This is the maximum number of splits. Any remaining
        part of value is ignored.

    Returns:
    array: An array of strings.
    '''

    request = session.Request()

    action = {
        "function": "split",
        "value": value
    }

    if separator != None:
        action['separator'] = separator

    if limit != None:
        action['limit'] = limit

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def starts_with(session, value, subString):
    '''
    Checks whether value starts with a string

    Checks whether `<dataType>` value starts with a subString and return the
    boolean result.

    Parameters:

        value ():

        subString (string):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "starts_with",
        "value": value,
        "subString": subString
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subset(session, list1, list2):
    '''
    Determines if the first array is a subset of second array

    Returns boolean true if the unique values in `<dataType>` list1 are all
    in `<dataType>` list2.

    Parameters:

        list1 (array): The first array.

        list2 (array): The second array.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "subset",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def substring(session, string, startIndex, endIndex=None):
    '''
    Extract a substring

    Returns the `<dataType>` substring of value beginning at zero-based
    position integer startIndex and ending at the position before integer
    endIndex. Specify -1 or omitting endIndex to return up to end of
    `<dataType>`.

    Parameters:

        string ():

        startIndex (integer):

        endIndex (integer):

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "substring",
        "string": string,
        "startIndex": startIndex
    }

    if endIndex != None:
        action['endIndex'] = endIndex

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract(session, arg1, arg2):
    '''
    Subtract numbers

    Subtract `<dataType>` arg2 from `<dataType>` arg1 and return the
    `<dataType>` result.

    Parameters:

        arg1 ():

        arg2 ():

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "subtract",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract_dayTimeDuration(session, arg1, arg2):
    '''
    Subtract numbers

    Subtract dayTimeDuration arg2 from `<dataType>` arg1 and return the
    `<dataType>` result.

    Parameters:

        arg1 ():

        arg2 (dayTimeDuration):

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "subtract_dayTimeDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract_yearMonthDuration(session, arg1, arg2):
    '''
    Subtract numbers

    Subtract yearMonthDuration arg2 from `<dataType>` arg1 and return the
    `<dataType>` result.

    Parameters:

        arg1 ():

        arg2 (yearMonthDuration):

    Returns:
    None: 
    '''

    request = session.Request()

    action = {
        "function": "subtract_yearMonthDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_anyURI(session, value):
    '''
    Converts string to anyURI

    Converts `<dataType>` value to anyURI.

    Parameters:

        value ():

    Returns:
    anyURI: 
    '''

    request = session.Request()

    action = {
        "function": "to_anyURI",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_boolean(session, value):
    '''
    Converts string to boolean

    Converts `<dataType>` value to boolean.

    Parameters:

        value ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "to_boolean",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_date(session, value):
    '''
    Converts string to date

    Converts `<dataType>` value to date.

    Parameters:

        value ():

    Returns:
    date: 
    '''

    request = session.Request()

    action = {
        "function": "to_date",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_dateTime(session, value):
    '''
    Converts string to dateTime

    Converts `<dataType>` value to dateTime.

    Parameters:

        value ():

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "to_dateTime",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_dayTimeDuration(session, value):
    '''
    Converts string to dayTimeDuration

    Converts `<dataType>` value to dayTimeDuration.

    Parameters:

        value ():

    Returns:
    dayTimeDuration: 
    '''

    request = session.Request()

    action = {
        "function": "to_dayTimeDuration",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_dnsName(session, value):
    '''
    Converts string to dnsName

    Converts `<dataType>` value to dnsName.

    Parameters:

        value ():

    Returns:
    dnsName: 
    '''

    request = session.Request()

    action = {
        "function": "to_dnsName",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_double(session, value):
    '''
    Converts to double

    Converts `<dataType>` value to double and returns double result.

    Parameters:

        value ():

    Returns:
    double: 
    '''

    request = session.Request()

    action = {
        "function": "to_double",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_integer(session, value):
    '''
    Converts to integer

    Truncate `<dataType>` value to a whole number and returns integer result.

    Parameters:

        value ():

    Returns:
    integer: 
    '''

    request = session.Request()

    action = {
        "function": "to_integer",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_ipAddress(session, value):
    '''
    Converts string to ipAddress

    Converts `<dataType>` value to ipAddress.

    Parameters:

        value ():

    Returns:
    ipAddress: 
    '''

    request = session.Request()

    action = {
        "function": "to_ipAddress",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_rfc822Name(session, value):
    '''
    Converts string to rfc822Name

    Converts `<dataType>` value to rfc822Name.

    Parameters:

        value ():

    Returns:
    rfc822Name: 
    '''

    request = session.Request()

    action = {
        "function": "to_rfc822Name",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_string(session, value):
    '''
    Converts value to string

    Converts `<dataType>` value to string. For array values, the to_string()
    value for each entry is returned separated with commas.

    Parameters:

        value (): A `<dataType>` value.

    Returns:
    string: The string representation of the value.
    '''

    request = session.Request()

    action = {
        "function": "to_string",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_time(session, value):
    '''
    Converts string to time

    Converts `<dataType>` value to time.

    Parameters:

        value ():

    Returns:
    time: 
    '''

    request = session.Request()

    action = {
        "function": "to_time",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_x500Name(session, value):
    '''
    Converts string to x500Name

    Converts `<dataType>` value to x500Name.

    Parameters:

        value ():

    Returns:
    x500Name: 
    '''

    request = session.Request()

    action = {
        "function": "to_x500Name",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_yearMonthDuration(session, value):
    '''
    Converts string to yearMonthDuration

    Converts `<dataType>` value to yearMonthDuration.

    Parameters:

        value ():

    Returns:
    yearMonthDuration: 
    '''

    request = session.Request()

    action = {
        "function": "to_yearMonthDuration",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def union(session, lists):
    '''
    Returns union of two or more string lists

    Returns an array of `<dataType>` contains all of the unique values in two
    or more array of `<dataType>` values.

    Parameters:

        lists (array): Two or more lists.

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "union",
        "lists": lists
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def url_encode(session, unencoded):
    '''
    URI encode

    URL encode a value or bag of values.

    Parameters:

        unencoded (): URL encode a single value. See the url_encode method
        for the data type of more details.

    Returns:
    string: URI encoded string.
    '''

    request = session.Request()

    action = {
        "function": "url_encode",
        "unencoded": unencoded
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

