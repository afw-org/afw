# -*- coding: utf-8 -*-

# Generated by afwdev generate afw

import requests
import json

def abs(session, value):
    """
    Absolute value

    Compute the absolute value of the `<dataType>` value and return the
    `<dataType>` result.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "abs",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def add(session, values):
    """
    Add

    Add 2 or more `<dataType>` values and return the `<dataType>` result.

    Args:
        values (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "add",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def add_dayTimeDuration(session, arg1, arg2):
    """
    Add duration

    Add `<dataType>` arg1 to dayTimeDuration arg2 and return the `<dataType>`
    result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "add_dayTimeDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def add_yearMonthDuration(session, arg1, arg2):
    """
    Add duration

    Add `<dataType>` arg1 to yearMonthDuration arg2 and return the
    `<dataType>` result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "add_yearMonthDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def at_least_one_member_of(session, array1, array2):
    """
    Checks for at least one value in common

    Returns boolean true if at least one value in `<dataType>` array1 is in
    `<dataType>` array2.

    Args:
        array1 (list): The first array.

        array2 (list): The second array.

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "at_least_one_member_of",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag(session, values=None):
    """
    Makes an array from values

    Takes any number of `<dataType>` values and returns an array of array.

    Args:
        values (list):

    Returns:
        list:
    """

    request = session.Request()

    action = {
        "function": "bag"
    }

    if values != None:
        action['values'] = values

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_size(session, value):
    """
    Returns the number of values in a bag

    This returns the integer number of values in array.

    Args:
        value (list):

    Returns:
        int:
    """

    request = session.Request()

    action = {
        "function": "bag_size",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ceil(session, value):
    """
    Round upward to nearest integer

    Determine the smallest integer that is greater then or equal to the
    `<dataType>` value and return the `<dataType>` result.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "ceil",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def clone(session, value):
    """
    Clone <dataType> value

    Deep clone a `<dataType>` value.

    Args:
        value (object): The `<dataType>` value to clone.

    Returns:
        object: The cloned `<dataType>` value.
    """

    request = session.Request()

    action = {
        "function": "clone",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def compile(session, source, listing=None):
    """
    Compile <dataType> value

    Compile `<dataType>` value and return either an unevaluated adaptive value
    or a string containing the compiler listing.

    Args:
        source (object): `<dataType>` string to compile

        listing (object): If specified, a compiler listing is produced instead
        of an unevaluated compiled value.
        
        This parameter can be an integer between 0 and 10 of a string that is
        used for indentation. If 0 is specified, no whitespace is added to the
        resulting string. If 1 through 10 is specified, that number of spaces
        is used.

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "compile",
        "source": source
    }

    if listing != None:
        action['listing'] = listing

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def decode_to_string(session, value):
    """
    Decode <dataType> to string

    Decode `<dataType>` value to string. An error is thrown if decoded value
    is not valid UTF-8.

    Args:
        value (object): The `<dataType>` value to decode.

    Returns:
        str: The decoded string.
    """

    request = session.Request()

    action = {
        "function": "decode_to_string",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def divide(session, dividend, divisor):
    """
    Divide numbers

    Divide `<dataType>` dividend by `<dataType>` divisor and return the
    `<dataType>` quotient.

    Args:
        dividend (object):

        divisor (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "divide",
        "dividend": dividend,
        "divisor": divisor
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def encode_as_base64Binary(session, value):
    """
    Encode to a base64Binary value

    Encode a value as a base64Binary. The effect is to create a base64Binary
    value with an internal value of the value passed.

    Args:
        value (object): The `<dataType>` value to encode.

    Returns:
        object: A base64Binary value.
    """

    request = session.Request()

    action = {
        "function": "encode_as_base64Binary",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def encode_as_hexBinary(session, value):
    """
    Encode to a hexBinary value

    Encode a value as a hexBinary. The effect is to create a hexBinary value
    with an internal value of the value passed.

    Args:
        value (object): The `<dataType>` value to encode.

    Returns:
        object: A hexBinary value.
    """

    request = session.Request()

    action = {
        "function": "encode_as_hexBinary",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ends_with(session, value, subString):
    """
    Checks whether value ends with a string

    Checks whether `<dataType>` value ends with a `<dataType>` and return the
    boolean result.

    Args:
        value (object):

        subString (str):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "ends_with",
        "value": value,
        "subString": subString
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq(session, arg1, arg2):
    """
    Checks for equal

    Determine if `<dataType>` arg1 is equal to the value of arg2 converted to
    the data type of arg1 then return the boolean result. Use 'eqx' ('===')
    instead if you want false to be returned if arg1 and arg2's data type
    don't match.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "eq",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq_ignore_case(session, arg1, arg2):
    """
    Checks for equal ignoring case

    Checks for `<dataType>` arg1 is equal to `<dataType>` arg2 ignoring case
    and return the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "eq_ignore_case",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eqx(session, arg1, arg2):
    """
    Checks for equal and type

    Determine if for `<dataType>` arg1 is equal to the value and data type of
    arg2 then return the boolean result. Use 'eq' ('==') instead if you want
    arg2 to be converted to the data type of arg1 before comparison.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "eqx",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def evaluate(session, source, additionalUntrustedQualifiedVariables=None):
    """
    Evaluate <dataType> value

    Compile and evaluate `<dataType>` value.

    Args:
        source (object): `<dataType>` string to compile and evaluate

        additionalUntrustedQualifiedVariables (dict): This parameter supplies
        additional qualified variables that can be accessed during evaluation.
        These variables will not be used by anything that needs to ensure its
        qualified variables must come from a trusted source, such as
        authorization. This parameter is intended to be used for testing only
        and should not be used for anything running in production.

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "evaluate",
        "source": source
    }

    if additionalUntrustedQualifiedVariables != None:
        action['additionalUntrustedQualifiedVariables'] = additionalUntrustedQualifiedVariables

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def floor(session, number):
    """
    Round downwards to nearest integer

    Determine the largest integer that is smaller then or equal to the
    `<dataType>` value and return the `<dataType>` result.

    Args:
        number (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "floor",
        "number": number
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ge(session, arg1, arg2):
    """
    Checks for greater than or equal

    Checks for `<dataType>` arg1 is greater than or equal to `<dataType>` arg2
    and return the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "ge",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def gt(session, arg1, arg2):
    """
    Checks for greater than

    Checks for `<dataType>` arg1 is greater than `<dataType>` arg2 and return
    the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "gt",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def in_range(session, time, startTime, endTime):
    """
    Checks if time in range

    Checks if `<dataType>` is between startTime and endTime, inclusive.
    Regardless of endTime value, it is always considered to be equal to, but
    less than 24 hours greater than startTime. If no `<dataType>` zone is
    specified for `<dataType>,` the default `<dataType>` zone is used. If no
    `<dataType>` zone is specified for startTime or endTime, the `<dataType>`
    zone of `<dataType>` is used.

    Args:
        time (object):

        startTime (object):

        endTime (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "in_range",
        "time": time,
        "startTime": startTime,
        "endTime": endTime
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def includes(session, searchString, subString, position=None):
    """
    Checks whether the <dataType> value includes a string

    Checks whether the `<dataType>` value includes a string and return the
    boolean result.

    Args:
        searchString (object): The `<dataType>` to search.

        subString (str): Substring to find.

        position (int): Zero-based position in the search string to start
        search.

    Returns:
        bool: Indicates if the substring is contained in the search string.
    """

    request = session.Request()

    action = {
        "function": "includes",
        "searchString": searchString,
        "subString": subString
    }

    if position != None:
        action['position'] = position

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def index_of(session, value, subString, startIndex=None):
    """
    Returns index of first occurrence

    Returns the zero-based index into `<dataType>` value of subString. If
    subString is not found, -1 is returned.

    Args:
        value (object): The `<dataType>` value to search.

        subString (str): Substring to search for.

        startIndex (int): Optional start index for search if different than
        start of string.

    Returns:
        int: Zero-based index of subString or -1 if not found.
    """

    request = session.Request()

    action = {
        "function": "index_of",
        "value": value,
        "subString": subString
    }

    if startIndex != None:
        action['startIndex'] = startIndex

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def intersection(session, array1, array2):
    """
    Returns intersection of two arrays

    Returns an array of `<dataType>` with the values that are common to both
    array of `<dataType>` array1 and array2.

    Args:
        array1 (list): The first array.

        array2 (list): The second array.

    Returns:
        list:
    """

    request = session.Request()

    action = {
        "function": "intersection",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_(session, value):
    """
    Checks whether value is dataType <dataType>

    Checks whether value is dataType `<dataType>` and return the boolean
    result.

    Args:
        value (object): Value to check

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "is",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_in(session, value, array):
    """
    Checks whether a value is in an array

    Checks whether `<dataType>` value is in array of `<dataType>` array and
    returns the boolean result.

    Args:
        value (object):

        array (list):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "is_in",
        "value": value,
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def last_index_of(session, value, subString, startIndex=None):
    """
    Returns index of last occurrence

    Returns the zero-based index into `<dataType>` value of the last
    occurrence of a subString. If subString is not found, -1 is returned.

    Args:
        value (object): The `<dataType>` value to search.

        subString (str): Substring to search for.

        startIndex (int): Optional start index for search if different than
        start of string.

    Returns:
        int: Zero-based index of subString or -1 if not found.
    """

    request = session.Request()

    action = {
        "function": "last_index_of",
        "value": value,
        "subString": subString
    }

    if startIndex != None:
        action['startIndex'] = startIndex

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def le(session, arg1, arg2):
    """
    Checks for less than or equal

    Checks for `<dataType>` arg1 is less than or equal to `<dataType>` arg2
    and return the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "le",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def length(session, value):
    """
    Returns number of codepoints or entries in value

    This is a polymorphic function where `<dataType>` can be any of the
    supported data types. Return the integer number of entries in datatype
    array or codepoints in others.

    Args:
        value (object): Returns the number of entries in an array or code
        points in others.

    Returns:
        int:
    """

    request = session.Request()

    action = {
        "function": "length",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def lt(session, arg1, arg2):
    """
    Checks for less than

    Checks for `<dataType>` arg1 is less that `<dataType>` arg2 and return the
    boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "lt",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def match(session, arg1, arg2):
    """
    Checks if x500Name matches

    Returns true if arg1 matches some terminal sequence of RDNs from arg2 when
    compared using `equal_<dataType>`.

    Args:
        arg1 (object):

        arg2 (str):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "match",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def max(session, values):
    """
    Maximum value

    Return the `<dataType>` value that is greater than or equal to the others.

    Args:
        values (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "max",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def min(session, values):
    """
    Minimum value

    Return the `<dataType>` value that is less than or equal to the others.

    Args:
        values (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "min",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def mod(session, dividend, divisor):
    """
    Remainder of dividing numbers

    Divide `<dataType>` dividend by `<dataType>` divisor and return the
    `<dataType>` remainder.

    Args:
        dividend (object):

        divisor (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "mod",
        "dividend": dividend,
        "divisor": divisor
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def multiply(session, values):
    """
    Multiply numbers

    Multiply 2 or more `<dataType>` values and return the `<dataType>` result.

    Args:
        values (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "multiply",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ne(session, arg1, arg2):
    """
    Checks for not equal

    Determine if `<dataType>` arg1 is not equal to the value of arg2 converted
    to the data type of arg1 then return the boolean result. Use 'nex' ('!==')
    instead if you want true to be returned if arg1 and arg2's data type don't
    match.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "ne",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def negative(session, value):
    """
    Negative of a number

    Return negative of `<dataType>` value.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "negative",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def nex(session, arg1, arg2):
    """
    Checks for not equal value or type

    Determine if for `<dataType>` arg1 is not equal to the value or data type
    of arg2 then return the boolean result. Use 'ne' ('!=') instead if you
    want arg2 to be converted to the data type of arg1 before comparison.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "nex",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def normalize_space(session, string):
    """
    Trims whitespace from beginning and end

    Remove whitespace from the beginning and end of a `<dataType>` value.

    Args:
        string (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "normalize_space",
        "string": string
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def normalize_to_lower_case(session, string):
    """
    Converts to lower case

    Normalize `<dataType>` value to lower case and returns `<dataType>`
    result.

    Args:
        string (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "normalize_to_lower_case",
        "string": string
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def one_and_only(session, array):
    """
    Converts a one value array to a <dataType> value

    This converts an array of `<dataType>` values that contains one value to a
    single `<dataType>` value.

    Args:
        array (list):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "one_and_only",
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def pow(session, base, exponent):
    """
    Base raised to a power

    This returns the value of base raised to a power. Multiple exponents can
    be specified to raise the previous exponent to the power of the latter
    exponent.

    Args:
        base (object): Base value.

        exponent (object): Exponent value.

    Returns:
        object: Base raised to the power.
    """

    request = session.Request()

    action = {
        "function": "pow",
        "base": base,
        "exponent": exponent
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def regexp_index_of(session, value, regexp):
    """
    Returns index of first match of regular expression

    Search `<dataType>` value for a regular expression and return index. If
    not found, -1 is returned.

    Args:
        value (object): The `<dataType>` value to search.

        regexp (str): A regular expression to use for search.

    Returns:
        int: Zero-based index of subString or -1 if not found.
    """

    request = session.Request()

    action = {
        "function": "regexp_index_of",
        "value": value,
        "regexp": regexp
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def regexp_match(session, value, regexp):
    """
    Search for a match using a regular expression

    Checks whether `<dataType>` value matches the regular expression regexp
    and return the boolean result.

    Args:
        value (object):

        regexp (str):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "regexp_match",
        "value": value,
        "regexp": regexp
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def regexp_replace(session, value, regexp, replacement, limit=None):
    """
    Replace strings matching a regular expression

    Replace matched values for a regular expression in a `<dataType>` value.

    Args:
        value (object): The original `<dataType>` value.

        regexp (str): A regular expression to use for search.

        replacement (str): The replacement string.

        limit (int): This is the maximum times to replace. The default is 1.
        Specify -1 to replace all occurrences.

    Returns:
        object: A `<dataType>` value with the matched string(s) replaced.
    """

    request = session.Request()

    action = {
        "function": "regexp_replace",
        "value": value,
        "regexp": regexp,
        "replacement": replacement
    }

    if limit != None:
        action['limit'] = limit

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def repeat(session, value, times):
    """
    Returns a repeated value

    Repeat a `<dataType>` value a specified number of times.

    Args:
        value (object): The `<dataType>` value to repeat.

        times (int): The number of times to repeat the value.

    Returns:
        object: The repeated `<dataType>` value.
    """

    request = session.Request()

    action = {
        "function": "repeat",
        "value": value,
        "times": times
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def replace(session, value, match, replacement, limit=None):
    """
    Replace strings

    Replace string(s) in a `<dataType>` value.

    Args:
        value (object): The original `<dataType>` value.

        match (str): The string to replace.

        replacement (str): The replacement string.

        limit (int): This is the maximum times to replace. The default is 1.
        Specify -1 to replace all occurrences.

    Returns:
        object: A `<dataType>` value with the matched string(s) replaced.
    """

    request = session.Request()

    action = {
        "function": "replace",
        "value": value,
        "match": match,
        "replacement": replacement
    }

    if limit != None:
        action['limit'] = limit

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def round(session, number):
    """
    Round to nearest integer

    Determine the integer closest to `<dataType>` value and return the
    `<dataType>` result.

    Args:
        number (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "round",
        "number": number
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def set_equals(session, array1, array2):
    """
    Checks whether two arrays are subsets of each other

    Returns boolean true if `<dataType>` array1 and `<dataType>` array2 are
    subsets of each other and return the boolean result.

    Args:
        array1 (list):

        array2 (list):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "set_equals",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def split(session, value, separator=None, limit=None):
    """
    Split at a separator

    Split `<dataType>` value into an array of strings using a separator.

    Args:
        value (object): The `<dataType>` value to split.

        separator (str): The separator to use. If this is an empty string or
        separator is not specified, the value is split between characters.

        limit (int): This is the maximum number of splits. Any remaining part
        of value is ignored.

    Returns:
        list: An array of strings.
    """

    request = session.Request()

    action = {
        "function": "split",
        "value": value
    }

    if separator != None:
        action['separator'] = separator

    if limit != None:
        action['limit'] = limit

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def starts_with(session, value, subString):
    """
    Checks whether value starts with a string

    Checks whether `<dataType>` value starts with a subString and return the
    boolean result.

    Args:
        value (object):

        subString (str):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "starts_with",
        "value": value,
        "subString": subString
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subset(session, array1, array2):
    """
    Determines if the first array is a subset of second array

    Returns boolean true if the unique values in `<dataType>` array1 are all
    in `<dataType>` array2.

    Args:
        array1 (list): The first array.

        array2 (list): The second array.

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "subset",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def substring(session, string, startIndex, endIndex=None):
    """
    Extract a substring

    Returns the `<dataType>` substring of value beginning at zero-based
    position integer startIndex and ending at the position before integer
    endIndex. Specify -1 or omitting endIndex to return up to end of
    `<dataType>`.

    Args:
        string (object):

        startIndex (int):

        endIndex (int):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "substring",
        "string": string,
        "startIndex": startIndex
    }

    if endIndex != None:
        action['endIndex'] = endIndex

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract(session, arg1, arg2):
    """
    Subtract numbers

    Subtract `<dataType>` arg2 from `<dataType>` arg1 and return the
    `<dataType>` result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "subtract",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract_dayTimeDuration(session, arg1, arg2):
    """
    Subtract numbers

    Subtract dayTimeDuration arg2 from `<dataType>` arg1 and return the
    `<dataType>` result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "subtract_dayTimeDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract_yearMonthDuration(session, arg1, arg2):
    """
    Subtract numbers

    Subtract yearMonthDuration arg2 from `<dataType>` arg1 and return the
    `<dataType>` result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "subtract_yearMonthDuration",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_anyURI(session, value):
    """
    Converts string to anyURI

    Converts `<dataType>` value to anyURI.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_anyURI",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_boolean(session, value):
    """
    Converts string to boolean

    Converts `<dataType>` value to boolean.

    Args:
        value (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "to_boolean",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_date(session, value):
    """
    Converts string to date

    Converts `<dataType>` value to date.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_date",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_dateTime(session, value):
    """
    Converts string to dateTime

    Converts `<dataType>` value to dateTime.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_dateTime",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_dayTimeDuration(session, value):
    """
    Converts string to dayTimeDuration

    Converts `<dataType>` value to dayTimeDuration.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_dayTimeDuration",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_dnsName(session, value):
    """
    Converts string to dnsName

    Converts `<dataType>` value to dnsName.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_dnsName",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_double(session, value):
    """
    Converts to double

    Converts `<dataType>` value to double and returns double result.

    Args:
        value (object):

    Returns:
        float:
    """

    request = session.Request()

    action = {
        "function": "to_double",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_integer(session, value):
    """
    Converts to integer

    Truncate `<dataType>` value to a whole number and returns integer result.

    Args:
        value (object):

    Returns:
        int:
    """

    request = session.Request()

    action = {
        "function": "to_integer",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_ipAddress(session, value):
    """
    Converts string to ipAddress

    Converts `<dataType>` value to ipAddress.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_ipAddress",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_rfc822Name(session, value):
    """
    Converts string to rfc822Name

    Converts `<dataType>` value to rfc822Name.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_rfc822Name",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_string(session, value):
    """
    Converts value to string

    Converts `<dataType>` value to string. For array values, the to_string()
    value for each entry is returned separated with commas.

    Args:
        value (object): A `<dataType>` value.

    Returns:
        str: The string representation of the value.
    """

    request = session.Request()

    action = {
        "function": "to_string",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_time(session, value):
    """
    Converts string to time

    Converts `<dataType>` value to time.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_time",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_x500Name(session, value):
    """
    Converts string to x500Name

    Converts `<dataType>` value to x500Name.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_x500Name",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_yearMonthDuration(session, value):
    """
    Converts string to yearMonthDuration

    Converts `<dataType>` value to yearMonthDuration.

    Args:
        value (object):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "to_yearMonthDuration",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def union(session, arrays):
    """
    Returns union of two or more string arrays

    Returns an array of `<dataType>` contains all of the unique values in two
    or more array of `<dataType>` values.

    Args:
        arrays (list): Two or more arrays.

    Returns:
        list:
    """

    request = session.Request()

    action = {
        "function": "union",
        "arrays": arrays
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def url_encode(session, unencoded):
    """
    URI encode

    URL encode a value or bag of values.

    Args:
        unencoded (object): URL encode a single value. See the url_encode
        method for the data type of more details.

    Returns:
        str: URI encoded string.
    """

    request = session.Request()

    action = {
        "function": "url_encode",
        "unencoded": unencoded
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

