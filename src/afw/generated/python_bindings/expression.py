# -*- coding: utf-8 -*-

# Generated by afwdev generate afw

import requests
import json

def bag_expression(session, values=None):
    """
    Makes an array from values

    Takes any number of expression values and returns an array of array.

    Args:
        values (list):

    Returns:
        list:
    """

    request = session.Request()

    action = {
        "function": "bag<expression>"
    }

    if values != None:
        action['values'] = values

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_size_expression(session, value):
    """
    Returns the number of values in a bag

    This returns the integer number of values in array.

    Args:
        value (list):

    Returns:
        int:
    """

    request = session.Request()

    action = {
        "function": "bag_size<expression>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def compile_expression(session, source, listing=None):
    """
    Compile expression value

    Compile expression value and return either an unevaluated adaptive value
    or a string containing the compiler listing.

    Args:
        source (object): expression string to compile

        listing (object): If specified, a compiler listing is produced
        instead of an unevaluated expression value.
        
        This parameter can be an integer between 0 and 10 of a string that is
        used for indentation. If 0 is specified, no whitespace is added to
        the resulting string. If 1 through 10 is specified, that number of
        spaces is used.

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "compile<expression>",
        "source": source
    }

    if listing != None:
        action['listing'] = listing

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq_expression(session, arg1, arg2):
    """
    Checks for equal

    Determine if expression arg1 is equal to the value of arg2 converted to
    the data type of arg1 then return the boolean result. Use 'eqx' ('===')
    instead if you want false to be returned if arg1 and arg2's data type
    don't match.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "eq<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eqx_expression(session, arg1, arg2):
    """
    Checks for equal and type

    Determine if for expression arg1 is equal to the value and data type of
    arg2 then return the boolean result. Use 'eq' ('==') instead if you want
    arg2 to be converted to the data type of arg1 before comparison.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "eqx<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def evaluate_expression(session, source, additionalUntrustedQualifiedVariables=None):
    """
    Evaluate expression value

    Compile and evaluate expression value.

    Args:
        source (object): expression string to compile and evaluate

        additionalUntrustedQualifiedVariables (dict): This parameter supplies
        additional qualified variables that can be accessed during
        evaluation. These variables will not be used by anything that needs
        to ensure its qualified variables must come from a trusted source,
        such as authorization. This parameter is intended to be used for
        testing only and should not be used for anything running in
        production.

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "evaluate<expression>",
        "source": source
    }

    if additionalUntrustedQualifiedVariables != None:
        action['additionalUntrustedQualifiedVariables'] = additionalUntrustedQualifiedVariables

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def expression(session, value):
    """
    Convert to data type expression

    Converts value to data type expression returning expression result.

    Args:
        value (object): Value to convert

    Returns:
        object: Converted value
    """

    request = session.Request()

    action = {
        "function": "expression",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ge_expression(session, arg1, arg2):
    """
    Checks for greater than or equal

    Checks for expression arg1 is greater than or equal to expression arg2
    and return the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "ge<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def gt_expression(session, arg1, arg2):
    """
    Checks for greater than

    Checks for expression arg1 is greater than expression arg2 and return the
    boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "gt<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_expression(session, value):
    """
    Checks whether value is dataType expression

    Checks whether value is dataType expression and return the boolean
    result.

    Args:
        value (object): Value to check

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "is<expression>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def le_expression(session, arg1, arg2):
    """
    Checks for less than or equal

    Checks for expression arg1 is less than or equal to expression arg2 and
    return the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "le<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def lt_expression(session, arg1, arg2):
    """
    Checks for less than

    Checks for expression arg1 is less that expression arg2 and return the
    boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "lt<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ne_expression(session, arg1, arg2):
    """
    Checks for not equal

    Determine if expression arg1 is not equal to the value of arg2 converted
    to the data type of arg1 then return the boolean result. Use 'nex'
    ('!==') instead if you want true to be returned if arg1 and arg2's data
    type don't match.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "ne<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def nex_expression(session, arg1, arg2):
    """
    Checks for not equal value or type

    Determine if for expression arg1 is not equal to the value or data type
    of arg2 then return the boolean result. Use 'ne' ('!=') instead if you
    want arg2 to be converted to the data type of arg1 before comparison.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "nex<expression>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_string_expression(session, value):
    """
    Converts value to string

    Converts expression value to string. For array values, the to_string()
    value for each entry is returned separated with commas.

    Args:
        value (object): A expression value.

    Returns:
        str: The string representation of the value.
    """

    request = session.Request()

    action = {
        "function": "to_string<expression>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

