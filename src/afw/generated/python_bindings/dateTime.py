# -*- coding: utf-8 -*-

# Generated by afwdev generate afw

import requests
import json

def add_dayTimeDuration_dateTime(session, arg1, arg2):
    '''
    Add duration

    Add dateTime arg1 to dayTimeDuration arg2 and return the dateTime result.

    Parameters:

        arg1 (dateTime):

        arg2 (dayTimeDuration):

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "add_dayTimeDuration<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def add_yearMonthDuration_dateTime(session, arg1, arg2):
    '''
    Add duration

    Add dateTime arg1 to yearMonthDuration arg2 and return the dateTime
    result.

    Parameters:

        arg1 (dateTime):

        arg2 (yearMonthDuration):

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "add_yearMonthDuration<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def at_least_one_member_of_dateTime(session, array1, array2):
    '''
    Checks for at least one value in common

    Returns boolean true if at least one value in dateTime array1 is in
    dateTime array2.

    Parameters:

        array1 (array): The first array.

        array2 (array): The second array.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "at_least_one_member_of<dateTime>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_dateTime(session, values=None):
    '''
    Makes an array from values

    Takes any number of dateTime values and returns an array of array.

    Parameters:

        values (array):

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "bag<dateTime>"
    }

    if values != None:
        action['values'] = values

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_size_dateTime(session, value):
    '''
    Returns the number of values in a bag

    This returns the integer number of values in array.

    Parameters:

        value (array):

    Returns:
    integer: 
    '''

    request = session.Request()

    action = {
        "function": "bag_size<dateTime>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def dateTime(session, value):
    '''
    Convert to data type dateTime

    Converts value to data type dateTime returning dateTime result.

    Parameters:

        value (): Value to convert

    Returns:
    dateTime: Converted value
    '''

    request = session.Request()

    action = {
        "function": "dateTime",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq_dateTime(session, arg1, arg2):
    '''
    Checks for equal

    Determine if dateTime arg1 is equal to the value of arg2 converted to the
    data type of arg1 then return the boolean result. Use 'eqx' ('===')
    instead if you want false to be returned if arg1 and arg2's data type
    don't match.

    Parameters:

        arg1 (dateTime):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eq<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eqx_dateTime(session, arg1, arg2):
    '''
    Checks for equal and type

    Determine if for dateTime arg1 is equal to the value and data type of
    arg2 then return the boolean result. Use 'eq' ('==') instead if you want
    arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 (dateTime):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eqx<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ge_dateTime(session, arg1, arg2):
    '''
    Checks for greater than or equal

    Checks for dateTime arg1 is greater than or equal to dateTime arg2 and
    return the boolean result.
    
    If a dateTime value does not include a time-zone value, then the local
    time-zone value will be assigned.

    Parameters:

        arg1 (dateTime):

        arg2 (dateTime):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ge<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def gt_dateTime(session, arg1, arg2):
    '''
    Checks for greater than

    Checks for dateTime arg1 is greater than dateTime arg2 and return the
    boolean result.
    
    If a dateTime value does not include a time-zone value, then the local
    time-zone value will be assigned.

    Parameters:

        arg1 (dateTime):

        arg2 (dateTime):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "gt<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def intersection_dateTime(session, array1, array2):
    '''
    Returns intersection of two arrays

    Returns an array of dateTime with the values that are common to both
    array of dateTime array1 and array2.

    Parameters:

        array1 (array): The first array.

        array2 (array): The second array.

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "intersection<dateTime>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_dateTime(session, value):
    '''
    Checks whether value is dataType dateTime

    Checks whether value is dataType dateTime and return the boolean result.

    Parameters:

        value (): Value to check

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is<dateTime>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_in_dateTime(session, value, array):
    '''
    Checks whether a value is in an array

    Checks whether dateTime value is in array of dateTime array and returns
    the boolean result.

    Parameters:

        value (dateTime):

        array (array):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is_in<dateTime>",
        "value": value,
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def le_dateTime(session, arg1, arg2):
    '''
    Checks for less than or equal

    Checks for dateTime arg1 is less than or equal to dateTime arg2 and
    return the boolean result.
    
    If a dateTime value does not include a time-zone value, then the local
    time-zone value will be assigned.

    Parameters:

        arg1 (dateTime):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "le<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def lt_dateTime(session, arg1, arg2):
    '''
    Checks for less than

    Checks for dateTime arg1 is less that dateTime arg2 and return the
    boolean result.
    
    If a dateTime value does not include a time-zone value, then the local
    time-zone value will be assigned.

    Parameters:

        arg1 (dateTime):

        arg2 (dateTime):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "lt<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def max_dateTime(session, values):
    '''
    Maximum value

    Return the dateTime value that is greater than or equal to the others.
    
    If a dateTime value does not include a time-zone value, then the local
    time-zone value will be assigned.

    Parameters:

        values (dateTime):

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "max<dateTime>",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def min_dateTime(session, values):
    '''
    Minimum value

    Return the dateTime value that is less than or equal to the others.
    
    If a dateTime value does not include a time-zone value, then the local
    time-zone value will be assigned.

    Parameters:

        values (dateTime):

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "min<dateTime>",
        "values": values
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ne_dateTime(session, arg1, arg2):
    '''
    Checks for not equal

    Determine if dateTime arg1 is not equal to the value of arg2 converted to
    the data type of arg1 then return the boolean result. Use 'nex' ('!==')
    instead if you want true to be returned if arg1 and arg2's data type
    don't match.

    Parameters:

        arg1 (dateTime):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ne<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def nex_dateTime(session, arg1, arg2):
    '''
    Checks for not equal value or type

    Determine if for dateTime arg1 is not equal to the value or data type of
    arg2 then return the boolean result. Use 'ne' ('!=') instead if you want
    arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 (dateTime):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "nex<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def one_and_only_dateTime(session, array):
    '''
    Converts a one value array to a dateTime value

    This converts an array of dateTime values that contains one value to a
    single dateTime value.

    Parameters:

        array (array):

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "one_and_only<dateTime>",
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def set_equals_dateTime(session, array1, array2):
    '''
    Checks whether two arrays are subsets of each other

    Returns boolean true if dateTime array1 and dateTime array2 are subsets
    of each other and return the boolean result.

    Parameters:

        array1 (array):

        array2 (array):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "set_equals<dateTime>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subset_dateTime(session, array1, array2):
    '''
    Determines if the first array is a subset of second array

    Returns boolean true if the unique values in dateTime array1 are all in
    dateTime array2.

    Parameters:

        array1 (array): The first array.

        array2 (array): The second array.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "subset<dateTime>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract_dayTimeDuration_dateTime(session, arg1, arg2):
    '''
    Subtract numbers

    Subtract dayTimeDuration arg2 from dateTime arg1 and return the dateTime
    result.

    Parameters:

        arg1 (dateTime):

        arg2 (dayTimeDuration):

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "subtract_dayTimeDuration<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subtract_yearMonthDuration_dateTime(session, arg1, arg2):
    '''
    Subtract numbers

    Subtract yearMonthDuration arg2 from dateTime arg1 and return the
    dateTime result.

    Parameters:

        arg1 (dateTime):

        arg2 (yearMonthDuration):

    Returns:
    dateTime: 
    '''

    request = session.Request()

    action = {
        "function": "subtract_yearMonthDuration<dateTime>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_string_dateTime(session, value):
    '''
    Converts value to string

    Converts dateTime value to string. For array values, the to_string()
    value for each entry is returned separated with commas.

    Parameters:

        value (dateTime): A dateTime value.

    Returns:
    string: The string representation of the value.
    '''

    request = session.Request()

    action = {
        "function": "to_string<dateTime>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def union_dateTime(session, arrays):
    '''
    Returns union of two or more string arrays

    Returns an array of dateTime contains all of the unique values in two or
    more array of dateTime values.

    Parameters:

        arrays (array): Two or more arrays.

    Returns:
    array: 
    '''

    request = session.Request()

    action = {
        "function": "union<dateTime>",
        "arrays": arrays
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

