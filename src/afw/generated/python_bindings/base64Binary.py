#!/usr/bin/env python3

##
# @file base64Binary.py
# @ingroup afw_bindings_python
# @brief This file contains the Python bindings for the base64Binary category.
#

# Generated by afwdev generate afw

import requests
import json

def at_least_one_member_of_base64Binary(session, array1, array2):
    """
    Checks for at least one value in common

    Returns boolean true if at least one value in base64Binary array1 is in
    base64Binary array2.

    Args:
        array1 (list): The first array.

        array2 (list): The second array.

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "at_least_one_member_of<base64Binary>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_base64Binary(session, values=None):
    """
    Makes an array from values

    Takes any number of base64Binary values and returns an array of array.

    Args:
        values (list):

    Returns:
        list:
    """

    request = session.Request()

    action = {
        "function": "bag<base64Binary>"
    }

    if values != None:
        action['values'] = values

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_size_base64Binary(session, value):
    """
    Returns the number of values in a bag

    This returns the integer number of values in array.

    Args:
        value (list):

    Returns:
        int:
    """

    request = session.Request()

    action = {
        "function": "bag_size<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def base64Binary(session, value):
    """
    Convert to data type base64Binary

    Converts value to data type base64Binary returning base64Binary result.

    Args:
        value (object): Value to convert

    Returns:
        object: Converted value
    """

    request = session.Request()

    action = {
        "function": "base64Binary",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def decode_to_string_base64Binary(session, value):
    """
    Decode base64Binary to string

    Decode base64Binary value to string. An error is thrown if decoded value
    is not valid UTF-8.

    Args:
        value (object): The base64Binary value to decode.

    Returns:
        str: The decoded string.
    """

    request = session.Request()

    action = {
        "function": "decode_to_string<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq_base64Binary(session, arg1, arg2):
    """
    Checks for equal

    Determine if base64Binary arg1 is equal to the value of arg2 converted to
    the data type of arg1 then return the boolean result. Use 'eqx' ('===')
    instead if you want false to be returned if arg1 and arg2's data type
    don't match.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "eq<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eqx_base64Binary(session, arg1, arg2):
    """
    Checks for equal and type

    Determine if for base64Binary arg1 is equal to the value and data type of
    arg2 then return the boolean result. Use 'eq' ('==') instead if you want
    arg2 to be converted to the data type of arg1 before comparison.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "eqx<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ge_base64Binary(session, arg1, arg2):
    """
    Checks for greater than or equal

    Checks for base64Binary arg1 is greater than or equal to base64Binary arg2
    and return the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "ge<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def gt_base64Binary(session, arg1, arg2):
    """
    Checks for greater than

    Checks for base64Binary arg1 is greater than base64Binary arg2 and return
    the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "gt<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def intersection_base64Binary(session, array1, array2):
    """
    Returns intersection of two arrays

    Returns an array of base64Binary with the values that are common to both
    array of base64Binary array1 and array2.

    Args:
        array1 (list): The first array.

        array2 (list): The second array.

    Returns:
        list:
    """

    request = session.Request()

    action = {
        "function": "intersection<base64Binary>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_base64Binary(session, value):
    """
    Checks whether value is dataType base64Binary

    Checks whether value is dataType base64Binary and return the boolean
    result.

    Args:
        value (object): Value to check

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "is<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_in_base64Binary(session, value, array):
    """
    Checks whether a value is in an array

    Checks whether base64Binary value is in array of base64Binary array and
    returns the boolean result.

    Args:
        value (object):

        array (list):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "is_in<base64Binary>",
        "value": value,
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def le_base64Binary(session, arg1, arg2):
    """
    Checks for less than or equal

    Checks for base64Binary arg1 is less than or equal to base64Binary arg2
    and return the boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "le<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def lt_base64Binary(session, arg1, arg2):
    """
    Checks for less than

    Checks for base64Binary arg1 is less that base64Binary arg2 and return the
    boolean result.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "lt<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ne_base64Binary(session, arg1, arg2):
    """
    Checks for not equal

    Determine if base64Binary arg1 is not equal to the value of arg2 converted
    to the data type of arg1 then return the boolean result. Use 'nex' ('!==')
    instead if you want true to be returned if arg1 and arg2's data type don't
    match.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "ne<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def nex_base64Binary(session, arg1, arg2):
    """
    Checks for not equal value or type

    Determine if for base64Binary arg1 is not equal to the value or data type
    of arg2 then return the boolean result. Use 'ne' ('!=') instead if you
    want arg2 to be converted to the data type of arg1 before comparison.

    Args:
        arg1 (object):

        arg2 (object):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "nex<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def one_and_only_base64Binary(session, array):
    """
    Converts a one value array to a base64Binary value

    This converts an array of base64Binary values that contains one value to a
    single base64Binary value.

    Args:
        array (list):

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "one_and_only<base64Binary>",
        "array": array
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def set_equals_base64Binary(session, array1, array2):
    """
    Checks whether two arrays are subsets of each other

    Returns boolean true if base64Binary array1 and base64Binary array2 are
    subsets of each other and return the boolean result.

    Args:
        array1 (list):

        array2 (list):

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "set_equals<base64Binary>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subset_base64Binary(session, array1, array2):
    """
    Determines if the first array is a subset of second array

    Returns boolean true if the unique values in base64Binary array1 are all
    in base64Binary array2.

    Args:
        array1 (list): The first array.

        array2 (list): The second array.

    Returns:
        bool:
    """

    request = session.Request()

    action = {
        "function": "subset<base64Binary>",
        "array1": array1,
        "array2": array2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_string_base64Binary(session, value):
    """
    Converts value to string

    Converts base64Binary value to string. For array values, the to_string()
    value for each entry is returned separated with commas.

    Args:
        value (object): A base64Binary value.

    Returns:
        str: The string representation of the value.
    """

    request = session.Request()

    action = {
        "function": "to_string<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def union_base64Binary(session, arrays):
    """
    Returns union of two or more string arrays

    Returns an array of base64Binary contains all of the unique values in two
    or more array of base64Binary values.

    Args:
        arrays (list): Two or more arrays.

    Returns:
        list:
    """

    request = session.Request()

    action = {
        "function": "union<base64Binary>",
        "arrays": arrays
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

