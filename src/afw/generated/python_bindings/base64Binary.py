# -*- coding: utf-8 -*-

# Generated by afwdev generate afw

import requests
import json

def at_least_one_member_of_base64Binary(session, list1, list2):
    '''
    Checks for at least one value in common

    Returns boolean true if at least one value in base64Binary list1 is in
    base64Binary list2.

    Parameters:

        list1 (list): The first list.

        list2 (list): The second list.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "at_least_one_member_of<base64Binary>",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_base64Binary(session, values=None):
    '''
    Makes a list from values

    Takes any number of base64Binary values and returns a list of list.

    Parameters:

        values (list):

    Returns:
    list: 
    '''

    request = session.Request()

    action = {
        "function": "bag<base64Binary>"
    }

    if values != None:
        action['values'] = values

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def bag_size_base64Binary(session, value):
    '''
    Returns the number of values in a bag

    This returns the integer number of values in list.

    Parameters:

        value (list):

    Returns:
    integer: 
    '''

    request = session.Request()

    action = {
        "function": "bag_size<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def base64Binary(session, value):
    '''
    Convert to data type base64Binary

    Converts value to data type base64Binary returning base64Binary result.

    Parameters:

        value (): Value to convert

    Returns:
    base64Binary: Converted value
    '''

    request = session.Request()

    action = {
        "function": "base64Binary",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def decode_to_string_base64Binary(session, value):
    '''
    Decode base64Binary to string

    Decode base64Binary value to string. An error is thrown if decoded value
    is not valid UTF-8.

    Parameters:

        value (base64Binary): The base64Binary value to decode.

    Returns:
    string: The decoded string.
    '''

    request = session.Request()

    action = {
        "function": "decode_to_string<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eq_base64Binary(session, arg1, arg2):
    '''
    Checks for equal

    Determine if base64Binary arg1 is equal to the value of arg2 converted to
    the data type of arg1 then return the boolean result. Use 'eqx' ('===')
    instead if you want false to be returned if arg1 and arg2's data type
    don't match.

    Parameters:

        arg1 (base64Binary):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eq<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def eqx_base64Binary(session, arg1, arg2):
    '''
    Checks for equal and type

    Determine if for base64Binary arg1 is equal to the value and data type of
    arg2 then return the boolean result. Use 'eq' ('==') instead if you want
    arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 (base64Binary):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "eqx<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ge_base64Binary(session, arg1, arg2):
    '''
    Checks for greater than or equal

    Checks for base64Binary arg1 is greater than or equal to base64Binary
    arg2 and return the boolean result.

    Parameters:

        arg1 (base64Binary):

        arg2 (base64Binary):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ge<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def gt_base64Binary(session, arg1, arg2):
    '''
    Checks for greater than

    Checks for base64Binary arg1 is greater than base64Binary arg2 and return
    the boolean result.

    Parameters:

        arg1 (base64Binary):

        arg2 (base64Binary):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "gt<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def intersection_base64Binary(session, list1, list2):
    '''
    Returns intersection of two lists

    Returns a list of base64Binary with the values that are common to both
    list of base64Binary list1 and list2.

    Parameters:

        list1 (list): The first list.

        list2 (list): The second list.

    Returns:
    list: 
    '''

    request = session.Request()

    action = {
        "function": "intersection<base64Binary>",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_base64Binary(session, value):
    '''
    Checks whether value is dataType base64Binary

    Checks whether value is dataType base64Binary and return the boolean
    result.

    Parameters:

        value (): Value to check

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def is_in_base64Binary(session, value, list):
    '''
    Checks whether a value is in a list

    Checks whether base64Binary value is in list of base64Binary list and
    returns the boolean result.

    Parameters:

        value (base64Binary):

        list (list):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "is_in<base64Binary>",
        "value": value,
        "list": list
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def le_base64Binary(session, arg1, arg2):
    '''
    Checks for less than or equal

    Checks for base64Binary arg1 is less than or equal to base64Binary arg2
    and return the boolean result.

    Parameters:

        arg1 (base64Binary):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "le<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def lt_base64Binary(session, arg1, arg2):
    '''
    Checks for less than

    Checks for base64Binary arg1 is less that base64Binary arg2 and return
    the boolean result.

    Parameters:

        arg1 (base64Binary):

        arg2 (base64Binary):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "lt<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def ne_base64Binary(session, arg1, arg2):
    '''
    Checks for not equal

    Determine if base64Binary arg1 is not equal to the value of arg2
    converted to the data type of arg1 then return the boolean result. Use
    'nex' ('!==') instead if you want true to be returned if arg1 and arg2's
    data type don't match.

    Parameters:

        arg1 (base64Binary):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "ne<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def nex_base64Binary(session, arg1, arg2):
    '''
    Checks for not equal value or type

    Determine if for base64Binary arg1 is not equal to the value or data type
    of arg2 then return the boolean result. Use 'ne' ('!=') instead if you
    want arg2 to be converted to the data type of arg1 before comparison.

    Parameters:

        arg1 (base64Binary):

        arg2 ():

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "nex<base64Binary>",
        "arg1": arg1,
        "arg2": arg2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def one_and_only_base64Binary(session, list):
    '''
    Converts a one value list to a base64Binary value

    This converts a list of base64Binary values that contains one value to a
    single base64Binary value.

    Parameters:

        list (list):

    Returns:
    base64Binary: 
    '''

    request = session.Request()

    action = {
        "function": "one_and_only<base64Binary>",
        "list": list
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def set_equals_base64Binary(session, list1, list2):
    '''
    Checks whether two lists are subsets of each other

    Returns boolean true if base64Binary list1 and base64Binary list2 are
    subsets of each other and return the boolean result.

    Parameters:

        list1 (list):

        list2 (list):

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "set_equals<base64Binary>",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def subset_base64Binary(session, list1, list2):
    '''
    Determines if the first list is a subset of second list

    Returns boolean true if the unique values in base64Binary list1 are all
    in base64Binary list2.

    Parameters:

        list1 (list): The first list.

        list2 (list): The second list.

    Returns:
    boolean: 
    '''

    request = session.Request()

    action = {
        "function": "subset<base64Binary>",
        "list1": list1,
        "list2": list2
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def to_string_base64Binary(session, value):
    '''
    Converts value to string

    Converts base64Binary value to string. For list values, the to_string()
    value for each entry is returned separated with commas.

    Parameters:

        value (base64Binary): A base64Binary value.

    Returns:
    string: The string representation of the value.
    '''

    request = session.Request()

    action = {
        "function": "to_string<base64Binary>",
        "value": value
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def union_base64Binary(session, lists):
    '''
    Returns union of two or more string lists

    Returns a list of base64Binary contains all of the unique values in two
    or more list of base64Binary values.

    Parameters:

        lists (list): Two or more lists.

    Returns:
    list: 
    '''

    request = session.Request()

    action = {
        "function": "union<base64Binary>",
        "lists": lists
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

