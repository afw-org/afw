# -*- coding: utf-8 -*-

# Generated by afwdev generate afw

import requests
import json

def extension_load(session, extension_id):
    """
    Load extension by id

    Load an extension by its extension id if it is not already loaded. Loading
    an AFW package's manifest extension will register the manifest of all
    extensions in the package.

    Args:
        extension_id (str): This is the object id of a
        /afw/_AdaptiveManifest_/ object.

    Returns:
        bool: If false the extension was already loaded. If true, the
        extension was successfully loaded which might have caused side effects
        such as environment registry changes. An error is thrown if there is a
        problem.
    """

    request = session.Request()

    action = {
        "function": "extension_load",
        "extension_id": extension_id
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def extension_load_by_module_path(session, module_path):
    """
    Load extension by module path

    Load an extension by its module path. Loading an AFW package's manifest
    extension will register the manifest of all extensions in the package.

    Args:
        module_path (str): This is the path to the dso containing the
        extension. If the extension is installed in the normal place, the
        library name without a file extension (.so) will suffice.

    Returns:
        str: The extension id of the extension loaded.
    """

    request = session.Request()

    action = {
        "function": "extension_load_by_module_path",
        "module_path": module_path
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def flag_get_active(session):
    """
    Get an array of active flags

    Get an array of of the flagId of flags that are set in the current
    execution context (xctx).

    Args:
    Returns:
        list: This is an array of the flagId of flags that are set in the
        current execution context (xctx).
    """

    request = session.Request()

    action = {
        "function": "flag_get_active"
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def flag_get_active_defaults(session):
    """
    Get an array of default active flags

    Get an array of the flagId of flags that are set by default when a new
    execution context (xctx) is created.

    Args:
    Returns:
        list: This is an array of the flagId of flags that are set by default
        when a new execution context (xctx) is created.
    """

    request = session.Request()

    action = {
        "function": "flag_get_active_defaults"
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def flag_get_defaults(session):
    """
    Get the array of flags used to determine the default active flags

    Get the array of the flagId of flags that are used to determine the
    default active flags when an execution context (xctx) is created. This
    array can contain the flagId of flags that have not yet been registered.
    Each of these flags and the flags they include are set as the active
    default flags.

    Args:
    Returns:
        list: This is an array of the flagId of flags used to determine the
        default active flags.
    """

    request = session.Request()

    action = {
        "function": "flag_get_defaults"
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def flag_modify_defaults(session, flagId, add=None):
    """
    Add or remove flags used to determine the default active flags

    Add or remove flags from the array of the flagId of flags that are used to
    determine the default active flags when an execution context (xctx) is
    created. This array can contain the flagId of flags that have not yet been
    registered. These flags and the flags they include are set as the active
    default flags.
    
    This change only lasts for the life of the current adaptive environment
    (e.g. until the adaptive server or afw command ends). If you want the
    change to persist, change the defaultFlags property in the application
    config.

    Args:
        flagId (list): The flagId of flags to be added or removed.

        add (bool): Specify true to add and false to remove flags. If not
        specified, flags are added.

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "flag_modify_defaults",
        "flagId": flagId
    }

    if add != None:
        action['add'] = add

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def flag_replace_defaults(session, flagId):
    """
    Replace the array of flags used to determine the default active flags

    Completely replace the array of the flagId of flags that are used to
    determine the default active flags when an execution context (xctx) is
    created. This array can contain the flagId of flags that have not yet been
    registered. These flags and the flags they include are set as the active
    default flags.
    
    This change only lasts for the life of the current adaptive environment
    (e.g. until the adaptive server or afw command ends). If you want the
    change to persist, change the defaultFlags property in the application
    config.

    Args:
        flagId (list): The array of the flagId of flags used to determine the
        default active flags.

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "flag_replace_defaults",
        "flagId": flagId
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def flag_set(session, flagId, setTo=None):
    """
    Set or unset active xctx flags

    Set or unset one or more active xctx (request) flags.

    Args:
        flagId (list): List of flagId of flags to set or unset.

        setTo (bool): Specify true to set and false to unset. If not
        specified, flags are set.

    Returns:
        object:
    """

    request = session.Request()

    action = {
        "function": "flag_set",
        "flagId": flagId
    }

    if setTo != None:
        action['setTo'] = setTo

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def registry_key_check(session, registryType, key, loadExtension=None):
    """
    Check to see if a registry key exists

    This will check to see if a registry key exists for a specified registry
    type and optionally load it's associated extension if needed.

    Args:
        registryType (str): This is the registry type, which is the object id
        of a /afw/_AdaptiveEnvironmentRegistryType_/ object.

        key (str): This is a key to check for existence in the specified
        registryType.

        loadExtension (bool): Specifying true for this optional parameter will
        cause the associated extension to be loaded if needed.

    Returns:
        bool: If false the extension was already loaded. If true, the
        extension was successfully loaded which might have caused side effects
        such as environment registry changes. An error is thrown if there is a
        problem.
    """

    request = session.Request()

    action = {
        "function": "registry_key_check",
        "registryType": registryType,
        "key": key
    }

    if loadExtension != None:
        action['loadExtension'] = loadExtension

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def service_get(session, serviceId):
    """
    Get service object

    Get a service object.

    Args:
        serviceId (str): The serviceId of the service.

    Returns:
        dict: _AdaptiveService_ object for the service which will contain the
        current status of the service. If there is an error, the status
        property value will be 'error' and 'statusMessage' contain an error
        message.
    """

    request = session.Request()

    action = {
        "function": "service_get",
        "serviceId": serviceId
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def service_restart(session, serviceId):
    """
    Restart service

    Restart a service.

    Args:
        serviceId (str): The serviceId of the service to restart.

    Returns:
        dict: _AdaptiveService_ object for the service which will contain the
        current status of the service. If there is an error, the status
        property value will be 'error' and 'statusMessage' contain an error
        message.
    """

    request = session.Request()

    action = {
        "function": "service_restart",
        "serviceId": serviceId
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def service_start(session, serviceId):
    """
    Start service

    Start a service.

    Args:
        serviceId (str): The serviceId of the service to start

    Returns:
        dict: _AdaptiveService_ object for the service which will contain the
        current status of the service. If there is an error, the status
        property value will be 'error' and 'statusMessage' contain an error
        message.
    """

    request = session.Request()

    action = {
        "function": "service_start",
        "serviceId": serviceId
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

def service_stop(session, serviceId):
    """
    Stop service

    Stop a service.

    Args:
        serviceId (str): The serviceId of the service to stop.

    Returns:
        dict: _AdaptiveService_ object for the service which will contain the
        current status of the service. If there is an error, the status
        property value will be 'error' and 'statusMessage' contain an error
        message.
    """

    request = session.Request()

    action = {
        "function": "service_stop",
        "serviceId": serviceId
    }

    request.add_action(action)

    response = request.perform()
    if response.get('status') == 'error':
        raise Exception(response.get('error'))

    return response['actions'][0]['result']

