<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: double functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">double functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adaptive Function to_string&lt;dnsName&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae270d2c5518859f044c0d2dea81138f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gae270d2c5518859f044c0d2dea81138f2">afw_function_execute_abs_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gae270d2c5518859f044c0d2dea81138f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function abs&lt;double&gt;  <a href="group__afw__functions__double.html#gae270d2c5518859f044c0d2dea81138f2">More...</a><br /></td></tr>
<tr class="separator:gae270d2c5518859f044c0d2dea81138f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d16102314a050deb86ba16f7dce7a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga07d16102314a050deb86ba16f7dce7a6">afw_function_execute_add_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga07d16102314a050deb86ba16f7dce7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function add&lt;double&gt;  <a href="group__afw__functions__double.html#ga07d16102314a050deb86ba16f7dce7a6">More...</a><br /></td></tr>
<tr class="separator:ga07d16102314a050deb86ba16f7dce7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040d833d78630d674be9de382263fefd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga040d833d78630d674be9de382263fefd">afw_function_execute_ceil_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga040d833d78630d674be9de382263fefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ceil&lt;double&gt;  <a href="group__afw__functions__double.html#ga040d833d78630d674be9de382263fefd">More...</a><br /></td></tr>
<tr class="separator:ga040d833d78630d674be9de382263fefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c66dafffa1cc4cd9980ebc6a5a279a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga2c66dafffa1cc4cd9980ebc6a5a279a0">afw_function_execute_divide_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga2c66dafffa1cc4cd9980ebc6a5a279a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function divide&lt;double&gt;  <a href="group__afw__functions__double.html#ga2c66dafffa1cc4cd9980ebc6a5a279a0">More...</a><br /></td></tr>
<tr class="separator:ga2c66dafffa1cc4cd9980ebc6a5a279a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga479f25a3ea8142a669f941f15d620c8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga479f25a3ea8142a669f941f15d620c8e">afw_function_execute_floor_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga479f25a3ea8142a669f941f15d620c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function floor&lt;double&gt;  <a href="group__afw__functions__double.html#ga479f25a3ea8142a669f941f15d620c8e">More...</a><br /></td></tr>
<tr class="separator:ga479f25a3ea8142a669f941f15d620c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278884c87f5f9ee66a143b45bf8f8a4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga278884c87f5f9ee66a143b45bf8f8a4c">afw_function_execute_is_NaN</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga278884c87f5f9ee66a143b45bf8f8a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is_NaN.  <a href="group__afw__functions__double.html#ga278884c87f5f9ee66a143b45bf8f8a4c">More...</a><br /></td></tr>
<tr class="separator:ga278884c87f5f9ee66a143b45bf8f8a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e368e5ba6f8f47e509222480d6a4413"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga6e368e5ba6f8f47e509222480d6a4413">afw_function_execute_is_finite</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga6e368e5ba6f8f47e509222480d6a4413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is_finite.  <a href="group__afw__functions__double.html#ga6e368e5ba6f8f47e509222480d6a4413">More...</a><br /></td></tr>
<tr class="separator:ga6e368e5ba6f8f47e509222480d6a4413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7264636dcb2647472c88584504f30aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gab7264636dcb2647472c88584504f30aa">afw_function_execute_multiply_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gab7264636dcb2647472c88584504f30aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function multiply&lt;double&gt;  <a href="group__afw__functions__double.html#gab7264636dcb2647472c88584504f30aa">More...</a><br /></td></tr>
<tr class="separator:gab7264636dcb2647472c88584504f30aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a315301020902003c5934c7d8b80441"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga4a315301020902003c5934c7d8b80441">afw_function_execute_negative_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga4a315301020902003c5934c7d8b80441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function negative&lt;double&gt;  <a href="group__afw__functions__double.html#ga4a315301020902003c5934c7d8b80441">More...</a><br /></td></tr>
<tr class="separator:ga4a315301020902003c5934c7d8b80441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de2b4a53bbf8412aba8dffc5c3a92d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga9de2b4a53bbf8412aba8dffc5c3a92d7">afw_function_execute_pow_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga9de2b4a53bbf8412aba8dffc5c3a92d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function pow&lt;double&gt;  <a href="group__afw__functions__double.html#ga9de2b4a53bbf8412aba8dffc5c3a92d7">More...</a><br /></td></tr>
<tr class="separator:ga9de2b4a53bbf8412aba8dffc5c3a92d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326424e0d0c4b5a85b8cba84935b94ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga326424e0d0c4b5a85b8cba84935b94ff">afw_function_execute_round_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga326424e0d0c4b5a85b8cba84935b94ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function round&lt;double&gt;  <a href="group__afw__functions__double.html#ga326424e0d0c4b5a85b8cba84935b94ff">More...</a><br /></td></tr>
<tr class="separator:ga326424e0d0c4b5a85b8cba84935b94ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7574d44b62260e5ada25e3845ef88a45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga7574d44b62260e5ada25e3845ef88a45">afw_function_execute_subtract_double</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga7574d44b62260e5ada25e3845ef88a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function subtract&lt;double&gt;  <a href="group__afw__functions__double.html#ga7574d44b62260e5ada25e3845ef88a45">More...</a><br /></td></tr>
<tr class="separator:ga7574d44b62260e5ada25e3845ef88a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8de954344b4e08a6a4965b74dafda145"><td class="memItemLeft" align="right" valign="top"><a id="ga8de954344b4e08a6a4965b74dafda145"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga8de954344b4e08a6a4965b74dafda145">afw_function_definition_abs_double</a></td></tr>
<tr class="memdesc:ga8de954344b4e08a6a4965b74dafda145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition abs&lt;double&gt; <br /></td></tr>
<tr class="separator:ga8de954344b4e08a6a4965b74dafda145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b28e6b0e887cc13c6414a2d7fac3c0"><td class="memItemLeft" align="right" valign="top"><a id="ga97b28e6b0e887cc13c6414a2d7fac3c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga97b28e6b0e887cc13c6414a2d7fac3c0">afw_function_definition_add_double</a></td></tr>
<tr class="memdesc:ga97b28e6b0e887cc13c6414a2d7fac3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition add&lt;double&gt; <br /></td></tr>
<tr class="separator:ga97b28e6b0e887cc13c6414a2d7fac3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cab28681476d3c6db8fe215f6e2b35f"><td class="memItemLeft" align="right" valign="top"><a id="ga3cab28681476d3c6db8fe215f6e2b35f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga3cab28681476d3c6db8fe215f6e2b35f">afw_function_definition_at_least_one_member_of_double</a></td></tr>
<tr class="memdesc:ga3cab28681476d3c6db8fe215f6e2b35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition at_least_one_member_of&lt;double&gt; <br /></td></tr>
<tr class="separator:ga3cab28681476d3c6db8fe215f6e2b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c58393a776b8f6d50e095914cba402"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga10c58393a776b8f6d50e095914cba402">afw_function_definition_bag_double</a></td></tr>
<tr class="memdesc:ga10c58393a776b8f6d50e095914cba402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function at_least_one_member_of&lt;double&gt;  <a href="group__afw__functions__double.html#ga10c58393a776b8f6d50e095914cba402">More...</a><br /></td></tr>
<tr class="separator:ga10c58393a776b8f6d50e095914cba402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefaf13d6aea44d738e8f7c6f9fdb0905"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gaefaf13d6aea44d738e8f7c6f9fdb0905">afw_function_definition_bag_size_double</a></td></tr>
<tr class="memdesc:gaefaf13d6aea44d738e8f7c6f9fdb0905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag&lt;double&gt;  <a href="group__afw__functions__double.html#gaefaf13d6aea44d738e8f7c6f9fdb0905">More...</a><br /></td></tr>
<tr class="separator:gaefaf13d6aea44d738e8f7c6f9fdb0905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda0da0bfbb356b45469bf41da7c92a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gadda0da0bfbb356b45469bf41da7c92a5">afw_function_definition_ceil_double</a></td></tr>
<tr class="memdesc:gadda0da0bfbb356b45469bf41da7c92a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag_size&lt;double&gt;  <a href="group__afw__functions__double.html#gadda0da0bfbb356b45469bf41da7c92a5">More...</a><br /></td></tr>
<tr class="separator:gadda0da0bfbb356b45469bf41da7c92a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e22e7032245eb147f7603e56bf7b2e"><td class="memItemLeft" align="right" valign="top"><a id="ga33e22e7032245eb147f7603e56bf7b2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga33e22e7032245eb147f7603e56bf7b2e">afw_function_definition_divide_double</a></td></tr>
<tr class="memdesc:ga33e22e7032245eb147f7603e56bf7b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition divide&lt;double&gt; <br /></td></tr>
<tr class="separator:ga33e22e7032245eb147f7603e56bf7b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca5b67a43f615e3f5e7f10537a19732"><td class="memItemLeft" align="right" valign="top"><a id="ga6ca5b67a43f615e3f5e7f10537a19732"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga6ca5b67a43f615e3f5e7f10537a19732">afw_function_definition_double</a></td></tr>
<tr class="memdesc:ga6ca5b67a43f615e3f5e7f10537a19732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition double. <br /></td></tr>
<tr class="separator:ga6ca5b67a43f615e3f5e7f10537a19732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d981c9b32724639f7645f0ba42675c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga82d981c9b32724639f7645f0ba42675c">afw_function_definition_eq_double</a></td></tr>
<tr class="memdesc:ga82d981c9b32724639f7645f0ba42675c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function double.  <a href="group__afw__functions__double.html#ga82d981c9b32724639f7645f0ba42675c">More...</a><br /></td></tr>
<tr class="separator:ga82d981c9b32724639f7645f0ba42675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7350cf3584d1dfa819b939025895be89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga7350cf3584d1dfa819b939025895be89">afw_function_definition_eqx_double</a></td></tr>
<tr class="memdesc:ga7350cf3584d1dfa819b939025895be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eq&lt;double&gt;  <a href="group__afw__functions__double.html#ga7350cf3584d1dfa819b939025895be89">More...</a><br /></td></tr>
<tr class="separator:ga7350cf3584d1dfa819b939025895be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec1a15f0e460ab228a44636e9c4c57e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gacec1a15f0e460ab228a44636e9c4c57e">afw_function_definition_floor_double</a></td></tr>
<tr class="memdesc:gacec1a15f0e460ab228a44636e9c4c57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eqx&lt;double&gt;  <a href="group__afw__functions__double.html#gacec1a15f0e460ab228a44636e9c4c57e">More...</a><br /></td></tr>
<tr class="separator:gacec1a15f0e460ab228a44636e9c4c57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ebe7787f17d11e994868971a971b84"><td class="memItemLeft" align="right" valign="top"><a id="gaa3ebe7787f17d11e994868971a971b84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gaa3ebe7787f17d11e994868971a971b84">afw_function_definition_ge_double</a></td></tr>
<tr class="memdesc:gaa3ebe7787f17d11e994868971a971b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition ge&lt;double&gt; <br /></td></tr>
<tr class="separator:gaa3ebe7787f17d11e994868971a971b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09aa5e4faf1a267ac8b6983a212b717"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gae09aa5e4faf1a267ac8b6983a212b717">afw_function_definition_gt_double</a></td></tr>
<tr class="memdesc:gae09aa5e4faf1a267ac8b6983a212b717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ge&lt;double&gt;  <a href="group__afw__functions__double.html#gae09aa5e4faf1a267ac8b6983a212b717">More...</a><br /></td></tr>
<tr class="separator:gae09aa5e4faf1a267ac8b6983a212b717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c87264b5f57729fceb3a34a10ef882"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga53c87264b5f57729fceb3a34a10ef882">afw_function_definition_intersection_double</a></td></tr>
<tr class="memdesc:ga53c87264b5f57729fceb3a34a10ef882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function gt&lt;double&gt;  <a href="group__afw__functions__double.html#ga53c87264b5f57729fceb3a34a10ef882">More...</a><br /></td></tr>
<tr class="separator:ga53c87264b5f57729fceb3a34a10ef882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71517f46f265f7d8481a4ae975bcdcbb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga71517f46f265f7d8481a4ae975bcdcbb">afw_function_definition_is_NaN</a></td></tr>
<tr class="memdesc:ga71517f46f265f7d8481a4ae975bcdcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function intersection&lt;double&gt;  <a href="group__afw__functions__double.html#ga71517f46f265f7d8481a4ae975bcdcbb">More...</a><br /></td></tr>
<tr class="separator:ga71517f46f265f7d8481a4ae975bcdcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425dd83dd646e283591cc7a17876f171"><td class="memItemLeft" align="right" valign="top"><a id="ga425dd83dd646e283591cc7a17876f171"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga425dd83dd646e283591cc7a17876f171">afw_function_definition_is_double</a></td></tr>
<tr class="memdesc:ga425dd83dd646e283591cc7a17876f171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition is&lt;double&gt; <br /></td></tr>
<tr class="separator:ga425dd83dd646e283591cc7a17876f171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedaa291a6c647e83c8f9114b8af200a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gaedaa291a6c647e83c8f9114b8af200a9">afw_function_definition_is_finite</a></td></tr>
<tr class="memdesc:gaedaa291a6c647e83c8f9114b8af200a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is&lt;double&gt;  <a href="group__afw__functions__double.html#gaedaa291a6c647e83c8f9114b8af200a9">More...</a><br /></td></tr>
<tr class="separator:gaedaa291a6c647e83c8f9114b8af200a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3241e129a46a1985dbde21e94d6ba192"><td class="memItemLeft" align="right" valign="top"><a id="ga3241e129a46a1985dbde21e94d6ba192"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga3241e129a46a1985dbde21e94d6ba192">afw_function_definition_is_in_double</a></td></tr>
<tr class="memdesc:ga3241e129a46a1985dbde21e94d6ba192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition is_in&lt;double&gt; <br /></td></tr>
<tr class="separator:ga3241e129a46a1985dbde21e94d6ba192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042d71bb8329ce5761bfb8b53f2b5a25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga042d71bb8329ce5761bfb8b53f2b5a25">afw_function_definition_le_double</a></td></tr>
<tr class="memdesc:ga042d71bb8329ce5761bfb8b53f2b5a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is_in&lt;double&gt;  <a href="group__afw__functions__double.html#ga042d71bb8329ce5761bfb8b53f2b5a25">More...</a><br /></td></tr>
<tr class="separator:ga042d71bb8329ce5761bfb8b53f2b5a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd276a2702e07f930b4567b12fc9ab93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gafd276a2702e07f930b4567b12fc9ab93">afw_function_definition_lt_double</a></td></tr>
<tr class="memdesc:gafd276a2702e07f930b4567b12fc9ab93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function le&lt;double&gt;  <a href="group__afw__functions__double.html#gafd276a2702e07f930b4567b12fc9ab93">More...</a><br /></td></tr>
<tr class="separator:gafd276a2702e07f930b4567b12fc9ab93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca695ab74adaf70f2ae71212d86f2572"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gaca695ab74adaf70f2ae71212d86f2572">afw_function_definition_max_double</a></td></tr>
<tr class="memdesc:gaca695ab74adaf70f2ae71212d86f2572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function lt&lt;double&gt;  <a href="group__afw__functions__double.html#gaca695ab74adaf70f2ae71212d86f2572">More...</a><br /></td></tr>
<tr class="separator:gaca695ab74adaf70f2ae71212d86f2572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c81934c7c4ed7d27b6cfdd1743531c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gab0c81934c7c4ed7d27b6cfdd1743531c">afw_function_definition_min_double</a></td></tr>
<tr class="memdesc:gab0c81934c7c4ed7d27b6cfdd1743531c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function max&lt;double&gt;  <a href="group__afw__functions__double.html#gab0c81934c7c4ed7d27b6cfdd1743531c">More...</a><br /></td></tr>
<tr class="separator:gab0c81934c7c4ed7d27b6cfdd1743531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9857a4ed119e83bec229ba8b2db9dc79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga9857a4ed119e83bec229ba8b2db9dc79">afw_function_definition_multiply_double</a></td></tr>
<tr class="memdesc:ga9857a4ed119e83bec229ba8b2db9dc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function min&lt;double&gt;  <a href="group__afw__functions__double.html#ga9857a4ed119e83bec229ba8b2db9dc79">More...</a><br /></td></tr>
<tr class="separator:ga9857a4ed119e83bec229ba8b2db9dc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b19be01c4a1fcc3c22952b9226bede"><td class="memItemLeft" align="right" valign="top"><a id="ga12b19be01c4a1fcc3c22952b9226bede"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga12b19be01c4a1fcc3c22952b9226bede">afw_function_definition_ne_double</a></td></tr>
<tr class="memdesc:ga12b19be01c4a1fcc3c22952b9226bede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition ne&lt;double&gt; <br /></td></tr>
<tr class="separator:ga12b19be01c4a1fcc3c22952b9226bede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga915cc6b33e93a6edc7d69e39157eef4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga915cc6b33e93a6edc7d69e39157eef4f">afw_function_definition_negative_double</a></td></tr>
<tr class="memdesc:ga915cc6b33e93a6edc7d69e39157eef4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ne&lt;double&gt;  <a href="group__afw__functions__double.html#ga915cc6b33e93a6edc7d69e39157eef4f">More...</a><br /></td></tr>
<tr class="separator:ga915cc6b33e93a6edc7d69e39157eef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d09cb7514a7fc51ea72313029ff2e5"><td class="memItemLeft" align="right" valign="top"><a id="gac1d09cb7514a7fc51ea72313029ff2e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gac1d09cb7514a7fc51ea72313029ff2e5">afw_function_definition_nex_double</a></td></tr>
<tr class="memdesc:gac1d09cb7514a7fc51ea72313029ff2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition nex&lt;double&gt; <br /></td></tr>
<tr class="separator:gac1d09cb7514a7fc51ea72313029ff2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a0bf0989b895fde6cff7f7d7b5cca54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga9a0bf0989b895fde6cff7f7d7b5cca54">afw_function_definition_one_and_only_double</a></td></tr>
<tr class="memdesc:ga9a0bf0989b895fde6cff7f7d7b5cca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function nex&lt;double&gt;  <a href="group__afw__functions__double.html#ga9a0bf0989b895fde6cff7f7d7b5cca54">More...</a><br /></td></tr>
<tr class="separator:ga9a0bf0989b895fde6cff7f7d7b5cca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2903a2e09030ab621b66da6789619366"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga2903a2e09030ab621b66da6789619366">afw_function_definition_pow_double</a></td></tr>
<tr class="memdesc:ga2903a2e09030ab621b66da6789619366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function one_and_only&lt;double&gt;  <a href="group__afw__functions__double.html#ga2903a2e09030ab621b66da6789619366">More...</a><br /></td></tr>
<tr class="separator:ga2903a2e09030ab621b66da6789619366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0580d61ffca156916f01de4c471130"><td class="memItemLeft" align="right" valign="top"><a id="gaba0580d61ffca156916f01de4c471130"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gaba0580d61ffca156916f01de4c471130">afw_function_definition_round_double</a></td></tr>
<tr class="memdesc:gaba0580d61ffca156916f01de4c471130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition round&lt;double&gt; <br /></td></tr>
<tr class="separator:gaba0580d61ffca156916f01de4c471130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10127693f5802ee69a07a9e5b5f7b246"><td class="memItemLeft" align="right" valign="top"><a id="ga10127693f5802ee69a07a9e5b5f7b246"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga10127693f5802ee69a07a9e5b5f7b246">afw_function_definition_set_equals_double</a></td></tr>
<tr class="memdesc:ga10127693f5802ee69a07a9e5b5f7b246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition set_equals&lt;double&gt; <br /></td></tr>
<tr class="separator:ga10127693f5802ee69a07a9e5b5f7b246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e0ac9d78fe0e465fa565d48c028627"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga96e0ac9d78fe0e465fa565d48c028627">afw_function_definition_subset_double</a></td></tr>
<tr class="memdesc:ga96e0ac9d78fe0e465fa565d48c028627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function set_equals&lt;double&gt;  <a href="group__afw__functions__double.html#ga96e0ac9d78fe0e465fa565d48c028627">More...</a><br /></td></tr>
<tr class="separator:ga96e0ac9d78fe0e465fa565d48c028627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa38d48d507655b8a33ba02565754709c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#gaa38d48d507655b8a33ba02565754709c">afw_function_definition_subtract_double</a></td></tr>
<tr class="memdesc:gaa38d48d507655b8a33ba02565754709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function subset&lt;double&gt;  <a href="group__afw__functions__double.html#gaa38d48d507655b8a33ba02565754709c">More...</a><br /></td></tr>
<tr class="separator:gaa38d48d507655b8a33ba02565754709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c071ec12873cb55d2f647a22429c55"><td class="memItemLeft" align="right" valign="top"><a id="ga12c071ec12873cb55d2f647a22429c55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga12c071ec12873cb55d2f647a22429c55">afw_function_definition_to_integer_double</a></td></tr>
<tr class="memdesc:ga12c071ec12873cb55d2f647a22429c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition to_integer&lt;double&gt; <br /></td></tr>
<tr class="separator:ga12c071ec12873cb55d2f647a22429c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f994f6693086ade7def9ddf8766b382"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga7f994f6693086ade7def9ddf8766b382">afw_function_definition_to_string_double</a></td></tr>
<tr class="memdesc:ga7f994f6693086ade7def9ddf8766b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_integer&lt;double&gt;  <a href="group__afw__functions__double.html#ga7f994f6693086ade7def9ddf8766b382">More...</a><br /></td></tr>
<tr class="separator:ga7f994f6693086ade7def9ddf8766b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga820629c858d7565dd1eabcdc4a97899c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__double.html#ga820629c858d7565dd1eabcdc4a97899c">afw_function_definition_union_double</a></td></tr>
<tr class="memdesc:ga820629c858d7565dd1eabcdc4a97899c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_string&lt;double&gt;  <a href="group__afw__functions__double.html#ga820629c858d7565dd1eabcdc4a97899c">More...</a><br /></td></tr>
<tr class="separator:ga820629c858d7565dd1eabcdc4a97899c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adaptive Function to_string&lt;dnsName&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts dnsName value to string. For list values, the to_string() value for each entry is returned separated with commas.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function to_string&lt;dnsName&gt;( value: dnsName ): string;</p>
<p>Parameters:</p>
<p>value - (dnsName) A dnsName value.</p>
<p>Returns:</p>
<p>(string) The string representation of the value.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>double adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae270d2c5518859f044c0d2dea81138f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae270d2c5518859f044c0d2dea81138f2">&#9670;&nbsp;</a></span>afw_function_execute_abs_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_abs_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function abs&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Compute the absolute value of the double value and return the double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function abs&lt;double&gt;( value: double ): double;</p>
<p>Parameters:</p>
<p>value - (double)</p>
<p>Returns:</p>
<p>(double)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000108">Todo:</a></b></dt><dd>FIXME: A lot of the argument check may be able to be replaced by signals. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00049">49</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga07d16102314a050deb86ba16f7dce7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d16102314a050deb86ba16f7dce7a6">&#9670;&nbsp;</a></span>afw_function_execute_add_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_add_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function add&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Add 2 or more double values and return the double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function add&lt;double&gt;( values_1: double, values_2: double, ...values_rest: (list of double) ): double;</p>
<p>Parameters:</p>
<p>values - (2 or more double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00097">97</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga040d833d78630d674be9de382263fefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga040d833d78630d674be9de382263fefd">&#9670;&nbsp;</a></span>afw_function_execute_ceil_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_ceil_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ceil&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the smallest integer that is greater then or equal to the double value and return the double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ceil&lt;double&gt;( value: double ): double;</p>
<p>Parameters:</p>
<p>value - (double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00143">143</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga2c66dafffa1cc4cd9980ebc6a5a279a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c66dafffa1cc4cd9980ebc6a5a279a0">&#9670;&nbsp;</a></span>afw_function_execute_divide_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_divide_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function divide&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Divide double dividend by double divisor and return the double quotient.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function divide&lt;double&gt;( dividend: double, divisor: double ): double;</p>
<p>Parameters:</p>
<p>dividend - (double)</p>
<p>divisor - (double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00185">185</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga479f25a3ea8142a669f941f15d620c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga479f25a3ea8142a669f941f15d620c8e">&#9670;&nbsp;</a></span>afw_function_execute_floor_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_floor_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function floor&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the largest integer that is smaller then or equal to the double value and return the double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function floor&lt;double&gt;( number: double ): double;</p>
<p>Parameters:</p>
<p>number - (double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00269">269</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga6e368e5ba6f8f47e509222480d6a4413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e368e5ba6f8f47e509222480d6a4413">&#9670;&nbsp;</a></span>afw_function_execute_is_finite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_is_finite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is_finite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if the argument 'number' is finite and returns the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function is_finite( number: double ): boolean;</p>
<p>Parameters:</p>
<p>number - (double) Number to check.</p>
<p>Returns:</p>
<p>(boolean) True if the argument 'number' is finite. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00227">227</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga278884c87f5f9ee66a143b45bf8f8a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga278884c87f5f9ee66a143b45bf8f8a4c">&#9670;&nbsp;</a></span>afw_function_execute_is_NaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_is_NaN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is_NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if the argument 'number' is not a number(NaN) and returns the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function is_NaN( number: double ): boolean;</p>
<p>Parameters:</p>
<p>number - (double) Number to check.</p>
<p>Returns:</p>
<p>(boolean) True if the argument 'number' is not a number. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00356">356</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="gab7264636dcb2647472c88584504f30aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7264636dcb2647472c88584504f30aa">&#9670;&nbsp;</a></span>afw_function_execute_multiply_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_multiply_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function multiply&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Multiply 2 or more double values and return the double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function multiply&lt;double&gt;( values_1: double, values_2: double, ...values_rest: (list of double) ): double;</p>
<p>Parameters:</p>
<p>values - (2 or more double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00310">310</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga4a315301020902003c5934c7d8b80441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a315301020902003c5934c7d8b80441">&#9670;&nbsp;</a></span>afw_function_execute_negative_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_negative_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function negative&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Return negative of double value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function negative&lt;double&gt;( value: double ): double;</p>
<p>Parameters:</p>
<p>value - (double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00593">593</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga9de2b4a53bbf8412aba8dffc5c3a92d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9de2b4a53bbf8412aba8dffc5c3a92d7">&#9670;&nbsp;</a></span>afw_function_execute_pow_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_pow_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function pow&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the value of base raised to a power. Multiple exponents can be specified to raise the previous exponent to the power of the latter exponent.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function pow&lt;double&gt;( base: double, exponent_1: double, ...exponent_rest: (list of double) ): double;</p>
<p>Parameters:</p>
<p>base - (double) Base value.</p>
<p>exponent - (1 or more double) Exponent value.</p>
<p>Returns:</p>
<p>(double) Base raised to the power. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00403">403</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga326424e0d0c4b5a85b8cba84935b94ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga326424e0d0c4b5a85b8cba84935b94ff">&#9670;&nbsp;</a></span>afw_function_execute_round_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_round_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function round&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the integer closest to double value and return the double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function round&lt;double&gt;( number: double ): double;</p>
<p>Parameters:</p>
<p>number - (double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00468">468</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<a id="ga7574d44b62260e5ada25e3845ef88a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7574d44b62260e5ada25e3845ef88a45">&#9670;&nbsp;</a></span>afw_function_execute_subtract_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_subtract_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function subtract&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Subtract double arg2 from double arg1 and return the double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function subtract&lt;double&gt;( arg1: double, arg2: double ): double;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (double)</p>
<p>Returns:</p>
<p>(double) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__double_8c_source.html#l00511">511</a> of file <a class="el" href="afw__function__double_8c_source.html">afw_function_double.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga10c58393a776b8f6d50e095914cba402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10c58393a776b8f6d50e095914cba402">&#9670;&nbsp;</a></span>afw_function_definition_bag_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function at_least_one_member_of&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if at least one value in double list1 is in double list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function at_least_one_member_of&lt;double&gt;( list1: (list double), list2: (list double) ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list double) The first list.</p>
<p>list2 - (list double) The second list.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaa5adc6433af8f5dcab16f7bd1f0643e3" title="Function implementation function AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING.">afw_function_execute_at_least_one_member_of()</a></p>
<hr  />
<p>Function definition bag&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l09668">9668</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaefaf13d6aea44d738e8f7c6f9fdb0905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefaf13d6aea44d738e8f7c6f9fdb0905">&#9670;&nbsp;</a></span>afw_function_definition_bag_size_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag_size_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes any number of double values and returns a list of list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function bag&lt;double&gt;( ...values: (list of (list double)) ): (list double);</p>
<p>Parameters:</p>
<p>values - (0 or more list double)</p>
<p>Returns:</p>
<p>(list double)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga39c1a41a0d8363c8d5ceae7a6d65489a" title="Function implementation function afw_function_execute_bag.">afw_function_execute_bag()</a></p>
<hr  />
<p>Function definition bag_size&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l09704">9704</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gadda0da0bfbb356b45469bf41da7c92a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda0da0bfbb356b45469bf41da7c92a5">&#9670;&nbsp;</a></span>afw_function_definition_ceil_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ceil_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag_size&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the integer number of values in list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function bag_size&lt;double&gt;( value: (list double) ): integer;</p>
<p>Parameters:</p>
<p>value - (list double)</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gae78d6ef2506492c58f64e35f7ec84fff" title="Function implementation function afw_function_execute_bag_size.">afw_function_execute_bag_size()</a></p>
<hr  />
<p>Function definition ceil&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l09740">9740</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga82d981c9b32724639f7645f0ba42675c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82d981c9b32724639f7645f0ba42675c">&#9670;&nbsp;</a></span>afw_function_definition_eq_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eq_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts value to data type double returning double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function double( value: any ): double;</p>
<p>Parameters:</p>
<p>value - (any dataType) Value to convert.</p>
<p>Returns:</p>
<p>(double) Converted value.</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>Function definition eq&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l09854">9854</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga7350cf3584d1dfa819b939025895be89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7350cf3584d1dfa819b939025895be89">&#9670;&nbsp;</a></span>afw_function_definition_eqx_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eqx_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eq&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if double arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "eqx" ("===") instead if you want false to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function eq&lt;double&gt;( arg1: double, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga4b5f63dcfd77b17d064ce733ffde1b04" title="Function implementation function afw_function_execute_eq.">afw_function_execute_eq()</a></p>
<hr  />
<p>Function definition eqx&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l09899">9899</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gacec1a15f0e460ab228a44636e9c4c57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacec1a15f0e460ab228a44636e9c4c57e">&#9670;&nbsp;</a></span>afw_function_definition_floor_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_floor_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eqx&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for double arg1 is equal to the value and data type of arg2 then return the boolean result. Use "eq" ("==") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function eqx&lt;double&gt;( arg1: double, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga8038bd01243984b8b135337e768925f5" title="Function implementation function afw_function_execute_eqx.">afw_function_execute_eqx()</a></p>
<hr  />
<p>Function definition floor&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l09940">9940</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gae09aa5e4faf1a267ac8b6983a212b717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae09aa5e4faf1a267ac8b6983a212b717">&#9670;&nbsp;</a></span>afw_function_definition_gt_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_gt_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ge&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for double arg1 is greater than or equal to double arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ge&lt;double&gt;( arg1: double, arg2: double ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (double)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga2c6ce9c296190c183129fe801999fb85" title="Function implementation function afw_function_execute_ge.">afw_function_execute_ge()</a></p>
<hr  />
<p>Function definition gt&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10016">10016</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga53c87264b5f57729fceb3a34a10ef882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c87264b5f57729fceb3a34a10ef882">&#9670;&nbsp;</a></span>afw_function_definition_intersection_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_intersection_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function gt&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for double arg1 is greater than double arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function gt&lt;double&gt;( arg1: double, arg2: double ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (double)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf8fcfd20e0990c533eaf3a75189f28c5" title="Function implementation function afw_function_execute_gt.">afw_function_execute_gt()</a></p>
<hr  />
<p>Function definition intersection&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10056">10056</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaedaa291a6c647e83c8f9114b8af200a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedaa291a6c647e83c8f9114b8af200a9">&#9670;&nbsp;</a></span>afw_function_definition_is_finite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_is_finite</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether value is dataType double and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function is&lt;double&gt;( value: any ): boolean;</p>
<p>Parameters:</p>
<p>value - (any dataType) Value to check.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga592ff430af3e6f20df8c7c7014da60d6" title="Function implementation function afw_function_execute_is.">afw_function_execute_is()</a></p>
<hr  />
<p>Function definition is_finite </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10168">10168</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga71517f46f265f7d8481a4ae975bcdcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71517f46f265f7d8481a4ae975bcdcbb">&#9670;&nbsp;</a></span>afw_function_definition_is_NaN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_is_NaN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function intersection&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of double with the values that are common to both list of double list1 and list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function intersection&lt;double&gt;( list1: (list double), list2: (list double) ): (list double);</p>
<p>Parameters:</p>
<p>list1 - (list double) The first list.</p>
<p>list2 - (list double) The second list.</p>
<p>Returns:</p>
<p>(list double)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga65a6458f6f7ab91c8cdba95450fab2ea" title="Function implementation function afw_function_execute_intersection.">afw_function_execute_intersection()</a></p>
<hr  />
<p>Function definition is_NaN </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10096">10096</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga042d71bb8329ce5761bfb8b53f2b5a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga042d71bb8329ce5761bfb8b53f2b5a25">&#9670;&nbsp;</a></span>afw_function_definition_le_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_le_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is_in&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether double value is in list of double list and returns the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function is_in&lt;double&gt;( value: double, list: (list double) ): boolean;</p>
<p>Parameters:</p>
<p>value - (double)</p>
<p>list - (list double)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga2c9f39702d570243e4e336709089a4ae" title="Function implementation function afw_function_execute_is_in.">afw_function_execute_is_in()</a></p>
<hr  />
<p>Function definition le&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10243">10243</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gafd276a2702e07f930b4567b12fc9ab93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd276a2702e07f930b4567b12fc9ab93">&#9670;&nbsp;</a></span>afw_function_definition_lt_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_lt_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function le&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for double arg1 is less than or equal to double arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function le&lt;double&gt;( arg1: double, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gab0b76d3bc6ee064c67c3bea1dda7989d" title="Function implementation function afw_function_execute_le.">afw_function_execute_le()</a></p>
<hr  />
<p>Function definition lt&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10283">10283</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaca695ab74adaf70f2ae71212d86f2572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca695ab74adaf70f2ae71212d86f2572">&#9670;&nbsp;</a></span>afw_function_definition_max_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_max_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function lt&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for double arg1 is less that double arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function lt&lt;double&gt;( arg1: double, arg2: double ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (double)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gafa22bf341d641f266c31a32ceeb256a6" title="Function implementation function afw_function_execute_lt.">afw_function_execute_lt()</a></p>
<hr  />
<p>Function definition max&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10323">10323</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gab0c81934c7c4ed7d27b6cfdd1743531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0c81934c7c4ed7d27b6cfdd1743531c">&#9670;&nbsp;</a></span>afw_function_definition_min_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_min_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function max&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the double value that is greater than or equal to the others.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function max&lt;double&gt;( values_1: double, ...values_rest: (list of double) ): double;</p>
<p>Parameters:</p>
<p>values - (1 or more double)</p>
<p>Returns:</p>
<p>(double)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga40441f16e040e4210d9999d3b1421d30" title="Function implementation function afw_function_execute_max.">afw_function_execute_max()</a></p>
<hr  />
<p>Function definition min&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10360">10360</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga9857a4ed119e83bec229ba8b2db9dc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9857a4ed119e83bec229ba8b2db9dc79">&#9670;&nbsp;</a></span>afw_function_definition_multiply_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_multiply_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function min&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the double value that is less than or equal to the others.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function min&lt;double&gt;( values_1: double, ...values_rest: (list of double) ): double;</p>
<p>Parameters:</p>
<p>values - (1 or more double)</p>
<p>Returns:</p>
<p>(double)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga4d26d532623f4f45bc81e9e2f956d148" title="Function implementation function afw_function_execute_min.">afw_function_execute_min()</a></p>
<hr  />
<p>Function definition multiply&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10397">10397</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga915cc6b33e93a6edc7d69e39157eef4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga915cc6b33e93a6edc7d69e39157eef4f">&#9670;&nbsp;</a></span>afw_function_definition_negative_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_negative_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ne&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if double arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "nex" ("!==") instead if you want true to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ne&lt;double&gt;( arg1: double, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf144f30dc392293fb1eb3058a00f3093" title="Function implementation function afw_function_execute_ne.">afw_function_execute_ne()</a></p>
<hr  />
<p>Function definition negative&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10479">10479</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga9a0bf0989b895fde6cff7f7d7b5cca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a0bf0989b895fde6cff7f7d7b5cca54">&#9670;&nbsp;</a></span>afw_function_definition_one_and_only_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_one_and_only_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function nex&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for double arg1 is not equal to the value or data type of arg2 then return the boolean result. Use "ne" ("!=") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function nex&lt;double&gt;( arg1: double, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (double)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga16fe2f777eb9e0a29ece94637d9c29ec" title="Function implementation function afw_function_execute_nex.">afw_function_execute_nex()</a></p>
<hr  />
<p>Function definition one_and_only&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10555">10555</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga2903a2e09030ab621b66da6789619366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2903a2e09030ab621b66da6789619366">&#9670;&nbsp;</a></span>afw_function_definition_pow_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_pow_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function one_and_only&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This converts a list of double values that contains one value to a single double value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function one_and_only&lt;double&gt;( list: (list list) ): double;</p>
<p>Parameters:</p>
<p>list - (list list)</p>
<p>Returns:</p>
<p>(double)</p>
<p>Errors thrown:</p>
<p>arg_error - list does not contain exactly one value</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gab84057f51b4e0e4a611b8a58fa434c52" title="Function implementation function afw_function_execute_one_and_only.">afw_function_execute_one_and_only()</a></p>
<hr  />
<p>Function definition pow&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10596">10596</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga96e0ac9d78fe0e465fa565d48c028627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e0ac9d78fe0e465fa565d48c028627">&#9670;&nbsp;</a></span>afw_function_definition_subset_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_subset_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function set_equals&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if double list1 and double list2 are subsets of each other and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function set_equals&lt;double&gt;( list1: (list double), list2: (list double) ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list double)</p>
<p>list2 - (list double)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaced2918866ee8eac66cf2997522a88d6" title="Function implementation function afw_function_execute_set_equals.">afw_function_execute_set_equals()</a></p>
<hr  />
<p>Function definition subset&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10712">10712</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaa38d48d507655b8a33ba02565754709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa38d48d507655b8a33ba02565754709c">&#9670;&nbsp;</a></span>afw_function_definition_subtract_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_subtract_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function subset&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if the unique values in double list1 are all in double list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function subset&lt;double&gt;( list1: (list double), list2: (list double) ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list double) The first list.</p>
<p>list2 - (list double) The second list.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga5fd4ac9ed33f3c6d98d78f41eb824dcc" title="Function implementation function afw_function_execute_subset.">afw_function_execute_subset()</a></p>
<hr  />
<p>Function definition subtract&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10752">10752</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga7f994f6693086ade7def9ddf8766b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f994f6693086ade7def9ddf8766b382">&#9670;&nbsp;</a></span>afw_function_definition_to_string_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_string_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_integer&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Truncate double value to a whole number and returns integer result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function to_integer&lt;double&gt;( value: double ): integer;</p>
<p>Parameters:</p>
<p>value - (double)</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga50cf948b9a831130c9707e588d3368c1" title="Function implementation function afw_function_execute_to_integer_double.">afw_function_execute_to_integer_double()</a></p>
<hr  />
<p>Function definition to_string&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10826">10826</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga820629c858d7565dd1eabcdc4a97899c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga820629c858d7565dd1eabcdc4a97899c">&#9670;&nbsp;</a></span>afw_function_definition_union_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_union_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_string&lt;double&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts double value to string. For list values, the to_string() value for each entry is returned separated with commas.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function to_string&lt;double&gt;( value: double ): string;</p>
<p>Parameters:</p>
<p>value - (double) A double value.</p>
<p>Returns:</p>
<p>(string) The string representation of the value.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>Function definition union&lt;double&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l10863">10863</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 4 2023 17:55:16 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
