<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: adaptor functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">adaptor functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga21510f38c5c35206a4c051d43c95d216"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga21510f38c5c35206a4c051d43c95d216">afw_function_execute_adaptor_objectCallback_signature</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga21510f38c5c35206a4c051d43c95d216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function adaptor_objectCallback_signature.  <a href="group__afw__functions__adaptor.html#ga21510f38c5c35206a4c051d43c95d216">More...</a><br /></td></tr>
<tr class="separator:ga21510f38c5c35206a4c051d43c95d216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1259050ffe03207b644675da179846fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga1259050ffe03207b644675da179846fa">afw_function_execute_add_object</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga1259050ffe03207b644675da179846fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function add_object.  <a href="group__afw__functions__adaptor.html#ga1259050ffe03207b644675da179846fa">More...</a><br /></td></tr>
<tr class="separator:ga1259050ffe03207b644675da179846fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94015a6eb16393a7091808c5769a26ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga94015a6eb16393a7091808c5769a26ba">afw_function_execute_add_object_with_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga94015a6eb16393a7091808c5769a26ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function add_object_with_uri.  <a href="group__afw__functions__adaptor.html#ga94015a6eb16393a7091808c5769a26ba">More...</a><br /></td></tr>
<tr class="separator:ga94015a6eb16393a7091808c5769a26ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460123f597d28b8171e7aa32e7a136e0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga460123f597d28b8171e7aa32e7a136e0">afw_function_execute_convert_AdaptiveQueryCriteria_to_query_string</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga460123f597d28b8171e7aa32e7a136e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function convert_AdaptiveQueryCriteria_to_query_string.  <a href="group__afw__functions__adaptor.html#ga460123f597d28b8171e7aa32e7a136e0">More...</a><br /></td></tr>
<tr class="separator:ga460123f597d28b8171e7aa32e7a136e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568f718ac1471b30bf5e02cbde89787b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga568f718ac1471b30bf5e02cbde89787b">afw_function_execute_convert_query_string_to_AdaptiveQueryCriteria</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga568f718ac1471b30bf5e02cbde89787b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function convert_query_string_to_AdaptiveQueryCriteria.  <a href="group__afw__functions__adaptor.html#ga568f718ac1471b30bf5e02cbde89787b">More...</a><br /></td></tr>
<tr class="separator:ga568f718ac1471b30bf5e02cbde89787b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4435034cfc44a30fd97399b92290db69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga4435034cfc44a30fd97399b92290db69">afw_function_execute_delete_object</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga4435034cfc44a30fd97399b92290db69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function delete_object.  <a href="group__afw__functions__adaptor.html#ga4435034cfc44a30fd97399b92290db69">More...</a><br /></td></tr>
<tr class="separator:ga4435034cfc44a30fd97399b92290db69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01f32d86e85824c8f0ccbd76a412462"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gad01f32d86e85824c8f0ccbd76a412462">afw_function_execute_delete_object_with_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gad01f32d86e85824c8f0ccbd76a412462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function delete_object_with_uri.  <a href="group__afw__functions__adaptor.html#gad01f32d86e85824c8f0ccbd76a412462">More...</a><br /></td></tr>
<tr class="separator:gad01f32d86e85824c8f0ccbd76a412462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5845d9c65ad5848e68adbc384792956"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gaa5845d9c65ad5848e68adbc384792956">afw_function_execute_get_object</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaa5845d9c65ad5848e68adbc384792956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function get_object.  <a href="group__afw__functions__adaptor.html#gaa5845d9c65ad5848e68adbc384792956">More...</a><br /></td></tr>
<tr class="separator:gaa5845d9c65ad5848e68adbc384792956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d079c314399ceb17e8f9788c45df25a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga8d079c314399ceb17e8f9788c45df25a">afw_function_execute_get_object_with_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga8d079c314399ceb17e8f9788c45df25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function get_object_with_uri.  <a href="group__afw__functions__adaptor.html#ga8d079c314399ceb17e8f9788c45df25a">More...</a><br /></td></tr>
<tr class="separator:ga8d079c314399ceb17e8f9788c45df25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b7a1f73cf515779df69822e7158c58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga66b7a1f73cf515779df69822e7158c58">afw_function_execute_modify_object</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga66b7a1f73cf515779df69822e7158c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function modify_object.  <a href="group__afw__functions__adaptor.html#ga66b7a1f73cf515779df69822e7158c58">More...</a><br /></td></tr>
<tr class="separator:ga66b7a1f73cf515779df69822e7158c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8daaf44512c5d06acbf30c0765328008"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga8daaf44512c5d06acbf30c0765328008">afw_function_execute_modify_object_with_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga8daaf44512c5d06acbf30c0765328008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function modify_object_with_uri.  <a href="group__afw__functions__adaptor.html#ga8daaf44512c5d06acbf30c0765328008">More...</a><br /></td></tr>
<tr class="separator:ga8daaf44512c5d06acbf30c0765328008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a80c9c87be2a103664c1e71912e4fb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga64a80c9c87be2a103664c1e71912e4fb">afw_function_execute_reconcile_object</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga64a80c9c87be2a103664c1e71912e4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function reconcile_object.  <a href="group__afw__functions__adaptor.html#ga64a80c9c87be2a103664c1e71912e4fb">More...</a><br /></td></tr>
<tr class="separator:ga64a80c9c87be2a103664c1e71912e4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5960776f724d91a8905aaa8e5d22f908"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga5960776f724d91a8905aaa8e5d22f908">afw_function_execute_replace_object</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga5960776f724d91a8905aaa8e5d22f908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function replace_object.  <a href="group__afw__functions__adaptor.html#ga5960776f724d91a8905aaa8e5d22f908">More...</a><br /></td></tr>
<tr class="separator:ga5960776f724d91a8905aaa8e5d22f908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34489c286354f9618e10d343a4cbc755"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga34489c286354f9618e10d343a4cbc755">afw_function_execute_replace_object_with_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga34489c286354f9618e10d343a4cbc755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function replace_object_with_uri.  <a href="group__afw__functions__adaptor.html#ga34489c286354f9618e10d343a4cbc755">More...</a><br /></td></tr>
<tr class="separator:ga34489c286354f9618e10d343a4cbc755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3325f6aa9f15d0434cec22de1f453b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga7d3325f6aa9f15d0434cec22de1f453b">afw_function_execute_retrieve_objects</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga7d3325f6aa9f15d0434cec22de1f453b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects.  <a href="group__afw__functions__adaptor.html#ga7d3325f6aa9f15d0434cec22de1f453b">More...</a><br /></td></tr>
<tr class="separator:ga7d3325f6aa9f15d0434cec22de1f453b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e604f190d68b7a3fb816e5dab2dcd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gaa9e604f190d68b7a3fb816e5dab2dcd2">afw_function_execute_retrieve_objects_to_callback</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaa9e604f190d68b7a3fb816e5dab2dcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects_to_callback.  <a href="group__afw__functions__adaptor.html#gaa9e604f190d68b7a3fb816e5dab2dcd2">More...</a><br /></td></tr>
<tr class="separator:gaa9e604f190d68b7a3fb816e5dab2dcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459bf0e5b1e73d603c4ca0fc47393395"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga459bf0e5b1e73d603c4ca0fc47393395">afw_function_execute_retrieve_objects_to_response</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga459bf0e5b1e73d603c4ca0fc47393395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects_to_response.  <a href="group__afw__functions__adaptor.html#ga459bf0e5b1e73d603c4ca0fc47393395">More...</a><br /></td></tr>
<tr class="separator:ga459bf0e5b1e73d603c4ca0fc47393395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad456f05d5c99b06ccfc7f04e6f3ffa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga1ad456f05d5c99b06ccfc7f04e6f3ffa">afw_function_execute_retrieve_objects_to_stream</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga1ad456f05d5c99b06ccfc7f04e6f3ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects_to_stream.  <a href="group__afw__functions__adaptor.html#ga1ad456f05d5c99b06ccfc7f04e6f3ffa">More...</a><br /></td></tr>
<tr class="separator:ga1ad456f05d5c99b06ccfc7f04e6f3ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a59e9a3ac20438ebb9061802425568"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga35a59e9a3ac20438ebb9061802425568">afw_function_execute_retrieve_objects_with_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga35a59e9a3ac20438ebb9061802425568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects_with_uri.  <a href="group__afw__functions__adaptor.html#ga35a59e9a3ac20438ebb9061802425568">More...</a><br /></td></tr>
<tr class="separator:ga35a59e9a3ac20438ebb9061802425568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b9fefa11c3dd706dec6e10db8c0274"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gaa8b9fefa11c3dd706dec6e10db8c0274">afw_function_execute_retrieve_objects_with_uri_to_callback</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaa8b9fefa11c3dd706dec6e10db8c0274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects_with_uri_to_callback.  <a href="group__afw__functions__adaptor.html#gaa8b9fefa11c3dd706dec6e10db8c0274">More...</a><br /></td></tr>
<tr class="separator:gaa8b9fefa11c3dd706dec6e10db8c0274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2b99a483804b42f2e4acc1473802d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gaef2b99a483804b42f2e4acc1473802d7">afw_function_execute_retrieve_objects_with_uri_to_response</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaef2b99a483804b42f2e4acc1473802d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects_with_uri_to_response.  <a href="group__afw__functions__adaptor.html#gaef2b99a483804b42f2e4acc1473802d7">More...</a><br /></td></tr>
<tr class="separator:gaef2b99a483804b42f2e4acc1473802d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f36f635ea1fd947e31c9e8441ccf7aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga8f36f635ea1fd947e31c9e8441ccf7aa">afw_function_execute_retrieve_objects_with_uri_to_stream</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga8f36f635ea1fd947e31c9e8441ccf7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function retrieve_objects_with_uri_to_stream.  <a href="group__afw__functions__adaptor.html#ga8f36f635ea1fd947e31c9e8441ccf7aa">More...</a><br /></td></tr>
<tr class="separator:ga8f36f635ea1fd947e31c9e8441ccf7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd449efd6d5f6e5c8014f8462350e5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga8dd449efd6d5f6e5c8014f8462350e5d">afw_function_execute_update_object</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga8dd449efd6d5f6e5c8014f8462350e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function update_object.  <a href="group__afw__functions__adaptor.html#ga8dd449efd6d5f6e5c8014f8462350e5d">More...</a><br /></td></tr>
<tr class="separator:ga8dd449efd6d5f6e5c8014f8462350e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e5ac33d59dfb8ec25c41f1a52d7031"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga26e5ac33d59dfb8ec25c41f1a52d7031">afw_function_execute_update_object_with_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga26e5ac33d59dfb8ec25c41f1a52d7031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function update_object_with_uri.  <a href="group__afw__functions__adaptor.html#ga26e5ac33d59dfb8ec25c41f1a52d7031">More...</a><br /></td></tr>
<tr class="separator:ga26e5ac33d59dfb8ec25c41f1a52d7031"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga071569338e067bd0b54d7cf6f4cb3895"><td class="memItemLeft" align="right" valign="top"><a id="ga071569338e067bd0b54d7cf6f4cb3895"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga071569338e067bd0b54d7cf6f4cb3895">afw_function_definition_adaptor_objectCallback_signature</a></td></tr>
<tr class="memdesc:ga071569338e067bd0b54d7cf6f4cb3895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition adaptor_objectCallback_signature. <br /></td></tr>
<tr class="separator:ga071569338e067bd0b54d7cf6f4cb3895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bc056b0439531953d81e2b6b174b73"><td class="memItemLeft" align="right" valign="top"><a id="gaf2bc056b0439531953d81e2b6b174b73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gaf2bc056b0439531953d81e2b6b174b73">afw_function_definition_add_object</a></td></tr>
<tr class="memdesc:gaf2bc056b0439531953d81e2b6b174b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition add_object. <br /></td></tr>
<tr class="separator:gaf2bc056b0439531953d81e2b6b174b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83ecb4e5a7691ae3e752f20bc6dd302"><td class="memItemLeft" align="right" valign="top"><a id="gae83ecb4e5a7691ae3e752f20bc6dd302"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gae83ecb4e5a7691ae3e752f20bc6dd302">afw_function_definition_add_object_with_uri</a></td></tr>
<tr class="memdesc:gae83ecb4e5a7691ae3e752f20bc6dd302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition add_object_with_uri. <br /></td></tr>
<tr class="separator:gae83ecb4e5a7691ae3e752f20bc6dd302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac650b6ab49747c2242e7ca739c94c956"><td class="memItemLeft" align="right" valign="top"><a id="gac650b6ab49747c2242e7ca739c94c956"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gac650b6ab49747c2242e7ca739c94c956">afw_function_definition_convert_AdaptiveQueryCriteria_to_query_string</a></td></tr>
<tr class="memdesc:gac650b6ab49747c2242e7ca739c94c956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition convert_AdaptiveQueryCriteria_to_query_string. <br /></td></tr>
<tr class="separator:gac650b6ab49747c2242e7ca739c94c956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fc7fe6370da200b401838ab5c3f2d8"><td class="memItemLeft" align="right" valign="top"><a id="ga88fc7fe6370da200b401838ab5c3f2d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga88fc7fe6370da200b401838ab5c3f2d8">afw_function_definition_convert_query_string_to_AdaptiveQueryCriteria</a></td></tr>
<tr class="memdesc:ga88fc7fe6370da200b401838ab5c3f2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition convert_query_string_to_AdaptiveQueryCriteria. <br /></td></tr>
<tr class="separator:ga88fc7fe6370da200b401838ab5c3f2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7810174e3e20c169e8af0dfbe065fe9a"><td class="memItemLeft" align="right" valign="top"><a id="ga7810174e3e20c169e8af0dfbe065fe9a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga7810174e3e20c169e8af0dfbe065fe9a">afw_function_definition_delete_object</a></td></tr>
<tr class="memdesc:ga7810174e3e20c169e8af0dfbe065fe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition delete_object. <br /></td></tr>
<tr class="separator:ga7810174e3e20c169e8af0dfbe065fe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db3e5152f860c5bed84146488bf6bca"><td class="memItemLeft" align="right" valign="top"><a id="ga3db3e5152f860c5bed84146488bf6bca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga3db3e5152f860c5bed84146488bf6bca">afw_function_definition_delete_object_with_uri</a></td></tr>
<tr class="memdesc:ga3db3e5152f860c5bed84146488bf6bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition delete_object_with_uri. <br /></td></tr>
<tr class="separator:ga3db3e5152f860c5bed84146488bf6bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4576f5e31aaa1f5612bcee6e5cb3c2c"><td class="memItemLeft" align="right" valign="top"><a id="gae4576f5e31aaa1f5612bcee6e5cb3c2c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gae4576f5e31aaa1f5612bcee6e5cb3c2c">afw_function_definition_get_object</a></td></tr>
<tr class="memdesc:gae4576f5e31aaa1f5612bcee6e5cb3c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition get_object. <br /></td></tr>
<tr class="separator:gae4576f5e31aaa1f5612bcee6e5cb3c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d14ca8a77586f20d2074b30709bb61e"><td class="memItemLeft" align="right" valign="top"><a id="ga5d14ca8a77586f20d2074b30709bb61e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga5d14ca8a77586f20d2074b30709bb61e">afw_function_definition_get_object_with_uri</a></td></tr>
<tr class="memdesc:ga5d14ca8a77586f20d2074b30709bb61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition get_object_with_uri. <br /></td></tr>
<tr class="separator:ga5d14ca8a77586f20d2074b30709bb61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9440c981eaf59048b95cee16bc08d19"><td class="memItemLeft" align="right" valign="top"><a id="gae9440c981eaf59048b95cee16bc08d19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gae9440c981eaf59048b95cee16bc08d19">afw_function_definition_modify_object</a></td></tr>
<tr class="memdesc:gae9440c981eaf59048b95cee16bc08d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition modify_object. <br /></td></tr>
<tr class="separator:gae9440c981eaf59048b95cee16bc08d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0204f43d88cb31c7e00bd17da71aa19d"><td class="memItemLeft" align="right" valign="top"><a id="ga0204f43d88cb31c7e00bd17da71aa19d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga0204f43d88cb31c7e00bd17da71aa19d">afw_function_definition_modify_object_with_uri</a></td></tr>
<tr class="memdesc:ga0204f43d88cb31c7e00bd17da71aa19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition modify_object_with_uri. <br /></td></tr>
<tr class="separator:ga0204f43d88cb31c7e00bd17da71aa19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a01adeb0c448184b60f0a42d21a157"><td class="memItemLeft" align="right" valign="top"><a id="ga39a01adeb0c448184b60f0a42d21a157"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga39a01adeb0c448184b60f0a42d21a157">afw_function_definition_reconcile_object</a></td></tr>
<tr class="memdesc:ga39a01adeb0c448184b60f0a42d21a157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition reconcile_object. <br /></td></tr>
<tr class="separator:ga39a01adeb0c448184b60f0a42d21a157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae5325d490f027457d6fb9da5509694"><td class="memItemLeft" align="right" valign="top"><a id="ga5ae5325d490f027457d6fb9da5509694"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga5ae5325d490f027457d6fb9da5509694">afw_function_definition_replace_object</a></td></tr>
<tr class="memdesc:ga5ae5325d490f027457d6fb9da5509694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition replace_object. <br /></td></tr>
<tr class="separator:ga5ae5325d490f027457d6fb9da5509694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3a75ea09935bc32aedc89788a2cd995"><td class="memItemLeft" align="right" valign="top"><a id="gad3a75ea09935bc32aedc89788a2cd995"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gad3a75ea09935bc32aedc89788a2cd995">afw_function_definition_replace_object_with_uri</a></td></tr>
<tr class="memdesc:gad3a75ea09935bc32aedc89788a2cd995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition replace_object_with_uri. <br /></td></tr>
<tr class="separator:gad3a75ea09935bc32aedc89788a2cd995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585e14a4eabfae0927eed65897b2743f"><td class="memItemLeft" align="right" valign="top"><a id="ga585e14a4eabfae0927eed65897b2743f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga585e14a4eabfae0927eed65897b2743f">afw_function_definition_retrieve_objects</a></td></tr>
<tr class="memdesc:ga585e14a4eabfae0927eed65897b2743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects. <br /></td></tr>
<tr class="separator:ga585e14a4eabfae0927eed65897b2743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa938abafa40168de080af6b66911f81"><td class="memItemLeft" align="right" valign="top"><a id="gaaa938abafa40168de080af6b66911f81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gaaa938abafa40168de080af6b66911f81">afw_function_definition_retrieve_objects_to_callback</a></td></tr>
<tr class="memdesc:gaaa938abafa40168de080af6b66911f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects_to_callback. <br /></td></tr>
<tr class="separator:gaaa938abafa40168de080af6b66911f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a0f7722abb5aaff82adab862ea8a53"><td class="memItemLeft" align="right" valign="top"><a id="ga48a0f7722abb5aaff82adab862ea8a53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga48a0f7722abb5aaff82adab862ea8a53">afw_function_definition_retrieve_objects_to_response</a></td></tr>
<tr class="memdesc:ga48a0f7722abb5aaff82adab862ea8a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects_to_response. <br /></td></tr>
<tr class="separator:ga48a0f7722abb5aaff82adab862ea8a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ae55652f6fd09cb01739a9ffb935d3"><td class="memItemLeft" align="right" valign="top"><a id="ga17ae55652f6fd09cb01739a9ffb935d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga17ae55652f6fd09cb01739a9ffb935d3">afw_function_definition_retrieve_objects_to_stream</a></td></tr>
<tr class="memdesc:ga17ae55652f6fd09cb01739a9ffb935d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects_to_stream. <br /></td></tr>
<tr class="separator:ga17ae55652f6fd09cb01739a9ffb935d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf48874a9d7521553edf38b89e3cdf3"><td class="memItemLeft" align="right" valign="top"><a id="ga1cf48874a9d7521553edf38b89e3cdf3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga1cf48874a9d7521553edf38b89e3cdf3">afw_function_definition_retrieve_objects_with_uri</a></td></tr>
<tr class="memdesc:ga1cf48874a9d7521553edf38b89e3cdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects_with_uri. <br /></td></tr>
<tr class="separator:ga1cf48874a9d7521553edf38b89e3cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ab47fdd36bfa44b3a96469824667f4"><td class="memItemLeft" align="right" valign="top"><a id="gae0ab47fdd36bfa44b3a96469824667f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gae0ab47fdd36bfa44b3a96469824667f4">afw_function_definition_retrieve_objects_with_uri_to_callback</a></td></tr>
<tr class="memdesc:gae0ab47fdd36bfa44b3a96469824667f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects_with_uri_to_callback. <br /></td></tr>
<tr class="separator:gae0ab47fdd36bfa44b3a96469824667f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bdef4200be8f6f90015fb602eeb50c2"><td class="memItemLeft" align="right" valign="top"><a id="ga7bdef4200be8f6f90015fb602eeb50c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga7bdef4200be8f6f90015fb602eeb50c2">afw_function_definition_retrieve_objects_with_uri_to_response</a></td></tr>
<tr class="memdesc:ga7bdef4200be8f6f90015fb602eeb50c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects_with_uri_to_response. <br /></td></tr>
<tr class="separator:ga7bdef4200be8f6f90015fb602eeb50c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf257caf13336f4fb909470faa1eb1205"><td class="memItemLeft" align="right" valign="top"><a id="gaf257caf13336f4fb909470faa1eb1205"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gaf257caf13336f4fb909470faa1eb1205">afw_function_definition_retrieve_objects_with_uri_to_stream</a></td></tr>
<tr class="memdesc:gaf257caf13336f4fb909470faa1eb1205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition retrieve_objects_with_uri_to_stream. <br /></td></tr>
<tr class="separator:gaf257caf13336f4fb909470faa1eb1205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65f76f6331ba77bfc1143c9589df48b"><td class="memItemLeft" align="right" valign="top"><a id="gae65f76f6331ba77bfc1143c9589df48b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#gae65f76f6331ba77bfc1143c9589df48b">afw_function_definition_update_object</a></td></tr>
<tr class="memdesc:gae65f76f6331ba77bfc1143c9589df48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition update_object. <br /></td></tr>
<tr class="separator:gae65f76f6331ba77bfc1143c9589df48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c11061eb408af1a1f32a28c5e663ef6"><td class="memItemLeft" align="right" valign="top"><a id="ga1c11061eb408af1a1f32a28c5e663ef6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__adaptor.html#ga1c11061eb408af1a1f32a28c5e663ef6">afw_function_definition_update_object_with_uri</a></td></tr>
<tr class="memdesc:ga1c11061eb408af1a1f32a28c5e663ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition update_object_with_uri. <br /></td></tr>
<tr class="separator:ga1c11061eb408af1a1f32a28c5e663ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>adaptor adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga21510f38c5c35206a4c051d43c95d216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21510f38c5c35206a4c051d43c95d216">&#9670;&nbsp;</a></span>afw_function_execute_adaptor_objectCallback_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_adaptor_objectCallback_signature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function adaptor_objectCallback_signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the function signature for the objectCallback parameter in adaptor functions. Calling this directly will throw a "Do not call directly" error.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function adaptor_objectCallback_signature( object: object, userData?: any ): boolean;</p>
<p>Parameters:</p>
<p>object - (object) This is the object from adaptor or undefined if there are no more objects to return.</p>
<p>userData - (optional any) This is the value of the userData parameter when objectCallback was called.</p>
<p>Returns:</p>
<p>(boolean) Return true if this callback should not be called again for any reason such a limit exceeded or the desired object being found. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l02806">2806</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga1259050ffe03207b644675da179846fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1259050ffe03207b644675da179846fa">&#9670;&nbsp;</a></span>afw_function_execute_add_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_add_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function add_object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Add an adaptive object to an adaptor, specified by the adaptorId, with a specified objectType. You may supply an optional objectId, if the underlying adaptorId allows it.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function add_object( adaptorId: string, objectType: string, object: object, objectId?: string, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>objectType - (string) Id of adaptive object type of object being added.</p>
<p>object - (object) Object to add.</p>
<p>objectId - (optional string) Optional preferred objectId of object to add. The adaptor may ignore this.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_add_object</p>
<p>where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. Property "objectId" is the objectId assigned by the adaptor. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00227">227</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga94015a6eb16393a7091808c5769a26ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94015a6eb16393a7091808c5769a26ba">&#9670;&nbsp;</a></span>afw_function_execute_add_object_with_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_add_object_with_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function add_object_with_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Add an adaptive object with a given URI.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function add_object_with_uri( uri: anyURI, object: object, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of object to add. If a URI begins with a single slash ('/'), it is the local object path. In the case of a local path, an optional preferred objectId of object can be including in URI which the adaptor may ignore.</p>
<p>object - (object) Object to add.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_add_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. Property "objectId" is the objectId assigned by the adaptor. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00329">329</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga460123f597d28b8171e7aa32e7a136e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga460123f597d28b8171e7aa32e7a136e0">&#9670;&nbsp;</a></span>afw_function_execute_convert_AdaptiveQueryCriteria_to_query_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_convert_AdaptiveQueryCriteria_to_query_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function convert_AdaptiveQueryCriteria_to_query_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts an <em>AdaptiveQueryCriteria</em> object to a query string.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function convert_AdaptiveQueryCriteria_to_query_string( queryCriteria: (object <em>AdaptiveQueryCriteria</em>), adaptorId?: string, objectType?: string, style?: integer ): string;</p>
<p>Parameters:</p>
<p>queryCriteria - (object <em>AdaptiveQueryCriteria</em>) An object type <em>AdaptiveQueryCriteria</em> object.</p>
<p>adaptorId - (optional string) This is the adaptorId of adaptor containing the objectType for validating and mapping this query. If not specified, no validation or mapping will occur.</p>
<p>objectType - (optional string) This is the objectType used in conjunction with the adaptorId parameter. This parameter is only allowed and is required if the adaptorId parameter is specified.</p>
<p>style - (optional integer) The style of the query string produced. All of the styles are appropriately url encoded.</p>
<p>0 - "name=op=value" where "=op=" will be "==", "!=", "=ge=", etc. with conjunctions "&amp;" (and) and "|" (or). Parentheses are placed around each group of like conjunctions except for outer "&amp;". (default)</p>
<p>1 - the same as 1 with "=gte=" instead of "=ge=", "=lte=" instead of "=le=", "=eq=" instead of "=", and "=ne=" instead of '!='.</p>
<p>2 - similar to 1 with ';' for '&amp;' and ',' for '|'.</p>
<p>3 - comparisons "op(name,value)" where "op" will be "eq", "ne", "ge", ..., plus conjunctions "and(list)" and "or(list)" where "list" is a comma separated list of any comparison or conjunction.</p>
<p>Returns:</p>
<p>(string) Query string representation of the query criteria. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00440">440</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga568f718ac1471b30bf5e02cbde89787b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga568f718ac1471b30bf5e02cbde89787b">&#9670;&nbsp;</a></span>afw_function_execute_convert_query_string_to_AdaptiveQueryCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_convert_query_string_to_AdaptiveQueryCriteria </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function convert_query_string_to_AdaptiveQueryCriteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a query string to an <em>AdaptiveQueryCriteria</em> object.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function convert_query_string_to_AdaptiveQueryCriteria( queryString: string, adaptorId?: string, objectType?: string ): (object <em>AdaptiveQueryCriteria</em>);</p>
<p>Parameters:</p>
<p>queryString - (string) The query string to convert.</p>
<p>adaptorId - (optional string) This is the adaptorId of adaptor containing the objectType for validating and mapping this query. If not specified, no validation or mapping will occur.</p>
<p>objectType - (optional string) This is the objectType used in conjunction with the adaptorId parameter. This parameter is only allowed and is required if the adaptorId parameter is specified.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveQueryCriteria</em>) An object type <em>AdaptiveQueryCriteria</em> object representing query string. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00542">542</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga4435034cfc44a30fd97399b92290db69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4435034cfc44a30fd97399b92290db69">&#9670;&nbsp;</a></span>afw_function_execute_delete_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_delete_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function delete_object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete an adaptive object.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function delete_object( adaptorId: string, objectType: string, objectId: string, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor containing object to delete.</p>
<p>objectType - (string) Id of adaptive object type of object to delete.</p>
<p>objectId - (string) Id of object to delete.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_delete_object</p>
<p>where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00642">642</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="gad01f32d86e85824c8f0ccbd76a412462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01f32d86e85824c8f0ccbd76a412462">&#9670;&nbsp;</a></span>afw_function_execute_delete_object_with_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_delete_object_with_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function delete_object_with_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete an adaptive object with a given URI.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function delete_object_with_uri( uri: anyURI, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of object to delete. If a URI begins with a single slash ('/'), it is the local object path.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_delete_object</p>
<p>where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00729">729</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="gaa5845d9c65ad5848e68adbc384792956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5845d9c65ad5848e68adbc384792956">&#9670;&nbsp;</a></span>afw_function_execute_get_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_get_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function get_object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get an adaptive object from the adaptor, specified by adaptorId, objectType and objectId. Optional view options and adaptor-specific options may be supplied to influence how the object is returned.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function get_object( adaptorId: string, objectType: string, objectId: string, options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): object;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor containing object to retrieve.</p>
<p>objectType - (string) Id of adaptive object type of object to retrieve.</p>
<p>objectId - (string) Id of object to retrieve.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_get_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object) Object retrieved or NULL if not found. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00835">835</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga8d079c314399ceb17e8f9788c45df25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d079c314399ceb17e8f9788c45df25a">&#9670;&nbsp;</a></span>afw_function_execute_get_object_with_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_get_object_with_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function get_object_with_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get an object with a given URI.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function get_object_with_uri( uri: anyURI, options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): object;</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of object to retrieve. If a URI begins with a single slash ('/'), it is the local object path.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_get_object</p>
<p>where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object) Object retrieved or NULL if not found. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l00924">924</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga66b7a1f73cf515779df69822e7158c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b7a1f73cf515779df69822e7158c58">&#9670;&nbsp;</a></span>afw_function_execute_modify_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_modify_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function modify_object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Modify an adaptive object.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function modify_object( adaptorId: string, objectType: string, objectId: string, entries: list, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor containing object to modify.</p>
<p>objectType - (string) Id of adaptive object type of object to modify.</p>
<p>objectId - (string) Id of object to modify.</p>
<p>entries - (list) List of modifications. Entries are of the form: </p><pre class="fragment">    [
        "add_value",
        "property name" or ["property name", ... ],
        value
    ]

    [
        "remove_property",
        "property name" or ["property name", ... ]
    ]

    [
        "remove_value",
        "property name" or ["property name", ... ],
        value
    ]

    [
        "set_property",
        "property name" or ["property name", ... ],
        value
    ].
</pre><p> journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_modify_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01054">1054</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga8daaf44512c5d06acbf30c0765328008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8daaf44512c5d06acbf30c0765328008">&#9670;&nbsp;</a></span>afw_function_execute_modify_object_with_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_modify_object_with_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function modify_object_with_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Modify an adaptive object with a given URI.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function modify_object_with_uri( uri: anyURI, entries: list, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of object to modify. If a URI begins with a single slash ('/'), it is the local object path.</p>
<p>entries - (list) List of asserts and modifications. Entries are of the form: </p><pre class="fragment">[
    "add_value",
    "property name" or ["property name", ... ],
    value
]

[
    "remove_property",
    "property name" or ["property name", ... ]
]

[
    "remove_value",
    "property name" or ["property name", ... ],
    value
]

[
    "set_property",
    "property name" or ["property name", ... ],
    value
].
</pre><p> journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_modify_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01165">1165</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga64a80c9c87be2a103664c1e71912e4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64a80c9c87be2a103664c1e71912e4fb">&#9670;&nbsp;</a></span>afw_function_execute_reconcile_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_reconcile_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function reconcile_object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Reconcile an adaptive object.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function reconcile_object( object: object, checkOnly?: boolean ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>object - (object) An object that has been retrieved with object options reconcilable, and whose properties have been modified. A modify_object request will be produced reflecting the difference between the original object and this unmodified object.</p>
<p>checkOnly - (optional boolean) Produce the modify_object request but don't execute it. The returned journal enter will contain the modify_object request.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000106">Todo:</a></b></dt><dd>FIXME: Make part of journal object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01249">1249</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga5960776f724d91a8905aaa8e5d22f908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5960776f724d91a8905aaa8e5d22f908">&#9670;&nbsp;</a></span>afw_function_execute_replace_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_replace_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function replace_object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace an adaptive object.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function replace_object( adaptorId: string, objectType: string, objectId: string, object: object, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor containing object to replace.</p>
<p>objectType - (string) Id of adaptive object type of object to replace.</p>
<p>objectId - (string) Id of object to replace.</p>
<p>object - (object) Replacement object.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_replace_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01364">1364</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga34489c286354f9618e10d343a4cbc755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34489c286354f9618e10d343a4cbc755">&#9670;&nbsp;</a></span>afw_function_execute_replace_object_with_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_replace_object_with_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function replace_object_with_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace an adaptive object with a given URI.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function replace_object_with_uri( uri: anyURI, object: object, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of object to replace. If a URI begins with a single slash ('/'), it is the local object path.</p>
<p>object - (object) Replacement object.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_replace_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01456">1456</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga7d3325f6aa9f15d0434cec22de1f453b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d3325f6aa9f15d0434cec22de1f453b">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects( adaptorId: string, objectType: string, queryCriteria?: (object <em>AdaptiveQueryCriteria</em>), options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): list;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor containing objects to retrieve.</p>
<p>objectType - (string) Id of adaptive object type of objects to retrieve.</p>
<p>queryCriteria - (optional object <em>AdaptiveQueryCriteria</em>) This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(list) This is the list of objects retrieved. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01567">1567</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="gaa9e604f190d68b7a3fb816e5dab2dcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e604f190d68b7a3fb816e5dab2dcd2">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects_to_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects_to_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects_to_callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.</p>
<p>Each object is passed to the callback as it's retrieved.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects_to_callback( objectCallback: (function (object: object, userData: any): boolean), userData: any, adaptorId: string, objectType: string, queryCriteria?: (object <em>AdaptiveQueryCriteria</em>), options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): null;</p>
<p>Parameters:</p>
<p>objectCallback - (function (object: object, userData: any): boolean) If this is specified, this function is called once for each object retrieved instead of adding the object to the return list. Parameter object will be an object retrieved or undefined if there are no more objects. This function should return true if it wants to abort the retrieve request.</p>
<p>userData - (any dataType) This value is passed to the objectCallback function in the userData parameter.</p>
<p>adaptorId - (string) Id of adaptor containing objects to retrieve.</p>
<p>objectType - (string) Id of adaptive object type of objects to retrieve.</p>
<p>queryCriteria - (optional object <em>AdaptiveQueryCriteria</em>) This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects_to_callbac k</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01697">1697</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga459bf0e5b1e73d603c4ca0fc47393395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga459bf0e5b1e73d603c4ca0fc47393395">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects_to_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects_to_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects_to_response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.</p>
<p>This function is only allowed when called during a request with content type "application/x-afw". An "_AdaptiveResponse_" object is written to the request's response as each object is retrieved. This "_AdaptiveResponse_" object has a "result" property containing the retrieved object and a "intermediate" property set to true.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects_to_response( adaptorId: string, objectType: string, queryCriteria?: (object <em>AdaptiveQueryCriteria</em>), options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): null;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor containing objects to retrieve.</p>
<p>objectType - (string) Id of adaptive object type of objects to retrieve.</p>
<p>queryCriteria - (optional object <em>AdaptiveQueryCriteria</em>) This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01821">1821</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga1ad456f05d5c99b06ccfc7f04e6f3ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ad456f05d5c99b06ccfc7f04e6f3ffa">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects_to_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects_to_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects_to_stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves adaptive objects from an adaptor, specified by adaptorId, which match the type specified by objectType.</p>
<p>Each object is written to the "streamId" stream as it's retrieved.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects_to_stream( streamNumber: integer, adaptorId: string, objectType: string, queryCriteria?: (object <em>AdaptiveQueryCriteria</em>), options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): null;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) Stream number objects will be written to as they are retrieved.</p>
<p>adaptorId - (string) Id of adaptor containing objects to retrieve.</p>
<p>objectType - (string) Id of adaptive object type of objects to retrieve.</p>
<p>queryCriteria - (optional object <em>AdaptiveQueryCriteria</em>) This is the query criteria for objects to be retrieved. If not specified, all objects will be retrieved.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l01952">1952</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga35a59e9a3ac20438ebb9061802425568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a59e9a3ac20438ebb9061802425568">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects_with_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects_with_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects_with_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve adaptive objects with a given URI.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects_with_uri( uri: anyURI, options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): list;</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(list) This is the list of objects retrieved. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l02098">2098</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="gaa8b9fefa11c3dd706dec6e10db8c0274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b9fefa11c3dd706dec6e10db8c0274">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects_with_uri_to_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects_with_uri_to_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects_with_uri_to_callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieve adaptive objects with a given URI.</p>
<p>Each object is passed to the callback as it's retrieved.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects_with_uri_to_callback( objectCallback: (function (object: object, userData: any): boolean), userData: any, uri: anyURI, options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): null;</p>
<p>Parameters:</p>
<p>objectCallback - (function (object: object, userData: any): boolean) If this is specified, this function is called once for each object retrieved instead of adding the object to the return list. Parameter object will be an object retrieved or undefined if there are no more objects. This function should return true if it wants to abort the retrieve request.</p>
<p>userData - (any) This is the value passed to the objectCallback function in the userData parameter.</p>
<p>uri - (anyURI) URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l02228">2228</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="gaef2b99a483804b42f2e4acc1473802d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2b99a483804b42f2e4acc1473802d7">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects_with_uri_to_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects_with_uri_to_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects_with_uri_to_response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves adaptive objects with a given URI.</p>
<p>This function is only allowed when called during a request with content type "application/x-afw". An "_AdaptiveResponse_" object is written to the request's response as each object is retrieved. This "_AdaptiveResponse_" object has a "result" property containing the retrieved object and a "partial" property set to true.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects_with_uri_to_response( uri: anyURI, options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): null;</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l02354">2354</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga8f36f635ea1fd947e31c9e8441ccf7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f36f635ea1fd947e31c9e8441ccf7aa">&#9670;&nbsp;</a></span>afw_function_execute_retrieve_objects_with_uri_to_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_retrieve_objects_with_uri_to_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function retrieve_objects_with_uri_to_stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves adaptive objects with a given URI.</p>
<p>Each object is written to the "streamId" stream as it's retrieved.</p>
<p>The optional queryCriteria is used to filter the adaptive objects returned. Use the objectOptions parameter to influence how the objects are viewed.</p>
<p>Options, specific to the adaptorId, can be optionally supplied.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function retrieve_objects_with_uri_to_stream( streamNumber: integer, uri: anyURI, options?: (object <em>AdaptiveObjectOptions</em>), adaptorTypeSpecific?: object ): null;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) Stream number objects will be written to as they are retrieved.</p>
<p>uri - (anyURI) URI of objects to retrieve. If a URI begins with a single slash ('/'), it is the local object path. A query string can be specified.</p>
<p>options - (optional object <em>AdaptiveObjectOptions</em>) Object view options. See /afw/_AdaptiveObjectType_/_AdaptiveObjectOptions_ for more information.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_retrieve_objects</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l02490">2490</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga8dd449efd6d5f6e5c8014f8462350e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dd449efd6d5f6e5c8014f8462350e5d">&#9670;&nbsp;</a></span>afw_function_execute_update_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_update_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function update_object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Update an adaptive object.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function update_object( adaptorId: string, objectType: string, objectId: string, object: object, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor containing object to update.</p>
<p>objectType - (string) Id of adaptive object type of object to update.</p>
<p>objectId - (string) Id of object to update.</p>
<p>object - (object) Object containing properties to replace in existing object. You can use object_modify instead to update properties of embedded objects and lists, as well as to modify individual values of the object.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_modify_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l02623">2623</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
<a id="ga26e5ac33d59dfb8ec25c41f1a52d7031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e5ac33d59dfb8ec25c41f1a52d7031">&#9670;&nbsp;</a></span>afw_function_execute_update_object_with_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_update_object_with_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function update_object_with_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Update an adaptive object with a given URI.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function update_object_with_uri( uri: anyURI, object: object, journal?: object, adaptorTypeSpecific?: object ): (object <em>AdaptiveJournalEntry</em>);</p>
<p>Parameters:</p>
<p>uri - (anyURI) URI of object to update. If a URI begins with a single slash ('/'), it is the local object path.</p>
<p>object - (object) Object containing properties to replace in existing object. You can use object_modify instead to update properties of embedded objects and lists, as well as to modify individual values of the object.</p>
<p>journal - (optional object) The properties of this object will be added to the associated journal entry. Refer to /afw/_AdaptiveObjectType_/_AdaptiveJournalEntry_ for property names to avoid and for ones that have specific semantics.</p>
<p>adaptorTypeSpecific - (optional object) This is an optional object parameter with an objectType determined by the adaptorType associated with the adaptorId parameter. If the adaptorType supports this parameter, adaptor afw will have an adaptive object type with an id of:</p>
<p><em>AdaptiveAdaptorTypeSpecific</em>${adaptorType}_modify_object</p>
<p>Where ${adaptorType} is the adaptor type id.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveJournalEntry</em>) Resulting journal entry. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__adaptor_8c_source.html#l02719">2719</a> of file <a class="el" href="afw__function__adaptor_8c_source.html">afw_function_adaptor.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 4 2023 17:55:16 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
