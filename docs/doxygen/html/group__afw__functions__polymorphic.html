<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: polymorphic functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">polymorphic functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adaptive Function to_string&lt;password&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaa9bf79e6290f924a36bf704dee0640aa"><td class="memItemLeft" align="right" valign="top"><a id="gaa9bf79e6290f924a36bf704dee0640aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaa9bf79e6290f924a36bf704dee0640aa">afw_function_definition_abs</a></td></tr>
<tr class="memdesc:gaa9bf79e6290f924a36bf704dee0640aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition abs. <br /></td></tr>
<tr class="separator:gaa9bf79e6290f924a36bf704dee0640aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860a0943679230aeb38d765b65d48553"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga860a0943679230aeb38d765b65d48553">afw_function_definition_add</a></td></tr>
<tr class="memdesc:ga860a0943679230aeb38d765b65d48553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function abs.  <a href="group__afw__functions__polymorphic.html#ga860a0943679230aeb38d765b65d48553">More...</a><br /></td></tr>
<tr class="separator:ga860a0943679230aeb38d765b65d48553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cdff4c3f76e0e5e57962a6c79e93ec4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga2cdff4c3f76e0e5e57962a6c79e93ec4">afw_function_definition_add_dayTimeDuration</a></td></tr>
<tr class="memdesc:ga2cdff4c3f76e0e5e57962a6c79e93ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function add.  <a href="group__afw__functions__polymorphic.html#ga2cdff4c3f76e0e5e57962a6c79e93ec4">More...</a><br /></td></tr>
<tr class="separator:ga2cdff4c3f76e0e5e57962a6c79e93ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71c49d7b8f56be66b723603f97476f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gac71c49d7b8f56be66b723603f97476f2">afw_function_definition_add_yearMonthDuration</a></td></tr>
<tr class="memdesc:gac71c49d7b8f56be66b723603f97476f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function add_dayTimeDuration.  <a href="group__afw__functions__polymorphic.html#gac71c49d7b8f56be66b723603f97476f2">More...</a><br /></td></tr>
<tr class="separator:gac71c49d7b8f56be66b723603f97476f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad544d7f917272899b946aad7e9173e54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gad544d7f917272899b946aad7e9173e54">afw_function_definition_at_least_one_member_of</a></td></tr>
<tr class="memdesc:gad544d7f917272899b946aad7e9173e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function add_yearMonthDuration.  <a href="group__afw__functions__polymorphic.html#gad544d7f917272899b946aad7e9173e54">More...</a><br /></td></tr>
<tr class="separator:gad544d7f917272899b946aad7e9173e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941f48b6ead84f48f56ed32e7981606d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga941f48b6ead84f48f56ed32e7981606d">afw_function_definition_bag</a></td></tr>
<tr class="memdesc:ga941f48b6ead84f48f56ed32e7981606d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function at_least_one_member_of.  <a href="group__afw__functions__polymorphic.html#ga941f48b6ead84f48f56ed32e7981606d">More...</a><br /></td></tr>
<tr class="separator:ga941f48b6ead84f48f56ed32e7981606d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37b05ac21c83e2a26c7022044ab7021"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaa37b05ac21c83e2a26c7022044ab7021">afw_function_definition_bag_size</a></td></tr>
<tr class="memdesc:gaa37b05ac21c83e2a26c7022044ab7021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag.  <a href="group__afw__functions__polymorphic.html#gaa37b05ac21c83e2a26c7022044ab7021">More...</a><br /></td></tr>
<tr class="separator:gaa37b05ac21c83e2a26c7022044ab7021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1f3546dfc96b5e151e531021a08d21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga6b1f3546dfc96b5e151e531021a08d21">afw_function_definition_ceil</a></td></tr>
<tr class="memdesc:ga6b1f3546dfc96b5e151e531021a08d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag_size.  <a href="group__afw__functions__polymorphic.html#ga6b1f3546dfc96b5e151e531021a08d21">More...</a><br /></td></tr>
<tr class="separator:ga6b1f3546dfc96b5e151e531021a08d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7a4bd83f95e566597a6f5d8cf2a67d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga1d7a4bd83f95e566597a6f5d8cf2a67d">afw_function_definition_clone</a></td></tr>
<tr class="memdesc:ga1d7a4bd83f95e566597a6f5d8cf2a67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ceil.  <a href="group__afw__functions__polymorphic.html#ga1d7a4bd83f95e566597a6f5d8cf2a67d">More...</a><br /></td></tr>
<tr class="separator:ga1d7a4bd83f95e566597a6f5d8cf2a67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b6a7fb548b8ddabb7fc7460269c8d4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga7b6a7fb548b8ddabb7fc7460269c8d4b">afw_function_definition_compile</a></td></tr>
<tr class="memdesc:ga7b6a7fb548b8ddabb7fc7460269c8d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function clone.  <a href="group__afw__functions__polymorphic.html#ga7b6a7fb548b8ddabb7fc7460269c8d4b">More...</a><br /></td></tr>
<tr class="separator:ga7b6a7fb548b8ddabb7fc7460269c8d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3464aa935cc89f83295a7062a3ff46f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga3464aa935cc89f83295a7062a3ff46f6">afw_function_definition_decode_to_string</a></td></tr>
<tr class="memdesc:ga3464aa935cc89f83295a7062a3ff46f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function compile.  <a href="group__afw__functions__polymorphic.html#ga3464aa935cc89f83295a7062a3ff46f6">More...</a><br /></td></tr>
<tr class="separator:ga3464aa935cc89f83295a7062a3ff46f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f6def4bcb2ba291ab0022cf67c7bf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga07f6def4bcb2ba291ab0022cf67c7bf4">afw_function_definition_divide</a></td></tr>
<tr class="memdesc:ga07f6def4bcb2ba291ab0022cf67c7bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function decode_to_string.  <a href="group__afw__functions__polymorphic.html#ga07f6def4bcb2ba291ab0022cf67c7bf4">More...</a><br /></td></tr>
<tr class="separator:ga07f6def4bcb2ba291ab0022cf67c7bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf702dc3da0143a7c857427a84fcc27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga6bf702dc3da0143a7c857427a84fcc27">afw_function_definition_encode_as_base64Binary</a></td></tr>
<tr class="memdesc:ga6bf702dc3da0143a7c857427a84fcc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function divide.  <a href="group__afw__functions__polymorphic.html#ga6bf702dc3da0143a7c857427a84fcc27">More...</a><br /></td></tr>
<tr class="separator:ga6bf702dc3da0143a7c857427a84fcc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a5a4645c379e3b89eca0970f59839c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga94a5a4645c379e3b89eca0970f59839c">afw_function_definition_encode_as_hexBinary</a></td></tr>
<tr class="memdesc:ga94a5a4645c379e3b89eca0970f59839c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function encode_as_base64Binary.  <a href="group__afw__functions__polymorphic.html#ga94a5a4645c379e3b89eca0970f59839c">More...</a><br /></td></tr>
<tr class="separator:ga94a5a4645c379e3b89eca0970f59839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3a945016cc637d6487e502eb00089a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaff3a945016cc637d6487e502eb00089a">afw_function_definition_ends_with</a></td></tr>
<tr class="memdesc:gaff3a945016cc637d6487e502eb00089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function encode_as_hexBinary.  <a href="group__afw__functions__polymorphic.html#gaff3a945016cc637d6487e502eb00089a">More...</a><br /></td></tr>
<tr class="separator:gaff3a945016cc637d6487e502eb00089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56651a8d5c75d67ca532d811c9b41d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gab56651a8d5c75d67ca532d811c9b41d8">afw_function_definition_eq</a></td></tr>
<tr class="memdesc:gab56651a8d5c75d67ca532d811c9b41d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ends_with.  <a href="group__afw__functions__polymorphic.html#gab56651a8d5c75d67ca532d811c9b41d8">More...</a><br /></td></tr>
<tr class="separator:gab56651a8d5c75d67ca532d811c9b41d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916ee2e86c29da770b7d08966456233b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga916ee2e86c29da770b7d08966456233b">afw_function_definition_eq_ignore_case</a></td></tr>
<tr class="memdesc:ga916ee2e86c29da770b7d08966456233b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eq.  <a href="group__afw__functions__polymorphic.html#ga916ee2e86c29da770b7d08966456233b">More...</a><br /></td></tr>
<tr class="separator:ga916ee2e86c29da770b7d08966456233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d39840e04f56cff0bee7f6c7eac7a0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga9d39840e04f56cff0bee7f6c7eac7a0f">afw_function_definition_eqx</a></td></tr>
<tr class="memdesc:ga9d39840e04f56cff0bee7f6c7eac7a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eq_ignore_case.  <a href="group__afw__functions__polymorphic.html#ga9d39840e04f56cff0bee7f6c7eac7a0f">More...</a><br /></td></tr>
<tr class="separator:ga9d39840e04f56cff0bee7f6c7eac7a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50df343f7920d0631659bb480dfc1680"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga50df343f7920d0631659bb480dfc1680">afw_function_definition_evaluate</a></td></tr>
<tr class="memdesc:ga50df343f7920d0631659bb480dfc1680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eqx.  <a href="group__afw__functions__polymorphic.html#ga50df343f7920d0631659bb480dfc1680">More...</a><br /></td></tr>
<tr class="separator:ga50df343f7920d0631659bb480dfc1680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e389eae6fa263809b53db83423dc69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga45e389eae6fa263809b53db83423dc69">afw_function_definition_floor</a></td></tr>
<tr class="memdesc:ga45e389eae6fa263809b53db83423dc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function evaluate.  <a href="group__afw__functions__polymorphic.html#ga45e389eae6fa263809b53db83423dc69">More...</a><br /></td></tr>
<tr class="separator:ga45e389eae6fa263809b53db83423dc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c7ce3d53fb4accd86f3bb10ab8f87e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga09c7ce3d53fb4accd86f3bb10ab8f87e">afw_function_definition_ge</a></td></tr>
<tr class="memdesc:ga09c7ce3d53fb4accd86f3bb10ab8f87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function floor.  <a href="group__afw__functions__polymorphic.html#ga09c7ce3d53fb4accd86f3bb10ab8f87e">More...</a><br /></td></tr>
<tr class="separator:ga09c7ce3d53fb4accd86f3bb10ab8f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a3b732d7c016355af9b2468fd0965a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga18a3b732d7c016355af9b2468fd0965a">afw_function_definition_gt</a></td></tr>
<tr class="memdesc:ga18a3b732d7c016355af9b2468fd0965a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ge.  <a href="group__afw__functions__polymorphic.html#ga18a3b732d7c016355af9b2468fd0965a">More...</a><br /></td></tr>
<tr class="separator:ga18a3b732d7c016355af9b2468fd0965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540a98826fb332359c41cfb4bf015937"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga540a98826fb332359c41cfb4bf015937">afw_function_definition_in_range</a></td></tr>
<tr class="memdesc:ga540a98826fb332359c41cfb4bf015937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function gt.  <a href="group__afw__functions__polymorphic.html#ga540a98826fb332359c41cfb4bf015937">More...</a><br /></td></tr>
<tr class="separator:ga540a98826fb332359c41cfb4bf015937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696d0cefcaa8a1098a117b280e9cbe76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga696d0cefcaa8a1098a117b280e9cbe76">afw_function_definition_includes</a></td></tr>
<tr class="memdesc:ga696d0cefcaa8a1098a117b280e9cbe76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function in_range.  <a href="group__afw__functions__polymorphic.html#ga696d0cefcaa8a1098a117b280e9cbe76">More...</a><br /></td></tr>
<tr class="separator:ga696d0cefcaa8a1098a117b280e9cbe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f80296f7c97021e4e74577faee91690"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga7f80296f7c97021e4e74577faee91690">afw_function_definition_index_of</a></td></tr>
<tr class="memdesc:ga7f80296f7c97021e4e74577faee91690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function includes.  <a href="group__afw__functions__polymorphic.html#ga7f80296f7c97021e4e74577faee91690">More...</a><br /></td></tr>
<tr class="separator:ga7f80296f7c97021e4e74577faee91690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa307fb37047fcbea459e59438f01df17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaa307fb37047fcbea459e59438f01df17">afw_function_definition_intersection</a></td></tr>
<tr class="memdesc:gaa307fb37047fcbea459e59438f01df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function index_of.  <a href="group__afw__functions__polymorphic.html#gaa307fb37047fcbea459e59438f01df17">More...</a><br /></td></tr>
<tr class="separator:gaa307fb37047fcbea459e59438f01df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a46cd7c3f1f225d96b79c668297829"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gae3a46cd7c3f1f225d96b79c668297829">afw_function_definition_is</a></td></tr>
<tr class="memdesc:gae3a46cd7c3f1f225d96b79c668297829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function intersection.  <a href="group__afw__functions__polymorphic.html#gae3a46cd7c3f1f225d96b79c668297829">More...</a><br /></td></tr>
<tr class="separator:gae3a46cd7c3f1f225d96b79c668297829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0902da5406a96c45e40a5f168f03fad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gac0902da5406a96c45e40a5f168f03fad">afw_function_definition_is_in</a></td></tr>
<tr class="memdesc:gac0902da5406a96c45e40a5f168f03fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is.  <a href="group__afw__functions__polymorphic.html#gac0902da5406a96c45e40a5f168f03fad">More...</a><br /></td></tr>
<tr class="separator:gac0902da5406a96c45e40a5f168f03fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51abcadee9b0b77c88f90d572222bc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gad51abcadee9b0b77c88f90d572222bc2">afw_function_definition_last_index_of</a></td></tr>
<tr class="memdesc:gad51abcadee9b0b77c88f90d572222bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is_in.  <a href="group__afw__functions__polymorphic.html#gad51abcadee9b0b77c88f90d572222bc2">More...</a><br /></td></tr>
<tr class="separator:gad51abcadee9b0b77c88f90d572222bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c170c870f06b1367a6e049bdc61c6e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga0c170c870f06b1367a6e049bdc61c6e6">afw_function_definition_le</a></td></tr>
<tr class="memdesc:ga0c170c870f06b1367a6e049bdc61c6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function last_index_of.  <a href="group__afw__functions__polymorphic.html#ga0c170c870f06b1367a6e049bdc61c6e6">More...</a><br /></td></tr>
<tr class="separator:ga0c170c870f06b1367a6e049bdc61c6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a9843339d55e021a6355b8d33c61be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga63a9843339d55e021a6355b8d33c61be">afw_function_definition_length</a></td></tr>
<tr class="memdesc:ga63a9843339d55e021a6355b8d33c61be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function le.  <a href="group__afw__functions__polymorphic.html#ga63a9843339d55e021a6355b8d33c61be">More...</a><br /></td></tr>
<tr class="separator:ga63a9843339d55e021a6355b8d33c61be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8d05c94b1be3dc48675f8971b0a4ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga1e8d05c94b1be3dc48675f8971b0a4ba">afw_function_definition_lt</a></td></tr>
<tr class="memdesc:ga1e8d05c94b1be3dc48675f8971b0a4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function length.  <a href="group__afw__functions__polymorphic.html#ga1e8d05c94b1be3dc48675f8971b0a4ba">More...</a><br /></td></tr>
<tr class="separator:ga1e8d05c94b1be3dc48675f8971b0a4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3283203c22f4699ee451eebf3e9c80e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gac3283203c22f4699ee451eebf3e9c80e">afw_function_definition_match</a></td></tr>
<tr class="memdesc:gac3283203c22f4699ee451eebf3e9c80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function lt.  <a href="group__afw__functions__polymorphic.html#gac3283203c22f4699ee451eebf3e9c80e">More...</a><br /></td></tr>
<tr class="separator:gac3283203c22f4699ee451eebf3e9c80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75996538ebf0dc9434a18b695894c61c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga75996538ebf0dc9434a18b695894c61c">afw_function_definition_max</a></td></tr>
<tr class="memdesc:ga75996538ebf0dc9434a18b695894c61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function match.  <a href="group__afw__functions__polymorphic.html#ga75996538ebf0dc9434a18b695894c61c">More...</a><br /></td></tr>
<tr class="separator:ga75996538ebf0dc9434a18b695894c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394e4da0b6046c3a578fe58f3ec0a022"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga394e4da0b6046c3a578fe58f3ec0a022">afw_function_definition_min</a></td></tr>
<tr class="memdesc:ga394e4da0b6046c3a578fe58f3ec0a022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function max.  <a href="group__afw__functions__polymorphic.html#ga394e4da0b6046c3a578fe58f3ec0a022">More...</a><br /></td></tr>
<tr class="separator:ga394e4da0b6046c3a578fe58f3ec0a022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54964019ed36c0118085ba2f4e6753ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga54964019ed36c0118085ba2f4e6753ae">afw_function_definition_mod</a></td></tr>
<tr class="memdesc:ga54964019ed36c0118085ba2f4e6753ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function min.  <a href="group__afw__functions__polymorphic.html#ga54964019ed36c0118085ba2f4e6753ae">More...</a><br /></td></tr>
<tr class="separator:ga54964019ed36c0118085ba2f4e6753ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b382130e71c177fa991a3f86438922"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga03b382130e71c177fa991a3f86438922">afw_function_definition_multiply</a></td></tr>
<tr class="memdesc:ga03b382130e71c177fa991a3f86438922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function mod.  <a href="group__afw__functions__polymorphic.html#ga03b382130e71c177fa991a3f86438922">More...</a><br /></td></tr>
<tr class="separator:ga03b382130e71c177fa991a3f86438922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a653bd19773c95bde4dbd19da0d80f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaf6a653bd19773c95bde4dbd19da0d80f">afw_function_definition_ne</a></td></tr>
<tr class="memdesc:gaf6a653bd19773c95bde4dbd19da0d80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function multiply.  <a href="group__afw__functions__polymorphic.html#gaf6a653bd19773c95bde4dbd19da0d80f">More...</a><br /></td></tr>
<tr class="separator:gaf6a653bd19773c95bde4dbd19da0d80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8629b6b6c18716b2571c780827b8de7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga8629b6b6c18716b2571c780827b8de7f">afw_function_definition_negative</a></td></tr>
<tr class="memdesc:ga8629b6b6c18716b2571c780827b8de7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ne.  <a href="group__afw__functions__polymorphic.html#ga8629b6b6c18716b2571c780827b8de7f">More...</a><br /></td></tr>
<tr class="separator:ga8629b6b6c18716b2571c780827b8de7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b36bc5bb8c8bcb58ad7dff05738e61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga25b36bc5bb8c8bcb58ad7dff05738e61">afw_function_definition_nex</a></td></tr>
<tr class="memdesc:ga25b36bc5bb8c8bcb58ad7dff05738e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function negative.  <a href="group__afw__functions__polymorphic.html#ga25b36bc5bb8c8bcb58ad7dff05738e61">More...</a><br /></td></tr>
<tr class="separator:ga25b36bc5bb8c8bcb58ad7dff05738e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d86fb0af5614f1ea87dca2bac55da5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gab0d86fb0af5614f1ea87dca2bac55da5">afw_function_definition_normalize_space</a></td></tr>
<tr class="memdesc:gab0d86fb0af5614f1ea87dca2bac55da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function nex.  <a href="group__afw__functions__polymorphic.html#gab0d86fb0af5614f1ea87dca2bac55da5">More...</a><br /></td></tr>
<tr class="separator:gab0d86fb0af5614f1ea87dca2bac55da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38305e48d85a19fc0edad0cdf46adf2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga38305e48d85a19fc0edad0cdf46adf2a">afw_function_definition_normalize_to_lower_case</a></td></tr>
<tr class="memdesc:ga38305e48d85a19fc0edad0cdf46adf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function normalize_space.  <a href="group__afw__functions__polymorphic.html#ga38305e48d85a19fc0edad0cdf46adf2a">More...</a><br /></td></tr>
<tr class="separator:ga38305e48d85a19fc0edad0cdf46adf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae668b7649ff3909d49139b7afee2be49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gae668b7649ff3909d49139b7afee2be49">afw_function_definition_one_and_only</a></td></tr>
<tr class="memdesc:gae668b7649ff3909d49139b7afee2be49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function normalize_to_lower_case.  <a href="group__afw__functions__polymorphic.html#gae668b7649ff3909d49139b7afee2be49">More...</a><br /></td></tr>
<tr class="separator:gae668b7649ff3909d49139b7afee2be49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014e57298bae8870a4a97cb3423b51e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga014e57298bae8870a4a97cb3423b51e0">afw_function_definition_pow</a></td></tr>
<tr class="memdesc:ga014e57298bae8870a4a97cb3423b51e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function one_and_only.  <a href="group__afw__functions__polymorphic.html#ga014e57298bae8870a4a97cb3423b51e0">More...</a><br /></td></tr>
<tr class="separator:ga014e57298bae8870a4a97cb3423b51e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df2f11c39875a2df4fadfbd40a96b64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga6df2f11c39875a2df4fadfbd40a96b64">afw_function_definition_regexp_index_of</a></td></tr>
<tr class="memdesc:ga6df2f11c39875a2df4fadfbd40a96b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function pow.  <a href="group__afw__functions__polymorphic.html#ga6df2f11c39875a2df4fadfbd40a96b64">More...</a><br /></td></tr>
<tr class="separator:ga6df2f11c39875a2df4fadfbd40a96b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a8c78344088fd23c7f7ba5a8064367"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gab0a8c78344088fd23c7f7ba5a8064367">afw_function_definition_regexp_match</a></td></tr>
<tr class="memdesc:gab0a8c78344088fd23c7f7ba5a8064367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function regexp_index_of.  <a href="group__afw__functions__polymorphic.html#gab0a8c78344088fd23c7f7ba5a8064367">More...</a><br /></td></tr>
<tr class="separator:gab0a8c78344088fd23c7f7ba5a8064367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbece144595da6712adccc0cae04c699"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gabbece144595da6712adccc0cae04c699">afw_function_definition_regexp_replace</a></td></tr>
<tr class="memdesc:gabbece144595da6712adccc0cae04c699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function regexp_match.  <a href="group__afw__functions__polymorphic.html#gabbece144595da6712adccc0cae04c699">More...</a><br /></td></tr>
<tr class="separator:gabbece144595da6712adccc0cae04c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf0c5a7031163b9fb92de87d57cddeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga6bf0c5a7031163b9fb92de87d57cddeb">afw_function_definition_repeat</a></td></tr>
<tr class="memdesc:ga6bf0c5a7031163b9fb92de87d57cddeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function regexp_replace.  <a href="group__afw__functions__polymorphic.html#ga6bf0c5a7031163b9fb92de87d57cddeb">More...</a><br /></td></tr>
<tr class="separator:ga6bf0c5a7031163b9fb92de87d57cddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a5c3d6352b29a46a33007c4f3a6c78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga89a5c3d6352b29a46a33007c4f3a6c78">afw_function_definition_replace</a></td></tr>
<tr class="memdesc:ga89a5c3d6352b29a46a33007c4f3a6c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function repeat.  <a href="group__afw__functions__polymorphic.html#ga89a5c3d6352b29a46a33007c4f3a6c78">More...</a><br /></td></tr>
<tr class="separator:ga89a5c3d6352b29a46a33007c4f3a6c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50bc9d3c3ea8a0c72c562a7f0bd12cc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga50bc9d3c3ea8a0c72c562a7f0bd12cc1">afw_function_definition_round</a></td></tr>
<tr class="memdesc:ga50bc9d3c3ea8a0c72c562a7f0bd12cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function replace.  <a href="group__afw__functions__polymorphic.html#ga50bc9d3c3ea8a0c72c562a7f0bd12cc1">More...</a><br /></td></tr>
<tr class="separator:ga50bc9d3c3ea8a0c72c562a7f0bd12cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cdcbf85ad788ce89f929ecf3ee1ad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaf0cdcbf85ad788ce89f929ecf3ee1ad5">afw_function_definition_set_equals</a></td></tr>
<tr class="memdesc:gaf0cdcbf85ad788ce89f929ecf3ee1ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function round.  <a href="group__afw__functions__polymorphic.html#gaf0cdcbf85ad788ce89f929ecf3ee1ad5">More...</a><br /></td></tr>
<tr class="separator:gaf0cdcbf85ad788ce89f929ecf3ee1ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab86cc1060d46a8f3ac34cfb67aace5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga6ab86cc1060d46a8f3ac34cfb67aace5">afw_function_definition_split</a></td></tr>
<tr class="memdesc:ga6ab86cc1060d46a8f3ac34cfb67aace5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function set_equals.  <a href="group__afw__functions__polymorphic.html#ga6ab86cc1060d46a8f3ac34cfb67aace5">More...</a><br /></td></tr>
<tr class="separator:ga6ab86cc1060d46a8f3ac34cfb67aace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f868597218589b41a8fb44d357943de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga2f868597218589b41a8fb44d357943de">afw_function_definition_starts_with</a></td></tr>
<tr class="memdesc:ga2f868597218589b41a8fb44d357943de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function split.  <a href="group__afw__functions__polymorphic.html#ga2f868597218589b41a8fb44d357943de">More...</a><br /></td></tr>
<tr class="separator:ga2f868597218589b41a8fb44d357943de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3895e060190d92de99b18c3c46e69803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga3895e060190d92de99b18c3c46e69803">afw_function_definition_subset</a></td></tr>
<tr class="memdesc:ga3895e060190d92de99b18c3c46e69803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function starts_with.  <a href="group__afw__functions__polymorphic.html#ga3895e060190d92de99b18c3c46e69803">More...</a><br /></td></tr>
<tr class="separator:ga3895e060190d92de99b18c3c46e69803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fcfaf0acfca23b84c4677c03766626d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga2fcfaf0acfca23b84c4677c03766626d">afw_function_definition_substring</a></td></tr>
<tr class="memdesc:ga2fcfaf0acfca23b84c4677c03766626d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function subset.  <a href="group__afw__functions__polymorphic.html#ga2fcfaf0acfca23b84c4677c03766626d">More...</a><br /></td></tr>
<tr class="separator:ga2fcfaf0acfca23b84c4677c03766626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb963dcf8165846eac750eb197238b00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gabb963dcf8165846eac750eb197238b00">afw_function_definition_subtract</a></td></tr>
<tr class="memdesc:gabb963dcf8165846eac750eb197238b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function substring.  <a href="group__afw__functions__polymorphic.html#gabb963dcf8165846eac750eb197238b00">More...</a><br /></td></tr>
<tr class="separator:gabb963dcf8165846eac750eb197238b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873198d38ab5e1a225efbd0b277dddc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga873198d38ab5e1a225efbd0b277dddc0">afw_function_definition_subtract_dayTimeDuration</a></td></tr>
<tr class="memdesc:ga873198d38ab5e1a225efbd0b277dddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function subtract.  <a href="group__afw__functions__polymorphic.html#ga873198d38ab5e1a225efbd0b277dddc0">More...</a><br /></td></tr>
<tr class="separator:ga873198d38ab5e1a225efbd0b277dddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga753b7335ecddb61541fc28f46f91c2dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga753b7335ecddb61541fc28f46f91c2dd">afw_function_definition_subtract_yearMonthDuration</a></td></tr>
<tr class="memdesc:ga753b7335ecddb61541fc28f46f91c2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function subtract_dayTimeDuration.  <a href="group__afw__functions__polymorphic.html#ga753b7335ecddb61541fc28f46f91c2dd">More...</a><br /></td></tr>
<tr class="separator:ga753b7335ecddb61541fc28f46f91c2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f76947e34322efd059c75fe6a388c8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga8f76947e34322efd059c75fe6a388c8c">afw_function_definition_to_anyURI</a></td></tr>
<tr class="memdesc:ga8f76947e34322efd059c75fe6a388c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function subtract_yearMonthDuration.  <a href="group__afw__functions__polymorphic.html#ga8f76947e34322efd059c75fe6a388c8c">More...</a><br /></td></tr>
<tr class="separator:ga8f76947e34322efd059c75fe6a388c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cec41981f269277a5355838b66c9dac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga2cec41981f269277a5355838b66c9dac">afw_function_definition_to_boolean</a></td></tr>
<tr class="memdesc:ga2cec41981f269277a5355838b66c9dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_anyURI.  <a href="group__afw__functions__polymorphic.html#ga2cec41981f269277a5355838b66c9dac">More...</a><br /></td></tr>
<tr class="separator:ga2cec41981f269277a5355838b66c9dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168f38af57f253c67496dcf215bd3c5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga168f38af57f253c67496dcf215bd3c5f">afw_function_definition_to_date</a></td></tr>
<tr class="memdesc:ga168f38af57f253c67496dcf215bd3c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_boolean.  <a href="group__afw__functions__polymorphic.html#ga168f38af57f253c67496dcf215bd3c5f">More...</a><br /></td></tr>
<tr class="separator:ga168f38af57f253c67496dcf215bd3c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88f7211f89991895fce3af76890890e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gad88f7211f89991895fce3af76890890e">afw_function_definition_to_dateTime</a></td></tr>
<tr class="memdesc:gad88f7211f89991895fce3af76890890e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_date.  <a href="group__afw__functions__polymorphic.html#gad88f7211f89991895fce3af76890890e">More...</a><br /></td></tr>
<tr class="separator:gad88f7211f89991895fce3af76890890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4064af9a3a0a17b048c47f2f73ae9a2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga4064af9a3a0a17b048c47f2f73ae9a2e">afw_function_definition_to_dayTimeDuration</a></td></tr>
<tr class="memdesc:ga4064af9a3a0a17b048c47f2f73ae9a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_dateTime.  <a href="group__afw__functions__polymorphic.html#ga4064af9a3a0a17b048c47f2f73ae9a2e">More...</a><br /></td></tr>
<tr class="separator:ga4064af9a3a0a17b048c47f2f73ae9a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea9c6f6f486c829e0a2f9cd73ca12194"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaea9c6f6f486c829e0a2f9cd73ca12194">afw_function_definition_to_dnsName</a></td></tr>
<tr class="memdesc:gaea9c6f6f486c829e0a2f9cd73ca12194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_dayTimeDuration.  <a href="group__afw__functions__polymorphic.html#gaea9c6f6f486c829e0a2f9cd73ca12194">More...</a><br /></td></tr>
<tr class="separator:gaea9c6f6f486c829e0a2f9cd73ca12194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18d2a24e91e47dc042338c6426e3af4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga18d2a24e91e47dc042338c6426e3af4c">afw_function_definition_to_double</a></td></tr>
<tr class="memdesc:ga18d2a24e91e47dc042338c6426e3af4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_dnsName.  <a href="group__afw__functions__polymorphic.html#ga18d2a24e91e47dc042338c6426e3af4c">More...</a><br /></td></tr>
<tr class="separator:ga18d2a24e91e47dc042338c6426e3af4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2be7c81ad4215563d1375153118887f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaf2be7c81ad4215563d1375153118887f">afw_function_definition_to_integer</a></td></tr>
<tr class="memdesc:gaf2be7c81ad4215563d1375153118887f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_double.  <a href="group__afw__functions__polymorphic.html#gaf2be7c81ad4215563d1375153118887f">More...</a><br /></td></tr>
<tr class="separator:gaf2be7c81ad4215563d1375153118887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f7899c198a0bc1adcdd9655e927869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga82f7899c198a0bc1adcdd9655e927869">afw_function_definition_to_ipAddress</a></td></tr>
<tr class="memdesc:ga82f7899c198a0bc1adcdd9655e927869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_integer.  <a href="group__afw__functions__polymorphic.html#ga82f7899c198a0bc1adcdd9655e927869">More...</a><br /></td></tr>
<tr class="separator:ga82f7899c198a0bc1adcdd9655e927869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d4c0b92bc43485779cbd5277944e257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga5d4c0b92bc43485779cbd5277944e257">afw_function_definition_to_rfc822Name</a></td></tr>
<tr class="memdesc:ga5d4c0b92bc43485779cbd5277944e257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_ipAddress.  <a href="group__afw__functions__polymorphic.html#ga5d4c0b92bc43485779cbd5277944e257">More...</a><br /></td></tr>
<tr class="separator:ga5d4c0b92bc43485779cbd5277944e257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d5a07ea143787291ebcc3aa8e75201"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga85d5a07ea143787291ebcc3aa8e75201">afw_function_definition_to_string</a></td></tr>
<tr class="memdesc:ga85d5a07ea143787291ebcc3aa8e75201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_rfc822Name.  <a href="group__afw__functions__polymorphic.html#ga85d5a07ea143787291ebcc3aa8e75201">More...</a><br /></td></tr>
<tr class="separator:ga85d5a07ea143787291ebcc3aa8e75201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda7ff0ec00def0d224a533cb601cbba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gacda7ff0ec00def0d224a533cb601cbba">afw_function_definition_to_time</a></td></tr>
<tr class="memdesc:gacda7ff0ec00def0d224a533cb601cbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_string.  <a href="group__afw__functions__polymorphic.html#gacda7ff0ec00def0d224a533cb601cbba">More...</a><br /></td></tr>
<tr class="separator:gacda7ff0ec00def0d224a533cb601cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bc89690ef8d87b762c2402675128ef6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga5bc89690ef8d87b762c2402675128ef6">afw_function_definition_to_x500Name</a></td></tr>
<tr class="memdesc:ga5bc89690ef8d87b762c2402675128ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_time.  <a href="group__afw__functions__polymorphic.html#ga5bc89690ef8d87b762c2402675128ef6">More...</a><br /></td></tr>
<tr class="separator:ga5bc89690ef8d87b762c2402675128ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b24ce4a289eed6f59e7f5e5d5de52ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga8b24ce4a289eed6f59e7f5e5d5de52ba">afw_function_definition_to_yearMonthDuration</a></td></tr>
<tr class="memdesc:ga8b24ce4a289eed6f59e7f5e5d5de52ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_x500Name.  <a href="group__afw__functions__polymorphic.html#ga8b24ce4a289eed6f59e7f5e5d5de52ba">More...</a><br /></td></tr>
<tr class="separator:ga8b24ce4a289eed6f59e7f5e5d5de52ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86e6221aa22c258c791efbbb7a76c44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#gaf86e6221aa22c258c791efbbb7a76c44">afw_function_definition_union</a></td></tr>
<tr class="memdesc:gaf86e6221aa22c258c791efbbb7a76c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_yearMonthDuration.  <a href="group__afw__functions__polymorphic.html#gaf86e6221aa22c258c791efbbb7a76c44">More...</a><br /></td></tr>
<tr class="separator:gaf86e6221aa22c258c791efbbb7a76c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4f86d9e7a13d636fade6e41bddef18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__polymorphic.html#ga0e4f86d9e7a13d636fade6e41bddef18">afw_function_definition_url_encode</a></td></tr>
<tr class="memdesc:ga0e4f86d9e7a13d636fade6e41bddef18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function union.  <a href="group__afw__functions__polymorphic.html#ga0e4f86d9e7a13d636fade6e41bddef18">More...</a><br /></td></tr>
<tr class="separator:ga0e4f86d9e7a13d636fade6e41bddef18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adaptive Function to_string&lt;password&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts password value to string. For list values, the to_string() value for each entry is returned separated with commas.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function to_string&lt;password&gt;( value: password ): string;</p>
<p>Parameters:</p>
<p>value - (password) A password value.</p>
<p>Returns:</p>
<p>(string) The string representation of the value.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>polymorphic adaptive functions. </p>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga860a0943679230aeb38d765b65d48553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga860a0943679230aeb38d765b65d48553">&#9670;&nbsp;</a></span>afw_function_definition_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_add</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function abs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Compute the absolute value of the &lt;dataType&gt; value and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double, integer.</p>
<p>Declaration:</p>
<p>function abs &lt;dataType&gt;( value: dataType ): dataType;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition add </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21592">21592</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga2cdff4c3f76e0e5e57962a6c79e93ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cdff4c3f76e0e5e57962a6c79e93ec4">&#9670;&nbsp;</a></span>afw_function_definition_add_dayTimeDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_add_dayTimeDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Add 2 or more &lt;dataType&gt; values and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double, integer, string.</p>
<p>Declaration:</p>
<p>function add &lt;dataType&gt;( values_1: dataType, values_2: dataType, ...values_rest: (list of dataType) ): dataType;</p>
<p>Parameters:</p>
<p>values - (2 or more &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition add_dayTimeDuration </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21634">21634</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gac71c49d7b8f56be66b723603f97476f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71c49d7b8f56be66b723603f97476f2">&#9670;&nbsp;</a></span>afw_function_definition_add_yearMonthDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_add_yearMonthDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function add_dayTimeDuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Add &lt;dataType&gt; arg1 to dayTimeDuration arg2 and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>dateTime.</p>
<p>Declaration:</p>
<p>function add_dayTimeDuration &lt;dataType&gt;( arg1: dataType, arg2: dayTimeDuration ): dataType;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (dayTimeDuration)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition add_yearMonthDuration </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21678">21678</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gad544d7f917272899b946aad7e9173e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad544d7f917272899b946aad7e9173e54">&#9670;&nbsp;</a></span>afw_function_definition_at_least_one_member_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_at_least_one_member_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function add_yearMonthDuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Add &lt;dataType&gt; arg1 to yearMonthDuration arg2 and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>date, dateTime.</p>
<p>Declaration:</p>
<p>function add_yearMonthDuration &lt;dataType&gt;( arg1: dataType, arg2: yearMonthDuration ): dataType;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (yearMonthDuration)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition at_least_one_member_of </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21722">21722</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga941f48b6ead84f48f56ed32e7981606d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941f48b6ead84f48f56ed32e7981606d">&#9670;&nbsp;</a></span>afw_function_definition_bag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function at_least_one_member_of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if at least one value in &lt;dataType&gt; list1 is in &lt;dataType&gt; list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double, hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function at_least_one_member_of &lt;dataType&gt;( list1: list, list2: list ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list &lt;Type&gt;) The first list.</p>
<p>list2 - (list &lt;Type&gt;) The second list.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition bag </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21767">21767</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaa37b05ac21c83e2a26c7022044ab7021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37b05ac21c83e2a26c7022044ab7021">&#9670;&nbsp;</a></span>afw_function_definition_bag_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes any number of &lt;dataType&gt; values and returns a list of list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, null, object, objectId, objectPath, password, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function bag &lt;dataType&gt;( ...values: (list of list) ): list;</p>
<p>Parameters:</p>
<p>values - (0 or more list &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(list &lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition bag_size </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21811">21811</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga6b1f3546dfc96b5e151e531021a08d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b1f3546dfc96b5e151e531021a08d21">&#9670;&nbsp;</a></span>afw_function_definition_ceil</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ceil</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag_size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the integer number of values in list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, null, object, objectId, objectPath, password, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function bag_size &lt;dataType&gt;( value: list ): integer;</p>
<p>Parameters:</p>
<p>value - (list &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition ceil </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21855">21855</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga1d7a4bd83f95e566597a6f5d8cf2a67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d7a4bd83f95e566597a6f5d8cf2a67d">&#9670;&nbsp;</a></span>afw_function_definition_clone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_clone</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ceil. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the smallest integer that is greater then or equal to the &lt;dataType&gt; value and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double.</p>
<p>Declaration:</p>
<p>function ceil &lt;dataType&gt;( value: dataType ): dataType;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition clone </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21896">21896</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga7b6a7fb548b8ddabb7fc7460269c8d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b6a7fb548b8ddabb7fc7460269c8d4b">&#9670;&nbsp;</a></span>afw_function_definition_compile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_compile</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function clone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Deep clone a &lt;dataType&gt; value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>list, object.</p>
<p>Declaration:</p>
<p>function clone &lt;dataType&gt;( value: dataType ): dataType;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to clone.</p>
<p>Returns:</p>
<p>(&lt;Type&gt;) The cloned &lt;dataType&gt; value.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition compile </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21936">21936</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga3464aa935cc89f83295a7062a3ff46f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3464aa935cc89f83295a7062a3ff46f6">&#9670;&nbsp;</a></span>afw_function_definition_decode_to_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_decode_to_string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function compile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile &lt;dataType&gt; value and return either an unevaluated adaptive value or a string containing the compiler listing.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>expression, hybrid, regexp, script, template, xpathExpression.</p>
<p>Declaration:</p>
<p>function compile &lt;dataType&gt;( source: dataType, listing?: any ): unevaluated;</p>
<p>Parameters:</p>
<p>source - (&lt;Type&gt;) &lt;dataType&gt; string to compile.</p>
<p>listing - (optional any dataType) If specified, a compiler listing is produced instead of an unevaluated expression value.</p>
<p>This parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(unevaluated)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition decode_to_string </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l21986">21986</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga07f6def4bcb2ba291ab0022cf67c7bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07f6def4bcb2ba291ab0022cf67c7bf4">&#9670;&nbsp;</a></span>afw_function_definition_divide</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_divide</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function decode_to_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Decode &lt;dataType&gt; value to string. An error is thrown if decoded value is not valid UTF-8.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>base64Binary, hexBinary.</p>
<p>Declaration:</p>
<p>function decode_to_string &lt;dataType&gt;( value: dataType ): string;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to decode.</p>
<p>Returns:</p>
<p>(string) The decoded string.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition divide </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22027">22027</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga6bf702dc3da0143a7c857427a84fcc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bf702dc3da0143a7c857427a84fcc27">&#9670;&nbsp;</a></span>afw_function_definition_encode_as_base64Binary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_encode_as_base64Binary</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function divide. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Divide &lt;dataType&gt; dividend by &lt;dataType&gt; divisor and return the &lt;dataType&gt; quotient.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double, integer.</p>
<p>Declaration:</p>
<p>function divide &lt;dataType&gt;( dividend: dataType, divisor: dataType ): dataType;</p>
<p>Parameters:</p>
<p>dividend - (&lt;Type&gt;)</p>
<p>divisor - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition encode_as_base64Binary </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22071">22071</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga94a5a4645c379e3b89eca0970f59839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a5a4645c379e3b89eca0970f59839c">&#9670;&nbsp;</a></span>afw_function_definition_encode_as_hexBinary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_encode_as_hexBinary</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function encode_as_base64Binary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Encode a value as a base64Binary. The effect is to create a base64Binary value with an internal value of the value passed.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function encode_as_base64Binary &lt;dataType&gt;( value: dataType ): base64Binary;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to encode.</p>
<p>Returns:</p>
<p>(base64Binary) A base64Binary value.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition encode_as_hexBinary </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22112">22112</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaff3a945016cc637d6487e502eb00089a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff3a945016cc637d6487e502eb00089a">&#9670;&nbsp;</a></span>afw_function_definition_ends_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ends_with</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function encode_as_hexBinary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Encode a value as a hexBinary. The effect is to create a hexBinary value with an internal value of the value passed.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function encode_as_hexBinary &lt;dataType&gt;( value: dataType ): hexBinary;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to encode.</p>
<p>Returns:</p>
<p>(hexBinary) A hexBinary value.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition ends_with </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22153">22153</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gab56651a8d5c75d67ca532d811c9b41d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56651a8d5c75d67ca532d811c9b41d8">&#9670;&nbsp;</a></span>afw_function_definition_eq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eq</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ends_with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether &lt;dataType&gt; value ends with a &lt;dataType&gt; and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function ends_with &lt;dataType&gt;( value: dataType, subString: string ): boolean;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>subString - (string)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition eq </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22197">22197</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga916ee2e86c29da770b7d08966456233b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga916ee2e86c29da770b7d08966456233b">&#9670;&nbsp;</a></span>afw_function_definition_eq_ignore_case</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eq_ignore_case</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eq. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if &lt;dataType&gt; arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "eqx" ("===") instead if you want false to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, regexp, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function eq &lt;dataType&gt;( arg1: dataType, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga4b5f63dcfd77b17d064ce733ffde1b04" title="Function implementation function afw_function_execute_eq.">afw_function_execute_eq()</a></p>
<hr  />
<p>Function definition eq_ignore_case </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22250">22250</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga9d39840e04f56cff0bee7f6c7eac7a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d39840e04f56cff0bee7f6c7eac7a0f">&#9670;&nbsp;</a></span>afw_function_definition_eqx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eqx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eq_ignore_case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for &lt;dataType&gt; arg1 is equal to &lt;dataType&gt; arg2 ignoring case and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function eq_ignore_case &lt;dataType&gt;( arg1: dataType, arg2: dataType ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition eqx </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22294">22294</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga50df343f7920d0631659bb480dfc1680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50df343f7920d0631659bb480dfc1680">&#9670;&nbsp;</a></span>afw_function_definition_evaluate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_evaluate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eqx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for &lt;dataType&gt; arg1 is equal to the value and data type of arg2 then return the boolean result. Use "eq" ("==") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, regexp, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function eqx &lt;dataType&gt;( arg1: dataType, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga8038bd01243984b8b135337e768925f5" title="Function implementation function afw_function_execute_eqx.">afw_function_execute_eqx()</a></p>
<hr  />
<p>Function definition evaluate </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22343">22343</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga45e389eae6fa263809b53db83423dc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45e389eae6fa263809b53db83423dc69">&#9670;&nbsp;</a></span>afw_function_definition_floor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_floor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function evaluate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile and evaluate &lt;dataType&gt; value.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>expression, hybrid, script, template, xpathExpression.</p>
<p>Declaration:</p>
<p>function evaluate &lt;dataType&gt;( source: dataType, additionalUntrustedQualifiedVariables?: (object <em>AdaptiveHybridPropertiesObjects</em>) ): unevaluated;</p>
<p>Parameters:</p>
<p>source - (&lt;Type&gt;) &lt;dataType&gt; string to compile and evaluate.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(unevaluated)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition floor </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22392">22392</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga09c7ce3d53fb4accd86f3bb10ab8f87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c7ce3d53fb4accd86f3bb10ab8f87e">&#9670;&nbsp;</a></span>afw_function_definition_ge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ge</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function floor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the largest integer that is smaller then or equal to the &lt;dataType&gt; value and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double.</p>
<p>Declaration:</p>
<p>function floor &lt;dataType&gt;( number: dataType ): dataType;</p>
<p>Parameters:</p>
<p>number - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition ge </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22433">22433</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga18a3b732d7c016355af9b2468fd0965a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18a3b732d7c016355af9b2468fd0965a">&#9670;&nbsp;</a></span>afw_function_definition_gt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_gt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for &lt;dataType&gt; arg1 is greater than or equal to &lt;dataType&gt; arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, regexp, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function ge &lt;dataType&gt;( arg1: dataType, arg2: dataType ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition gt </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22481">22481</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga540a98826fb332359c41cfb4bf015937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga540a98826fb332359c41cfb4bf015937">&#9670;&nbsp;</a></span>afw_function_definition_in_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_in_range</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function gt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for &lt;dataType&gt; arg1 is greater than &lt;dataType&gt; arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, regexp, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function gt &lt;dataType&gt;( arg1: dataType, arg2: dataType ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition in_range </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22529">22529</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga696d0cefcaa8a1098a117b280e9cbe76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga696d0cefcaa8a1098a117b280e9cbe76">&#9670;&nbsp;</a></span>afw_function_definition_includes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_includes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function in_range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if &lt;dataType&gt; is between startTime and endTime, inclusive. Regardless of endTime value, it is always considered to be equal to, but less than 24 hours greater than startTime. If no &lt;dataType&gt; zone is specified for &lt;dataType&gt;, the default &lt;dataType&gt; zone is used. If no &lt;dataType&gt; zone is specified for startTime or endTime, the &lt;dataType&gt; zone of &lt;dataType&gt; is used.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>time.</p>
<p>Declaration:</p>
<p>function in_range &lt;dataType&gt;( time: dataType, startTime: dataType, endTime: dataType ): boolean;</p>
<p>Parameters:</p>
<p>time - (&lt;Type&gt;)</p>
<p>startTime - (&lt;Type&gt;)</p>
<p>endTime - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition includes </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22580">22580</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga7f80296f7c97021e4e74577faee91690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f80296f7c97021e4e74577faee91690">&#9670;&nbsp;</a></span>afw_function_definition_index_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_index_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function includes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether the &lt;dataType&gt; value includes a string and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, list, string.</p>
<p>Declaration:</p>
<p>function includes &lt;dataType&gt;( searchString: dataType, subString: string, position?: integer ): boolean;</p>
<p>Parameters:</p>
<p>searchString - (&lt;Type&gt;) The &lt;dataType&gt; to search.</p>
<p>subString - (string) Substring to find.</p>
<p>position - (optional integer) Zero-based position in the search string to start search.</p>
<p>Returns:</p>
<p>(boolean) Indicates if the substring is contained in the search string.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition index_of </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22628">22628</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaa307fb37047fcbea459e59438f01df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa307fb37047fcbea459e59438f01df17">&#9670;&nbsp;</a></span>afw_function_definition_intersection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_intersection</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function index_of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the zero-based index into &lt;dataType&gt; value of subString. If subString is not found, -1 is returned.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function index_of &lt;dataType&gt;( value: dataType, subString: string, startIndex?: integer ): integer;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to search.</p>
<p>subString - (string) Substring to search for.</p>
<p>startIndex - (optional integer) Optional start index for search if different than start of string.</p>
<p>Returns:</p>
<p>(integer) Zero-based index of subString or -1 if not found.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition intersection </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22676">22676</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gae3a46cd7c3f1f225d96b79c668297829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3a46cd7c3f1f225d96b79c668297829">&#9670;&nbsp;</a></span>afw_function_definition_is</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_is</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function intersection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of &lt;dataType&gt; with the values that are common to both list of &lt;dataType&gt; list1 and list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double, hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function intersection &lt;dataType&gt;( list1: list, list2: list ): list;</p>
<p>Parameters:</p>
<p>list1 - (list &lt;Type&gt;) The first list.</p>
<p>list2 - (list &lt;Type&gt;) The second list.</p>
<p>Returns:</p>
<p>(list &lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition is </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22721">22721</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gac0902da5406a96c45e40a5f168f03fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0902da5406a96c45e40a5f168f03fad">&#9670;&nbsp;</a></span>afw_function_definition_is_in</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_is_in</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether value is dataType &lt;dataType&gt; and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, null, object, objectId, objectPath, password, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration, unevaluated.</p>
<p>Declaration:</p>
<p>function is &lt;dataType&gt;( value: any ): boolean;</p>
<p>Parameters:</p>
<p>value - (any dataType) Value to check.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga592ff430af3e6f20df8c7c7014da60d6" title="Function implementation function afw_function_execute_is.">afw_function_execute_is()</a></p>
<hr  />
<p>Function definition is_in </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22765">22765</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gad51abcadee9b0b77c88f90d572222bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad51abcadee9b0b77c88f90d572222bc2">&#9670;&nbsp;</a></span>afw_function_definition_last_index_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_last_index_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is_in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether &lt;dataType&gt; value is in list of &lt;dataType&gt; list and returns the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, hexBinary, integer, ipAddress, rfc822Name, string, time, x500Name, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function is_in &lt;dataType&gt;( value: dataType, list: list ): boolean;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>list - (list &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition last_index_of </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22811">22811</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga0c170c870f06b1367a6e049bdc61c6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c170c870f06b1367a6e049bdc61c6e6">&#9670;&nbsp;</a></span>afw_function_definition_le</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_le</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function last_index_of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the zero-based index into &lt;dataType&gt; value of the last occurrence of a subString. If subString is not found, -1 is returned.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function last_index_of &lt;dataType&gt;( value: dataType, subString: string, startIndex?: integer ): integer;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to search.</p>
<p>subString - (string) Substring to search for.</p>
<p>startIndex - (optional integer) Optional start index for search if different than start of string.</p>
<p>Returns:</p>
<p>(integer) Zero-based index of subString or -1 if not found.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition le </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22859">22859</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga63a9843339d55e021a6355b8d33c61be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a9843339d55e021a6355b8d33c61be">&#9670;&nbsp;</a></span>afw_function_definition_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function le. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for &lt;dataType&gt; arg1 is less than or equal to &lt;dataType&gt; arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, regexp, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function le &lt;dataType&gt;( arg1: dataType, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition length </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22907">22907</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga1e8d05c94b1be3dc48675f8971b0a4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8d05c94b1be3dc48675f8971b0a4ba">&#9670;&nbsp;</a></span>afw_function_definition_lt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_lt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a polymorphic function where &lt;dataType&gt; can be any of the supported data types. Return the integer number of entries in datatype list or codepoints in others.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, list, string.</p>
<p>Declaration:</p>
<p>function length &lt;dataType&gt;( value: dataType ): integer;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) Returns the number of entries in a list or code points in others.</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition lt </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22950">22950</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gac3283203c22f4699ee451eebf3e9c80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3283203c22f4699ee451eebf3e9c80e">&#9670;&nbsp;</a></span>afw_function_definition_match</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function lt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for &lt;dataType&gt; arg1 is less that &lt;dataType&gt; arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, regexp, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function lt &lt;dataType&gt;( arg1: dataType, arg2: dataType ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition match </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l22998">22998</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga75996538ebf0dc9434a18b695894c61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75996538ebf0dc9434a18b695894c61c">&#9670;&nbsp;</a></span>afw_function_definition_max</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_max</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true if arg1 matches some terminal sequence of RDNs from arg2 when compared using equal_&lt;dataType&gt;.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>rfc822Name, x500Name.</p>
<p>Declaration:</p>
<p>function match &lt;dataType&gt;( arg1: dataType, arg2: string ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (string)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition max </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23042">23042</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga394e4da0b6046c3a578fe58f3ec0a022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga394e4da0b6046c3a578fe58f3ec0a022">&#9670;&nbsp;</a></span>afw_function_definition_min</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_min</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the &lt;dataType&gt; value that is greater than or equal to the others.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>date, dateTime, double, integer, string, time.</p>
<p>Declaration:</p>
<p>function max &lt;dataType&gt;( values_1: dataType, ...values_rest: (list of dataType) ): dataType;</p>
<p>Parameters:</p>
<p>values - (1 or more &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition min </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23083">23083</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga54964019ed36c0118085ba2f4e6753ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54964019ed36c0118085ba2f4e6753ae">&#9670;&nbsp;</a></span>afw_function_definition_mod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_mod</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function min. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the &lt;dataType&gt; value that is less than or equal to the others.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>date, dateTime, double, integer, string, time.</p>
<p>Declaration:</p>
<p>function min &lt;dataType&gt;( values_1: dataType, ...values_rest: (list of dataType) ): dataType;</p>
<p>Parameters:</p>
<p>values - (1 or more &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition mod </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23124">23124</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga03b382130e71c177fa991a3f86438922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b382130e71c177fa991a3f86438922">&#9670;&nbsp;</a></span>afw_function_definition_multiply</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_multiply</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function mod. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Divide &lt;dataType&gt; dividend by &lt;dataType&gt; divisor and return the &lt;dataType&gt; remainder.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>integer.</p>
<p>Declaration:</p>
<p>function mod &lt;dataType&gt;( dividend: dataType, divisor: dataType ): dataType;</p>
<p>Parameters:</p>
<p>dividend - (&lt;Type&gt;)</p>
<p>divisor - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition multiply </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23168">23168</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaf6a653bd19773c95bde4dbd19da0d80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6a653bd19773c95bde4dbd19da0d80f">&#9670;&nbsp;</a></span>afw_function_definition_ne</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ne</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function multiply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Multiply 2 or more &lt;dataType&gt; values and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double, integer.</p>
<p>Declaration:</p>
<p>function multiply &lt;dataType&gt;( values_1: dataType, values_2: dataType, ...values_rest: (list of dataType) ): dataType;</p>
<p>Parameters:</p>
<p>values - (2 or more &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition ne </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23210">23210</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga8629b6b6c18716b2571c780827b8de7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8629b6b6c18716b2571c780827b8de7f">&#9670;&nbsp;</a></span>afw_function_definition_negative</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_negative</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ne. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if &lt;dataType&gt; arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "nex" ("!==") instead if you want true to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, regexp, rfc822Name, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function ne &lt;dataType&gt;( arg1: dataType, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf144f30dc392293fb1eb3058a00f3093" title="Function implementation function afw_function_execute_ne.">afw_function_execute_ne()</a></p>
<hr  />
<p>Function definition negative </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23264">23264</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga25b36bc5bb8c8bcb58ad7dff05738e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b36bc5bb8c8bcb58ad7dff05738e61">&#9670;&nbsp;</a></span>afw_function_definition_nex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_nex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function negative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Return negative of &lt;dataType&gt; value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double, integer.</p>
<p>Declaration:</p>
<p>function negative &lt;dataType&gt;( value: dataType ): dataType;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition nex </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23304">23304</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gab0d86fb0af5614f1ea87dca2bac55da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d86fb0af5614f1ea87dca2bac55da5">&#9670;&nbsp;</a></span>afw_function_definition_normalize_space</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_normalize_space</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function nex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for &lt;dataType&gt; arg1 is not equal to the value or data type of arg2 then return the boolean result. Use "ne" ("!=") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, function, hexBinary, hybrid, ia5String, integer, ipAddress, list, object, objectId, objectPath, password, rfc822Name, regexp, script, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function nex &lt;dataType&gt;( arg1: dataType, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga16fe2f777eb9e0a29ece94637d9c29ec" title="Function implementation function afw_function_execute_nex.">afw_function_execute_nex()</a></p>
<hr  />
<p>Function definition normalize_space </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23353">23353</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga38305e48d85a19fc0edad0cdf46adf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38305e48d85a19fc0edad0cdf46adf2a">&#9670;&nbsp;</a></span>afw_function_definition_normalize_to_lower_case</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_normalize_to_lower_case</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function normalize_space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove whitespace from the beginning and end of a &lt;dataType&gt; value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function normalize_space &lt;dataType&gt;( string: dataType ): dataType;</p>
<p>Parameters:</p>
<p>string - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition normalize_to_lower_case </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23393">23393</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gae668b7649ff3909d49139b7afee2be49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae668b7649ff3909d49139b7afee2be49">&#9670;&nbsp;</a></span>afw_function_definition_one_and_only</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_one_and_only</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function normalize_to_lower_case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Normalize &lt;dataType&gt; value to lower case and returns &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function normalize_to_lower_case &lt;dataType&gt;( string: dataType ): dataType;</p>
<p>Parameters:</p>
<p>string - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition one_and_only </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23433">23433</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga014e57298bae8870a4a97cb3423b51e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga014e57298bae8870a4a97cb3423b51e0">&#9670;&nbsp;</a></span>afw_function_definition_pow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_pow</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function one_and_only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This converts a list of &lt;dataType&gt; values that contains one value to a single &lt;dataType&gt; value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, hexBinary, integer, ipAddress, rfc822Name, string, time, x500Name, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function one_and_only &lt;dataType&gt;( list: (list list) ): dataType;</p>
<p>Parameters:</p>
<p>list - (list list)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Errors thrown:</p>
<p>arg_error - list does not contain exactly one value</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition pow </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23480">23480</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga6df2f11c39875a2df4fadfbd40a96b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6df2f11c39875a2df4fadfbd40a96b64">&#9670;&nbsp;</a></span>afw_function_definition_regexp_index_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_regexp_index_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function pow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the value of base raised to a power. Multiple exponents can be specified to raise the previous exponent to the power of the latter exponent.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double.</p>
<p>Declaration:</p>
<p>function pow &lt;dataType&gt;( base: dataType, exponent_1: dataType, ...exponent_rest: (list of dataType) ): dataType;</p>
<p>Parameters:</p>
<p>base - (&lt;Type&gt;) Base value.</p>
<p>exponent - (1 or more &lt;Type&gt;) Exponent value.</p>
<p>Returns:</p>
<p>(&lt;Type&gt;) Base raised to the power.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition regexp_index_of </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23526">23526</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gab0a8c78344088fd23c7f7ba5a8064367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a8c78344088fd23c7f7ba5a8064367">&#9670;&nbsp;</a></span>afw_function_definition_regexp_match</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_regexp_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function regexp_index_of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Search &lt;dataType&gt; value for a regular expression and return index. If not found, -1 is returned.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function regexp_index_of &lt;dataType&gt;( value: dataType, regexp: string ): integer;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to search.</p>
<p>regexp - (string) A regular expression to use for search.</p>
<p>Returns:</p>
<p>(integer) Zero-based index of subString or -1 if not found.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition regexp_match </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23570">23570</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gabbece144595da6712adccc0cae04c699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbece144595da6712adccc0cae04c699">&#9670;&nbsp;</a></span>afw_function_definition_regexp_replace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_regexp_replace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function regexp_match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether &lt;dataType&gt; value matches the regular expression regexp and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, dnsName, ipAddress, rfc822Name, string, x500Name.</p>
<p>Declaration:</p>
<p>function regexp_match &lt;dataType&gt;( value: dataType, regexp: string ): boolean;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>regexp - (string)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition regexp_replace </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23614">23614</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga6bf0c5a7031163b9fb92de87d57cddeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bf0c5a7031163b9fb92de87d57cddeb">&#9670;&nbsp;</a></span>afw_function_definition_repeat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_repeat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function regexp_replace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace matched values for a regular expression in a &lt;dataType&gt; value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function regexp_replace &lt;dataType&gt;( value: dataType, regexp: string, replacement: string, limit?: integer ): dataType;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The original &lt;dataType&gt; value.</p>
<p>regexp - (string) A regular expression to use for search.</p>
<p>replacement - (string) The replacement string.</p>
<p>limit - (optional integer) This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences.</p>
<p>Returns:</p>
<p>(&lt;Type&gt;) A &lt;dataType&gt; value with the matched string(s) replaced.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition repeat </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23664">23664</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga89a5c3d6352b29a46a33007c4f3a6c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a5c3d6352b29a46a33007c4f3a6c78">&#9670;&nbsp;</a></span>afw_function_definition_replace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_replace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function repeat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Repeat a &lt;dataType&gt; value a specified number of times.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function repeat &lt;dataType&gt;( value: dataType, times: integer ): dataType;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to repeat.</p>
<p>times - (integer) The number of times to repeat the value.</p>
<p>Returns:</p>
<p>(&lt;Type&gt;) The repeated &lt;dataType&gt; value.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition replace </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23707">23707</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga50bc9d3c3ea8a0c72c562a7f0bd12cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50bc9d3c3ea8a0c72c562a7f0bd12cc1">&#9670;&nbsp;</a></span>afw_function_definition_round</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_round</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function replace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace string(s) in a &lt;dataType&gt; value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function replace &lt;dataType&gt;( value: dataType, match: string, replacement: string, limit?: integer ): dataType;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The original &lt;dataType&gt; value.</p>
<p>match - (string) The string to replace.</p>
<p>replacement - (string) The replacement string.</p>
<p>limit - (optional integer) This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences.</p>
<p>Returns:</p>
<p>(&lt;Type&gt;) A &lt;dataType&gt; value with the matched string(s) replaced.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition round </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23757">23757</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaf0cdcbf85ad788ce89f929ecf3ee1ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0cdcbf85ad788ce89f929ecf3ee1ad5">&#9670;&nbsp;</a></span>afw_function_definition_set_equals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_set_equals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function round. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the integer closest to &lt;dataType&gt; value and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double.</p>
<p>Declaration:</p>
<p>function round &lt;dataType&gt;( number: dataType ): dataType;</p>
<p>Parameters:</p>
<p>number - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition set_equals </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23798">23798</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga6ab86cc1060d46a8f3ac34cfb67aace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ab86cc1060d46a8f3ac34cfb67aace5">&#9670;&nbsp;</a></span>afw_function_definition_split</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_split</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function set_equals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if &lt;dataType&gt; list1 and &lt;dataType&gt; list2 are subsets of each other and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double, hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function set_equals &lt;dataType&gt;( list1: list, list2: list ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list &lt;Type&gt;)</p>
<p>list2 - (list &lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition split </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23843">23843</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga2f868597218589b41a8fb44d357943de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f868597218589b41a8fb44d357943de">&#9670;&nbsp;</a></span>afw_function_definition_starts_with</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_starts_with</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function split. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Split &lt;dataType&gt; value into an list of strings using a separator.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function split &lt;dataType&gt;( value: dataType, separator?: string, limit?: integer ): list;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) The &lt;dataType&gt; value to split.</p>
<p>separator - (optional string) The separator to use. If this is an empty string or separator is not specified, the value is split between characters.</p>
<p>limit - (optional integer) This is the maximum number of splits. Any remaining part of value is ignored.</p>
<p>Returns:</p>
<p>(list) An list of strings.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition starts_with </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23892">23892</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga3895e060190d92de99b18c3c46e69803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3895e060190d92de99b18c3c46e69803">&#9670;&nbsp;</a></span>afw_function_definition_subset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_subset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function starts_with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether &lt;dataType&gt; value starts with a subString and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function starts_with &lt;dataType&gt;( value: dataType, subString: string ): boolean;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>subString - (string)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition subset </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23936">23936</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga2fcfaf0acfca23b84c4677c03766626d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fcfaf0acfca23b84c4677c03766626d">&#9670;&nbsp;</a></span>afw_function_definition_substring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_substring</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function subset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if the unique values in &lt;dataType&gt; list1 are all in &lt;dataType&gt; list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double, hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function subset &lt;dataType&gt;( list1: list, list2: list ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list &lt;Type&gt;) The first list.</p>
<p>list2 - (list &lt;Type&gt;) The second list.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition substring </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l23981">23981</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gabb963dcf8165846eac750eb197238b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb963dcf8165846eac750eb197238b00">&#9670;&nbsp;</a></span>afw_function_definition_subtract</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_subtract</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the &lt;dataType&gt; substring of value beginning at zero-based position integer startIndex and ending at the position before integer endIndex. Specify -1 or omitting endIndex to return up to end of &lt;dataType&gt;.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, string.</p>
<p>Declaration:</p>
<p>function substring &lt;dataType&gt;( string: dataType, startIndex: integer, endIndex?: integer ): dataType;</p>
<p>Parameters:</p>
<p>string - (&lt;Type&gt;)</p>
<p>startIndex - (integer)</p>
<p>endIndex - (optional integer)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Errors thrown:</p>
<p>arg_error - startIndex or endIndex is out of range</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition subtract </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24033">24033</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga873198d38ab5e1a225efbd0b277dddc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873198d38ab5e1a225efbd0b277dddc0">&#9670;&nbsp;</a></span>afw_function_definition_subtract_dayTimeDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_subtract_dayTimeDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Subtract &lt;dataType&gt; arg2 from &lt;dataType&gt; arg1 and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double, integer.</p>
<p>Declaration:</p>
<p>function subtract &lt;dataType&gt;( arg1: dataType, arg2: dataType ): dataType;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition subtract_dayTimeDuration </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24077">24077</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga753b7335ecddb61541fc28f46f91c2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga753b7335ecddb61541fc28f46f91c2dd">&#9670;&nbsp;</a></span>afw_function_definition_subtract_yearMonthDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_subtract_yearMonthDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function subtract_dayTimeDuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Subtract dayTimeDuration arg2 from &lt;dataType&gt; arg1 and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>dateTime.</p>
<p>Declaration:</p>
<p>function subtract_dayTimeDuration &lt;dataType&gt;( arg1: dataType, arg2: dayTimeDuration ): dataType;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (dayTimeDuration)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition subtract_yearMonthDuration </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24121">24121</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga8f76947e34322efd059c75fe6a388c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f76947e34322efd059c75fe6a388c8c">&#9670;&nbsp;</a></span>afw_function_definition_to_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function subtract_yearMonthDuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Subtract yearMonthDuration arg2 from &lt;dataType&gt; arg1 and return the &lt;dataType&gt; result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>date, dateTime.</p>
<p>Declaration:</p>
<p>function subtract_yearMonthDuration &lt;dataType&gt;( arg1: dataType, arg2: yearMonthDuration ): dataType;</p>
<p>Parameters:</p>
<p>arg1 - (&lt;Type&gt;)</p>
<p>arg2 - (yearMonthDuration)</p>
<p>Returns:</p>
<p>(&lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_anyURI </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24165">24165</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga2cec41981f269277a5355838b66c9dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cec41981f269277a5355838b66c9dac">&#9670;&nbsp;</a></span>afw_function_definition_to_boolean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_boolean</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_anyURI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to anyURI.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_anyURI &lt;dataType&gt;( value: dataType ): anyURI;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(anyURI)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_boolean </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24209">24209</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga168f38af57f253c67496dcf215bd3c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168f38af57f253c67496dcf215bd3c5f">&#9670;&nbsp;</a></span>afw_function_definition_to_date</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_date</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to boolean.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_boolean &lt;dataType&gt;( value: dataType ): boolean;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_date </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24253">24253</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gad88f7211f89991895fce3af76890890e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad88f7211f89991895fce3af76890890e">&#9670;&nbsp;</a></span>afw_function_definition_to_dateTime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_dateTime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to date.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_date &lt;dataType&gt;( value: dataType ): date;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(date)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_dateTime </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24297">24297</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga4064af9a3a0a17b048c47f2f73ae9a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4064af9a3a0a17b048c47f2f73ae9a2e">&#9670;&nbsp;</a></span>afw_function_definition_to_dayTimeDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_dayTimeDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_dateTime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to dateTime.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_dateTime &lt;dataType&gt;( value: dataType ): dateTime;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(dateTime)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_dayTimeDuration </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24341">24341</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaea9c6f6f486c829e0a2f9cd73ca12194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea9c6f6f486c829e0a2f9cd73ca12194">&#9670;&nbsp;</a></span>afw_function_definition_to_dnsName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_dnsName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_dayTimeDuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to dayTimeDuration.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_dayTimeDuration &lt;dataType&gt;( value: dataType ): dayTimeDuration;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(dayTimeDuration)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_dnsName </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24385">24385</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga18d2a24e91e47dc042338c6426e3af4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18d2a24e91e47dc042338c6426e3af4c">&#9670;&nbsp;</a></span>afw_function_definition_to_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_dnsName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to dnsName.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_dnsName &lt;dataType&gt;( value: dataType ): dnsName;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(dnsName)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_double </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24429">24429</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaf2be7c81ad4215563d1375153118887f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2be7c81ad4215563d1375153118887f">&#9670;&nbsp;</a></span>afw_function_definition_to_integer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_integer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to double and returns double result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>integer, string.</p>
<p>Declaration:</p>
<p>function to_double &lt;dataType&gt;( value: dataType ): double;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(double)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_integer </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24473">24473</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga82f7899c198a0bc1adcdd9655e927869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82f7899c198a0bc1adcdd9655e927869">&#9670;&nbsp;</a></span>afw_function_definition_to_ipAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_ipAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Truncate &lt;dataType&gt; value to a whole number and returns integer result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>double, string.</p>
<p>Declaration:</p>
<p>function to_integer &lt;dataType&gt;( value: dataType ): integer;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_ipAddress </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24513">24513</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga5d4c0b92bc43485779cbd5277944e257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d4c0b92bc43485779cbd5277944e257">&#9670;&nbsp;</a></span>afw_function_definition_to_rfc822Name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_rfc822Name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_ipAddress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to ipAddress.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_ipAddress &lt;dataType&gt;( value: dataType ): ipAddress;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(ipAddress)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_rfc822Name </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24557">24557</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga85d5a07ea143787291ebcc3aa8e75201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85d5a07ea143787291ebcc3aa8e75201">&#9670;&nbsp;</a></span>afw_function_definition_to_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_rfc822Name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to rfc822Name.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_rfc822Name &lt;dataType&gt;( value: dataType ): rfc822Name;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(rfc822Name)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_string </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24601">24601</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gacda7ff0ec00def0d224a533cb601cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacda7ff0ec00def0d224a533cb601cbba">&#9670;&nbsp;</a></span>afw_function_definition_to_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to string. For list values, the to_string() value for each entry is returned separated with commas.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, dnsName, double, expression, hexBinary, hybrid, ia5String, integer, ipAddress, list, null, object, objectId, objectPath, password, rfc822Name, string, template, time, x500Name, xpathExpression, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function to_string &lt;dataType&gt;( value: dataType ): string;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;) A &lt;dataType&gt; value.</p>
<p>Returns:</p>
<p>(string) The string representation of the value.</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_time </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24645">24645</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga5bc89690ef8d87b762c2402675128ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bc89690ef8d87b762c2402675128ef6">&#9670;&nbsp;</a></span>afw_function_definition_to_x500Name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_x500Name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to time.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_time &lt;dataType&gt;( value: dataType ): time;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(time)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_x500Name </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24689">24689</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga8b24ce4a289eed6f59e7f5e5d5de52ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b24ce4a289eed6f59e7f5e5d5de52ba">&#9670;&nbsp;</a></span>afw_function_definition_to_yearMonthDuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_yearMonthDuration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_x500Name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to x500Name.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_x500Name &lt;dataType&gt;( value: dataType ): x500Name;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(x500Name)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition to_yearMonthDuration </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24733">24733</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaf86e6221aa22c258c791efbbb7a76c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86e6221aa22c258c791efbbb7a76c44">&#9670;&nbsp;</a></span>afw_function_definition_union</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_union</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_yearMonthDuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts &lt;dataType&gt; value to yearMonthDuration.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>string.</p>
<p>Declaration:</p>
<p>function to_yearMonthDuration &lt;dataType&gt;( value: dataType ): yearMonthDuration;</p>
<p>Parameters:</p>
<p>value - (&lt;Type&gt;)</p>
<p>Returns:</p>
<p>(yearMonthDuration)</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition union </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24777">24777</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga0e4f86d9e7a13d636fade6e41bddef18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e4f86d9e7a13d636fade6e41bddef18">&#9670;&nbsp;</a></span>afw_function_definition_url_encode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_url_encode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function union. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of &lt;dataType&gt; contains all of the unique values in two or more list of &lt;dataType&gt; values.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Supported &lt;dataType&gt;:</p>
<p>anyURI, base64Binary, boolean, date, dateTime, dayTimeDuration, double, hexBinary, integer, rfc822Name, string, time, x500Name, yearMonthDuration.</p>
<p>Declaration:</p>
<p>function union &lt;dataType&gt;( lists_1: list, lists_2: list, ...lists_rest: (list of list) ): list;</p>
<p>Parameters:</p>
<p>lists - (2 or more list &lt;Type&gt;) Two or more lists.</p>
<p>Returns:</p>
<p>(list &lt;Type&gt;)</p>
<p>Implemented by <a class="el" href="group__afw__function.html#ga3c89d85149c8f59e4eefef3f9a1b101e" title="Function execute is handled by standard polymorphic function handling.">AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING()</a></p>
<hr  />
<p>Function definition url_encode </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l24821">24821</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 8 2023 19:30:17 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
