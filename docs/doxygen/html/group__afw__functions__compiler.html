<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: compiler functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">compiler functions<div class="ingroups"><a class="el" href="group__package__afw.html">Adaptive Framework Base Package.</a> &raquo; <a class="el" href="group__afw__c__api__public.html">C API</a> &raquo; <a class="el" href="group__afw__c__api__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adaptive Function <code>union&lt;boolean&gt;</code>  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga177e1afddfe631291d3f13ad2152752e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga177e1afddfe631291d3f13ad2152752e">afw_function_execute_assert</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga177e1afddfe631291d3f13ad2152752e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>assert</code>  <a href="group__afw__functions__compiler.html#ga177e1afddfe631291d3f13ad2152752e">More...</a><br /></td></tr>
<tr class="separator:ga177e1afddfe631291d3f13ad2152752e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52165424e07476d98edc7cd78fdcb1f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga52165424e07476d98edc7cd78fdcb1f7">afw_function_execute_compile_expression_tuple</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga52165424e07476d98edc7cd78fdcb1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>compile_expression_tuple</code>  <a href="group__afw__functions__compiler.html#ga52165424e07476d98edc7cd78fdcb1f7">More...</a><br /></td></tr>
<tr class="separator:ga52165424e07476d98edc7cd78fdcb1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90a7247ee0052938d0f1b26b98ff4a26"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga90a7247ee0052938d0f1b26b98ff4a26">afw_function_execute_compile_json</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga90a7247ee0052938d0f1b26b98ff4a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>compile_json</code>  <a href="group__afw__functions__compiler.html#ga90a7247ee0052938d0f1b26b98ff4a26">More...</a><br /></td></tr>
<tr class="separator:ga90a7247ee0052938d0f1b26b98ff4a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01aa6cb375706b022831313f3b7f2f91"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga01aa6cb375706b022831313f3b7f2f91">afw_function_execute_compile_relaxed_json</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga01aa6cb375706b022831313f3b7f2f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>compile_relaxed_json</code>  <a href="group__afw__functions__compiler.html#ga01aa6cb375706b022831313f3b7f2f91">More...</a><br /></td></tr>
<tr class="separator:ga01aa6cb375706b022831313f3b7f2f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1adb4355fa778e9cc785548046e4d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga8c1adb4355fa778e9cc785548046e4d7">afw_function_execute_convert_syntax_hybrid_to_expression</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga8c1adb4355fa778e9cc785548046e4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>convert_syntax_hybrid_to_expression</code>  <a href="group__afw__functions__compiler.html#ga8c1adb4355fa778e9cc785548046e4d7">More...</a><br /></td></tr>
<tr class="separator:ga8c1adb4355fa778e9cc785548046e4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d36e4c01fe4aab14f13ff69ea65ae9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga67d36e4c01fe4aab14f13ff69ea65ae9">afw_function_execute_decompile</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga67d36e4c01fe4aab14f13ff69ea65ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>decompile</code>  <a href="group__afw__functions__compiler.html#ga67d36e4c01fe4aab14f13ff69ea65ae9">More...</a><br /></td></tr>
<tr class="separator:ga67d36e4c01fe4aab14f13ff69ea65ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca130e3936560cb892e7afc4379c456"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga7ca130e3936560cb892e7afc4379c456">afw_function_execute_evaluate_expression_tuple</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga7ca130e3936560cb892e7afc4379c456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>evaluate_expression_tuple</code>  <a href="group__afw__functions__compiler.html#ga7ca130e3936560cb892e7afc4379c456">More...</a><br /></td></tr>
<tr class="separator:ga7ca130e3936560cb892e7afc4379c456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa190e52aee74fa8a60e914893eb9661"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gaaa190e52aee74fa8a60e914893eb9661">afw_function_execute_evaluate_value</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaaa190e52aee74fa8a60e914893eb9661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>evaluate_value</code>  <a href="group__afw__functions__compiler.html#gaaa190e52aee74fa8a60e914893eb9661">More...</a><br /></td></tr>
<tr class="separator:gaaa190e52aee74fa8a60e914893eb9661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ed8cd757cdc742a464c19d91fb0b52"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga40ed8cd757cdc742a464c19d91fb0b52">afw_function_execute_evaluate_with_retry</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga40ed8cd757cdc742a464c19d91fb0b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>evaluate_with_retry</code>  <a href="group__afw__functions__compiler.html#ga40ed8cd757cdc742a464c19d91fb0b52">More...</a><br /></td></tr>
<tr class="separator:ga40ed8cd757cdc742a464c19d91fb0b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35ef382afdc0e1102fb392f634d9605"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gad35ef382afdc0e1102fb392f634d9605">afw_function_execute_qualifier</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gad35ef382afdc0e1102fb392f634d9605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>qualifier</code>  <a href="group__afw__functions__compiler.html#gad35ef382afdc0e1102fb392f634d9605">More...</a><br /></td></tr>
<tr class="separator:gad35ef382afdc0e1102fb392f634d9605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d4e17af43e5c1ed97fd72582f71ea1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gac9d4e17af43e5c1ed97fd72582f71ea1">afw_function_execute_qualifiers</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gac9d4e17af43e5c1ed97fd72582f71ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>qualifiers</code>  <a href="group__afw__functions__compiler.html#gac9d4e17af43e5c1ed97fd72582f71ea1">More...</a><br /></td></tr>
<tr class="separator:gac9d4e17af43e5c1ed97fd72582f71ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fbc6b21022bdf1153dad2187e2af97d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga9fbc6b21022bdf1153dad2187e2af97d">afw_function_execute_safe_evaluate</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga9fbc6b21022bdf1153dad2187e2af97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>safe_evaluate</code>  <a href="group__afw__functions__compiler.html#ga9fbc6b21022bdf1153dad2187e2af97d">More...</a><br /></td></tr>
<tr class="separator:ga9fbc6b21022bdf1153dad2187e2af97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cdfac54eb7db024f745d9ffed1bed78"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga2cdfac54eb7db024f745d9ffed1bed78">afw_function_execute_stringify</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga2cdfac54eb7db024f745d9ffed1bed78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>stringify</code>  <a href="group__afw__functions__compiler.html#ga2cdfac54eb7db024f745d9ffed1bed78">More...</a><br /></td></tr>
<tr class="separator:ga2cdfac54eb7db024f745d9ffed1bed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0fcd6eaf2e54f57e232f362619d1b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga4f0fcd6eaf2e54f57e232f362619d1b5">afw_function_execute_test_expression</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga4f0fcd6eaf2e54f57e232f362619d1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>test_expression</code>  <a href="group__afw__functions__compiler.html#ga4f0fcd6eaf2e54f57e232f362619d1b5">More...</a><br /></td></tr>
<tr class="separator:ga4f0fcd6eaf2e54f57e232f362619d1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd22307ced35386152b818c48d48934c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gacd22307ced35386152b818c48d48934c">afw_function_execute_test_expression_tuple</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gacd22307ced35386152b818c48d48934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>test_expression_tuple</code>  <a href="group__afw__functions__compiler.html#gacd22307ced35386152b818c48d48934c">More...</a><br /></td></tr>
<tr class="separator:gacd22307ced35386152b818c48d48934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e1d2070910f6d2c6aa08765d437432"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga60e1d2070910f6d2c6aa08765d437432">afw_function_execute_test_hybrid</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga60e1d2070910f6d2c6aa08765d437432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>test_hybrid</code>  <a href="group__afw__functions__compiler.html#ga60e1d2070910f6d2c6aa08765d437432">More...</a><br /></td></tr>
<tr class="separator:ga60e1d2070910f6d2c6aa08765d437432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7715a397c0da24a7fd889d0f6aa17c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gaa7715a397c0da24a7fd889d0f6aa17c7">afw_function_execute_test_script</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaa7715a397c0da24a7fd889d0f6aa17c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>test_script</code>  <a href="group__afw__functions__compiler.html#gaa7715a397c0da24a7fd889d0f6aa17c7">More...</a><br /></td></tr>
<tr class="separator:gaa7715a397c0da24a7fd889d0f6aa17c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece17edebd816a6813118c72f3441cb1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gaece17edebd816a6813118c72f3441cb1">afw_function_execute_test_script_runtime_support</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaece17edebd816a6813118c72f3441cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>test_script_runtime_support</code>  <a href="group__afw__functions__compiler.html#gaece17edebd816a6813118c72f3441cb1">More...</a><br /></td></tr>
<tr class="separator:gaece17edebd816a6813118c72f3441cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7471245a09c8a0675c6571f3e30b008e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga7471245a09c8a0675c6571f3e30b008e">afw_function_execute_test_template</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga7471245a09c8a0675c6571f3e30b008e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>test_template</code>  <a href="group__afw__functions__compiler.html#ga7471245a09c8a0675c6571f3e30b008e">More...</a><br /></td></tr>
<tr class="separator:ga7471245a09c8a0675c6571f3e30b008e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadedb4b4f81ac8529d4bcd07ff47c186d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gadedb4b4f81ac8529d4bcd07ff47c186d">afw_function_execute_test_value</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gadedb4b4f81ac8529d4bcd07ff47c186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>test_value</code>  <a href="group__afw__functions__compiler.html#gadedb4b4f81ac8529d4bcd07ff47c186d">More...</a><br /></td></tr>
<tr class="separator:gadedb4b4f81ac8529d4bcd07ff47c186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8934d5a9b92ca3c78404c72659056b9c"><td class="memItemLeft" align="right" valign="top"><a id="ga8934d5a9b92ca3c78404c72659056b9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga8934d5a9b92ca3c78404c72659056b9c">afw_function_definition_assert</a></td></tr>
<tr class="memdesc:ga8934d5a9b92ca3c78404c72659056b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition assert. <br /></td></tr>
<tr class="separator:ga8934d5a9b92ca3c78404c72659056b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6deacbd04fb891072d7a6cfe41e24b81"><td class="memItemLeft" align="right" valign="top"><a id="ga6deacbd04fb891072d7a6cfe41e24b81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga6deacbd04fb891072d7a6cfe41e24b81">afw_function_definition_compile_expression_tuple</a></td></tr>
<tr class="memdesc:ga6deacbd04fb891072d7a6cfe41e24b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition compile_expression_tuple. <br /></td></tr>
<tr class="separator:ga6deacbd04fb891072d7a6cfe41e24b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66cebc61039de01c5ecff371b5869418"><td class="memItemLeft" align="right" valign="top"><a id="ga66cebc61039de01c5ecff371b5869418"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga66cebc61039de01c5ecff371b5869418">afw_function_definition_compile_json</a></td></tr>
<tr class="memdesc:ga66cebc61039de01c5ecff371b5869418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition compile_json. <br /></td></tr>
<tr class="separator:ga66cebc61039de01c5ecff371b5869418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f066ab2b1ca388b551e315dd49229fd"><td class="memItemLeft" align="right" valign="top"><a id="ga6f066ab2b1ca388b551e315dd49229fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga6f066ab2b1ca388b551e315dd49229fd">afw_function_definition_compile_relaxed_json</a></td></tr>
<tr class="memdesc:ga6f066ab2b1ca388b551e315dd49229fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition compile_relaxed_json. <br /></td></tr>
<tr class="separator:ga6f066ab2b1ca388b551e315dd49229fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df6d460cd5d6700a23d2562c1d72140"><td class="memItemLeft" align="right" valign="top"><a id="ga9df6d460cd5d6700a23d2562c1d72140"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga9df6d460cd5d6700a23d2562c1d72140">afw_function_definition_convert_syntax_hybrid_to_expression</a></td></tr>
<tr class="memdesc:ga9df6d460cd5d6700a23d2562c1d72140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition convert_syntax_hybrid_to_expression. <br /></td></tr>
<tr class="separator:ga9df6d460cd5d6700a23d2562c1d72140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc0225b8cd5789dffb69fb06b2e4d89"><td class="memItemLeft" align="right" valign="top"><a id="ga4bc0225b8cd5789dffb69fb06b2e4d89"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga4bc0225b8cd5789dffb69fb06b2e4d89">afw_function_definition_decompile</a></td></tr>
<tr class="memdesc:ga4bc0225b8cd5789dffb69fb06b2e4d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition decompile. <br /></td></tr>
<tr class="separator:ga4bc0225b8cd5789dffb69fb06b2e4d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14855b3473f8b494d9db6a43a54f246c"><td class="memItemLeft" align="right" valign="top"><a id="ga14855b3473f8b494d9db6a43a54f246c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga14855b3473f8b494d9db6a43a54f246c">afw_function_definition_evaluate_expression_tuple</a></td></tr>
<tr class="memdesc:ga14855b3473f8b494d9db6a43a54f246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition evaluate_expression_tuple. <br /></td></tr>
<tr class="separator:ga14855b3473f8b494d9db6a43a54f246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8368bc380898a38ed00e11dce2567d2"><td class="memItemLeft" align="right" valign="top"><a id="gab8368bc380898a38ed00e11dce2567d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gab8368bc380898a38ed00e11dce2567d2">afw_function_definition_evaluate_value</a></td></tr>
<tr class="memdesc:gab8368bc380898a38ed00e11dce2567d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition evaluate_value. <br /></td></tr>
<tr class="separator:gab8368bc380898a38ed00e11dce2567d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4447bf0d25d543e6b54765d29c1cc29f"><td class="memItemLeft" align="right" valign="top"><a id="ga4447bf0d25d543e6b54765d29c1cc29f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga4447bf0d25d543e6b54765d29c1cc29f">afw_function_definition_evaluate_with_retry</a></td></tr>
<tr class="memdesc:ga4447bf0d25d543e6b54765d29c1cc29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition evaluate_with_retry. <br /></td></tr>
<tr class="separator:ga4447bf0d25d543e6b54765d29c1cc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ceb06843d8d1be794082623a0d6c16"><td class="memItemLeft" align="right" valign="top"><a id="ga39ceb06843d8d1be794082623a0d6c16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga39ceb06843d8d1be794082623a0d6c16">afw_function_definition_qualifier</a></td></tr>
<tr class="memdesc:ga39ceb06843d8d1be794082623a0d6c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition qualifier. <br /></td></tr>
<tr class="separator:ga39ceb06843d8d1be794082623a0d6c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5994df59f5f556e411f8dfb6c81d8e62"><td class="memItemLeft" align="right" valign="top"><a id="ga5994df59f5f556e411f8dfb6c81d8e62"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga5994df59f5f556e411f8dfb6c81d8e62">afw_function_definition_qualifiers</a></td></tr>
<tr class="memdesc:ga5994df59f5f556e411f8dfb6c81d8e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition qualifiers. <br /></td></tr>
<tr class="separator:ga5994df59f5f556e411f8dfb6c81d8e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e2df970aa8aea18a2a2cc3e3730db0"><td class="memItemLeft" align="right" valign="top"><a id="ga47e2df970aa8aea18a2a2cc3e3730db0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga47e2df970aa8aea18a2a2cc3e3730db0">afw_function_definition_safe_evaluate</a></td></tr>
<tr class="memdesc:ga47e2df970aa8aea18a2a2cc3e3730db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition safe_evaluate. <br /></td></tr>
<tr class="separator:ga47e2df970aa8aea18a2a2cc3e3730db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3e9a006ee07a91f4bcb0a6b56f3415"><td class="memItemLeft" align="right" valign="top"><a id="ga0a3e9a006ee07a91f4bcb0a6b56f3415"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga0a3e9a006ee07a91f4bcb0a6b56f3415">afw_function_definition_stringify</a></td></tr>
<tr class="memdesc:ga0a3e9a006ee07a91f4bcb0a6b56f3415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition stringify. <br /></td></tr>
<tr class="separator:ga0a3e9a006ee07a91f4bcb0a6b56f3415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cffc67aee4730a9bc289b3f9995ac16"><td class="memItemLeft" align="right" valign="top"><a id="ga8cffc67aee4730a9bc289b3f9995ac16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga8cffc67aee4730a9bc289b3f9995ac16">afw_function_definition_test_expression</a></td></tr>
<tr class="memdesc:ga8cffc67aee4730a9bc289b3f9995ac16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition test_expression. <br /></td></tr>
<tr class="separator:ga8cffc67aee4730a9bc289b3f9995ac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5de9d24b1f12e980fc7f7f2e7891c5e"><td class="memItemLeft" align="right" valign="top"><a id="gab5de9d24b1f12e980fc7f7f2e7891c5e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gab5de9d24b1f12e980fc7f7f2e7891c5e">afw_function_definition_test_expression_tuple</a></td></tr>
<tr class="memdesc:gab5de9d24b1f12e980fc7f7f2e7891c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition test_expression_tuple. <br /></td></tr>
<tr class="separator:gab5de9d24b1f12e980fc7f7f2e7891c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62b656c4868dfa5674189bdf5bd772a"><td class="memItemLeft" align="right" valign="top"><a id="gae62b656c4868dfa5674189bdf5bd772a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#gae62b656c4868dfa5674189bdf5bd772a">afw_function_definition_test_hybrid</a></td></tr>
<tr class="memdesc:gae62b656c4868dfa5674189bdf5bd772a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition test_hybrid. <br /></td></tr>
<tr class="separator:gae62b656c4868dfa5674189bdf5bd772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a721f52493c59fd86ce4baf7f29097"><td class="memItemLeft" align="right" valign="top"><a id="ga98a721f52493c59fd86ce4baf7f29097"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga98a721f52493c59fd86ce4baf7f29097">afw_function_definition_test_script</a></td></tr>
<tr class="memdesc:ga98a721f52493c59fd86ce4baf7f29097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition test_script. <br /></td></tr>
<tr class="separator:ga98a721f52493c59fd86ce4baf7f29097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e79cfb42f53561e430c96fa6d4a0bb7"><td class="memItemLeft" align="right" valign="top"><a id="ga3e79cfb42f53561e430c96fa6d4a0bb7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga3e79cfb42f53561e430c96fa6d4a0bb7">afw_function_definition_test_script_runtime_support</a></td></tr>
<tr class="memdesc:ga3e79cfb42f53561e430c96fa6d4a0bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition test_script_runtime_support. <br /></td></tr>
<tr class="separator:ga3e79cfb42f53561e430c96fa6d4a0bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga127b8f83a991affcb4f981193754a0e4"><td class="memItemLeft" align="right" valign="top"><a id="ga127b8f83a991affcb4f981193754a0e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga127b8f83a991affcb4f981193754a0e4">afw_function_definition_test_template</a></td></tr>
<tr class="memdesc:ga127b8f83a991affcb4f981193754a0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition test_template. <br /></td></tr>
<tr class="separator:ga127b8f83a991affcb4f981193754a0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b34c445ebb787be068e64208d3ee097"><td class="memItemLeft" align="right" valign="top"><a id="ga8b34c445ebb787be068e64208d3ee097"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__compiler.html#ga8b34c445ebb787be068e64208d3ee097">afw_function_definition_test_value</a></td></tr>
<tr class="memdesc:ga8b34c445ebb787be068e64208d3ee097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition test_value. <br /></td></tr>
<tr class="separator:ga8b34c445ebb787be068e64208d3ee097"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adaptive Function <code>union&lt;boolean&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of boolean contains all of the unique values in two or more list of boolean values.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> union&lt;boolean&gt;(</div>
<div class="line">    lists_1: (list <span class="keywordtype">boolean</span>),</div>
<div class="line">    lists_2: (list <span class="keywordtype">boolean</span>),</div>
<div class="line">    ...lists_rest: (list of (list <span class="keywordtype">boolean</span>))</div>
<div class="line">): (list boolean);</div>
</div><!-- fragment --><p>Parameters:</p>
<p>lists - (2 or more list boolean) Two or more lists.</p>
<p>Returns:</p>
<p>(list boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gac65fd70ccba4536ea9f74c17d5c86cd1" title="Function implementation function afw_function_execute_union.">afw_function_execute_union()</a></p>
<hr  />
<p>compiler adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga177e1afddfe631291d3f13ad2152752e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga177e1afddfe631291d3f13ad2152752e">&#9670;&nbsp;</a></span>afw_function_execute_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_assert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>assert</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Assert that a value is true. If not, an assertion_failed error is thrown.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> assert(</div>
<div class="line">    assertion: <span class="keywordtype">boolean</span>,</div>
<div class="line">    reason?: <span class="keywordtype">string</span></div>
<div class="line">): null;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>assertion - (boolean) This is the assertion to make. If not true, an assertion_failed error is thrown.</p>
<p>reason - (optional string) This is an optional reason to include in the assertion_failed message.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00054">54</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga52165424e07476d98edc7cd78fdcb1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52165424e07476d98edc7cd78fdcb1f7">&#9670;&nbsp;</a></span>afw_function_execute_compile_expression_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_compile_expression_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>compile_expression_tuple</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile a string containing adaptive expression tuple syntax and return either an unevaluated expression tuple adaptive value or a string containing the compiler listing.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> compile_expression_tuple(</div>
<div class="line">    expression_tuple: list,</div>
<div class="line">    listing?: any</div>
<div class="line">): any;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>expression_tuple - (list) expression tuple to compile.</p>
<p>listing - (optional any dataType) If specified, a compiler listing is produced instead of an unevaluated expression tuple value.</p>
<p>This parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(any dataType) An unevaluated expression tuple value ready for use by function evaluate() or a string containing the compiler listing. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00170">170</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga90a7247ee0052938d0f1b26b98ff4a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90a7247ee0052938d0f1b26b98ff4a26">&#9670;&nbsp;</a></span>afw_function_execute_compile_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_compile_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>compile_json</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile a string containing adaptive JSON syntax and return either an unevaluated JSON adaptive value or a string containing the compiler listing.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> compile_json(</div>
<div class="line">    json: <span class="keywordtype">string</span>,</div>
<div class="line">    listing?: any</div>
<div class="line">): any;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>json - (string) JSON string to compile.</p>
<p>listing - (optional any dataType) If specified, a compiler listing is produced instead of an unevaluated JSON value.</p>
<p>This parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(any dataType) An unevaluated JSON value ready for use by function evaluate() or a string containing the compiler listing. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00240">240</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga01aa6cb375706b022831313f3b7f2f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01aa6cb375706b022831313f3b7f2f91">&#9670;&nbsp;</a></span>afw_function_execute_compile_relaxed_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_compile_relaxed_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>compile_relaxed_json</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile an adaptive relaxed JSON syntax string and return an adaptive value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> compile_relaxed_json(</div>
<div class="line">    json: <span class="keywordtype">string</span>,</div>
<div class="line">    listing?: any</div>
<div class="line">): any;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>json - (string) Adaptive relaxed JSON syntax string to compile.</p>
<p>listing - (optional any dataType) If specified, a compiler listing is produced instead of an unevaluated relaxed JSON value.</p>
<p>This parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(any dataType) An unevaluated relaxed JSON value ready for use by function evaluate() or a string containing the compiler listing. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00306">306</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga8c1adb4355fa778e9cc785548046e4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1adb4355fa778e9cc785548046e4d7">&#9670;&nbsp;</a></span>afw_function_execute_convert_syntax_hybrid_to_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_convert_syntax_hybrid_to_expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>convert_syntax_hybrid_to_expression</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a string containing adaptive hybrid syntax, which can be an adaptive template or adaptive expression tuple, to adaptive expression syntax.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> convert_syntax_hybrid_to_expression(</div>
<div class="line">    hybrid: <span class="keywordtype">string</span>,</div>
<div class="line">    whitespace?: any</div>
<div class="line">): expression;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>hybrid - (string) The hybrid to convert.</p>
<p>whitespace - (optional any dataType) Add whitespace for readability if present and not 0. This parameter can be an integer between 0 and 10 or a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(expression) The converted value in adaptive expression syntax. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00370">370</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga67d36e4c01fe4aab14f13ff69ea65ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d36e4c01fe4aab14f13ff69ea65ae9">&#9670;&nbsp;</a></span>afw_function_execute_decompile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_decompile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>decompile</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Decompile an adaptive value to string.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> decompile(</div>
<div class="line">    value: any,</div>
<div class="line">    whitespace?: any</div>
<div class="line">): string;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (any dataType) Value to decompile.</p>
<p>whitespace - (optional any dataType) Add whitespace for readability if present and not 0. This parameter can be an integer between 0 and 10 or a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(string) Decompiled value. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00429">429</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga7ca130e3936560cb892e7afc4379c456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca130e3936560cb892e7afc4379c456">&#9670;&nbsp;</a></span>afw_function_execute_evaluate_expression_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_evaluate_expression_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>evaluate_expression_tuple</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile a string containing adaptive expression tuple syntax and then evaluate the result.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> evaluate_expression_tuple(</div>
<div class="line">    expression_tuple: <span class="keywordtype">string</span>,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): any;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>expression_tuple - (string) Expression tuple to compile and evaluate.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(any dataType) Evaluated adaptive expression tuple. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00482">482</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="gaaa190e52aee74fa8a60e914893eb9661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa190e52aee74fa8a60e914893eb9661">&#9670;&nbsp;</a></span>afw_function_execute_evaluate_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_evaluate_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>evaluate_value</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate an adaptive value.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> evaluate_value(</div>
<div class="line">    value: any,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): any;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (any dataType)</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(any dataType) Evaluated adaptive value. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00547">547</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga40ed8cd757cdc742a464c19d91fb0b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ed8cd757cdc742a464c19d91fb0b52">&#9670;&nbsp;</a></span>afw_function_execute_evaluate_with_retry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_evaluate_with_retry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>evaluate_with_retry</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate a value and retry up to a limit if an exception occurs.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> evaluate_with_retry(</div>
<div class="line">    value: any,</div>
<div class="line">    limit: integer</div>
<div class="line">): any;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (any dataType) Value to evaluated.</p>
<p>limit - (integer) Maximum number to retry if an exception occurs.</p>
<p>Returns:</p>
<p>(any dataType) Evaluated value. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00598">598</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="gad35ef382afdc0e1102fb392f634d9605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad35ef382afdc0e1102fb392f634d9605">&#9670;&nbsp;</a></span>afw_function_execute_qualifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_qualifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>qualifier</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the active variables for a qualifier to be accessed as the properties of an object.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> qualifier(</div>
<div class="line">    qualifier: <span class="keywordtype">string</span>,</div>
<div class="line">    forTesting?: <span class="keywordtype">boolean</span></div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>qualifier - (string) This is the qualifier whose variables are to be accessed as properties of the returned object.</p>
<p>forTesting - (optional boolean) If specified and true, the object returned will be suitable to pass as the additionalUntrustedQualifiedVariables parameter of evaluate*() functions. This is intended for testing purposes and should not be used in production.</p>
<p>Returns:</p>
<p>(object) Each property is the name of a variable with the value influenced by the forTesting property. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l01575">1575</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="gac9d4e17af43e5c1ed97fd72582f71ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9d4e17af43e5c1ed97fd72582f71ea1">&#9670;&nbsp;</a></span>afw_function_execute_qualifiers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_qualifiers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>qualifiers</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the active qualifiers to be accessed as properties of an object. The value of each of these properties is an object whose properties are the variables for the corresponding qualifier.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> qualifiers(</div>
<div class="line">    forTesting?: <span class="keywordtype">boolean</span></div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>forTesting - (optional boolean) If specified and true, the object returned will be suitable to pass as the additionalUntrustedQualifiedVariables parameter of evaluate*() functions. This is intended for testing purposes and should not be used in production.</p>
<p>Returns:</p>
<p>(object) Each property is the name of a qualifier with a value that is an object whose properties are the variables of that qualifier. The value of the variable properties is influenced by the forTesting property. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l01633">1633</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga9fbc6b21022bdf1153dad2187e2af97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fbc6b21022bdf1153dad2187e2af97d">&#9670;&nbsp;</a></span>afw_function_execute_safe_evaluate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_safe_evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>safe_evaluate</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the evaluated adaptive value. If an exception occurs, return evaluated error instead.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> safe_evaluate(</div>
<div class="line">    value: any,</div>
<div class="line">    error: any</div>
<div class="line">): any;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (any dataType) Value to evaluated.</p>
<p>error - (any dataType) Value to evaluate and return if exception occurs. If an error occurs evaluating this value, the exception will continue.</p>
<p>Returns:</p>
<p>(any dataType) Evaluated adaptive value or error value. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00674">674</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga2cdfac54eb7db024f745d9ffed1bed78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cdfac54eb7db024f745d9ffed1bed78">&#9670;&nbsp;</a></span>afw_function_execute_stringify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_stringify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>stringify</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate and decompile an adaptive value to string. For most values this has the effect of producing a string containing json.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> stringify(</div>
<div class="line">    value: any,</div>
<div class="line">    replacer?: any,</div>
<div class="line">    whitespace?: any</div>
<div class="line">): string;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (any dataType) Value to stringify.</p>
<p>replacer - (optional any dataType) Optional replacer function.</p>
<p>whitespace - (optional any dataType) Add whitespace for readability if present and not 0. This parameter can be an integer between 0 and 10 or a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(string) Evaluated and decompiled value. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000110">Todo:</a></b></dt><dd>FIXME: add support for replacer </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00740">740</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga4f0fcd6eaf2e54f57e232f362619d1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f0fcd6eaf2e54f57e232f362619d1b5">&#9670;&nbsp;</a></span>afw_function_execute_test_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_test_expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>test_expression</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile and evaluate an adaptive expression and compare the results to an expected value. Return object with the test's results.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> test_expression(</div>
<div class="line">    <span class="keywordtype">id</span>: <span class="keywordtype">string</span>,</div>
<div class="line">    description: <span class="keywordtype">string</span>,</div>
<div class="line">    expression: <span class="keywordtype">string</span>,</div>
<div class="line">    expected: any,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>id - (string) Id of test.</p>
<p>description - (string) Description of test.</p>
<p>expression - (string) Expression to compile and evaluate.</p>
<p>expected - (any dataType) Expected result.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(object) Test results. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00823">823</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="gacd22307ced35386152b818c48d48934c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd22307ced35386152b818c48d48934c">&#9670;&nbsp;</a></span>afw_function_execute_test_expression_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_test_expression_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>test_expression_tuple</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile and evaluate an adaptive expression tuple and compare the results to an expected value. Return object with the test's results.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> test_expression_tuple(</div>
<div class="line">    <span class="keywordtype">id</span>: <span class="keywordtype">string</span>,</div>
<div class="line">    description: <span class="keywordtype">string</span>,</div>
<div class="line">    expression: <span class="keywordtype">string</span>,</div>
<div class="line">    expected: any,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>id - (string) Id of test.</p>
<p>description - (string) Description of test.</p>
<p>expression - (string) Expression tuple to compile and evaluate.</p>
<p>expected - (any dataType) Expected result.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(object) Test results. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l00950">950</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga60e1d2070910f6d2c6aa08765d437432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e1d2070910f6d2c6aa08765d437432">&#9670;&nbsp;</a></span>afw_function_execute_test_hybrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_test_hybrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>test_hybrid</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile and evaluate a string containing adaptive hybrid syntax which can be an adaptive template or adaptive expression tuple and then compare the results to an expected value. Return object with the test's results.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> test_hybrid(</div>
<div class="line">    <span class="keywordtype">id</span>: <span class="keywordtype">string</span>,</div>
<div class="line">    description: <span class="keywordtype">string</span>,</div>
<div class="line">    hybrid: <span class="keywordtype">string</span>,</div>
<div class="line">    expected: any,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>id - (string) Id of test.</p>
<p>description - (string) Description of test.</p>
<p>hybrid - (string) Hybrid to compile and evaluate.</p>
<p>expected - (any dataType) Expected evaluated result.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(object) Test results. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l01078">1078</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="gaa7715a397c0da24a7fd889d0f6aa17c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7715a397c0da24a7fd889d0f6aa17c7">&#9670;&nbsp;</a></span>afw_function_execute_test_script()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_test_script </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>test_script</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile and evaluate an adaptive script and compare the results to an expected value. Return object with the test's results.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> test_script(</div>
<div class="line">    <span class="keywordtype">id</span>: <span class="keywordtype">string</span>,</div>
<div class="line">    description: <span class="keywordtype">string</span>,</div>
<div class="line">    script: <span class="keywordtype">string</span>,</div>
<div class="line">    expected: any,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>id - (string) Id of test.</p>
<p>description - (string) Description of test.</p>
<p>script - (string) Script to compile and evaluate.</p>
<p>expected - (any dataType) Expected result.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(object) Test results. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l01205">1205</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="gaece17edebd816a6813118c72f3441cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece17edebd816a6813118c72f3441cb1">&#9670;&nbsp;</a></span>afw_function_execute_test_script_runtime_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_test_script_runtime_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>test_script_runtime_support</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a function called internally as the result of a test_script compile. This function is not intended to be called directly.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> test_script_runtime_support(</div>
<div class="line">    testScriptObject: (<span class="keywordtype">object</span> _AdaptiveTestScriptResult_)</div>
<div class="line">): (object _AdaptiveTestScriptResult_);</div>
</div><!-- fragment --><p>Parameters:</p>
<p>testScriptObject - (object <em>AdaptiveTestScriptResult</em>) A test script results object with the required evaluation result properties missing. The sources will be evaluated and the corresponding test result properties will be set.</p>
<p>Returns:</p>
<p>(object <em>AdaptiveTestScriptResult</em>) The testScriptObject object with test result properties set. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l01685">1685</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="ga7471245a09c8a0675c6571f3e30b008e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7471245a09c8a0675c6571f3e30b008e">&#9670;&nbsp;</a></span>afw_function_execute_test_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_test_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>test_template</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile and evaluate an adaptive template and compare the results to an expected value. Return object with the test's results.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> test_template(</div>
<div class="line">    <span class="keywordtype">id</span>: <span class="keywordtype">string</span>,</div>
<div class="line">    description: <span class="keywordtype">string</span>,</div>
<div class="line">    <span class="keyword">template</span>: <span class="keywordtype">string</span>,</div>
<div class="line">    expected: any,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>id - (string) Id of test.</p>
<p>description - (string) Description of test.</p>
<p>template - (string) Template to compile and evaluate.</p>
<p>expected - (any dataType) Expected evaluated result.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(object) Test results. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l01332">1332</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
<a id="gadedb4b4f81ac8529d4bcd07ff47c186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadedb4b4f81ac8529d4bcd07ff47c186d">&#9670;&nbsp;</a></span>afw_function_execute_test_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_test_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>test_value</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate an adaptive value and compare it to an expected value. Return object with the test's results.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> test_value(</div>
<div class="line">    <span class="keywordtype">id</span>: <span class="keywordtype">string</span>,</div>
<div class="line">    description: <span class="keywordtype">string</span>,</div>
<div class="line">    value: <span class="keywordtype">string</span>,</div>
<div class="line">    expected: any,</div>
<div class="line">    additionalUntrustedQualifiedVariables?: (<span class="keywordtype">object</span> _AdaptiveHybridPropertiesObjects_)</div>
<div class="line">): object;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>id - (string) Id of test.</p>
<p>description - (string) Description of test.</p>
<p>value - (string) Value to evaluate.</p>
<p>expected - (any dataType) Expected result.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(object) Test results. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__compiler_8c_source.html#l01459">1459</a> of file <a class="el" href="afw__function__compiler_8c_source.html">afw_function_compiler.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2023 16:19:58 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
