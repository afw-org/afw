<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: Stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Stack<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:afw__stack_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afw__stack_8h.html">afw_stack.h</a></td></tr>
<tr class="memdesc:afw__stack_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Framework stack support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga63563e7c497b2a71da2c4339a0951ce6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga63563e7c497b2a71da2c4339a0951ce6">afw_stack_create</a>(typedef_name,  initial_count,  maximum_count,  create_subpool_pool,  p,  scope)</td></tr>
<tr class="memdesc:ga63563e7c497b2a71da2c4339a0951ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stack for the specified typedef.  <a href="group__afw__stack.html#ga63563e7c497b2a71da2c4339a0951ce6">More...</a><br /></td></tr>
<tr class="separator:ga63563e7c497b2a71da2c4339a0951ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4961e4239e762c83423831370292736f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga4961e4239e762c83423831370292736f">afw_stack_release</a>(instance,  scope)&#160;&#160;&#160;<a class="el" href="group__afw__stack.html#gaf041d115658dc79b98f9e578691d0768">afw_stack_release_impl</a>( &amp;((instance)-&gt;pub), scope)</td></tr>
<tr class="memdesc:ga4961e4239e762c83423831370292736f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release stack implementation.  <a href="group__afw__stack.html#ga4961e4239e762c83423831370292736f">More...</a><br /></td></tr>
<tr class="separator:ga4961e4239e762c83423831370292736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad28df2a02ae8b5a71fe7a162fbab1ed0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#gad28df2a02ae8b5a71fe7a162fbab1ed0">afw_stack_copy</a>(instance,  count,  ptr,  p,  scope)&#160;&#160;&#160;<a class="el" href="group__afw__stack.html#ga6f76dab2a110e15161c502e23fa8f22d">afw_stack_copy_impl</a>( &amp;((instance)-&gt;pub), count, ptr, p, scope)</td></tr>
<tr class="memdesc:gad28df2a02ae8b5a71fe7a162fbab1ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy stack.  <a href="group__afw__stack.html#gad28df2a02ae8b5a71fe7a162fbab1ed0">More...</a><br /></td></tr>
<tr class="separator:gad28df2a02ae8b5a71fe7a162fbab1ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d7114d3fb2214d3c6767f53cdc82ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#gae0d7114d3fb2214d3c6767f53cdc82ec">afw_stack_copy_and_release</a>(instance,  count,  ptr,  p,  scope)</td></tr>
<tr class="memdesc:gae0d7114d3fb2214d3c6767f53cdc82ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and release stack.  <a href="group__afw__stack.html#gae0d7114d3fb2214d3c6767f53cdc82ec">More...</a><br /></td></tr>
<tr class="separator:gae0d7114d3fb2214d3c6767f53cdc82ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989d368a878b7bfa182e565a3ddae4e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga989d368a878b7bfa182e565a3ddae4e4">afw_stack_is_empty</a>(instance)&#160;&#160;&#160;    ((instance)-&gt;top &lt; (instance)-&gt;first)</td></tr>
<tr class="memdesc:ga989d368a878b7bfa182e565a3ddae4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine is a stack is empty.  <a href="group__afw__stack.html#ga989d368a878b7bfa182e565a3ddae4e4">More...</a><br /></td></tr>
<tr class="separator:ga989d368a878b7bfa182e565a3ddae4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3e9626e06f7c598e7dee98796c594f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#gaff3e9626e06f7c598e7dee98796c594f">afw_stack_pop</a>(instance,  scope)</td></tr>
<tr class="memdesc:gaff3e9626e06f7c598e7dee98796c594f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement stack-&gt;top to location of previous entry.  <a href="group__afw__stack.html#gaff3e9626e06f7c598e7dee98796c594f">More...</a><br /></td></tr>
<tr class="separator:gaff3e9626e06f7c598e7dee98796c594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6548628591d242de2ce382b9b4c4e9d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga6548628591d242de2ce382b9b4c4e9d5">afw_stack_count</a>(instance,  scope)&#160;&#160;&#160;    ((instance)-&gt;top + 1 - (instance)-&gt;first))</td></tr>
<tr class="memdesc:ga6548628591d242de2ce382b9b4c4e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries in stack.  <a href="group__afw__stack.html#ga6548628591d242de2ce382b9b4c4e9d5">More...</a><br /></td></tr>
<tr class="separator:ga6548628591d242de2ce382b9b4c4e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56dadac86ddd565edf7484609655361"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#gae56dadac86ddd565edf7484609655361">afw_stack_push</a>(instance,  scope)</td></tr>
<tr class="memdesc:gae56dadac86ddd565edf7484609655361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment stack-&gt;top to location of next entry and returns *top.  <a href="group__afw__stack.html#gae56dadac86ddd565edf7484609655361">More...</a><br /></td></tr>
<tr class="separator:gae56dadac86ddd565edf7484609655361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga149db6cb249215fa359cdb25c9b33627"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga149db6cb249215fa359cdb25c9b33627">afw_stack_push_direct</a>(instance,  scope)</td></tr>
<tr class="memdesc:ga149db6cb249215fa359cdb25c9b33627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment stack-&gt;top to location of next entry and returns top.  <a href="group__afw__stack.html#ga149db6cb249215fa359cdb25c9b33627">More...</a><br /></td></tr>
<tr class="separator:ga149db6cb249215fa359cdb25c9b33627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d48f070c6dc3548004c30b0628d868"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga45d48f070c6dc3548004c30b0628d868">afw_stack_push_and_get_entry</a>(instance,  entry,  scope)</td></tr>
<tr class="memdesc:ga45d48f070c6dc3548004c30b0628d868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment stack-&gt;top to location of next entry and get entry.  <a href="group__afw__stack.html#ga45d48f070c6dc3548004c30b0628d868">More...</a><br /></td></tr>
<tr class="separator:ga45d48f070c6dc3548004c30b0628d868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2945db55aa2cd5e61472d22bfd3a72f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga2945db55aa2cd5e61472d22bfd3a72f2">afw_stack_set_empty</a>(instance)&#160;&#160;&#160;    (instance)-&gt;top = ((instance)-&gt;first) - 1</td></tr>
<tr class="memdesc:ga2945db55aa2cd5e61472d22bfd3a72f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment stack-&gt;top to location of next entry.  <a href="group__afw__stack.html#ga2945db55aa2cd5e61472d22bfd3a72f2">More...</a><br /></td></tr>
<tr class="separator:ga2945db55aa2cd5e61472d22bfd3a72f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga15aba79051ca01de2ffaaa1f6f22305a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga15aba79051ca01de2ffaaa1f6f22305a">afw_stack_create_impl</a> (<a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a> entry_size, <a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a> initial_count, <a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a> maximum_count, <a class="el" href="group__afw__common.html#ga54967bd7180a4c18b5b3bed720c9c1f7">afw_boolean_t</a> create_subpool_pool, const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *p, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:ga15aba79051ca01de2ffaaa1f6f22305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stack implementation.  <a href="group__afw__stack.html#ga15aba79051ca01de2ffaaa1f6f22305a">More...</a><br /></td></tr>
<tr class="separator:ga15aba79051ca01de2ffaaa1f6f22305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf041d115658dc79b98f9e578691d0768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#gaf041d115658dc79b98f9e578691d0768">afw_stack_release_impl</a> (<a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a> *instance, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:gaf041d115658dc79b98f9e578691d0768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release stack implementation.  <a href="group__afw__stack.html#gaf041d115658dc79b98f9e578691d0768">More...</a><br /></td></tr>
<tr class="separator:gaf041d115658dc79b98f9e578691d0768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f76dab2a110e15161c502e23fa8f22d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga6f76dab2a110e15161c502e23fa8f22d">afw_stack_copy_impl</a> (<a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a> *instance, <a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a> *count, const void ***ptr, const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *p, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:ga6f76dab2a110e15161c502e23fa8f22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy stack implementation.  <a href="group__afw__stack.html#ga6f76dab2a110e15161c502e23fa8f22d">More...</a><br /></td></tr>
<tr class="separator:ga6f76dab2a110e15161c502e23fa8f22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11af063d667c3f352e6345aa0a67117f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#ga11af063d667c3f352e6345aa0a67117f">afw_stack_extend_impl</a> (<a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a> *instance, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:ga11af063d667c3f352e6345aa0a67117f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend stack implementation.  <a href="group__afw__stack.html#ga11af063d667c3f352e6345aa0a67117f">More...</a><br /></td></tr>
<tr class="separator:ga11af063d667c3f352e6345aa0a67117f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2141f35f3d5febf6271b0072f995fea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__stack.html#gae2141f35f3d5febf6271b0072f995fea">afw_stack_internal_set_qualifier_stack</a> (<a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="separator:gae2141f35f3d5febf6271b0072f995fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1877711503ba42fd9e2c55898b5a9cc"><td class="memItemLeft" align="right" valign="top"><a id="gac1877711503ba42fd9e2c55898b5a9cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>afw_stack_internal_set_evaluation_stack</b> (<a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="separator:gac1877711503ba42fd9e2c55898b5a9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adaptive Framework Stack. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad28df2a02ae8b5a71fe7a162fbab1ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad28df2a02ae8b5a71fe7a162fbab1ed0">&#9670;&nbsp;</a></span>afw_stack_copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_copy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__afw__stack.html#ga6f76dab2a110e15161c502e23fa8f22d">afw_stack_copy_impl</a>( &amp;((instance)-&gt;pub), count, ptr, p, scope)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of <a class="el" href="group__afw__common.html#ga05c22e7ba132794827d44dcacf956814" title="Define a struct for a stack with the specified entry type.">AFW_STACK_STRUCT()</a>. </td></tr>
    <tr><td class="paramname">count</td><td>is place to return count. </td></tr>
    <tr><td class="paramname">ptr</td><td>is place to return pointer to copy. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00104">104</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="gae0d7114d3fb2214d3c6767f53cdc82ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d7114d3fb2214d3c6767f53cdc82ec">&#9670;&nbsp;</a></span>afw_stack_copy_and_release</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_copy_and_release</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__afw__stack.html#gad28df2a02ae8b5a71fe7a162fbab1ed0">afw_stack_copy</a>(instance, (count), (<span class="keyword">const</span> <span class="keywordtype">void</span> ***)(ptr), (p), (scope)); \</div>
<div class="line">afw_stack_release(instance, (scope))</div>
<div class="ttc" id="agroup__afw__stack_html_gad28df2a02ae8b5a71fe7a162fbab1ed0"><div class="ttname"><a href="group__afw__stack.html#gad28df2a02ae8b5a71fe7a162fbab1ed0">afw_stack_copy</a></div><div class="ttdeci">#define afw_stack_copy(instance, count, ptr, p, scope)</div><div class="ttdoc">Copy stack.</div><div class="ttdef"><b>Definition:</b> <a href="afw__stack_8h_source.html#l00104">afw_stack.h:104</a></div></div>
</div><!-- fragment -->
<p>Copy and release stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of <a class="el" href="group__afw__common.html#ga05c22e7ba132794827d44dcacf956814" title="Define a struct for a stack with the specified entry type.">AFW_STACK_STRUCT()</a>. </td></tr>
    <tr><td class="paramname">count</td><td>is place to return count or NULL. </td></tr>
    <tr><td class="paramname">ptr</td><td>is place to return pointer to copy. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00135">135</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="ga6548628591d242de2ce382b9b4c4e9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6548628591d242de2ce382b9b4c4e9d5">&#9670;&nbsp;</a></span>afw_stack_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_count</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    ((instance)-&gt;top + 1 - (instance)-&gt;first))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of entries in stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance.</td><td></td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of entries. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00185">185</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="ga63563e7c497b2a71da2c4339a0951ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63563e7c497b2a71da2c4339a0951ce6">&#9670;&nbsp;</a></span>afw_stack_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_create</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typedef_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">initial_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maximum_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">create_subpool_pool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(typedef_name *)<a class="code" href="group__afw__stack.html#ga15aba79051ca01de2ffaaa1f6f22305a">afw_stack_create_impl</a>( \</div>
<div class="line">    <span class="keyword">sizeof</span>(*(((typedef_name *)0))-&gt;first), \</div>
<div class="line">    initial_count, maximum_count, create_subpool_pool, p, scope);</div>
<div class="ttc" id="agroup__afw__stack_html_ga15aba79051ca01de2ffaaa1f6f22305a"><div class="ttname"><a href="group__afw__stack.html#ga15aba79051ca01de2ffaaa1f6f22305a">afw_stack_create_impl</a></div><div class="ttdeci">afw_stack_t * afw_stack_create_impl(afw_size_t entry_size, afw_size_t initial_count, afw_size_t maximum_count, afw_boolean_t create_subpool_pool, const afw_pool_t *p, afw_scope_t *scope)</div><div class="ttdoc">Create a stack implementation.</div><div class="ttdef"><b>Definition:</b> <a href="afw__stack_8c_source.html#l00099">afw_stack.c:99</a></div></div>
</div><!-- fragment -->
<p>Create a stack for the specified typedef. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typedef_name</td><td>(See AFW_STACK_STRUCT macro in <a class="el" href="afw__common_8h.html" title="Adaptive Framework Common Header.">afw_common.h</a>) </td></tr>
    <tr><td class="paramname">initial_count</td><td></td></tr>
    <tr><td class="paramname">maximum_count</td><td>or 0 if no limit </td></tr>
    <tr><td class="paramname">create_subpool_pool</td><td>if true. </td></tr>
    <tr><td class="paramname">p</td><td>for stack </td></tr>
    <tr><td class="paramname">scope</td><td>of caller </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to created stack of type typedef_name *. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00044">44</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="ga989d368a878b7bfa182e565a3ddae4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989d368a878b7bfa182e565a3ddae4e4">&#9670;&nbsp;</a></span>afw_stack_is_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_is_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance</td><td>)</td>
          <td>&#160;&#160;&#160;    ((instance)-&gt;top &lt; (instance)-&gt;first)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine is a stack is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance.</td><td>stack-&gt;top will point to uninitialize storage. If needed the stack's extend will be called, so stack first and end may change after afw_stack_push*(). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00161">161</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="gaff3e9626e06f7c598e7dee98796c594f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff3e9626e06f7c598e7dee98796c594f">&#9670;&nbsp;</a></span>afw_stack_pop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_pop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">if</span> ((instance)-&gt;top &lt; ((instance)-&gt;first)) { \</div>
<div class="line">        AFW_THROW_ERROR_Z(general, <span class="stringliteral">&quot;stack underflow&quot;</span>, scope); \</div>
<div class="line">    } \</div>
<div class="line">    ((instance)-&gt;top)--;</div>
</div><!-- fragment -->
<p>Decrement stack-&gt;top to location of previous entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance.</td><td></td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>An error will be thrown on underflow. </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00172">172</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="gae56dadac86ddd565edf7484609655361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae56dadac86ddd565edf7484609655361">&#9670;&nbsp;</a></span>afw_stack_push</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_push</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((instance)-&gt;top)++; \</div>
<div class="line">    if ((instance)-&gt;top &gt;= ((instance)-&gt;end)) { \</div>
<div class="line">        afw_stack_extend_impl(&amp;((instance)-&gt;pub), scope); \</div>
<div class="line">    } \</div>
<div class="line">    *((instance)-&gt;top)</div>
</div><!-- fragment -->
<p>Increment stack-&gt;top to location of next entry and returns *top. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of <a class="el" href="group__afw__common.html#ga05c22e7ba132794827d44dcacf956814" title="Define a struct for a stack with the specified entry type.">AFW_STACK_STRUCT()</a>. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack-&gt;top.</dd></dl>
<p>stack-&gt;top will point to uninitialize storage. If needed the stack's extend will be called, so stack first and end may change after afw_stack_push*(). </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00199">199</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="ga45d48f070c6dc3548004c30b0628d868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d48f070c6dc3548004c30b0628d868">&#9670;&nbsp;</a></span>afw_stack_push_and_get_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_push_and_get_entry</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="group__afw__stack.html#ga149db6cb249215fa359cdb25c9b33627">afw_stack_push_direct</a>(instance, scope); \</div>
<div class="line">    entry = (instance)-&gt;top</div>
<div class="ttc" id="agroup__afw__stack_html_ga149db6cb249215fa359cdb25c9b33627"><div class="ttname"><a href="group__afw__stack.html#ga149db6cb249215fa359cdb25c9b33627">afw_stack_push_direct</a></div><div class="ttdeci">#define afw_stack_push_direct(instance, scope)</div><div class="ttdoc">Increment stack-&gt;top to location of next entry and returns top.</div><div class="ttdef"><b>Definition:</b> <a href="afw__stack_8h_source.html#l00217">afw_stack.h:217</a></div></div>
</div><!-- fragment -->
<p>Increment stack-&gt;top to location of next entry and get entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of <a class="el" href="group__afw__common.html#ga05c22e7ba132794827d44dcacf956814" title="Define a struct for a stack with the specified entry type.">AFW_STACK_STRUCT()</a>. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack-&gt;top.</dd></dl>
<p>stack-&gt;top will point to uninitialize storage. If needed the stack's extend will be called, so stack first and end may change after afw_stack_push*(). </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00234">234</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="ga149db6cb249215fa359cdb25c9b33627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga149db6cb249215fa359cdb25c9b33627">&#9670;&nbsp;</a></span>afw_stack_push_direct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_push_direct</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((instance)-&gt;top)++; \</div>
<div class="line">    if ((instance)-&gt;top &gt;= ((instance)-&gt;end)) { \</div>
<div class="line">        afw_stack_extend_impl(&amp;((instance)-&gt;pub), scope); \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Increment stack-&gt;top to location of next entry and returns top. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of <a class="el" href="group__afw__common.html#ga05c22e7ba132794827d44dcacf956814" title="Define a struct for a stack with the specified entry type.">AFW_STACK_STRUCT()</a>. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Don't count return. Use (instance)-&gt;top.</dd></dl>
<p>stack-&gt;top will point to uninitialize storage. If needed the stack's extend will be called, so stack first and end may change after afw_stack_push*(). </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00217">217</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="ga4961e4239e762c83423831370292736f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4961e4239e762c83423831370292736f">&#9670;&nbsp;</a></span>afw_stack_release</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_release</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__afw__stack.html#gaf041d115658dc79b98f9e578691d0768">afw_stack_release_impl</a>( &amp;((instance)-&gt;pub), scope)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release stack implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of <a class="el" href="group__afw__common.html#ga05c22e7ba132794827d44dcacf956814" title="Define a struct for a stack with the specified entry type.">AFW_STACK_STRUCT()</a>. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00079">79</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<a id="ga2945db55aa2cd5e61472d22bfd3a72f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2945db55aa2cd5e61472d22bfd3a72f2">&#9670;&nbsp;</a></span>afw_stack_set_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_stack_set_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance</td><td>)</td>
          <td>&#160;&#160;&#160;    (instance)-&gt;top = ((instance)-&gt;first) - 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment stack-&gt;top to location of next entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance.</td><td>stack-&gt;top will point to uninitialize storage. If needed the stack's extend will be called, so stack first and end may change after afw_stack_push*(). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="afw__stack_8h_source.html#l00247">247</a> of file <a class="el" href="afw__stack_8h_source.html">afw_stack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6f76dab2a110e15161c502e23fa8f22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f76dab2a110e15161c502e23fa8f22d">&#9670;&nbsp;</a></span>afw_stack_copy_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void afw_stack_copy_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a> *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void ***&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy stack implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td></td></tr>
    <tr><td class="paramname">count</td><td>is place to return count or NULL. </td></tr>
    <tr><td class="paramname">ptr</td><td>is place to return pointer to copy. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is normally called by macro <a class="el" href="group__afw__stack.html#gad28df2a02ae8b5a71fe7a162fbab1ed0" title="Copy stack.">afw_stack_copy()</a>. </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8c_source.html#l00148">148</a> of file <a class="el" href="afw__stack_8c_source.html">afw_stack.c</a>.</p>

</div>
</div>
<a id="ga15aba79051ca01de2ffaaa1f6f22305a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15aba79051ca01de2ffaaa1f6f22305a">&#9670;&nbsp;</a></span>afw_stack_create_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a>* afw_stack_create_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a>&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a>&#160;</td>
          <td class="paramname"><em>initial_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a>&#160;</td>
          <td class="paramname"><em>maximum_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#ga54967bd7180a4c18b5b3bed720c9c1f7">afw_boolean_t</a>&#160;</td>
          <td class="paramname"><em>create_subpool_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stack implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_size</td><td></td></tr>
    <tr><td class="paramname">initial_count</td><td></td></tr>
    <tr><td class="paramname">maximum_count</td><td>or 0 for no limit. </td></tr>
    <tr><td class="paramname">create_subpool_pool</td><td>if true. </td></tr>
    <tr><td class="paramname">p</td><td>for stack. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack</dd></dl>
<p>This is normally called by macro <a class="el" href="group__afw__stack.html#ga63563e7c497b2a71da2c4339a0951ce6" title="Create a stack for the specified typedef.">afw_stack_create()</a>. </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8c_source.html#l00099">99</a> of file <a class="el" href="afw__stack_8c_source.html">afw_stack.c</a>.</p>

</div>
</div>
<a id="ga11af063d667c3f352e6345aa0a67117f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11af063d667c3f352e6345aa0a67117f">&#9670;&nbsp;</a></span>afw_stack_extend_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void afw_stack_extend_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extend stack implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td></td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is normally called by a afw_stack_push*() macro. </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8c_source.html#l00176">176</a> of file <a class="el" href="afw__stack_8c_source.html">afw_stack.c</a>.</p>

</div>
</div>
<a id="gae2141f35f3d5febf6271b0072f995fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2141f35f3d5febf6271b0072f995fea">&#9670;&nbsp;</a></span>afw_stack_internal_set_qualifier_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_stack_internal_set_qualifier_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000327">Todo:</a></b></dt><dd>FIXME:</dd></dl>
<p>self-&gt;maximum_count should be able to be 0, but the entries are the full struct. When an expand happens, all of these structs are copied to another area so they have different addresses.</p>
<p>To allow this, all code must access these entries indirectly by using an index.</p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8c_source.html#l00031">31</a> of file <a class="el" href="afw__stack_8c_source.html">afw_stack.c</a>.</p>

</div>
</div>
<a id="gaf041d115658dc79b98f9e578691d0768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf041d115658dc79b98f9e578691d0768">&#9670;&nbsp;</a></span>afw_stack_release_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void afw_stack_release_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gade41fab9465632ce3a83f7794d48c497">afw_stack_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release stack implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td></td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is normally called by macro <a class="el" href="group__afw__stack.html#ga4961e4239e762c83423831370292736f" title="Release stack implementation.">afw_stack_release()</a>. </p>

<p class="definition">Definition at line <a class="el" href="afw__stack_8c_source.html#l00131">131</a> of file <a class="el" href="afw__stack_8c_source.html">afw_stack.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 4 2023 17:55:16 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
