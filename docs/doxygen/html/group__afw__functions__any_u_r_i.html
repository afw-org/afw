<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: anyURI functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">anyURI functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga490157bc9bd2b234ff24fa697ab71f31"><td class="memItemLeft" align="right" valign="top"><a id="ga490157bc9bd2b234ff24fa697ab71f31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga490157bc9bd2b234ff24fa697ab71f31">afw_function_definition_anyURI</a></td></tr>
<tr class="memdesc:ga490157bc9bd2b234ff24fa697ab71f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition anyURI. <br /></td></tr>
<tr class="separator:ga490157bc9bd2b234ff24fa697ab71f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac949747e4884920283cf0ac4cc6baac4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gac949747e4884920283cf0ac4cc6baac4">afw_function_definition_at_least_one_member_of_anyURI</a></td></tr>
<tr class="memdesc:gac949747e4884920283cf0ac4cc6baac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function anyURI.  <a href="group__afw__functions__any_u_r_i.html#gac949747e4884920283cf0ac4cc6baac4">More...</a><br /></td></tr>
<tr class="separator:gac949747e4884920283cf0ac4cc6baac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a14e9ec1ba7d669d12123984faa6cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gac2a14e9ec1ba7d669d12123984faa6cd">afw_function_definition_bag_anyURI</a></td></tr>
<tr class="memdesc:gac2a14e9ec1ba7d669d12123984faa6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function at_least_one_member_of&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gac2a14e9ec1ba7d669d12123984faa6cd">More...</a><br /></td></tr>
<tr class="separator:gac2a14e9ec1ba7d669d12123984faa6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16359ce96a868d132435a34d8273f460"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga16359ce96a868d132435a34d8273f460">afw_function_definition_bag_size_anyURI</a></td></tr>
<tr class="memdesc:ga16359ce96a868d132435a34d8273f460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga16359ce96a868d132435a34d8273f460">More...</a><br /></td></tr>
<tr class="separator:ga16359ce96a868d132435a34d8273f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1665c92c88220784573d4bb2b1351d65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga1665c92c88220784573d4bb2b1351d65">afw_function_definition_ends_with_anyURI</a></td></tr>
<tr class="memdesc:ga1665c92c88220784573d4bb2b1351d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag_size&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga1665c92c88220784573d4bb2b1351d65">More...</a><br /></td></tr>
<tr class="separator:ga1665c92c88220784573d4bb2b1351d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab549158f3fecfb67de15ea473fe52236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gab549158f3fecfb67de15ea473fe52236">afw_function_definition_eq_anyURI</a></td></tr>
<tr class="memdesc:gab549158f3fecfb67de15ea473fe52236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ends_with&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gab549158f3fecfb67de15ea473fe52236">More...</a><br /></td></tr>
<tr class="separator:gab549158f3fecfb67de15ea473fe52236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aeb54ac46cb50d324ae873d93777491"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga2aeb54ac46cb50d324ae873d93777491">afw_function_definition_eqx_anyURI</a></td></tr>
<tr class="memdesc:ga2aeb54ac46cb50d324ae873d93777491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eq&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga2aeb54ac46cb50d324ae873d93777491">More...</a><br /></td></tr>
<tr class="separator:ga2aeb54ac46cb50d324ae873d93777491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49469373228326d40c37f68b9c092a80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga49469373228326d40c37f68b9c092a80">afw_function_definition_ge_anyURI</a></td></tr>
<tr class="memdesc:ga49469373228326d40c37f68b9c092a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eqx&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga49469373228326d40c37f68b9c092a80">More...</a><br /></td></tr>
<tr class="separator:ga49469373228326d40c37f68b9c092a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e158a96f58ad5b4d08a3861f475cab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga1e158a96f58ad5b4d08a3861f475cab2">afw_function_definition_gt_anyURI</a></td></tr>
<tr class="memdesc:ga1e158a96f58ad5b4d08a3861f475cab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ge&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga1e158a96f58ad5b4d08a3861f475cab2">More...</a><br /></td></tr>
<tr class="separator:ga1e158a96f58ad5b4d08a3861f475cab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075ed7aea04f76ca73af43e084db0fe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga075ed7aea04f76ca73af43e084db0fe7">afw_function_definition_includes_anyURI</a></td></tr>
<tr class="memdesc:ga075ed7aea04f76ca73af43e084db0fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function gt&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga075ed7aea04f76ca73af43e084db0fe7">More...</a><br /></td></tr>
<tr class="separator:ga075ed7aea04f76ca73af43e084db0fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bfb85109d1d0c765817550a49787a30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga0bfb85109d1d0c765817550a49787a30">afw_function_definition_index_of_anyURI</a></td></tr>
<tr class="memdesc:ga0bfb85109d1d0c765817550a49787a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function includes&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga0bfb85109d1d0c765817550a49787a30">More...</a><br /></td></tr>
<tr class="separator:ga0bfb85109d1d0c765817550a49787a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b174c5099fb52efcc958d0b8339888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga84b174c5099fb52efcc958d0b8339888">afw_function_definition_intersection_anyURI</a></td></tr>
<tr class="memdesc:ga84b174c5099fb52efcc958d0b8339888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function index_of&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga84b174c5099fb52efcc958d0b8339888">More...</a><br /></td></tr>
<tr class="separator:ga84b174c5099fb52efcc958d0b8339888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5277b9e5e57bee8e8e5465b73c76845"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gae5277b9e5e57bee8e8e5465b73c76845">afw_function_definition_is_anyURI</a></td></tr>
<tr class="memdesc:gae5277b9e5e57bee8e8e5465b73c76845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function intersection&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gae5277b9e5e57bee8e8e5465b73c76845">More...</a><br /></td></tr>
<tr class="separator:gae5277b9e5e57bee8e8e5465b73c76845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66dc64c6f3a59099c9639c49d63097c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga66dc64c6f3a59099c9639c49d63097c2">afw_function_definition_is_in_anyURI</a></td></tr>
<tr class="memdesc:ga66dc64c6f3a59099c9639c49d63097c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga66dc64c6f3a59099c9639c49d63097c2">More...</a><br /></td></tr>
<tr class="separator:ga66dc64c6f3a59099c9639c49d63097c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5487c8052dcf87b740a7c4212d6550"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gadd5487c8052dcf87b740a7c4212d6550">afw_function_definition_last_index_of_anyURI</a></td></tr>
<tr class="memdesc:gadd5487c8052dcf87b740a7c4212d6550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is_in&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gadd5487c8052dcf87b740a7c4212d6550">More...</a><br /></td></tr>
<tr class="separator:gadd5487c8052dcf87b740a7c4212d6550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffaad16a904f83ef1de9dfd1858dd8ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gaffaad16a904f83ef1de9dfd1858dd8ee">afw_function_definition_le_anyURI</a></td></tr>
<tr class="memdesc:gaffaad16a904f83ef1de9dfd1858dd8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function last_index_of&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gaffaad16a904f83ef1de9dfd1858dd8ee">More...</a><br /></td></tr>
<tr class="separator:gaffaad16a904f83ef1de9dfd1858dd8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8967a990bfbd37ef1bfbecf28f37bccb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga8967a990bfbd37ef1bfbecf28f37bccb">afw_function_definition_length_anyURI</a></td></tr>
<tr class="memdesc:ga8967a990bfbd37ef1bfbecf28f37bccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function le&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga8967a990bfbd37ef1bfbecf28f37bccb">More...</a><br /></td></tr>
<tr class="separator:ga8967a990bfbd37ef1bfbecf28f37bccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea54ab79bb4e1c86c191e1018053dfdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gaea54ab79bb4e1c86c191e1018053dfdd">afw_function_definition_lt_anyURI</a></td></tr>
<tr class="memdesc:gaea54ab79bb4e1c86c191e1018053dfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function length&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gaea54ab79bb4e1c86c191e1018053dfdd">More...</a><br /></td></tr>
<tr class="separator:gaea54ab79bb4e1c86c191e1018053dfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646ad31177e63ec201062e4d45cee02a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga646ad31177e63ec201062e4d45cee02a">afw_function_definition_ne_anyURI</a></td></tr>
<tr class="memdesc:ga646ad31177e63ec201062e4d45cee02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function lt&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga646ad31177e63ec201062e4d45cee02a">More...</a><br /></td></tr>
<tr class="separator:ga646ad31177e63ec201062e4d45cee02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb3cbe113f6d2acc6d918334146665e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gacfb3cbe113f6d2acc6d918334146665e">afw_function_definition_nex_anyURI</a></td></tr>
<tr class="memdesc:gacfb3cbe113f6d2acc6d918334146665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ne&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gacfb3cbe113f6d2acc6d918334146665e">More...</a><br /></td></tr>
<tr class="separator:gacfb3cbe113f6d2acc6d918334146665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga170d6a1a0d3ae4db72c00a90977df420"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga170d6a1a0d3ae4db72c00a90977df420">afw_function_definition_one_and_only_anyURI</a></td></tr>
<tr class="memdesc:ga170d6a1a0d3ae4db72c00a90977df420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function nex&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga170d6a1a0d3ae4db72c00a90977df420">More...</a><br /></td></tr>
<tr class="separator:ga170d6a1a0d3ae4db72c00a90977df420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383bf326d09a440d55c4fce32484632a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga383bf326d09a440d55c4fce32484632a">afw_function_definition_regexp_index_of_anyURI</a></td></tr>
<tr class="memdesc:ga383bf326d09a440d55c4fce32484632a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function one_and_only&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga383bf326d09a440d55c4fce32484632a">More...</a><br /></td></tr>
<tr class="separator:ga383bf326d09a440d55c4fce32484632a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0682e9099717767a83d0834683a7cb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gac0682e9099717767a83d0834683a7cb6">afw_function_definition_regexp_match_anyURI</a></td></tr>
<tr class="memdesc:gac0682e9099717767a83d0834683a7cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function regexp_index_of&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gac0682e9099717767a83d0834683a7cb6">More...</a><br /></td></tr>
<tr class="separator:gac0682e9099717767a83d0834683a7cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279377b54916207897ab26bfcdc9473e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga279377b54916207897ab26bfcdc9473e">afw_function_definition_regexp_replace_anyURI</a></td></tr>
<tr class="memdesc:ga279377b54916207897ab26bfcdc9473e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function regexp_match&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga279377b54916207897ab26bfcdc9473e">More...</a><br /></td></tr>
<tr class="separator:ga279377b54916207897ab26bfcdc9473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f140a11ce3d7f442a87769b3ba92358"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga8f140a11ce3d7f442a87769b3ba92358">afw_function_definition_repeat_anyURI</a></td></tr>
<tr class="memdesc:ga8f140a11ce3d7f442a87769b3ba92358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function regexp_replace&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga8f140a11ce3d7f442a87769b3ba92358">More...</a><br /></td></tr>
<tr class="separator:ga8f140a11ce3d7f442a87769b3ba92358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707abddfe4c4a44569a9d1252e1ac1ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga707abddfe4c4a44569a9d1252e1ac1ee">afw_function_definition_replace_anyURI</a></td></tr>
<tr class="memdesc:ga707abddfe4c4a44569a9d1252e1ac1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function repeat&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga707abddfe4c4a44569a9d1252e1ac1ee">More...</a><br /></td></tr>
<tr class="separator:ga707abddfe4c4a44569a9d1252e1ac1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801e712588223359e4aecf78b61c445f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga801e712588223359e4aecf78b61c445f">afw_function_definition_set_equals_anyURI</a></td></tr>
<tr class="memdesc:ga801e712588223359e4aecf78b61c445f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function replace&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga801e712588223359e4aecf78b61c445f">More...</a><br /></td></tr>
<tr class="separator:ga801e712588223359e4aecf78b61c445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8498d0fe5294b0637023b06be34bdb55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga8498d0fe5294b0637023b06be34bdb55">afw_function_definition_split_anyURI</a></td></tr>
<tr class="memdesc:ga8498d0fe5294b0637023b06be34bdb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function set_equals&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga8498d0fe5294b0637023b06be34bdb55">More...</a><br /></td></tr>
<tr class="separator:ga8498d0fe5294b0637023b06be34bdb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac132c59dab0226dba15a389f06a3e48b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gac132c59dab0226dba15a389f06a3e48b">afw_function_definition_starts_with_anyURI</a></td></tr>
<tr class="memdesc:gac132c59dab0226dba15a389f06a3e48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function split&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gac132c59dab0226dba15a389f06a3e48b">More...</a><br /></td></tr>
<tr class="separator:gac132c59dab0226dba15a389f06a3e48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c3837ff78a533c6b3f5e8b97efc7a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#ga98c3837ff78a533c6b3f5e8b97efc7a3">afw_function_definition_subset_anyURI</a></td></tr>
<tr class="memdesc:ga98c3837ff78a533c6b3f5e8b97efc7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function starts_with&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#ga98c3837ff78a533c6b3f5e8b97efc7a3">More...</a><br /></td></tr>
<tr class="separator:ga98c3837ff78a533c6b3f5e8b97efc7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba08992f7dc732605726d7e72c6b3ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gadba08992f7dc732605726d7e72c6b3ee">afw_function_definition_substring_anyURI</a></td></tr>
<tr class="memdesc:gadba08992f7dc732605726d7e72c6b3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function subset&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gadba08992f7dc732605726d7e72c6b3ee">More...</a><br /></td></tr>
<tr class="separator:gadba08992f7dc732605726d7e72c6b3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c66992e47e758f6507ef956a6200db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gaf0c66992e47e758f6507ef956a6200db">afw_function_definition_to_string_anyURI</a></td></tr>
<tr class="memdesc:gaf0c66992e47e758f6507ef956a6200db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function substring&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gaf0c66992e47e758f6507ef956a6200db">More...</a><br /></td></tr>
<tr class="separator:gaf0c66992e47e758f6507ef956a6200db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39960c519eafe435a63d8952ca3b323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gad39960c519eafe435a63d8952ca3b323">afw_function_definition_union_anyURI</a></td></tr>
<tr class="memdesc:gad39960c519eafe435a63d8952ca3b323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function to_string&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gad39960c519eafe435a63d8952ca3b323">More...</a><br /></td></tr>
<tr class="separator:gad39960c519eafe435a63d8952ca3b323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9923ef66d33dfc161962efedd0415d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__any_u_r_i.html#gabd9923ef66d33dfc161962efedd0415d">afw_function_definition_url_encode_anyURI</a></td></tr>
<tr class="memdesc:gabd9923ef66d33dfc161962efedd0415d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function union&lt;anyURI&gt;  <a href="group__afw__functions__any_u_r_i.html#gabd9923ef66d33dfc161962efedd0415d">More...</a><br /></td></tr>
<tr class="separator:gabd9923ef66d33dfc161962efedd0415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>anyURI adaptive functions. </p>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gac949747e4884920283cf0ac4cc6baac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac949747e4884920283cf0ac4cc6baac4">&#9670;&nbsp;</a></span>afw_function_definition_at_least_one_member_of_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_at_least_one_member_of_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function anyURI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts value to data type anyURI returning anyURI result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function anyURI( value: any ): anyURI;</p>
<p>Parameters:</p>
<p>value - (any dataType) Value to convert.</p>
<p>Returns:</p>
<p>(anyURI) Converted value.</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>Function definition at_least_one_member_of&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02124">2124</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gac2a14e9ec1ba7d669d12123984faa6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a14e9ec1ba7d669d12123984faa6cd">&#9670;&nbsp;</a></span>afw_function_definition_bag_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function at_least_one_member_of&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if at least one value in anyURI list1 is in anyURI list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function at_least_one_member_of&lt;anyURI&gt;( list1: (list anyURI), list2: (list anyURI) ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list anyURI) The first list.</p>
<p>list2 - (list anyURI) The second list.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaa5adc6433af8f5dcab16f7bd1f0643e3" title="Function implementation function AFW_FUNCTION_EXECUTE_STANDARD_POLYMORPHIC_FUNCTION_HANDLING.">afw_function_execute_at_least_one_member_of()</a></p>
<hr  />
<p>Function definition bag&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02164">2164</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga16359ce96a868d132435a34d8273f460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16359ce96a868d132435a34d8273f460">&#9670;&nbsp;</a></span>afw_function_definition_bag_size_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag_size_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes any number of anyURI values and returns a list of list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function bag&lt;anyURI&gt;( ...values: (list of (list anyURI)) ): (list anyURI);</p>
<p>Parameters:</p>
<p>values - (0 or more list anyURI)</p>
<p>Returns:</p>
<p>(list anyURI)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga39c1a41a0d8363c8d5ceae7a6d65489a" title="Function implementation function afw_function_execute_bag.">afw_function_execute_bag()</a></p>
<hr  />
<p>Function definition bag_size&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02200">2200</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga1665c92c88220784573d4bb2b1351d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1665c92c88220784573d4bb2b1351d65">&#9670;&nbsp;</a></span>afw_function_definition_ends_with_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ends_with_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag_size&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the integer number of values in list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function bag_size&lt;anyURI&gt;( value: (list anyURI) ): integer;</p>
<p>Parameters:</p>
<p>value - (list anyURI)</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gae78d6ef2506492c58f64e35f7ec84fff" title="Function implementation function afw_function_execute_bag_size.">afw_function_execute_bag_size()</a></p>
<hr  />
<p>Function definition ends_with&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02236">2236</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gab549158f3fecfb67de15ea473fe52236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab549158f3fecfb67de15ea473fe52236">&#9670;&nbsp;</a></span>afw_function_definition_eq_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eq_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ends_with&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether anyURI value ends with a anyURI and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ends_with&lt;anyURI&gt;( value: anyURI, subString: string ): boolean;</p>
<p>Parameters:</p>
<p>value - (anyURI)</p>
<p>subString - (string)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga4f813e63893268c520e7b358c486a26b" title="Function implementation function afw_function_execute_ends_with.">afw_function_execute_ends_with()</a></p>
<hr  />
<p>Function definition eq&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02276">2276</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga2aeb54ac46cb50d324ae873d93777491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aeb54ac46cb50d324ae873d93777491">&#9670;&nbsp;</a></span>afw_function_definition_eqx_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eqx_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eq&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if anyURI arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "eqx" ("===") instead if you want false to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function eq&lt;anyURI&gt;( arg1: anyURI, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga4b5f63dcfd77b17d064ce733ffde1b04" title="Function implementation function afw_function_execute_eq.">afw_function_execute_eq()</a></p>
<hr  />
<p>Function definition eqx&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02321">2321</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga49469373228326d40c37f68b9c092a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49469373228326d40c37f68b9c092a80">&#9670;&nbsp;</a></span>afw_function_definition_ge_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ge_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eqx&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for anyURI arg1 is equal to the value and data type of arg2 then return the boolean result. Use "eq" ("==") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function eqx&lt;anyURI&gt;( arg1: anyURI, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga8038bd01243984b8b135337e768925f5" title="Function implementation function afw_function_execute_eqx.">afw_function_execute_eqx()</a></p>
<hr  />
<p>Function definition ge&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02362">2362</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga1e158a96f58ad5b4d08a3861f475cab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e158a96f58ad5b4d08a3861f475cab2">&#9670;&nbsp;</a></span>afw_function_definition_gt_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_gt_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ge&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for anyURI arg1 is greater than or equal to anyURI arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ge&lt;anyURI&gt;( arg1: anyURI, arg2: anyURI ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (anyURI)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga2c6ce9c296190c183129fe801999fb85" title="Function implementation function afw_function_execute_ge.">afw_function_execute_ge()</a></p>
<hr  />
<p>Function definition gt&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02402">2402</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga075ed7aea04f76ca73af43e084db0fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga075ed7aea04f76ca73af43e084db0fe7">&#9670;&nbsp;</a></span>afw_function_definition_includes_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_includes_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function gt&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for anyURI arg1 is greater than anyURI arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function gt&lt;anyURI&gt;( arg1: anyURI, arg2: anyURI ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (anyURI)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf8fcfd20e0990c533eaf3a75189f28c5" title="Function implementation function afw_function_execute_gt.">afw_function_execute_gt()</a></p>
<hr  />
<p>Function definition includes&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02442">2442</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga0bfb85109d1d0c765817550a49787a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bfb85109d1d0c765817550a49787a30">&#9670;&nbsp;</a></span>afw_function_definition_index_of_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_index_of_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function includes&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether the anyURI value includes a string and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function includes&lt;anyURI&gt;( searchString: anyURI, subString: string, position?: integer ): boolean;</p>
<p>Parameters:</p>
<p>searchString - (anyURI) The anyURI to search.</p>
<p>subString - (string) Substring to find.</p>
<p>position - (optional integer) Zero-based position in the search string to start search.</p>
<p>Returns:</p>
<p>(boolean) Indicates if the substring is contained in the search string.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga3d2fd176d71da59fa6d8b01c772ce72d" title="Function implementation function afw_function_execute_includes.">afw_function_execute_includes()</a></p>
<hr  />
<p>Function definition index_of&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02486">2486</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga84b174c5099fb52efcc958d0b8339888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84b174c5099fb52efcc958d0b8339888">&#9670;&nbsp;</a></span>afw_function_definition_intersection_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_intersection_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function index_of&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the zero-based index into anyURI value of subString. If subString is not found, -1 is returned.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function index_of&lt;anyURI&gt;( value: anyURI, subString: string, startIndex?: integer ): integer;</p>
<p>Parameters:</p>
<p>value - (anyURI) The anyURI value to search.</p>
<p>subString - (string) Substring to search for.</p>
<p>startIndex - (optional integer) Optional start index for search if different than start of string.</p>
<p>Returns:</p>
<p>(integer) Zero-based index of subString or -1 if not found.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga40556ded6877eff9392160024c428008" title="Function implementation function afw_function_execute_index_of.">afw_function_execute_index_of()</a></p>
<hr  />
<p>Function definition intersection&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02530">2530</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gae5277b9e5e57bee8e8e5465b73c76845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5277b9e5e57bee8e8e5465b73c76845">&#9670;&nbsp;</a></span>afw_function_definition_is_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_is_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function intersection&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of anyURI with the values that are common to both list of anyURI list1 and list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function intersection&lt;anyURI&gt;( list1: (list anyURI), list2: (list anyURI) ): (list anyURI);</p>
<p>Parameters:</p>
<p>list1 - (list anyURI) The first list.</p>
<p>list2 - (list anyURI) The second list.</p>
<p>Returns:</p>
<p>(list anyURI)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga65a6458f6f7ab91c8cdba95450fab2ea" title="Function implementation function afw_function_execute_intersection.">afw_function_execute_intersection()</a></p>
<hr  />
<p>Function definition is&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02570">2570</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga66dc64c6f3a59099c9639c49d63097c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66dc64c6f3a59099c9639c49d63097c2">&#9670;&nbsp;</a></span>afw_function_definition_is_in_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_is_in_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether value is dataType anyURI and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function is&lt;anyURI&gt;( value: any ): boolean;</p>
<p>Parameters:</p>
<p>value - (any dataType) Value to check.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga592ff430af3e6f20df8c7c7014da60d6" title="Function implementation function afw_function_execute_is.">afw_function_execute_is()</a></p>
<hr  />
<p>Function definition is_in&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02606">2606</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gadd5487c8052dcf87b740a7c4212d6550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd5487c8052dcf87b740a7c4212d6550">&#9670;&nbsp;</a></span>afw_function_definition_last_index_of_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_last_index_of_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is_in&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether anyURI value is in list of anyURI list and returns the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function is_in&lt;anyURI&gt;( value: anyURI, list: (list anyURI) ): boolean;</p>
<p>Parameters:</p>
<p>value - (anyURI)</p>
<p>list - (list anyURI)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga2c9f39702d570243e4e336709089a4ae" title="Function implementation function afw_function_execute_is_in.">afw_function_execute_is_in()</a></p>
<hr  />
<p>Function definition last_index_of&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02646">2646</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaffaad16a904f83ef1de9dfd1858dd8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffaad16a904f83ef1de9dfd1858dd8ee">&#9670;&nbsp;</a></span>afw_function_definition_le_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_le_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function last_index_of&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the zero-based index into anyURI value of the last occurrence of a subString. If subString is not found, -1 is returned.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function last_index_of&lt;anyURI&gt;( value: anyURI, subString: string, startIndex?: integer ): integer;</p>
<p>Parameters:</p>
<p>value - (anyURI) The anyURI value to search.</p>
<p>subString - (string) Substring to search for.</p>
<p>startIndex - (optional integer) Optional start index for search if different than start of string.</p>
<p>Returns:</p>
<p>(integer) Zero-based index of subString or -1 if not found.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaa01de0a1069bd5230563cb17922c4687" title="Function implementation function afw_function_execute_last_index_of.">afw_function_execute_last_index_of()</a></p>
<hr  />
<p>Function definition le&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02690">2690</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga8967a990bfbd37ef1bfbecf28f37bccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8967a990bfbd37ef1bfbecf28f37bccb">&#9670;&nbsp;</a></span>afw_function_definition_length_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_length_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function le&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for anyURI arg1 is less than or equal to anyURI arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function le&lt;anyURI&gt;( arg1: anyURI, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gab0b76d3bc6ee064c67c3bea1dda7989d" title="Function implementation function afw_function_execute_le.">afw_function_execute_le()</a></p>
<hr  />
<p>Function definition length&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02730">2730</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaea54ab79bb4e1c86c191e1018053dfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea54ab79bb4e1c86c191e1018053dfdd">&#9670;&nbsp;</a></span>afw_function_definition_lt_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_lt_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function length&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a polymorphic function where anyURI can be any of the supported data types. Return the integer number of entries in datatype list or codepoints in others.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function length&lt;anyURI&gt;( value: anyURI ): integer;</p>
<p>Parameters:</p>
<p>value - (anyURI) Returns the number of entries in a list or code points in others.</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaa1e4913ec9825d6381c5598f489c6a2e" title="Function implementation function afw_function_execute_length.">afw_function_execute_length()</a></p>
<hr  />
<p>Function definition lt&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02769">2769</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga646ad31177e63ec201062e4d45cee02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga646ad31177e63ec201062e4d45cee02a">&#9670;&nbsp;</a></span>afw_function_definition_ne_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ne_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function lt&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for anyURI arg1 is less that anyURI arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function lt&lt;anyURI&gt;( arg1: anyURI, arg2: anyURI ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (anyURI)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gafa22bf341d641f266c31a32ceeb256a6" title="Function implementation function afw_function_execute_lt.">afw_function_execute_lt()</a></p>
<hr  />
<p>Function definition ne&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02809">2809</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gacfb3cbe113f6d2acc6d918334146665e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfb3cbe113f6d2acc6d918334146665e">&#9670;&nbsp;</a></span>afw_function_definition_nex_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_nex_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ne&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if anyURI arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "nex" ("!==") instead if you want true to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ne&lt;anyURI&gt;( arg1: anyURI, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf144f30dc392293fb1eb3058a00f3093" title="Function implementation function afw_function_execute_ne.">afw_function_execute_ne()</a></p>
<hr  />
<p>Function definition nex&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02854">2854</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga170d6a1a0d3ae4db72c00a90977df420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga170d6a1a0d3ae4db72c00a90977df420">&#9670;&nbsp;</a></span>afw_function_definition_one_and_only_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_one_and_only_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function nex&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for anyURI arg1 is not equal to the value or data type of arg2 then return the boolean result. Use "ne" ("!=") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function nex&lt;anyURI&gt;( arg1: anyURI, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (anyURI)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga16fe2f777eb9e0a29ece94637d9c29ec" title="Function implementation function afw_function_execute_nex.">afw_function_execute_nex()</a></p>
<hr  />
<p>Function definition one_and_only&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02895">2895</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga383bf326d09a440d55c4fce32484632a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga383bf326d09a440d55c4fce32484632a">&#9670;&nbsp;</a></span>afw_function_definition_regexp_index_of_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_regexp_index_of_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function one_and_only&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This converts a list of anyURI values that contains one value to a single anyURI value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function one_and_only&lt;anyURI&gt;( list: (list list) ): anyURI;</p>
<p>Parameters:</p>
<p>list - (list list)</p>
<p>Returns:</p>
<p>(anyURI)</p>
<p>Errors thrown:</p>
<p>arg_error - list does not contain exactly one value</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gab84057f51b4e0e4a611b8a58fa434c52" title="Function implementation function afw_function_execute_one_and_only.">afw_function_execute_one_and_only()</a></p>
<hr  />
<p>Function definition regexp_index_of&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02936">2936</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gac0682e9099717767a83d0834683a7cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0682e9099717767a83d0834683a7cb6">&#9670;&nbsp;</a></span>afw_function_definition_regexp_match_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_regexp_match_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function regexp_index_of&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Search anyURI value for a regular expression and return index. If not found, -1 is returned.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function regexp_index_of&lt;anyURI&gt;( value: anyURI, regexp: string ): integer;</p>
<p>Parameters:</p>
<p>value - (anyURI) The anyURI value to search.</p>
<p>regexp - (string) A regular expression to use for search.</p>
<p>Returns:</p>
<p>(integer) Zero-based index of subString or -1 if not found.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga2b69682da3bec7298908cd7a0fbe7aa7" title="Function implementation function afw_function_execute_regexp_index_of.">afw_function_execute_regexp_index_of()</a></p>
<hr  />
<p>Function definition regexp_match&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l02976">2976</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga279377b54916207897ab26bfcdc9473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga279377b54916207897ab26bfcdc9473e">&#9670;&nbsp;</a></span>afw_function_definition_regexp_replace_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_regexp_replace_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function regexp_match&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether anyURI value matches the regular expression regexp and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function regexp_match&lt;anyURI&gt;( value: anyURI, regexp: string ): boolean;</p>
<p>Parameters:</p>
<p>value - (anyURI)</p>
<p>regexp - (string)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga6e043e5dbab1090b65e539cd0392b4be" title="Function implementation function afw_function_execute_regexp_match.">afw_function_execute_regexp_match()</a></p>
<hr  />
<p>Function definition regexp_replace&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03016">3016</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga8f140a11ce3d7f442a87769b3ba92358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f140a11ce3d7f442a87769b3ba92358">&#9670;&nbsp;</a></span>afw_function_definition_repeat_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_repeat_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function regexp_replace&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace matched values for a regular expression in a anyURI value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function regexp_replace&lt;anyURI&gt;( value: anyURI, regexp: string, replacement: string, limit?: integer ): anyURI;</p>
<p>Parameters:</p>
<p>value - (anyURI) The original anyURI value.</p>
<p>regexp - (string) A regular expression to use for search.</p>
<p>replacement - (string) The replacement string.</p>
<p>limit - (optional integer) This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences.</p>
<p>Returns:</p>
<p>(anyURI) A anyURI value with the matched string(s) replaced.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga966f3d922ac0fa0790206b4a19d189aa" title="Function implementation function afw_function_execute_regexp_replace.">afw_function_execute_regexp_replace()</a></p>
<hr  />
<p>Function definition repeat&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03062">3062</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga707abddfe4c4a44569a9d1252e1ac1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707abddfe4c4a44569a9d1252e1ac1ee">&#9670;&nbsp;</a></span>afw_function_definition_replace_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_replace_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function repeat&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Repeat a anyURI value a specified number of times.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function repeat&lt;anyURI&gt;( value: anyURI, times: integer ): anyURI;</p>
<p>Parameters:</p>
<p>value - (anyURI) The anyURI value to repeat.</p>
<p>times - (integer) The number of times to repeat the value.</p>
<p>Returns:</p>
<p>(anyURI) The repeated anyURI value.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gafa35e2168004c65e52f74eb0241a1a1c" title="Function implementation function afw_function_execute_repeat.">afw_function_execute_repeat()</a></p>
<hr  />
<p>Function definition replace&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03101">3101</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga801e712588223359e4aecf78b61c445f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga801e712588223359e4aecf78b61c445f">&#9670;&nbsp;</a></span>afw_function_definition_set_equals_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_set_equals_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function replace&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace string(s) in a anyURI value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function replace&lt;anyURI&gt;( value: anyURI, match: string, replacement: string, limit?: integer ): anyURI;</p>
<p>Parameters:</p>
<p>value - (anyURI) The original anyURI value.</p>
<p>match - (string) The string to replace.</p>
<p>replacement - (string) The replacement string.</p>
<p>limit - (optional integer) This is the maximum times to replace. The default is 1. Specify -1 to replace all occurrences.</p>
<p>Returns:</p>
<p>(anyURI) A anyURI value with the matched string(s) replaced.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga6fad981bb029ae0b1059eb50eb2c603b" title="Function implementation function afw_function_execute_replace.">afw_function_execute_replace()</a></p>
<hr  />
<p>Function definition set_equals&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03147">3147</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga8498d0fe5294b0637023b06be34bdb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8498d0fe5294b0637023b06be34bdb55">&#9670;&nbsp;</a></span>afw_function_definition_split_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_split_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function set_equals&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if anyURI list1 and anyURI list2 are subsets of each other and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function set_equals&lt;anyURI&gt;( list1: (list anyURI), list2: (list anyURI) ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list anyURI)</p>
<p>list2 - (list anyURI)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaced2918866ee8eac66cf2997522a88d6" title="Function implementation function afw_function_execute_set_equals.">afw_function_execute_set_equals()</a></p>
<hr  />
<p>Function definition split&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03187">3187</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gac132c59dab0226dba15a389f06a3e48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac132c59dab0226dba15a389f06a3e48b">&#9670;&nbsp;</a></span>afw_function_definition_starts_with_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_starts_with_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function split&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Split anyURI value into an list of strings using a separator.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function split&lt;anyURI&gt;( value: anyURI, separator?: string, limit?: integer ): list;</p>
<p>Parameters:</p>
<p>value - (anyURI) The anyURI value to split.</p>
<p>separator - (optional string) The separator to use. If this is an empty string or separator is not specified, the value is split between characters.</p>
<p>limit - (optional integer) This is the maximum number of splits. Any remaining part of value is ignored.</p>
<p>Returns:</p>
<p>(list) An list of strings.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga03f67cc392015c6009f25da7d8ec7b0b" title="Function implementation function afw_function_execute_split.">afw_function_execute_split()</a></p>
<hr  />
<p>Function definition starts_with&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03232">3232</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga98c3837ff78a533c6b3f5e8b97efc7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98c3837ff78a533c6b3f5e8b97efc7a3">&#9670;&nbsp;</a></span>afw_function_definition_subset_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_subset_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function starts_with&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether anyURI value starts with a subString and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function starts_with&lt;anyURI&gt;( value: anyURI, subString: string ): boolean;</p>
<p>Parameters:</p>
<p>value - (anyURI)</p>
<p>subString - (string)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga06ed56260527fee7d03d01daf96d3386" title="Function implementation function afw_function_execute_starts_with.">afw_function_execute_starts_with()</a></p>
<hr  />
<p>Function definition subset&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03272">3272</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gadba08992f7dc732605726d7e72c6b3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadba08992f7dc732605726d7e72c6b3ee">&#9670;&nbsp;</a></span>afw_function_definition_substring_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_substring_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function subset&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns boolean true if the unique values in anyURI list1 are all in anyURI list2.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function subset&lt;anyURI&gt;( list1: (list anyURI), list2: (list anyURI) ): boolean;</p>
<p>Parameters:</p>
<p>list1 - (list anyURI) The first list.</p>
<p>list2 - (list anyURI) The second list.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga5fd4ac9ed33f3c6d98d78f41eb824dcc" title="Function implementation function afw_function_execute_subset.">afw_function_execute_subset()</a></p>
<hr  />
<p>Function definition substring&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03312">3312</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaf0c66992e47e758f6507ef956a6200db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c66992e47e758f6507ef956a6200db">&#9670;&nbsp;</a></span>afw_function_definition_to_string_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_to_string_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function substring&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the anyURI substring of value beginning at zero-based position integer startIndex and ending at the position before integer endIndex. Specify -1 or omitting endIndex to return up to end of anyURI.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function substring&lt;anyURI&gt;( string: anyURI, startIndex: integer, endIndex?: integer ): anyURI;</p>
<p>Parameters:</p>
<p>string - (anyURI)</p>
<p>startIndex - (integer)</p>
<p>endIndex - (optional integer)</p>
<p>Returns:</p>
<p>(anyURI)</p>
<p>Errors thrown:</p>
<p>arg_error - startIndex or endIndex is out of range</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga23555acb984bd6bd1944b3f4393c2ba5" title="Function implementation function afw_function_execute_substring.">afw_function_execute_substring()</a></p>
<hr  />
<p>Function definition to_string&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03360">3360</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gad39960c519eafe435a63d8952ca3b323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad39960c519eafe435a63d8952ca3b323">&#9670;&nbsp;</a></span>afw_function_definition_union_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_union_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function to_string&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts anyURI value to string. For list values, the to_string() value for each entry is returned separated with commas.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function to_string&lt;anyURI&gt;( value: anyURI ): string;</p>
<p>Parameters:</p>
<p>value - (anyURI) A anyURI value.</p>
<p>Returns:</p>
<p>(string) The string representation of the value.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>Function definition union&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03397">3397</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gabd9923ef66d33dfc161962efedd0415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9923ef66d33dfc161962efedd0415d">&#9670;&nbsp;</a></span>afw_function_definition_url_encode_anyURI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_url_encode_anyURI</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function union&lt;anyURI&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of anyURI contains all of the unique values in two or more list of anyURI values.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function union&lt;anyURI&gt;( lists_1: (list anyURI), lists_2: (list anyURI), ...lists_rest: (list of (list anyURI)) ): (list anyURI);</p>
<p>Parameters:</p>
<p>lists - (2 or more list anyURI) Two or more lists.</p>
<p>Returns:</p>
<p>(list anyURI)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gac65fd70ccba4536ea9f74c17d5c86cd1" title="Function implementation function afw_function_execute_union.">afw_function_execute_union()</a></p>
<hr  />
<p>Function definition url_encode&lt;anyURI&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l03436">3436</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 8 2023 19:30:17 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
