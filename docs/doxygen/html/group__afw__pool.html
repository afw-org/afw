<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: Pool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Pool<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:afw__pool_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afw__pool_8h.html">afw_pool.h</a></td></tr>
<tr class="memdesc:afw__pool_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Framework memory pool support header. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afw__pool_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afw__pool_8h.html">afw_pool.h</a></td></tr>
<tr class="memdesc:afw__pool_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Framework memory pool support header. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afw__pool_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afw__pool_8h.html">afw_pool.h</a></td></tr>
<tr class="memdesc:afw__pool_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Framework memory pool support header. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structafw__pool__cleanup__s.html">afw_pool_cleanup_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for registered cleanup functions.  <a href="structafw__pool__cleanup__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structafw__pool__internal__multithreaded__self__s.html">afw_pool_internal_multithreaded_self_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structafw__pool__internal__singlethreaded__self__s.html">afw_pool_internal_singlethreaded_self_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structafw__thread__s.html">afw_thread_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for public part of afw_pool_t.  <a href="structafw__thread__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac5ec961b3b7e38f71487691c41f954b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gac5ec961b3b7e38f71487691c41f954b0">afw_pool_calloc_type</a>(instance,  type,  scope)&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#ga7366649ba5fa8667b16d35013707d0e1">afw_pool_calloc</a>(instance, sizeof(type), scope)</td></tr>
<tr class="memdesc:gac5ec961b3b7e38f71487691c41f954b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to allocate cleared memory to hold type in pool.  <a href="group__afw__pool.html#gac5ec961b3b7e38f71487691c41f954b0">More...</a><br /></td></tr>
<tr class="separator:gac5ec961b3b7e38f71487691c41f954b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93f5f6235ca5407acdbb1b034552943"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gaf93f5f6235ca5407acdbb1b034552943">afw_pool_malloc_type</a>(instance,  type,  scope)&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#ga27351730ba8a941f7f63f19067e7024b">afw_pool_malloc</a>(instance, sizeof(type), scope)</td></tr>
<tr class="memdesc:gaf93f5f6235ca5407acdbb1b034552943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to allocate uncleared memory to hold type in pool.  <a href="group__afw__pool.html#gaf93f5f6235ca5407acdbb1b034552943">More...</a><br /></td></tr>
<tr class="separator:gaf93f5f6235ca5407acdbb1b034552943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677a86b855e84ca4850d7bcd40628245"><td class="memItemLeft" align="right" valign="top"><a id="ga677a86b855e84ca4850d7bcd40628245"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga677a86b855e84ca4850d7bcd40628245">afw_thread_mutex_create</a>&#160;&#160;&#160;apr_thread_mutex_create</td></tr>
<tr class="memdesc:ga677a86b855e84ca4850d7bcd40628245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses apr_thread_mutex_t asis. <br /></td></tr>
<tr class="separator:ga677a86b855e84ca4850d7bcd40628245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a9dfc1b5c5fcacc7ded2fd460556d5"><td class="memItemLeft" align="right" valign="top"><a id="gac1a9dfc1b5c5fcacc7ded2fd460556d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gac1a9dfc1b5c5fcacc7ded2fd460556d5">afw_thread_mutex_lock</a>&#160;&#160;&#160;apr_thread_mutex_lock</td></tr>
<tr class="memdesc:gac1a9dfc1b5c5fcacc7ded2fd460556d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses apr_thread_mutex_t asis. <br /></td></tr>
<tr class="separator:gac1a9dfc1b5c5fcacc7ded2fd460556d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb585d9a7af159d62e6d5a83129bac5a"><td class="memItemLeft" align="right" valign="top"><a id="gafb585d9a7af159d62e6d5a83129bac5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gafb585d9a7af159d62e6d5a83129bac5a">afw_thread_mutex_trylock</a>&#160;&#160;&#160;apr_thread_mutex_trylock</td></tr>
<tr class="memdesc:gafb585d9a7af159d62e6d5a83129bac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses apr_thread_mutex_trylock asis. <br /></td></tr>
<tr class="separator:gafb585d9a7af159d62e6d5a83129bac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5564d25d26ed53b4662340528256d558"><td class="memItemLeft" align="right" valign="top"><a id="ga5564d25d26ed53b4662340528256d558"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga5564d25d26ed53b4662340528256d558">afw_thread_mutex_unlock</a>&#160;&#160;&#160;apr_thread_mutex_unlock</td></tr>
<tr class="memdesc:ga5564d25d26ed53b4662340528256d558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses apr_thread_mutex_unlock asis. <br /></td></tr>
<tr class="separator:ga5564d25d26ed53b4662340528256d558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b8903fd97358d4210d39e0372793fdc"><td class="memItemLeft" align="right" valign="top"><a id="ga1b8903fd97358d4210d39e0372793fdc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga1b8903fd97358d4210d39e0372793fdc">afw_thread_mutex_destroy</a>&#160;&#160;&#160;apr_thread_mutex_destroy</td></tr>
<tr class="memdesc:ga1b8903fd97358d4210d39e0372793fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses apr_thread_mutex_destroy asis. <br /></td></tr>
<tr class="separator:ga1b8903fd97358d4210d39e0372793fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553a439d96e400f35b8b0781fc6125c6"><td class="memItemLeft" align="right" valign="top"><a id="ga553a439d96e400f35b8b0781fc6125c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga553a439d96e400f35b8b0781fc6125c6">AFW_THREAD_FUNCTION</a>&#160;&#160;&#160;APR_THREAD_FUNC</td></tr>
<tr class="memdesc:ga553a439d96e400f35b8b0781fc6125c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses APR_THREAD_FUNC as AFW_THREAD_FUNCTION. <br /></td></tr>
<tr class="separator:ga553a439d96e400f35b8b0781fc6125c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d30af2f5a9d64026c401869c634c8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga24d30af2f5a9d64026c401869c634c8a">AFW_THREAD_MUTEX_LOCK</a>(mutex,  scope)</td></tr>
<tr class="memdesc:ga24d30af2f5a9d64026c401869c634c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to begin a mutex lock section.  <a href="group__afw__pool.html#ga24d30af2f5a9d64026c401869c634c8a">More...</a><br /></td></tr>
<tr class="separator:ga24d30af2f5a9d64026c401869c634c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a9b0a39fba68811fabd41a86d041f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga32a9b0a39fba68811fabd41a86d041f8">AFW_THREAD_MUTEX_UNLOCK</a>()</td></tr>
<tr class="memdesc:ga32a9b0a39fba68811fabd41a86d041f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to end a mutex lock.  <a href="group__afw__pool.html#ga32a9b0a39fba68811fabd41a86d041f8">More...</a><br /></td></tr>
<tr class="separator:ga32a9b0a39fba68811fabd41a86d041f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac89211f9dfda4a903d6a3b43c4d0bd51"><td class="memItemLeft" align="right" valign="top"><a id="gac89211f9dfda4a903d6a3b43c4d0bd51"></a>
typedef struct <a class="el" href="structafw__pool__cleanup__s.html">afw_pool_cleanup_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gac89211f9dfda4a903d6a3b43c4d0bd51">afw_pool_cleanup_t</a></td></tr>
<tr class="memdesc:gac89211f9dfda4a903d6a3b43c4d0bd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for registered cleanup functions. <br /></td></tr>
<tr class="separator:gac89211f9dfda4a903d6a3b43c4d0bd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee95c823e34fd0995ceb79958dd39d2"><td class="memItemLeft" align="right" valign="top"><a id="ga7ee95c823e34fd0995ceb79958dd39d2"></a>
typedef struct <a class="el" href="structafw__pool__internal__multithreaded__self__s.html">afw_pool_internal_multithreaded_self_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>afw_pool_internal_multithreaded_self_t</b></td></tr>
<tr class="separator:ga7ee95c823e34fd0995ceb79958dd39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5fbef9097d49f944fa0876661e8eed4"><td class="memItemLeft" align="right" valign="top"><a id="gad5fbef9097d49f944fa0876661e8eed4"></a>
typedef struct <a class="el" href="structafw__pool__internal__singlethreaded__self__s.html">afw_pool_internal_singlethreaded_self_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>afw_pool_internal_singlethreaded_self_t</b></td></tr>
<tr class="separator:gad5fbef9097d49f944fa0876661e8eed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d3dd1df68f32ce228618f414a7425b"><td class="memItemLeft" align="right" valign="top"><a id="ga29d3dd1df68f32ce228618f414a7425b"></a>
typedef void *(<a class="el" href="group__afw__pool.html#ga553a439d96e400f35b8b0781fc6125c6">AFW_THREAD_FUNCTION</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga29d3dd1df68f32ce228618f414a7425b">afw_thread_function_t</a>) (const <a class="el" href="group__afw__common.html#gafa9968786e5f8ebc37bada5fc3b82048">afw_thread_t</a> *thread, void *arg)</td></tr>
<tr class="memdesc:ga29d3dd1df68f32ce228618f414a7425b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for thread start function. <br /></td></tr>
<tr class="separator:ga29d3dd1df68f32ce228618f414a7425b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2dd196c68c25ef6688acd4508d871ce"><td class="memItemLeft" align="right" valign="top"><a id="gac2dd196c68c25ef6688acd4508d871ce"></a>
typedef struct afw_thread_attr_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gac2dd196c68c25ef6688acd4508d871ce">afw_thread_attr_t</a></td></tr>
<tr class="memdesc:gac2dd196c68c25ef6688acd4508d871ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for afw_thread_attr. <br /></td></tr>
<tr class="separator:gac2dd196c68c25ef6688acd4508d871ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga918447cc5ff654257393b4370c1f7641"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga918447cc5ff654257393b4370c1f7641">afw_pool_create</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:ga918447cc5ff654257393b4370c1f7641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new pool.  <a href="group__afw__pool.html#ga918447cc5ff654257393b4370c1f7641">More...</a><br /></td></tr>
<tr class="separator:ga918447cc5ff654257393b4370c1f7641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ecd44ab9769aa467bd0d4103eba950"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga42ecd44ab9769aa467bd0d4103eba950">afw_pool_create_debug</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope, const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *source_z)</td></tr>
<tr class="memdesc:ga42ecd44ab9769aa467bd0d4103eba950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug version of create a new pool.  <a href="group__afw__pool.html#ga42ecd44ab9769aa467bd0d4103eba950">More...</a><br /></td></tr>
<tr class="separator:ga42ecd44ab9769aa467bd0d4103eba950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71033fbf3daff951d7fe7b3058d718ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga71033fbf3daff951d7fe7b3058d718ff">afw_pool_create_multithreaded</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:ga71033fbf3daff951d7fe7b3058d718ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new multithreaded pool.  <a href="group__afw__pool.html#ga71033fbf3daff951d7fe7b3058d718ff">More...</a><br /></td></tr>
<tr class="separator:ga71033fbf3daff951d7fe7b3058d718ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac139193656fc148221bc63764d5d26fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gac139193656fc148221bc63764d5d26fa">afw_pool_create_multithreaded_debug</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope, const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *source_z)</td></tr>
<tr class="memdesc:gac139193656fc148221bc63764d5d26fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug version of create a new multithreaded pool.  <a href="group__afw__pool.html#gac139193656fc148221bc63764d5d26fa">More...</a><br /></td></tr>
<tr class="separator:gac139193656fc148221bc63764d5d26fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06dcb1035bcfc2c193b111cfa85c993"><td class="memItemLeft" align="right" valign="top"><a id="gaf06dcb1035bcfc2c193b111cfa85c993"></a>
const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>afw_pool_internal_create_base_pool</b> ()</td></tr>
<tr class="separator:gaf06dcb1035bcfc2c193b111cfa85c993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fae6e96ad5a37501945e623de301f76"><td class="memItemLeft" align="right" valign="top"><a id="ga3fae6e96ad5a37501945e623de301f76"></a>
<a class="el" href="group__afw__common.html#gafa9968786e5f8ebc37bada5fc3b82048">afw_thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>afw_pool_internal_create_thread</b> (<a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a> size, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="separator:ga3fae6e96ad5a37501945e623de301f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f62596c9f08fbc3ae359c7542e99ac"><td class="memItemLeft" align="right" valign="top"><a id="ga85f62596c9f08fbc3ae359c7542e99ac"></a>
<a class="el" href="group__afw__common.html#gafa9968786e5f8ebc37bada5fc3b82048">afw_thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>afw_pool_internal_create_thread_debug</b> (<a class="el" href="group__afw__common.html#gab55186af3197840e46bf41d88d0eb83b">afw_size_t</a> size, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope, const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *source_z)</td></tr>
<tr class="separator:ga85f62596c9f08fbc3ae359c7542e99ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab303906cc70998d119d4123152176e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__afw__common.html#gac2dd196c68c25ef6688acd4508d871ce">afw_thread_attr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gab303906cc70998d119d4123152176e49">afw_thread_attr_create</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *p, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:gab303906cc70998d119d4123152176e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread attr.  <a href="group__afw__pool.html#gab303906cc70998d119d4123152176e49">More...</a><br /></td></tr>
<tr class="separator:gab303906cc70998d119d4123152176e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb8ebf39d7ab906b2d4be56a4b66a27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__afw__common.html#gafa9968786e5f8ebc37bada5fc3b82048">afw_thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gafdb8ebf39d7ab906b2d4be56a4b66a27">afw_thread_create</a> (<a class="el" href="group__afw__common.html#gac2dd196c68c25ef6688acd4508d871ce">afw_thread_attr_t</a> *thread_attr, <a class="el" href="group__afw__pool.html#ga29d3dd1df68f32ce228618f414a7425b">afw_thread_function_t</a> start_function, void *start_function_arg, const <a class="el" href="group__afw__common.html#gae4a62c5bdbd11f4f86bf0f426f20434f">afw_utf8_t</a> *name, <a class="el" href="group__afw__common.html#gaf758b90e3fadf75b6264795b4f8a1e57">afw_integer_t</a> thread_number, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:gafdb8ebf39d7ab906b2d4be56a4b66a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread.  <a href="group__afw__pool.html#gafdb8ebf39d7ab906b2d4be56a4b66a27">More...</a><br /></td></tr>
<tr class="separator:gafdb8ebf39d7ab906b2d4be56a4b66a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga968205f9b276bb214c8239d482c5a5c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga968205f9b276bb214c8239d482c5a5c0">afw_thread_join</a> (const <a class="el" href="group__afw__common.html#gafa9968786e5f8ebc37bada5fc3b82048">afw_thread_t</a> *thread, <a class="el" href="structafw__scope__s.html">afw_scope_t</a> *scope)</td></tr>
<tr class="memdesc:ga968205f9b276bb214c8239d482c5a5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a thread.  <a href="group__afw__pool.html#ga968205f9b276bb214c8239d482c5a5c0">More...</a><br /></td></tr>
<tr class="separator:ga968205f9b276bb214c8239d482c5a5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Pool support </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac5ec961b3b7e38f71487691c41f954b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5ec961b3b7e38f71487691c41f954b0">&#9670;&nbsp;</a></span>afw_pool_calloc_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_pool_calloc_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#ga7366649ba5fa8667b16d35013707d0e1">afw_pool_calloc</a>(instance, sizeof(type), scope)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to allocate cleared memory to hold type in pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of pool. </td></tr>
    <tr><td class="paramname">type</td><td>to allocate. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory allocated cast to pointer of type.</dd></dl>
<p>This is a helper macro to call <a class="el" href="group__afw__pool__interface.html#ga7366649ba5fa8667b16d35013707d0e1" title="Call method calloc of interface afw_pool.">afw_pool_calloc()</a> to allocate memory for a specified type and cast the return pointer to a pointer to that type. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool_8h_source.html#l00170">170</a> of file <a class="el" href="afw__pool_8h_source.html">afw_pool.h</a>.</p>

</div>
</div>
<a id="gaf93f5f6235ca5407acdbb1b034552943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf93f5f6235ca5407acdbb1b034552943">&#9670;&nbsp;</a></span>afw_pool_malloc_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_pool_malloc_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#ga27351730ba8a941f7f63f19067e7024b">afw_pool_malloc</a>(instance, sizeof(type), scope)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to allocate uncleared memory to hold type in pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of pool. </td></tr>
    <tr><td class="paramname">type</td><td>to allocate. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory allocated cast to pointer of type.</dd></dl>
<p>This is a helper macro to call <a class="el" href="group__afw__pool__interface.html#ga27351730ba8a941f7f63f19067e7024b" title="Call method malloc of interface afw_pool.">afw_pool_malloc()</a> to allocate memory for a specified type and cast the return pointer to a pointer to that type. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool_8h_source.html#l00185">185</a> of file <a class="el" href="afw__pool_8h_source.html">afw_pool.h</a>.</p>

</div>
</div>
<a id="ga24d30af2f5a9d64026c401869c634c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24d30af2f5a9d64026c401869c634c8a">&#9670;&nbsp;</a></span>AFW_THREAD_MUTEX_LOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AFW_THREAD_MUTEX_LOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scope&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">    afw_thread_mutex_t *this_mutex; \</div>
<div class="line">    this_mutex = mutex; \</div>
<div class="line">    afw_thread_mutex_lock(mutex); \</div>
<div class="line">    AFW_TRY</div>
</div><!-- fragment -->
<p>Macro to begin a mutex lock section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage:</p>
<p><a class="el" href="group__afw__pool.html#ga24d30af2f5a9d64026c401869c634c8a" title="Macro to begin a mutex lock section.">AFW_THREAD_MUTEX_LOCK(scope)</a> { ... a very small amount of code that doesn't call anything } <a class="el" href="group__afw__pool.html#ga32a9b0a39fba68811fabd41a86d041f8" title="Macro to end a mutex lock.">AFW_THREAD_MUTEX_UNLOCK()</a>; </p>

<p class="definition">Definition at line <a class="el" href="afw__thread_8h_source.html#l00140">140</a> of file <a class="el" href="afw__thread_8h_source.html">afw_thread.h</a>.</p>

</div>
</div>
<a id="ga32a9b0a39fba68811fabd41a86d041f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32a9b0a39fba68811fabd41a86d041f8">&#9670;&nbsp;</a></span>AFW_THREAD_MUTEX_UNLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AFW_THREAD_MUTEX_UNLOCK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__afw__error.html#ga09be8438b41e77dd92a388cd3bc8073e">AFW_FINALLY</a> { \</div>
<div class="line">    afw_thread_mutex_unlock(this_mutex); \</div>
<div class="line">} \</div>
<div class="line">AFW_ENDTRY; \</div>
<div class="line">} <span class="keywordflow">while</span>(0)</div>
<div class="ttc" id="agroup__afw__error_html_ga09be8438b41e77dd92a388cd3bc8073e"><div class="ttname"><a href="group__afw__error.html#ga09be8438b41e77dd92a388cd3bc8073e">AFW_FINALLY</a></div><div class="ttdeci">#define AFW_FINALLY</div><div class="ttdoc">Always executed regardless of error.</div><div class="ttdef"><b>Definition:</b> <a href="afw__error_8h_source.html#l00706">afw_error.h:706</a></div></div>
</div><!-- fragment -->
<p>Macro to end a mutex lock. </p>
<p>See AFW_THREAD_MUTEX_LOCK for usage. </p>

<p class="definition">Definition at line <a class="el" href="afw__thread_8h_source.html#l00154">154</a> of file <a class="el" href="afw__thread_8h_source.html">afw_thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga918447cc5ff654257393b4370c1f7641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga918447cc5ff654257393b4370c1f7641">&#9670;&nbsp;</a></span>afw_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool.</dd></dl>
<p>A pool created with this function is either thread specific or a multithreaded pool depending on the parent.</p>
<p>If the parent is a thread specific pool, the created pool will also be thread specific. Thread specific pools are single threaded and no locking is allowed. If any of the pool functions are called from other than the specific thread, an error is thrown.</p>
<p>If the parent is a multithread pool, the created pool will also be a multithreaded pool. Calls to lock function will be directed to the nearest ancestor pool that was created with <a class="el" href="group__afw__pool.html#ga71033fbf3daff951d7fe7b3058d718ff" title="Create a new multithreaded pool.">afw_pool_create_multithreaded()</a> or the base pool for the environment. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool__singlethreaded_8c_source.html#l00159">159</a> of file <a class="el" href="afw__pool__singlethreaded_8c_source.html">afw_pool_singlethreaded.c</a>.</p>

</div>
</div>
<a id="ga42ecd44ab9769aa467bd0d4103eba950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ecd44ab9769aa467bd0d4103eba950">&#9670;&nbsp;</a></span>afw_pool_create_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create_debug </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *&#160;</td>
          <td class="paramname"><em>source_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug version of create a new pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
    <tr><td class="paramname">source_z</td><td><a href="file:line">file:line</a> where function called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__afw__pool.html#ga918447cc5ff654257393b4370c1f7641" title="Create a new pool.">afw_pool_create()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__pool__singlethreaded_8c_source.html#l00183">183</a> of file <a class="el" href="afw__pool__singlethreaded_8c_source.html">afw_pool_singlethreaded.c</a>.</p>

</div>
</div>
<a id="ga71033fbf3daff951d7fe7b3058d718ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71033fbf3daff951d7fe7b3058d718ff">&#9670;&nbsp;</a></span>afw_pool_create_multithreaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create_multithreaded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new multithreaded pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool or NULL. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool.</dd></dl>
<p>The parent specified must be a multithreaded pool. If NULL is specified, the base pool for the environment is used.</p>
<p>Use paired afw_pool_lock_read()/afw_pool_unlock_read() and afw_pool_lock_write()/afw_pool_unlock_write() as appropriate. Insure this happens using AFW_TRY/AFW_FINALLY.</p>
<p>For example:</p>
<p>afw_pool_lock_write(p); AFW_TRY { ... code that updates things in pool. AFW_CATCH_UNHANDLED { AFW_MARK_UNHANDLED; } AFW_FINALLY { afw_pool_unlock_write(p); } AFW_ENDTRY;</p>
<p>There are helper macros to do this. See:</p>
<p>AFW_POOL_LOCK_READ AFW_POOL_UNLOCK_READ AFW_POOL_LOCK_WRITE AFW_POOL_UNLOCK_WRITE</p>
<p>It is the responsibility of the caller to obtain locks before passing a pool as a parameter to a function unless clearly documented otherwise. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool__multithreaded_8c_source.html#l00197">197</a> of file <a class="el" href="afw__pool__multithreaded_8c_source.html">afw_pool_multithreaded.c</a>.</p>

</div>
</div>
<a id="gac139193656fc148221bc63764d5d26fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac139193656fc148221bc63764d5d26fa">&#9670;&nbsp;</a></span>afw_pool_create_multithreaded_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create_multithreaded_debug </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *&#160;</td>
          <td class="paramname"><em>source_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug version of create a new multithreaded pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool or NULL. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
    <tr><td class="paramname">source_z</td><td><a href="file:line">file:line</a> where function called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__afw__pool.html#ga71033fbf3daff951d7fe7b3058d718ff" title="Create a new multithreaded pool.">afw_pool_create_multithreaded()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__pool__multithreaded_8c_source.html#l00222">222</a> of file <a class="el" href="afw__pool__multithreaded_8c_source.html">afw_pool_multithreaded.c</a>.</p>

</div>
</div>
<a id="gab303906cc70998d119d4123152176e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab303906cc70998d119d4123152176e49">&#9670;&nbsp;</a></span>afw_thread_attr_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__afw__common.html#gac2dd196c68c25ef6688acd4508d871ce">afw_thread_attr_t</a>* afw_thread_attr_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread attr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>to use. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new thread attr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__thread_8c_source.html#l00019">19</a> of file <a class="el" href="afw__thread_8c_source.html">afw_thread.c</a>.</p>

</div>
</div>
<a id="gafdb8ebf39d7ab906b2d4be56a4b66a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb8ebf39d7ab906b2d4be56a4b66a27">&#9670;&nbsp;</a></span>afw_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__afw__common.html#gafa9968786e5f8ebc37bada5fc3b82048">afw_thread_t</a>* afw_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gac2dd196c68c25ef6688acd4508d871ce">afw_thread_attr_t</a> *&#160;</td>
          <td class="paramname"><em>thread_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__afw__pool.html#ga29d3dd1df68f32ce228618f414a7425b">afw_thread_function_t</a>&#160;</td>
          <td class="paramname"><em>start_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start_function_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__afw__common.html#gae4a62c5bdbd11f4f86bf0f426f20434f">afw_utf8_t</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gaf758b90e3fadf75b6264795b4f8a1e57">afw_integer_t</a>&#160;</td>
          <td class="paramname"><em>thread_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_attr</td><td>to use. </td></tr>
    <tr><td class="paramname">start_function</td><td>to call when thread starts. </td></tr>
    <tr><td class="paramname">start_function_arg</td><td>to pass to start function. </td></tr>
    <tr><td class="paramname">name</td><td>to be associated with thread. </td></tr>
    <tr><td class="paramname">thread_number</td><td>to be associated with thread. </td></tr>
    <tr><td class="paramname">p</td><td>to use. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new threadr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__thread_8c_source.html#l00041">41</a> of file <a class="el" href="afw__thread_8c_source.html">afw_thread.c</a>.</p>

</div>
</div>
<a id="ga968205f9b276bb214c8239d482c5a5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga968205f9b276bb214c8239d482c5a5c0">&#9670;&nbsp;</a></span>afw_thread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void afw_thread_join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__afw__common.html#gafa9968786e5f8ebc37bada5fc3b82048">afw_thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__scope__s.html">afw_scope_t</a> *&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>to join. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new threadr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__thread_8c_source.html#l00071">71</a> of file <a class="el" href="afw__thread_8c_source.html">afw_thread.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 4 2023 17:55:16 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
