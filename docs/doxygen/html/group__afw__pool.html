<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: Pool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Pool<div class="ingroups"><a class="el" href="group__package__afw.html">Adaptive Framework Base Package.</a> &raquo; <a class="el" href="group__afw__c__api__public.html">C API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:afw__pool_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afw__pool_8h.html">afw_pool.h</a></td></tr>
<tr class="memdesc:afw__pool_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Framework memory pool support header. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structafw__pool__cleanup__s.html">afw_pool_cleanup_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for registered cleanup functions.  <a href="structafw__pool__cleanup__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga028594c9632d440f3204a55a92b99429"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga028594c9632d440f3204a55a92b99429">afw_pool_calloc_type</a>(instance,  type,  xctx)&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#gaaa40790e9d86449a6e9b24ff15cfddd2">afw_pool_calloc</a>(instance, sizeof(type), xctx)</td></tr>
<tr class="memdesc:ga028594c9632d440f3204a55a92b99429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to allocate cleared memory to hold type in pool.  <a href="group__afw__pool.html#ga028594c9632d440f3204a55a92b99429">More...</a><br /></td></tr>
<tr class="separator:ga028594c9632d440f3204a55a92b99429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2cc387c478c65fedcc63b832b21dad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga6f2cc387c478c65fedcc63b832b21dad">afw_pool_malloc_type</a>(instance,  type,  xctx)&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#ga604ef68fc449df3641d092f20f8dc576">afw_pool_malloc</a>(instance, sizeof(type), xctx)</td></tr>
<tr class="memdesc:ga6f2cc387c478c65fedcc63b832b21dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to allocate uncleared memory to hold type in pool.  <a href="group__afw__pool.html#ga6f2cc387c478c65fedcc63b832b21dad">More...</a><br /></td></tr>
<tr class="separator:ga6f2cc387c478c65fedcc63b832b21dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac89211f9dfda4a903d6a3b43c4d0bd51"><td class="memItemLeft" align="right" valign="top"><a id="gac89211f9dfda4a903d6a3b43c4d0bd51"></a>
typedef struct <a class="el" href="structafw__pool__cleanup__s.html">afw_pool_cleanup_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gac89211f9dfda4a903d6a3b43c4d0bd51">afw_pool_cleanup_t</a></td></tr>
<tr class="memdesc:gac89211f9dfda4a903d6a3b43c4d0bd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for registered cleanup functions. <br /></td></tr>
<tr class="separator:gac89211f9dfda4a903d6a3b43c4d0bd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2c63deb23873d803babf840e74ca9e94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#ga2c63deb23873d803babf840e74ca9e94">afw_pool_create</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *xctx)</td></tr>
<tr class="memdesc:ga2c63deb23873d803babf840e74ca9e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new pool.  <a href="group__afw__pool.html#ga2c63deb23873d803babf840e74ca9e94">More...</a><br /></td></tr>
<tr class="separator:ga2c63deb23873d803babf840e74ca9e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff37cd2417b542182d22c2292bf4ca75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gaff37cd2417b542182d22c2292bf4ca75">afw_pool_create_debug</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *xctx, const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *source_z)</td></tr>
<tr class="memdesc:gaff37cd2417b542182d22c2292bf4ca75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug version of create a new pool.  <a href="group__afw__pool.html#gaff37cd2417b542182d22c2292bf4ca75">More...</a><br /></td></tr>
<tr class="separator:gaff37cd2417b542182d22c2292bf4ca75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8769aca2b11f289b5937797f7a320cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gae8769aca2b11f289b5937797f7a320cb">afw_pool_create_multithreaded</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *xctx)</td></tr>
<tr class="memdesc:gae8769aca2b11f289b5937797f7a320cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new multithreaded pool.  <a href="group__afw__pool.html#gae8769aca2b11f289b5937797f7a320cb">More...</a><br /></td></tr>
<tr class="separator:gae8769aca2b11f289b5937797f7a320cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf476546786dd563d0852571ad270ce83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__pool.html#gaf476546786dd563d0852571ad270ce83">afw_pool_create_multithreaded_debug</a> (const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *parent, <a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *xctx, const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *source_z)</td></tr>
<tr class="memdesc:gaf476546786dd563d0852571ad270ce83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug version of create a new multithreaded pool.  <a href="group__afw__pool.html#gaf476546786dd563d0852571ad270ce83">More...</a><br /></td></tr>
<tr class="separator:gaf476546786dd563d0852571ad270ce83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Pool support </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga028594c9632d440f3204a55a92b99429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga028594c9632d440f3204a55a92b99429">&#9670;&nbsp;</a></span>afw_pool_calloc_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_pool_calloc_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xctx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#gaaa40790e9d86449a6e9b24ff15cfddd2">afw_pool_calloc</a>(instance, sizeof(type), xctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to allocate cleared memory to hold type in pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of pool. </td></tr>
    <tr><td class="paramname">type</td><td>to allocate. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory allocated cast to pointer of type.</dd></dl>
<p>This is a helper macro to call <a class="el" href="group__afw__pool__interface.html#gaaa40790e9d86449a6e9b24ff15cfddd2" title="Call method calloc of interface afw_pool.">afw_pool_calloc()</a> to allocate memory for a specified type and cast the return pointer to a pointer to that type. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool_8h_source.html#l00167">167</a> of file <a class="el" href="afw__pool_8h_source.html">afw_pool.h</a>.</p>

</div>
</div>
<a id="ga6f2cc387c478c65fedcc63b832b21dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2cc387c478c65fedcc63b832b21dad">&#9670;&nbsp;</a></span>afw_pool_malloc_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define afw_pool_malloc_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xctx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (type *) <a class="el" href="group__afw__pool__interface.html#ga604ef68fc449df3641d092f20f8dc576">afw_pool_malloc</a>(instance, sizeof(type), xctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to allocate uncleared memory to hold type in pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>of pool. </td></tr>
    <tr><td class="paramname">type</td><td>to allocate. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory allocated cast to pointer of type.</dd></dl>
<p>This is a helper macro to call <a class="el" href="group__afw__pool__interface.html#ga604ef68fc449df3641d092f20f8dc576" title="Call method malloc of interface afw_pool.">afw_pool_malloc()</a> to allocate memory for a specified type and cast the return pointer to a pointer to that type. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool_8h_source.html#l00182">182</a> of file <a class="el" href="afw__pool_8h_source.html">afw_pool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2c63deb23873d803babf840e74ca9e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c63deb23873d803babf840e74ca9e94">&#9670;&nbsp;</a></span>afw_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *&#160;</td>
          <td class="paramname"><em>xctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool.</dd></dl>
<p>A pool created with this function is either thread specific or a multithreaded pool depending on the parent.</p>
<p>If the parent is a thread specific pool, the created pool will also be thread specific. Thread specific pools are single threaded and no locking is allowed. If any of the pool functions are called from other than the specific thread, an error is thrown.</p>
<p>If the parent is a multithread pool, the created pool will also be a multithreaded pool. Calls to lock function will be directed to the nearest ancestor pool that was created with <a class="el" href="group__afw__pool.html#gae8769aca2b11f289b5937797f7a320cb" title="Create a new multithreaded pool.">afw_pool_create_multithreaded()</a> or the base pool for the environment. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool__singlethreaded_8c_source.html#l00159">159</a> of file <a class="el" href="afw__pool__singlethreaded_8c_source.html">afw_pool_singlethreaded.c</a>.</p>

</div>
</div>
<a id="gaff37cd2417b542182d22c2292bf4ca75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff37cd2417b542182d22c2292bf4ca75">&#9670;&nbsp;</a></span>afw_pool_create_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create_debug </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *&#160;</td>
          <td class="paramname"><em>xctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *&#160;</td>
          <td class="paramname"><em>source_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug version of create a new pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller. </td></tr>
    <tr><td class="paramname">source_z</td><td><a href="file:line">file:line</a> where function called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__afw__pool.html#ga2c63deb23873d803babf840e74ca9e94" title="Create a new pool.">afw_pool_create()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__pool__singlethreaded_8c_source.html#l00183">183</a> of file <a class="el" href="afw__pool__singlethreaded_8c_source.html">afw_pool_singlethreaded.c</a>.</p>

</div>
</div>
<a id="gae8769aca2b11f289b5937797f7a320cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8769aca2b11f289b5937797f7a320cb">&#9670;&nbsp;</a></span>afw_pool_create_multithreaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create_multithreaded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *&#160;</td>
          <td class="paramname"><em>xctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new multithreaded pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool or NULL. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool.</dd></dl>
<p>The parent specified must be a multithreaded pool. If NULL is specified, the base pool for the environment is used.</p>
<p>Use paired afw_pool_lock_read()/afw_pool_unlock_read() and afw_pool_lock_write()/afw_pool_unlock_write() as appropriate. Insure this happens using AFW_TRY/AFW_FINALLY.</p>
<p>For example:</p>
<p>afw_pool_lock_write(p); AFW_TRY { ... code that updates things in pool. AFW_CATCH_UNHANDLED { AFW_MARK_UNHANDLED; } AFW_FINALLY { afw_pool_unlock_write(p); } AFW_ENDTRY;</p>
<p>There are helper macros to do this. See:</p>
<p>AFW_POOL_LOCK_READ AFW_POOL_UNLOCK_READ AFW_POOL_LOCK_WRITE AFW_POOL_UNLOCK_WRITE</p>
<p>It is the responsibility of the caller to obtain locks before passing a pool as a parameter to a function unless clearly documented otherwise. </p>

<p class="definition">Definition at line <a class="el" href="afw__pool__multithreaded_8c_source.html#l00197">197</a> of file <a class="el" href="afw__pool__multithreaded_8c_source.html">afw_pool_multithreaded.c</a>.</p>

</div>
</div>
<a id="gaf476546786dd563d0852571ad270ce83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf476546786dd563d0852571ad270ce83">&#9670;&nbsp;</a></span>afw_pool_create_multithreaded_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a>* afw_pool_create_multithreaded_debug </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structafw__pool__s.html">afw_pool_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafw__xctx__s.html">afw_xctx_t</a> *&#160;</td>
          <td class="paramname"><em>xctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__afw__common.html#ga9475c257219897def2828518dc3d42e9">afw_utf8_z_t</a> *&#160;</td>
          <td class="paramname"><em>source_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug version of create a new multithreaded pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>of new pool or NULL. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller. </td></tr>
    <tr><td class="paramname">source_z</td><td><a href="file:line">file:line</a> where function called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new pool. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__afw__pool.html#gae8769aca2b11f289b5937797f7a320cb" title="Create a new multithreaded pool.">afw_pool_create_multithreaded()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__pool__multithreaded_8c_source.html#l00222">222</a> of file <a class="el" href="afw__pool__multithreaded_8c_source.html">afw_pool_multithreaded.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2023 16:19:58 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
