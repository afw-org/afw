<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: list functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">list functions<div class="ingroups"><a class="el" href="group__package__afw.html">Adaptive Framework Base Package.</a> &raquo; <a class="el" href="group__afw__c__api__public.html">C API</a> &raquo; <a class="el" href="group__afw__c__api__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf8297bdf5909504858c344e497a313b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaaf8297bdf5909504858c344e497a313b">afw_function_execute_add_entries</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaaf8297bdf5909504858c344e497a313b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>add_entries</code>  <a href="group__afw__functions__list.html#gaaf8297bdf5909504858c344e497a313b">More...</a><br /></td></tr>
<tr class="separator:gaaf8297bdf5909504858c344e497a313b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab7e1d3b1157f8360889333551c7ce80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaab7e1d3b1157f8360889333551c7ce80">afw_function_execute_join</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaab7e1d3b1157f8360889333551c7ce80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>join</code>  <a href="group__afw__functions__list.html#gaab7e1d3b1157f8360889333551c7ce80">More...</a><br /></td></tr>
<tr class="separator:gaab7e1d3b1157f8360889333551c7ce80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8e5a51f71eddb6ab98bd07db191c53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaec8e5a51f71eddb6ab98bd07db191c53">afw_function_execute_list</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaec8e5a51f71eddb6ab98bd07db191c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>list</code>  <a href="group__afw__functions__list.html#gaec8e5a51f71eddb6ab98bd07db191c53">More...</a><br /></td></tr>
<tr class="separator:gaec8e5a51f71eddb6ab98bd07db191c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cfa3ad8b4a5b0f7792c50d67b4b0ff3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga2cfa3ad8b4a5b0f7792c50d67b4b0ff3">afw_function_execute_reverse</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga2cfa3ad8b4a5b0f7792c50d67b4b0ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>reverse</code>  <a href="group__afw__functions__list.html#ga2cfa3ad8b4a5b0f7792c50d67b4b0ff3">More...</a><br /></td></tr>
<tr class="separator:ga2cfa3ad8b4a5b0f7792c50d67b4b0ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f7f11c0c6540567c02ec421de7e9fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga33f7f11c0c6540567c02ec421de7e9fd">afw_function_execute_slice</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga33f7f11c0c6540567c02ec421de7e9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>slice</code>  <a href="group__afw__functions__list.html#ga33f7f11c0c6540567c02ec421de7e9fd">More...</a><br /></td></tr>
<tr class="separator:ga33f7f11c0c6540567c02ec421de7e9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae5d9bc96605b1c0a0cc79185691bf9d6"><td class="memItemLeft" align="right" valign="top"><a id="gae5d9bc96605b1c0a0cc79185691bf9d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gae5d9bc96605b1c0a0cc79185691bf9d6">afw_function_definition_add_entries</a></td></tr>
<tr class="memdesc:gae5d9bc96605b1c0a0cc79185691bf9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition add_entries. <br /></td></tr>
<tr class="separator:gae5d9bc96605b1c0a0cc79185691bf9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75cec47dfacd453afff374519012a0c"><td class="memItemLeft" align="right" valign="top"><a id="gab75cec47dfacd453afff374519012a0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gab75cec47dfacd453afff374519012a0c">afw_function_definition_bag_list</a></td></tr>
<tr class="memdesc:gab75cec47dfacd453afff374519012a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition bag&lt;list&gt; <br /></td></tr>
<tr class="separator:gab75cec47dfacd453afff374519012a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f5fc1bca0548108b147b56f31c1137c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga8f5fc1bca0548108b147b56f31c1137c">afw_function_definition_bag_size_list</a></td></tr>
<tr class="memdesc:ga8f5fc1bca0548108b147b56f31c1137c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>bag&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga8f5fc1bca0548108b147b56f31c1137c">More...</a><br /></td></tr>
<tr class="separator:ga8f5fc1bca0548108b147b56f31c1137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd7cd9af495fb9825793c4be9cfaf14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga6bd7cd9af495fb9825793c4be9cfaf14">afw_function_definition_clone_list</a></td></tr>
<tr class="memdesc:ga6bd7cd9af495fb9825793c4be9cfaf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>bag_size&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga6bd7cd9af495fb9825793c4be9cfaf14">More...</a><br /></td></tr>
<tr class="separator:ga6bd7cd9af495fb9825793c4be9cfaf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed846009e234754d9e4eb9da6457dac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaeed846009e234754d9e4eb9da6457dac">afw_function_definition_eq_list</a></td></tr>
<tr class="memdesc:gaeed846009e234754d9e4eb9da6457dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>clone&lt;list&gt;</code>  <a href="group__afw__functions__list.html#gaeed846009e234754d9e4eb9da6457dac">More...</a><br /></td></tr>
<tr class="separator:gaeed846009e234754d9e4eb9da6457dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18af81e01f9c7fd214365f034b17079"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gab18af81e01f9c7fd214365f034b17079">afw_function_definition_eqx_list</a></td></tr>
<tr class="memdesc:gab18af81e01f9c7fd214365f034b17079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>eq&lt;list&gt;</code>  <a href="group__afw__functions__list.html#gab18af81e01f9c7fd214365f034b17079">More...</a><br /></td></tr>
<tr class="separator:gab18af81e01f9c7fd214365f034b17079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a53d725f60820740f26640ba33aff4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga1a53d725f60820740f26640ba33aff4d">afw_function_definition_ge_list</a></td></tr>
<tr class="memdesc:ga1a53d725f60820740f26640ba33aff4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>eqx&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga1a53d725f60820740f26640ba33aff4d">More...</a><br /></td></tr>
<tr class="separator:ga1a53d725f60820740f26640ba33aff4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae045382ddce29a72d1aa4b71ef1232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga6ae045382ddce29a72d1aa4b71ef1232">afw_function_definition_gt_list</a></td></tr>
<tr class="memdesc:ga6ae045382ddce29a72d1aa4b71ef1232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>ge&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga6ae045382ddce29a72d1aa4b71ef1232">More...</a><br /></td></tr>
<tr class="separator:ga6ae045382ddce29a72d1aa4b71ef1232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd36959676cfae04e8e170b34715759"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaacd36959676cfae04e8e170b34715759">afw_function_definition_includes_list</a></td></tr>
<tr class="memdesc:gaacd36959676cfae04e8e170b34715759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>gt&lt;list&gt;</code>  <a href="group__afw__functions__list.html#gaacd36959676cfae04e8e170b34715759">More...</a><br /></td></tr>
<tr class="separator:gaacd36959676cfae04e8e170b34715759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7deac2d15dda99bf9d1e969d3fa23747"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga7deac2d15dda99bf9d1e969d3fa23747">afw_function_definition_is_list</a></td></tr>
<tr class="memdesc:ga7deac2d15dda99bf9d1e969d3fa23747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>includes&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga7deac2d15dda99bf9d1e969d3fa23747">More...</a><br /></td></tr>
<tr class="separator:ga7deac2d15dda99bf9d1e969d3fa23747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc9b2749d9588be1767301cb36f8db6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaccc9b2749d9588be1767301cb36f8db6">afw_function_definition_join</a></td></tr>
<tr class="memdesc:gaccc9b2749d9588be1767301cb36f8db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>is&lt;list&gt;</code>  <a href="group__afw__functions__list.html#gaccc9b2749d9588be1767301cb36f8db6">More...</a><br /></td></tr>
<tr class="separator:gaccc9b2749d9588be1767301cb36f8db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae733a7cca3cf9af64497cd456ef9820"><td class="memItemLeft" align="right" valign="top"><a id="gaae733a7cca3cf9af64497cd456ef9820"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaae733a7cca3cf9af64497cd456ef9820">afw_function_definition_le_list</a></td></tr>
<tr class="memdesc:gaae733a7cca3cf9af64497cd456ef9820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition le&lt;list&gt; <br /></td></tr>
<tr class="separator:gaae733a7cca3cf9af64497cd456ef9820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab781c092ddbf47550371eaf5fdf94630"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gab781c092ddbf47550371eaf5fdf94630">afw_function_definition_length_list</a></td></tr>
<tr class="memdesc:gab781c092ddbf47550371eaf5fdf94630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>le&lt;list&gt;</code>  <a href="group__afw__functions__list.html#gab781c092ddbf47550371eaf5fdf94630">More...</a><br /></td></tr>
<tr class="separator:gab781c092ddbf47550371eaf5fdf94630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531faf21bc5d866f4ba131b5180dd90f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga531faf21bc5d866f4ba131b5180dd90f">afw_function_definition_list</a></td></tr>
<tr class="memdesc:ga531faf21bc5d866f4ba131b5180dd90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>length&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga531faf21bc5d866f4ba131b5180dd90f">More...</a><br /></td></tr>
<tr class="separator:ga531faf21bc5d866f4ba131b5180dd90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57c5de9b95a72b90e1177883b3be437"><td class="memItemLeft" align="right" valign="top"><a id="gab57c5de9b95a72b90e1177883b3be437"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gab57c5de9b95a72b90e1177883b3be437">afw_function_definition_lt_list</a></td></tr>
<tr class="memdesc:gab57c5de9b95a72b90e1177883b3be437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition lt&lt;list&gt; <br /></td></tr>
<tr class="separator:gab57c5de9b95a72b90e1177883b3be437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5621fb27e98acdd7412896099007e959"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga5621fb27e98acdd7412896099007e959">afw_function_definition_ne_list</a></td></tr>
<tr class="memdesc:ga5621fb27e98acdd7412896099007e959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>lt&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga5621fb27e98acdd7412896099007e959">More...</a><br /></td></tr>
<tr class="separator:ga5621fb27e98acdd7412896099007e959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09c991ce385a7a878b080d330078ed7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaf09c991ce385a7a878b080d330078ed7">afw_function_definition_nex_list</a></td></tr>
<tr class="memdesc:gaf09c991ce385a7a878b080d330078ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>ne&lt;list&gt;</code>  <a href="group__afw__functions__list.html#gaf09c991ce385a7a878b080d330078ed7">More...</a><br /></td></tr>
<tr class="separator:gaf09c991ce385a7a878b080d330078ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b48dada4fb9162891f507de7e63c8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#ga15b48dada4fb9162891f507de7e63c8b">afw_function_definition_reverse</a></td></tr>
<tr class="memdesc:ga15b48dada4fb9162891f507de7e63c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function <code>nex&lt;list&gt;</code>  <a href="group__afw__functions__list.html#ga15b48dada4fb9162891f507de7e63c8b">More...</a><br /></td></tr>
<tr class="separator:ga15b48dada4fb9162891f507de7e63c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c2b672d0aa39ceeba0edcf17a2a06e"><td class="memItemLeft" align="right" valign="top"><a id="gaa6c2b672d0aa39ceeba0edcf17a2a06e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gaa6c2b672d0aa39ceeba0edcf17a2a06e">afw_function_definition_slice</a></td></tr>
<tr class="memdesc:gaa6c2b672d0aa39ceeba0edcf17a2a06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition slice. <br /></td></tr>
<tr class="separator:gaa6c2b672d0aa39ceeba0edcf17a2a06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53b9b435d8d3f6899d76db155199b56"><td class="memItemLeft" align="right" valign="top"><a id="gad53b9b435d8d3f6899d76db155199b56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__list.html#gad53b9b435d8d3f6899d76db155199b56">afw_function_definition_to_string_list</a></td></tr>
<tr class="memdesc:gad53b9b435d8d3f6899d76db155199b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition to_string&lt;list&gt; <br /></td></tr>
<tr class="separator:gad53b9b435d8d3f6899d76db155199b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>list adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf8297bdf5909504858c344e497a313b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8297bdf5909504858c344e497a313b">&#9670;&nbsp;</a></span>afw_function_execute_add_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_add_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>add_entries</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Add the entries of one or more lists to another.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> add_entries(</div>
<div class="line">    target: list,</div>
<div class="line">    source_1: list,</div>
<div class="line">    ...source_rest: (list of list)</div>
<div class="line">): list;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>target - (list) Target list. This list must not be immutable.</p>
<p>source - (1 or more list) Source list(s).</p>
<p>Returns:</p>
<p>(list) The modified target list. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__list_8c_source.html#l00051">51</a> of file <a class="el" href="afw__function__list_8c_source.html">afw_function_list.c</a>.</p>

</div>
</div>
<a id="gaab7e1d3b1157f8360889333551c7ce80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab7e1d3b1157f8360889333551c7ce80">&#9670;&nbsp;</a></span>afw_function_execute_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>join</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Concatenate the string values of the elements of a list with a separator.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> join(</div>
<div class="line">    value: list,</div>
<div class="line">    separator?: <span class="keywordtype">string</span></div>
<div class="line">): string;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (list) A list of values of any data type.</p>
<p>separator - (optional string) The separator to use. If not specified, a comma (,) is used.</p>
<p>Returns:</p>
<p>(string) Joined list values. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__list_8c_source.html#l00239">239</a> of file <a class="el" href="afw__function__list_8c_source.html">afw_function_list.c</a>.</p>

</div>
</div>
<a id="gaec8e5a51f71eddb6ab98bd07db191c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8e5a51f71eddb6ab98bd07db191c53">&#9670;&nbsp;</a></span>afw_function_execute_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>list</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts 1 or more values in a list. If A value is a list, its individual values are included.</p>
<p>If the data types of all values in the resulting list are the same, the list will be a list of that data type. Otherwise, the resulting list will be untyped.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> list(</div>
<div class="line">    ...values: (list of any)</div>
<div class="line">): list;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>values - (0 or more any dataType) Value to convert.</p>
<p>Returns:</p>
<p>(list) Converted value.</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted </p>

<p class="definition">Definition at line <a class="el" href="afw__function__list_8c_source.html#l00115">115</a> of file <a class="el" href="afw__function__list_8c_source.html">afw_function_list.c</a>.</p>

</div>
</div>
<a id="ga2cfa3ad8b4a5b0f7792c50d67b4b0ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cfa3ad8b4a5b0f7792c50d67b4b0ff3">&#9670;&nbsp;</a></span>afw_function_execute_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>reverse</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Reverse the order of the elements in a list. If the list is typed, the resulting list will be the same type.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> reverse(</div>
<div class="line">    list: list</div>
<div class="line">): list;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>list - (list) A list to reverse.</p>
<p>Returns:</p>
<p>(list) A list with elements reversed. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__list_8c_source.html#l00336">336</a> of file <a class="el" href="afw__function__list_8c_source.html">afw_function_list.c</a>.</p>

</div>
</div>
<a id="ga33f7f11c0c6540567c02ec421de7e9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f7f11c0c6540567c02ec421de7e9fd">&#9670;&nbsp;</a></span>afw_function_execute_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>slice</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function extracts a consecutive slice of values from a list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> slice(</div>
<div class="line">    list: list,</div>
<div class="line">    startIndex?: integer,</div>
<div class="line">    endIndex?: integer</div>
<div class="line">): list;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>list - (list) The list to slice.</p>
<p>startIndex - (optional integer) This is the zero based starting index. Use negative number to index from the end of the list. If not specified, an index of 0 is assumed.</p>
<p>endIndex - (optional integer) This is the zero based ending index. If positive, this is one more than the index of the last value to include in the list. If negative, the index is from the end of the list. If not specified, the slice is from startIndex up to and including the end of the list.</p>
<p>Returns:</p>
<p>(list) A list containing the selected values. If all of the values are the same data type, the list will be a list of that data type. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__list_8c_source.html#l00404">404</a> of file <a class="el" href="afw__function__list_8c_source.html">afw_function_list.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga8f5fc1bca0548108b147b56f31c1137c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f5fc1bca0548108b147b56f31c1137c">&#9670;&nbsp;</a></span>afw_function_definition_bag_size_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag_size_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>bag&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes any number of list values and returns a list of list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> bag&lt;list&gt;(</div>
<div class="line">    ...values: (list of (list list))</div>
<div class="line">): (list list);</div>
</div><!-- fragment --><p>Parameters:</p>
<p>values - (0 or more list list)</p>
<p>Returns:</p>
<p>(list list)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga39c1a41a0d8363c8d5ceae7a6d65489a" title="Function implementation function afw_function_execute_bag.">afw_function_execute_bag()</a></p>
<hr  />
<p>Function definition bag_size&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16128">16128</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga6bd7cd9af495fb9825793c4be9cfaf14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bd7cd9af495fb9825793c4be9cfaf14">&#9670;&nbsp;</a></span>afw_function_definition_clone_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_clone_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>bag_size&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the integer number of values in list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> bag_size&lt;list&gt;(</div>
<div class="line">    value: (list list)</div>
<div class="line">): integer;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (list list)</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gae78d6ef2506492c58f64e35f7ec84fff" title="Function implementation function afw_function_execute_bag_size.">afw_function_execute_bag_size()</a></p>
<hr  />
<p>Function definition clone&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16162">16162</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaeed846009e234754d9e4eb9da6457dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed846009e234754d9e4eb9da6457dac">&#9670;&nbsp;</a></span>afw_function_definition_eq_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eq_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>clone&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Deep clone a list value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> clone&lt;list&gt;(</div>
<div class="line">    value: list</div>
<div class="line">): list;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (list) The list value to clone.</p>
<p>Returns:</p>
<p>(list) The cloned list value.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga747834324ca50130f39a4c6f64f5411d" title="Function implementation function afw_function_execute_clone.">afw_function_execute_clone()</a></p>
<hr  />
<p>Function definition eq&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16196">16196</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gab18af81e01f9c7fd214365f034b17079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab18af81e01f9c7fd214365f034b17079">&#9670;&nbsp;</a></span>afw_function_definition_eqx_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eqx_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>eq&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if list arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "eqx" ("===") instead if you want false to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> eq&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: any</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga4b5f63dcfd77b17d064ce733ffde1b04" title="Function implementation function afw_function_execute_eq.">afw_function_execute_eq()</a></p>
<hr  />
<p>Function definition eqx&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16239">16239</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga1a53d725f60820740f26640ba33aff4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a53d725f60820740f26640ba33aff4d">&#9670;&nbsp;</a></span>afw_function_definition_ge_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ge_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>eqx&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for list arg1 is equal to the value and data type of arg2 then return the boolean result. Use "eq" ("==") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> eqx&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: any</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga8038bd01243984b8b135337e768925f5" title="Function implementation function afw_function_execute_eqx.">afw_function_execute_eqx()</a></p>
<hr  />
<p>Function definition ge&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16278">16278</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga6ae045382ddce29a72d1aa4b71ef1232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ae045382ddce29a72d1aa4b71ef1232">&#9670;&nbsp;</a></span>afw_function_definition_gt_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_gt_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>ge&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for list arg1 is greater than or equal to list arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> ge&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: list</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (list)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga2c6ce9c296190c183129fe801999fb85" title="Function implementation function afw_function_execute_ge.">afw_function_execute_ge()</a></p>
<hr  />
<p>Function definition gt&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16316">16316</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaacd36959676cfae04e8e170b34715759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacd36959676cfae04e8e170b34715759">&#9670;&nbsp;</a></span>afw_function_definition_includes_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_includes_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>gt&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for list arg1 is greater than list arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> gt&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: list</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (list)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf8fcfd20e0990c533eaf3a75189f28c5" title="Function implementation function afw_function_execute_gt.">afw_function_execute_gt()</a></p>
<hr  />
<p>Function definition includes&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16354">16354</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga7deac2d15dda99bf9d1e969d3fa23747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7deac2d15dda99bf9d1e969d3fa23747">&#9670;&nbsp;</a></span>afw_function_definition_is_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_is_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>includes&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether or not a list contains any value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> includes&lt;list&gt;(</div>
<div class="line">    list: list,</div>
<div class="line">    searchElement: any,</div>
<div class="line">    fromIndex?: integer</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>list - (<code>&lt;Type&gt;</code>) The list to search.</p>
<p>searchElement - (any dataType) Element to find.</p>
<p>fromIndex - (optional integer) Index in the list to start search.</p>
<p>Returns:</p>
<p>(boolean) Indicates if the element is found in list.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaae3b6bb4851a281f0092b126fbdabd7d" title="Function implementation function afw_function_execute_includes_list.">afw_function_execute_includes_list()</a></p>
<hr  />
<p>Function definition is&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16394">16394</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaccc9b2749d9588be1767301cb36f8db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccc9b2749d9588be1767301cb36f8db6">&#9670;&nbsp;</a></span>afw_function_definition_join</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_join</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>is&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether value is dataType list and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> is&lt;list&gt;(</div>
<div class="line">    value: any</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (any dataType) Value to check.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga592ff430af3e6f20df8c7c7014da60d6" title="Function implementation function afw_function_execute_is.">afw_function_execute_is()</a></p>
<hr  />
<p>Function definition join </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16428">16428</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gab781c092ddbf47550371eaf5fdf94630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab781c092ddbf47550371eaf5fdf94630">&#9670;&nbsp;</a></span>afw_function_definition_length_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_length_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>le&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for list arg1 is less than or equal to list arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> le&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: any</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gab0b76d3bc6ee064c67c3bea1dda7989d" title="Function implementation function afw_function_execute_le.">afw_function_execute_le()</a></p>
<hr  />
<p>Function definition length&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16503">16503</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga531faf21bc5d866f4ba131b5180dd90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga531faf21bc5d866f4ba131b5180dd90f">&#9670;&nbsp;</a></span>afw_function_definition_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>length&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a polymorphic function where list can be any of the supported data types. Return the integer number of entries in datatype list or codepoints in others.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> length&lt;list&gt;(</div>
<div class="line">    value: list</div>
<div class="line">): integer;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>value - (list) Returns the number of entries in a list or code points in others.</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaa1e4913ec9825d6381c5598f489c6a2e" title="Function implementation function afw_function_execute_length.">afw_function_execute_length()</a></p>
<hr  />
<p>Function definition list </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16540">16540</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga5621fb27e98acdd7412896099007e959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5621fb27e98acdd7412896099007e959">&#9670;&nbsp;</a></span>afw_function_definition_ne_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ne_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>lt&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for list arg1 is less that list arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> lt&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: list</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (list)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gafa22bf341d641f266c31a32ceeb256a6" title="Function implementation function afw_function_execute_lt.">afw_function_execute_lt()</a></p>
<hr  />
<p>Function definition ne&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16619">16619</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gaf09c991ce385a7a878b080d330078ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf09c991ce385a7a878b080d330078ed7">&#9670;&nbsp;</a></span>afw_function_definition_nex_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_nex_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>ne&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if list arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "nex" ("!==") instead if you want true to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> ne&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: any</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf144f30dc392293fb1eb3058a00f3093" title="Function implementation function afw_function_execute_ne.">afw_function_execute_ne()</a></p>
<hr  />
<p>Function definition nex&lt;list&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16662">16662</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga15b48dada4fb9162891f507de7e63c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b48dada4fb9162891f507de7e63c8b">&#9670;&nbsp;</a></span>afw_function_definition_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_reverse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function <code>nex&lt;list&gt;</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>function execute parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for list arg1 is not equal to the value or data type of arg2 then return the boolean result. Use "ne" ("!=") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> nex&lt;list&gt;(</div>
<div class="line">    arg1: list,</div>
<div class="line">    arg2: any</div>
<div class="line">): boolean;</div>
</div><!-- fragment --><p>Parameters:</p>
<p>arg1 - (list)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga16fe2f777eb9e0a29ece94637d9c29ec" title="Function implementation function afw_function_execute_nex.">afw_function_execute_nex()</a></p>
<hr  />
<p>Function definition reverse </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l16701">16701</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 2 2023 14:20:33 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
