<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: journal functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">journal functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adaptive Function to_string&lt;ipAddress&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaeb9662349ef64ca7496cc663a3c6a37d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#gaeb9662349ef64ca7496cc663a3c6a37d">afw_function_execute_journal_advance_cursor_for_consumer</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaeb9662349ef64ca7496cc663a3c6a37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function journal_advance_cursor_for_consumer.  <a href="group__afw__functions__journal.html#gaeb9662349ef64ca7496cc663a3c6a37d">More...</a><br /></td></tr>
<tr class="separator:gaeb9662349ef64ca7496cc663a3c6a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca24e7b8fce8a87c40f3089a3b15097"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga7ca24e7b8fce8a87c40f3089a3b15097">afw_function_execute_journal_get_by_cursor</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga7ca24e7b8fce8a87c40f3089a3b15097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function journal_get_by_cursor.  <a href="group__afw__functions__journal.html#ga7ca24e7b8fce8a87c40f3089a3b15097">More...</a><br /></td></tr>
<tr class="separator:ga7ca24e7b8fce8a87c40f3089a3b15097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035bbaa661c17ae6399abd1bc3d7b510"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga035bbaa661c17ae6399abd1bc3d7b510">afw_function_execute_journal_get_first</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga035bbaa661c17ae6399abd1bc3d7b510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function journal_get_first.  <a href="group__afw__functions__journal.html#ga035bbaa661c17ae6399abd1bc3d7b510">More...</a><br /></td></tr>
<tr class="separator:ga035bbaa661c17ae6399abd1bc3d7b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac080c751f379204caafc919be5f253b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#gac080c751f379204caafc919be5f253b9">afw_function_execute_journal_get_next_after_cursor</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gac080c751f379204caafc919be5f253b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function journal_get_next_after_cursor.  <a href="group__afw__functions__journal.html#gac080c751f379204caafc919be5f253b9">More...</a><br /></td></tr>
<tr class="separator:gac080c751f379204caafc919be5f253b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a60c5fef32e94821c889468b36536d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga33a60c5fef32e94821c889468b36536d">afw_function_execute_journal_get_next_for_consumer</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga33a60c5fef32e94821c889468b36536d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function journal_get_next_for_consumer.  <a href="group__afw__functions__journal.html#ga33a60c5fef32e94821c889468b36536d">More...</a><br /></td></tr>
<tr class="separator:ga33a60c5fef32e94821c889468b36536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9bc42536ce29a9f43b0015170e4b481"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#gac9bc42536ce29a9f43b0015170e4b481">afw_function_execute_journal_get_next_for_consumer_after_cursor</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gac9bc42536ce29a9f43b0015170e4b481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function journal_get_next_for_consumer_after_cursor.  <a href="group__afw__functions__journal.html#gac9bc42536ce29a9f43b0015170e4b481">More...</a><br /></td></tr>
<tr class="separator:gac9bc42536ce29a9f43b0015170e4b481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a87a81469f98a74591a763465ab2268"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga0a87a81469f98a74591a763465ab2268">afw_function_execute_journal_mark_consumed</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga0a87a81469f98a74591a763465ab2268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function journal_mark_consumed.  <a href="group__afw__functions__journal.html#ga0a87a81469f98a74591a763465ab2268">More...</a><br /></td></tr>
<tr class="separator:ga0a87a81469f98a74591a763465ab2268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga15e55cbdbb38de2266d4798e4bcdfa79"><td class="memItemLeft" align="right" valign="top"><a id="ga15e55cbdbb38de2266d4798e4bcdfa79"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga15e55cbdbb38de2266d4798e4bcdfa79">afw_function_definition_journal_advance_cursor_for_consumer</a></td></tr>
<tr class="memdesc:ga15e55cbdbb38de2266d4798e4bcdfa79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition journal_advance_cursor_for_consumer. <br /></td></tr>
<tr class="separator:ga15e55cbdbb38de2266d4798e4bcdfa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga968360986f61056f26a93a147b178dff"><td class="memItemLeft" align="right" valign="top"><a id="ga968360986f61056f26a93a147b178dff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga968360986f61056f26a93a147b178dff">afw_function_definition_journal_get_by_cursor</a></td></tr>
<tr class="memdesc:ga968360986f61056f26a93a147b178dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition journal_get_by_cursor. <br /></td></tr>
<tr class="separator:ga968360986f61056f26a93a147b178dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9ece2b260b2e33cf8cabf3202282a5"><td class="memItemLeft" align="right" valign="top"><a id="ga9a9ece2b260b2e33cf8cabf3202282a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga9a9ece2b260b2e33cf8cabf3202282a5">afw_function_definition_journal_get_first</a></td></tr>
<tr class="memdesc:ga9a9ece2b260b2e33cf8cabf3202282a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition journal_get_first. <br /></td></tr>
<tr class="separator:ga9a9ece2b260b2e33cf8cabf3202282a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a6c71ebe2cd6d916893177ead63213"><td class="memItemLeft" align="right" valign="top"><a id="gab1a6c71ebe2cd6d916893177ead63213"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#gab1a6c71ebe2cd6d916893177ead63213">afw_function_definition_journal_get_next_after_cursor</a></td></tr>
<tr class="memdesc:gab1a6c71ebe2cd6d916893177ead63213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition journal_get_next_after_cursor. <br /></td></tr>
<tr class="separator:gab1a6c71ebe2cd6d916893177ead63213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29bb63cc7a23061aeefdc866aecedd90"><td class="memItemLeft" align="right" valign="top"><a id="ga29bb63cc7a23061aeefdc866aecedd90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga29bb63cc7a23061aeefdc866aecedd90">afw_function_definition_journal_get_next_for_consumer</a></td></tr>
<tr class="memdesc:ga29bb63cc7a23061aeefdc866aecedd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition journal_get_next_for_consumer. <br /></td></tr>
<tr class="separator:ga29bb63cc7a23061aeefdc866aecedd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8756be0539be70979a49e7cda6e0c708"><td class="memItemLeft" align="right" valign="top"><a id="ga8756be0539be70979a49e7cda6e0c708"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga8756be0539be70979a49e7cda6e0c708">afw_function_definition_journal_get_next_for_consumer_after_cursor</a></td></tr>
<tr class="memdesc:ga8756be0539be70979a49e7cda6e0c708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition journal_get_next_for_consumer_after_cursor. <br /></td></tr>
<tr class="separator:ga8756be0539be70979a49e7cda6e0c708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f8c8e50e81eff3fe0724a1ddf4a144"><td class="memItemLeft" align="right" valign="top"><a id="ga19f8c8e50e81eff3fe0724a1ddf4a144"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__journal.html#ga19f8c8e50e81eff3fe0724a1ddf4a144">afw_function_definition_journal_mark_consumed</a></td></tr>
<tr class="memdesc:ga19f8c8e50e81eff3fe0724a1ddf4a144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition journal_mark_consumed. <br /></td></tr>
<tr class="separator:ga19f8c8e50e81eff3fe0724a1ddf4a144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adaptive Function to_string&lt;ipAddress&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts ipAddress value to string. For list values, the to_string() value for each entry is returned separated with commas.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function to_string&lt;ipAddress&gt;( value: ipAddress ): string;</p>
<p>Parameters:</p>
<p>value - (ipAddress) A ipAddress value.</p>
<p>Returns:</p>
<p>(string) The string representation of the value.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>journal adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaeb9662349ef64ca7496cc663a3c6a37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb9662349ef64ca7496cc663a3c6a37d">&#9670;&nbsp;</a></span>afw_function_execute_journal_advance_cursor_for_consumer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_journal_advance_cursor_for_consumer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function journal_advance_cursor_for_consumer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Update the advance cursor for a consumer referenced by the consumerId parameter. The limit parameter specifies the maximum number of entries to scan for an applicable entry for consumer before returning. NULL is always returned.</p>
<p>There are no response properties set by this function.</p>
<p>The properties of the <em>AdaptiveProvisioningPeer</em> object associated with the consumer_id are used in the following way:</p>
<p>The consumerFilter expression is used to determine if an entry is applicable.</p>
<p>Journal entries are scanned beginning at the entry at the cursor in the advanceCursor property. If the advanceCursor property is not present, the scan begins after the cursor in currentCursor. If neither are present, the scan begins at the start of the journal.</p>
<p>If an new applicable entry is found or if the limit is met, the advanceCursor property is set to the currently scanned entry's cursor.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function journal_advance_cursor_for_consumer( adaptorId: string, consumerId: string, limit?: integer ): object;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>consumerId - (string) The consumerId property value of the associated <em>AdaptiveProvisioningPeer</em> object.</p>
<p>limit - (optional integer) The maximum number of entries that will be scanned for an entry where the consumerFilter expression in the associated <em>AdaptiveProvisioningPeer</em> object evaluates to true.</p>
<p>Returns:</p>
<p>(object) Response object. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__journal_8c_source.html#l00073">73</a> of file <a class="el" href="afw__function__journal_8c_source.html">afw_function_journal.c</a>.</p>

</div>
</div>
<a id="ga7ca24e7b8fce8a87c40f3089a3b15097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca24e7b8fce8a87c40f3089a3b15097">&#9670;&nbsp;</a></span>afw_function_execute_journal_get_by_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_journal_get_by_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function journal_get_by_cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get journal entry specified by entry_cursor parameter.</p>
<p>This option will set response properties "entry" and "cursor" if there is an entry to retrieve. If an entry with the supplied cursor does not exist, a not_found error is thrown.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function journal_get_by_cursor( adaptorId: string, cursor: string ): object;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>cursor - (string) Journal entry cursor.</p>
<p>Returns:</p>
<p>(object) Response object. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__journal_8c_source.html#l00131">131</a> of file <a class="el" href="afw__function__journal_8c_source.html">afw_function_journal.c</a>.</p>

</div>
</div>
<a id="ga035bbaa661c17ae6399abd1bc3d7b510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga035bbaa661c17ae6399abd1bc3d7b510">&#9670;&nbsp;</a></span>afw_function_execute_journal_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_journal_get_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function journal_get_first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get first journal entry.</p>
<p>This option will set response properties "entry" and "cursor" if there is a first entry to return.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function journal_get_first( adaptorId: string ): object;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>Returns:</p>
<p>(object) Response object. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__journal_8c_source.html#l00178">178</a> of file <a class="el" href="afw__function__journal_8c_source.html">afw_function_journal.c</a>.</p>

</div>
</div>
<a id="gac080c751f379204caafc919be5f253b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac080c751f379204caafc919be5f253b9">&#9670;&nbsp;</a></span>afw_function_execute_journal_get_next_after_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_journal_get_next_after_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function journal_get_next_after_cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the next journal entry after the one specified by the entry_cursor parameter.</p>
<p>This option will set response properties "entry" and "cursor" if there is a next entry to retrieve.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function journal_get_next_after_cursor( adaptorId: string, cursor: string ): object;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>cursor - (string) Journal entry cursor.</p>
<p>Returns:</p>
<p>(object) Response object. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__journal_8c_source.html#l00227">227</a> of file <a class="el" href="afw__function__journal_8c_source.html">afw_function_journal.c</a>.</p>

</div>
</div>
<a id="ga33a60c5fef32e94821c889468b36536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33a60c5fef32e94821c889468b36536d">&#9670;&nbsp;</a></span>afw_function_execute_journal_get_next_for_consumer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_journal_get_next_for_consumer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function journal_get_next_for_consumer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the next journal entry for a consumer referenced by the consumer_id parameter. The entry_cursor parameter is ignored. The limit parameter specifies the maximum number of entries to scan for an applicable entry for consumer before returning.</p>
<p>This option will set response properties "entry" and "entryCursor" if an applicable entry is retrieved. Property "reissue" will be set as described below.</p>
<p>The properties of the <em>AdaptiveProvisioningPeer</em> object associated with the consumer_id are used in the following way:</p>
<p>The consumerFilter expression is used to determine if an entry is applicable.</p>
<p>If consumeCursor property exists, return that entry at that cursor again immediately with a "reissue" property added and set to true.</p>
<p>Journal entries are scanned beginning at the entry at the cursor in the advanceCursor property. If the advanceCursor property is not present, the scan begins after the cursor in currentCursor. If neither are present, the scan begins at the start of the journal.</p>
<p>If an applicable entry is found, properties consumeStart and consumeCursor are set, advanceCursor is removed, and the entry is returned. Method mark_entry_consumed() will remove these properties.</p>
<p>If no applicable entry is found, advanceCursor is set to the last entry scanned.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function journal_get_next_for_consumer( adaptorId: string, consumerId: string, limit?: integer ): object;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>consumerId - (string) The consumerId property value of the associated <em>AdaptiveProvisioningPeer</em> object.</p>
<p>limit - (optional integer) The maximum number of entries that will be scanned for an entry where the consumerFilter expression in the associated <em>AdaptiveProvisioningPeer</em> object evaluates to true.</p>
<p>Returns:</p>
<p>(object) Response object. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__journal_8c_source.html#l00308">308</a> of file <a class="el" href="afw__function__journal_8c_source.html">afw_function_journal.c</a>.</p>

</div>
</div>
<a id="gac9bc42536ce29a9f43b0015170e4b481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9bc42536ce29a9f43b0015170e4b481">&#9670;&nbsp;</a></span>afw_function_execute_journal_get_next_for_consumer_after_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_journal_get_next_for_consumer_after_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function journal_get_next_for_consumer_after_cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the next journal entry for a consumer referenced by the consumer_id after the one specified by the entry_cursor parameter. The limit parameter specifies the maximum number of entries to scan for an applicable entry for consumer before returning.</p>
<p>This option will set response properties "entry" and "cursor" if an applicable entry is retrieved.</p>
<p>The properties of the <em>AdaptiveProvisioningPeer</em> object associated with the consumer_id are used in the following way:</p>
<p>The consumerFilter expression is used to determine if an entry is applicable.</p>
<p>Unlike option get_next_for_consumer, no other properties are referenced or modified.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function journal_get_next_for_consumer_after_cursor( adaptorId: string, consumerId: string, cursor: string, limit?: integer ): object;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>consumerId - (string) The consumerId property value of the associated <em>AdaptiveProvisioningPeer</em> object.</p>
<p>cursor - (string) Journal entry cursor.</p>
<p>limit - (optional integer) The maximum number of entries that will be scanned for an entry where the consumerFilter expression in the associated <em>AdaptiveProvisioningPeer</em> object evaluates to true.</p>
<p>Returns:</p>
<p>(object) Response object. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__journal_8c_source.html#l00386">386</a> of file <a class="el" href="afw__function__journal_8c_source.html">afw_function_journal.c</a>.</p>

</div>
</div>
<a id="ga0a87a81469f98a74591a763465ab2268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a87a81469f98a74591a763465ab2268">&#9670;&nbsp;</a></span>afw_function_execute_journal_mark_consumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_journal_mark_consumed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function journal_mark_consumed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Mark a journal entry returned by get_next_for_consumer() as consumed.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function journal_mark_consumed( adaptorId: string, consumerId: string, cursor: string ): null;</p>
<p>Parameters:</p>
<p>adaptorId - (string) Id of adaptor.</p>
<p>consumerId - (string) The consumerId property value of the associated <em>AdaptiveProvisioningPeer</em> object.</p>
<p>cursor - (string) Journal entry cursor.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__journal_8c_source.html#l00447">447</a> of file <a class="el" href="afw__function__journal_8c_source.html">afw_function_journal.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 8 2023 19:30:17 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
