<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: stream functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stream functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6701522669ae4b4deb5edbd1314e1644"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga6701522669ae4b4deb5edbd1314e1644">afw_function_execute_close</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga6701522669ae4b4deb5edbd1314e1644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function close.  <a href="group__afw__functions__stream.html#ga6701522669ae4b4deb5edbd1314e1644">More...</a><br /></td></tr>
<tr class="separator:ga6701522669ae4b4deb5edbd1314e1644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632b6233b4622c960a098e6d00217dbb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga632b6233b4622c960a098e6d00217dbb">afw_function_execute_flush</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga632b6233b4622c960a098e6d00217dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function flush.  <a href="group__afw__functions__stream.html#ga632b6233b4622c960a098e6d00217dbb">More...</a><br /></td></tr>
<tr class="separator:ga632b6233b4622c960a098e6d00217dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6719b15fc248f5b771cfc42acd887f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gaa6719b15fc248f5b771cfc42acd887f9">afw_function_execute_get_stream_error</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaa6719b15fc248f5b771cfc42acd887f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function get_stream_error.  <a href="group__afw__functions__stream.html#gaa6719b15fc248f5b771cfc42acd887f9">More...</a><br /></td></tr>
<tr class="separator:gaa6719b15fc248f5b771cfc42acd887f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9362de0bcf015aaf7bc32f9edb2a8f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gae9362de0bcf015aaf7bc32f9edb2a8f7">afw_function_execute_open_file</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gae9362de0bcf015aaf7bc32f9edb2a8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function open_file.  <a href="group__afw__functions__stream.html#gae9362de0bcf015aaf7bc32f9edb2a8f7">More...</a><br /></td></tr>
<tr class="separator:gae9362de0bcf015aaf7bc32f9edb2a8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79fbe37f17dd39bef25d6e659f262c60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga79fbe37f17dd39bef25d6e659f262c60">afw_function_execute_open_response</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga79fbe37f17dd39bef25d6e659f262c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function open_response.  <a href="group__afw__functions__stream.html#ga79fbe37f17dd39bef25d6e659f262c60">More...</a><br /></td></tr>
<tr class="separator:ga79fbe37f17dd39bef25d6e659f262c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945fcbe81974efb94522cb7a5ed8aa8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga945fcbe81974efb94522cb7a5ed8aa8e">afw_function_execute_open_uri</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga945fcbe81974efb94522cb7a5ed8aa8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function open_uri.  <a href="group__afw__functions__stream.html#ga945fcbe81974efb94522cb7a5ed8aa8e">More...</a><br /></td></tr>
<tr class="separator:ga945fcbe81974efb94522cb7a5ed8aa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c8d836f310a456f167ace5b279e831"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gab6c8d836f310a456f167ace5b279e831">afw_function_execute_print</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gab6c8d836f310a456f167ace5b279e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function print.  <a href="group__afw__functions__stream.html#gab6c8d836f310a456f167ace5b279e831">More...</a><br /></td></tr>
<tr class="separator:gab6c8d836f310a456f167ace5b279e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6fa40ddab1cf8697737311a1b350ae9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gae6fa40ddab1cf8697737311a1b350ae9">afw_function_execute_println</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gae6fa40ddab1cf8697737311a1b350ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function println.  <a href="group__afw__functions__stream.html#gae6fa40ddab1cf8697737311a1b350ae9">More...</a><br /></td></tr>
<tr class="separator:gae6fa40ddab1cf8697737311a1b350ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13056c1d221444db758382af04decb46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga13056c1d221444db758382af04decb46">afw_function_execute_read</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga13056c1d221444db758382af04decb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function read.  <a href="group__afw__functions__stream.html#ga13056c1d221444db758382af04decb46">More...</a><br /></td></tr>
<tr class="separator:ga13056c1d221444db758382af04decb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b35c8bfdccfdd332530baf630cf24a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga92b35c8bfdccfdd332530baf630cf24a">afw_function_execute_read_to_base64Binary</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga92b35c8bfdccfdd332530baf630cf24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function read_to_base64Binary.  <a href="group__afw__functions__stream.html#ga92b35c8bfdccfdd332530baf630cf24a">More...</a><br /></td></tr>
<tr class="separator:ga92b35c8bfdccfdd332530baf630cf24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac866de784671f054af86aa4af44002c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gac866de784671f054af86aa4af44002c5">afw_function_execute_read_to_hexBinary</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gac866de784671f054af86aa4af44002c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function read_to_hexBinary.  <a href="group__afw__functions__stream.html#gac866de784671f054af86aa4af44002c5">More...</a><br /></td></tr>
<tr class="separator:gac866de784671f054af86aa4af44002c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773ed14326b16410d9c3d041bbb0776d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga773ed14326b16410d9c3d041bbb0776d">afw_function_execute_readln</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga773ed14326b16410d9c3d041bbb0776d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function readln.  <a href="group__afw__functions__stream.html#ga773ed14326b16410d9c3d041bbb0776d">More...</a><br /></td></tr>
<tr class="separator:ga773ed14326b16410d9c3d041bbb0776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32592feb3dc57c69184fd31473682b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gac32592feb3dc57c69184fd31473682b5">afw_function_execute_stream</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gac32592feb3dc57c69184fd31473682b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function stream.  <a href="group__afw__functions__stream.html#gac32592feb3dc57c69184fd31473682b5">More...</a><br /></td></tr>
<tr class="separator:gac32592feb3dc57c69184fd31473682b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8420cf8ce2f19ff6d0e84ce787727702"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga8420cf8ce2f19ff6d0e84ce787727702">afw_function_execute_write</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga8420cf8ce2f19ff6d0e84ce787727702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function write.  <a href="group__afw__functions__stream.html#ga8420cf8ce2f19ff6d0e84ce787727702">More...</a><br /></td></tr>
<tr class="separator:ga8420cf8ce2f19ff6d0e84ce787727702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac680c2f70583ccc7924b421126b56c7e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gac680c2f70583ccc7924b421126b56c7e">afw_function_execute_write_internal</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gac680c2f70583ccc7924b421126b56c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function write_internal.  <a href="group__afw__functions__stream.html#gac680c2f70583ccc7924b421126b56c7e">More...</a><br /></td></tr>
<tr class="separator:gac680c2f70583ccc7924b421126b56c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a8dbd432e920b25950b64311a618bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gab9a8dbd432e920b25950b64311a618bc">afw_function_execute_writeln</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gab9a8dbd432e920b25950b64311a618bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function writeln.  <a href="group__afw__functions__stream.html#gab9a8dbd432e920b25950b64311a618bc">More...</a><br /></td></tr>
<tr class="separator:gab9a8dbd432e920b25950b64311a618bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga288dc19b436311dc191015ed1af082d0"><td class="memItemLeft" align="right" valign="top"><a id="ga288dc19b436311dc191015ed1af082d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga288dc19b436311dc191015ed1af082d0">afw_function_definition_close</a></td></tr>
<tr class="memdesc:ga288dc19b436311dc191015ed1af082d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition close. <br /></td></tr>
<tr class="separator:ga288dc19b436311dc191015ed1af082d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9291e1258d5e56bb83d3745e12a6e7a5"><td class="memItemLeft" align="right" valign="top"><a id="ga9291e1258d5e56bb83d3745e12a6e7a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga9291e1258d5e56bb83d3745e12a6e7a5">afw_function_definition_flush</a></td></tr>
<tr class="memdesc:ga9291e1258d5e56bb83d3745e12a6e7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition flush. <br /></td></tr>
<tr class="separator:ga9291e1258d5e56bb83d3745e12a6e7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d16646cce8dc82ed430556032bf0f3b"><td class="memItemLeft" align="right" valign="top"><a id="ga5d16646cce8dc82ed430556032bf0f3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga5d16646cce8dc82ed430556032bf0f3b">afw_function_definition_get_stream_error</a></td></tr>
<tr class="memdesc:ga5d16646cce8dc82ed430556032bf0f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition get_stream_error. <br /></td></tr>
<tr class="separator:ga5d16646cce8dc82ed430556032bf0f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac41d994e14da12edb9ff7d1b02aff4"><td class="memItemLeft" align="right" valign="top"><a id="gabac41d994e14da12edb9ff7d1b02aff4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gabac41d994e14da12edb9ff7d1b02aff4">afw_function_definition_open_file</a></td></tr>
<tr class="memdesc:gabac41d994e14da12edb9ff7d1b02aff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition open_file. <br /></td></tr>
<tr class="separator:gabac41d994e14da12edb9ff7d1b02aff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e7637d7e0a234340c6d5e49ac76078"><td class="memItemLeft" align="right" valign="top"><a id="ga43e7637d7e0a234340c6d5e49ac76078"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga43e7637d7e0a234340c6d5e49ac76078">afw_function_definition_open_response</a></td></tr>
<tr class="memdesc:ga43e7637d7e0a234340c6d5e49ac76078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition open_response. <br /></td></tr>
<tr class="separator:ga43e7637d7e0a234340c6d5e49ac76078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c52e616c3e88f63ce5d0ca9758285c"><td class="memItemLeft" align="right" valign="top"><a id="gab3c52e616c3e88f63ce5d0ca9758285c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gab3c52e616c3e88f63ce5d0ca9758285c">afw_function_definition_open_uri</a></td></tr>
<tr class="memdesc:gab3c52e616c3e88f63ce5d0ca9758285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition open_uri. <br /></td></tr>
<tr class="separator:gab3c52e616c3e88f63ce5d0ca9758285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592034a999e8f1f4dfc5e4a97a905718"><td class="memItemLeft" align="right" valign="top"><a id="ga592034a999e8f1f4dfc5e4a97a905718"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga592034a999e8f1f4dfc5e4a97a905718">afw_function_definition_print</a></td></tr>
<tr class="memdesc:ga592034a999e8f1f4dfc5e4a97a905718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition print. <br /></td></tr>
<tr class="separator:ga592034a999e8f1f4dfc5e4a97a905718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec280a37ef25b4da6edb82e2b9e63df2"><td class="memItemLeft" align="right" valign="top"><a id="gaec280a37ef25b4da6edb82e2b9e63df2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gaec280a37ef25b4da6edb82e2b9e63df2">afw_function_definition_println</a></td></tr>
<tr class="memdesc:gaec280a37ef25b4da6edb82e2b9e63df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition println. <br /></td></tr>
<tr class="separator:gaec280a37ef25b4da6edb82e2b9e63df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a9b12bc746b69a555420bb4c22e9da"><td class="memItemLeft" align="right" valign="top"><a id="gad1a9b12bc746b69a555420bb4c22e9da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gad1a9b12bc746b69a555420bb4c22e9da">afw_function_definition_read</a></td></tr>
<tr class="memdesc:gad1a9b12bc746b69a555420bb4c22e9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition read. <br /></td></tr>
<tr class="separator:gad1a9b12bc746b69a555420bb4c22e9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36c91d66320d86dc7c404c29468ada3e"><td class="memItemLeft" align="right" valign="top"><a id="ga36c91d66320d86dc7c404c29468ada3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga36c91d66320d86dc7c404c29468ada3e">afw_function_definition_read_to_base64Binary</a></td></tr>
<tr class="memdesc:ga36c91d66320d86dc7c404c29468ada3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition read_to_base64Binary. <br /></td></tr>
<tr class="separator:ga36c91d66320d86dc7c404c29468ada3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68131c9e8150c5603ba89cc6f6c8c848"><td class="memItemLeft" align="right" valign="top"><a id="ga68131c9e8150c5603ba89cc6f6c8c848"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga68131c9e8150c5603ba89cc6f6c8c848">afw_function_definition_read_to_hexBinary</a></td></tr>
<tr class="memdesc:ga68131c9e8150c5603ba89cc6f6c8c848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition read_to_hexBinary. <br /></td></tr>
<tr class="separator:ga68131c9e8150c5603ba89cc6f6c8c848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d857a0147da4b901df93523e2309086"><td class="memItemLeft" align="right" valign="top"><a id="ga4d857a0147da4b901df93523e2309086"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga4d857a0147da4b901df93523e2309086">afw_function_definition_readln</a></td></tr>
<tr class="memdesc:ga4d857a0147da4b901df93523e2309086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition readln. <br /></td></tr>
<tr class="separator:ga4d857a0147da4b901df93523e2309086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2bdb578046d5c604581f693859b191f"><td class="memItemLeft" align="right" valign="top"><a id="gae2bdb578046d5c604581f693859b191f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#gae2bdb578046d5c604581f693859b191f">afw_function_definition_stream</a></td></tr>
<tr class="memdesc:gae2bdb578046d5c604581f693859b191f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition stream. <br /></td></tr>
<tr class="separator:gae2bdb578046d5c604581f693859b191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8466507a57e7aecb1bdb39dc592b6b19"><td class="memItemLeft" align="right" valign="top"><a id="ga8466507a57e7aecb1bdb39dc592b6b19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga8466507a57e7aecb1bdb39dc592b6b19">afw_function_definition_write</a></td></tr>
<tr class="memdesc:ga8466507a57e7aecb1bdb39dc592b6b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition write. <br /></td></tr>
<tr class="separator:ga8466507a57e7aecb1bdb39dc592b6b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91cd6c36f6bb234c59f591adcbe72647"><td class="memItemLeft" align="right" valign="top"><a id="ga91cd6c36f6bb234c59f591adcbe72647"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga91cd6c36f6bb234c59f591adcbe72647">afw_function_definition_write_internal</a></td></tr>
<tr class="memdesc:ga91cd6c36f6bb234c59f591adcbe72647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition write_internal. <br /></td></tr>
<tr class="separator:ga91cd6c36f6bb234c59f591adcbe72647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b96e58cab8eb1585842aaa1e1ff1ce5"><td class="memItemLeft" align="right" valign="top"><a id="ga1b96e58cab8eb1585842aaa1e1ff1ce5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__stream.html#ga1b96e58cab8eb1585842aaa1e1ff1ce5">afw_function_definition_writeln</a></td></tr>
<tr class="memdesc:ga1b96e58cab8eb1585842aaa1e1ff1ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition writeln. <br /></td></tr>
<tr class="separator:ga1b96e58cab8eb1585842aaa1e1ff1ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>stream adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6701522669ae4b4deb5edbd1314e1644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6701522669ae4b4deb5edbd1314e1644">&#9670;&nbsp;</a></span>afw_function_execute_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function close. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This will close an open stream</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function close( streamNumber: integer ): null;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) The streamNumber for the stream to close.</p>
<p>Returns:</p>
<p>(null) </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000121">Todo:</a></b></dt><dd>FIXME: Haven't decided what to do about bad number. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00342">342</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="ga632b6233b4622c960a098e6d00217dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga632b6233b4622c960a098e6d00217dbb">&#9670;&nbsp;</a></span>afw_function_execute_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Write the content of the stream's buffers to its destination.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function flush( streamNumber: integer ): null;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) The streamNumber for the stream to flush.</p>
<p>Returns:</p>
<p>(null) </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000118">Todo:</a></b></dt><dd>FIXME: Haven't decided what to do about bad number. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00045">45</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gaa6719b15fc248f5b771cfc42acd887f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6719b15fc248f5b771cfc42acd887f9">&#9670;&nbsp;</a></span>afw_function_execute_get_stream_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_get_stream_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function get_stream_error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the most recent stream error.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function get_stream_error(</p>
<p>): string;</p>
<p>Parameters:</p>
<p>Returns:</p>
<p>(string) The most recent stream error. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00387">387</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gae9362de0bcf015aaf7bc32f9edb2a8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9362de0bcf015aaf7bc32f9edb2a8f7">&#9670;&nbsp;</a></span>afw_function_execute_open_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_open_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function open_file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This will open a file stream.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function open_file( streamId: string, path: string, mode: string, autoFlush?: boolean ): integer;</p>
<p>Parameters:</p>
<p>streamId - (string) This is the streamId that will be associated with this open file stream.</p>
<p>path - (string) This is the path to the file to open. The rootDirectory of the path is defined in the application object.</p>
<p>mode - (string) This is the access mode string. Values can be: r - Open an existing file text file for read. w - Open a text file for writing. If the file does not exist, it will be created. a - Open a text file for writing additional data to the end. If the file does not exist, it will be created. r+ - Open a text file for both reading and writing. w+ - Open a text file for both reading and writing. If the file exists, it will be overwritten. If the file does not exist, it will be created. a+ - Open a text file for both reading and writing. Reading will begin at the start of the file while writing will be appended to the end.</p>
<p>All of these modes expect data type string. If you are using data type base64Binary or hexBinary you can use corresponding binary modes, "rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", and "a+b".</p>
<p>autoFlush - (optional boolean) If specified and true, this will automatically flush the stream's buffers after every write.</p>
<p>Returns:</p>
<p>(integer) The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00457">457</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="ga79fbe37f17dd39bef25d6e659f262c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79fbe37f17dd39bef25d6e659f262c60">&#9670;&nbsp;</a></span>afw_function_execute_open_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_open_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function open_response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This will open a response text write-only stream that will be written to the http response.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function open_response( streamId: string, autoFlush?: boolean ): integer;</p>
<p>Parameters:</p>
<p>streamId - (string) This is the streamId that will be associated with this open response stream.</p>
<p>autoFlush - (optional boolean) If specified and true, this will automatically flush the stream's buffers after every write.</p>
<p>Returns:</p>
<p>(integer) The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00534">534</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="ga945fcbe81974efb94522cb7a5ed8aa8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga945fcbe81974efb94522cb7a5ed8aa8e">&#9670;&nbsp;</a></span>afw_function_execute_open_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_open_uri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function open_uri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This will open a read or write stream for a URI.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function open_uri( streamId: string, uri: string, mode: string, autoFlush?: boolean ): integer;</p>
<p>Parameters:</p>
<p>streamId - (string) This is the streamId that will be associated with this open URI stream.</p>
<p>uri - (string) This is the URI of the stream to open.</p>
<p>mode - (string) This is the access mode string. Values can be "r" for read or "w" for write.</p>
<p>autoFlush - (optional boolean) If specified and true, this will automatically flush the stream's buffers after every write.</p>
<p>Returns:</p>
<p>(integer) The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000122">Todo:</a></b></dt><dd>FIXME: Add code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00604">604</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gab6c8d836f310a456f167ace5b279e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6c8d836f310a456f167ace5b279e831">&#9670;&nbsp;</a></span>afw_function_execute_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function print. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate and convert 0 or more values to its string value, then write them to stdout. An undefined value is represented by '&lt;undefined&gt;'.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function print( ...values: (list of any) ): null;</p>
<p>Parameters:</p>
<p>values - (0 or more any dataType) Values to print.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00094">94</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gae6fa40ddab1cf8697737311a1b350ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6fa40ddab1cf8697737311a1b350ae9">&#9670;&nbsp;</a></span>afw_function_execute_println()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_println </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function println. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate and convert 0 or more values to their string value, then write them to stdout. A newline character ('<br  />
') is written after the last value. An undefined value is represented by '&lt;undefined&gt;'.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function println( ...value: (list of any) ): null;</p>
<p>Parameters:</p>
<p>value - (0 or more any dataType) Values to print.</p>
<p>Returns:</p>
<p>(null) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00151">151</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="ga13056c1d221444db758382af04decb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13056c1d221444db758382af04decb46">&#9670;&nbsp;</a></span>afw_function_execute_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Read a UTF-8 text stream up to a specified number of octets. The stream must contain valid UTF-8 or an error is thrown.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function read( streamNumber: integer, n: any ): string;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) Stream number.</p>
<p>n - (any dataType) The maximum number of octets to read.</p>
<p>Returns:</p>
<p>(string) The UTF-8 string read. Check the size of this value to determine the actual number of octets read. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000123">Todo:</a></b></dt><dd>FIXME: Add code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00645">645</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="ga92b35c8bfdccfdd332530baf630cf24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92b35c8bfdccfdd332530baf630cf24a">&#9670;&nbsp;</a></span>afw_function_execute_read_to_base64Binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_read_to_base64Binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function read_to_base64Binary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Read a stream up to a specified number of octets. The result will be the internal memory of a base64Binary value.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function read_to_base64Binary( streamNumber: integer, n: any ): base64Binary;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) Stream number.</p>
<p>n - (any dataType) The maximum number of octets to read.</p>
<p>Returns:</p>
<p>(base64Binary) The base64Binary value read. Check the size of this value to determine the actual number of octets read. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000124">Todo:</a></b></dt><dd>FIXME: Add code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00686">686</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gac866de784671f054af86aa4af44002c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac866de784671f054af86aa4af44002c5">&#9670;&nbsp;</a></span>afw_function_execute_read_to_hexBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_read_to_hexBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function read_to_hexBinary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Read a stream up to a specified number of octets. The result will be the internal memory of a hexBinary value.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function read_to_hexBinary( streamNumber: integer, n: any ): hexBinary;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) Stream number.</p>
<p>n - (any dataType) The maximum number of octets to read.</p>
<p>Returns:</p>
<p>(hexBinary) The hexBinary value read. Check the size of this value to determine the actual number of octets read. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000125">Todo:</a></b></dt><dd>FIXME: Add code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00727">727</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="ga773ed14326b16410d9c3d041bbb0776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga773ed14326b16410d9c3d041bbb0776d">&#9670;&nbsp;</a></span>afw_function_execute_readln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_readln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function readln. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Read a UTF-8 text stream line. The stream must contain valid UTF-8 or an error is thrown.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function readln( streamNumber: integer ): string;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) Stream number.</p>
<p>Returns:</p>
<p>(string) The UTF-8 string read. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000126">Todo:</a></b></dt><dd>FIXME: Add code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00764">764</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gac32592feb3dc57c69184fd31473682b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32592feb3dc57c69184fd31473682b5">&#9670;&nbsp;</a></span>afw_function_execute_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This will return the streamNumber for a streamId. This function useful to obtain the number of the automatically opened standard streams "console", "stderr" and "stdout" as well and any other open stream.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function stream( streamId: string ): integer;</p>
<p>Parameters:</p>
<p>streamId - (string) The id of a stream.</p>
<p>Returns:</p>
<p>(integer) The streamNumber for the streamId or -1 if there was an error. Use get_stream_error() for error information. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00803">803</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="ga8420cf8ce2f19ff6d0e84ce787727702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8420cf8ce2f19ff6d0e84ce787727702">&#9670;&nbsp;</a></span>afw_function_execute_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate and convert 0 or more values to its string value, then write them to stream. An value with an undefined value is represented by '&lt;undefined&gt;'.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function write( streamNumber: integer, ...value: (list of any) ): null;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) The streamNumber for the stream to write.</p>
<p>value - (0 or more any) Values to write as their string value.</p>
<p>Returns:</p>
<p>(null) </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd>FIXME: Haven't decided what to do about bad number. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00211">211</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gac680c2f70583ccc7924b421126b56c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac680c2f70583ccc7924b421126b56c7e">&#9670;&nbsp;</a></span>afw_function_execute_write_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_write_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function write_internal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Write a value's internal memory. This is especially useful for writing data type base64Binary and hexBinary.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function write_internal( streamNumber: integer, value: any ): null;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) The streamNumber for the stream to write.</p>
<p>value - (any) The internal memory of this value is written.</p>
<p>Returns:</p>
<p>(null) </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000127">Todo:</a></b></dt><dd>FIXME: Add code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00857">857</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
<a id="gab9a8dbd432e920b25950b64311a618bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a8dbd432e920b25950b64311a618bc">&#9670;&nbsp;</a></span>afw_function_execute_writeln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_writeln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function writeln. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate and convert 0 or more values to its string value, then write them to stream. A newline character ('<br  />
') is written after the last value. An undefined value is represented by '&lt;undefined&gt;'.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function writeln( streamNumber: integer, ...value: (list of any) ): null;</p>
<p>Parameters:</p>
<p>streamNumber - (integer) The streamNumber for the stream to write.</p>
<p>value - (0 or more any dataType) Values to write.</p>
<p>Returns:</p>
<p>(null) </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000120">Todo:</a></b></dt><dd>FIXME: Haven't decided what to do about bad number. </dd></dl>

<p class="definition">Definition at line <a class="el" href="afw__function__stream_8c_source.html#l00279">279</a> of file <a class="el" href="afw__function__stream_8c_source.html">afw_function_stream.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 8 2023 19:30:17 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
