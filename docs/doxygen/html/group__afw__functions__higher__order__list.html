<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: higher_order_list functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">higher_order_list functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adaptive Function union&lt;hexBinary&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacc12153b7763382efaba712d95b1699d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gacc12153b7763382efaba712d95b1699d">afw_function_execute_all_of</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gacc12153b7763382efaba712d95b1699d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function all_of.  <a href="group__afw__functions__higher__order__list.html#gacc12153b7763382efaba712d95b1699d">More...</a><br /></td></tr>
<tr class="separator:gacc12153b7763382efaba712d95b1699d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ef2994ac9920e9d6cefa3049ab07a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga45ef2994ac9920e9d6cefa3049ab07a5">afw_function_execute_all_of_all</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga45ef2994ac9920e9d6cefa3049ab07a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function all_of_all.  <a href="group__afw__functions__higher__order__list.html#ga45ef2994ac9920e9d6cefa3049ab07a5">More...</a><br /></td></tr>
<tr class="separator:ga45ef2994ac9920e9d6cefa3049ab07a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae337adf36ca73a77a4eb189f8cbb66df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gae337adf36ca73a77a4eb189f8cbb66df">afw_function_execute_all_of_any</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gae337adf36ca73a77a4eb189f8cbb66df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function all_of_any.  <a href="group__afw__functions__higher__order__list.html#gae337adf36ca73a77a4eb189f8cbb66df">More...</a><br /></td></tr>
<tr class="separator:gae337adf36ca73a77a4eb189f8cbb66df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5384b6cafd393e4ff85391ca64b45919"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga5384b6cafd393e4ff85391ca64b45919">afw_function_execute_any_of</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga5384b6cafd393e4ff85391ca64b45919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function any_of.  <a href="group__afw__functions__higher__order__list.html#ga5384b6cafd393e4ff85391ca64b45919">More...</a><br /></td></tr>
<tr class="separator:ga5384b6cafd393e4ff85391ca64b45919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637b205d67b07677e84d23fbc934ae30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga637b205d67b07677e84d23fbc934ae30">afw_function_execute_any_of_all</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga637b205d67b07677e84d23fbc934ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function any_of_all.  <a href="group__afw__functions__higher__order__list.html#ga637b205d67b07677e84d23fbc934ae30">More...</a><br /></td></tr>
<tr class="separator:ga637b205d67b07677e84d23fbc934ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6200480d6084d4fd19c0bb03273f257"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gaf6200480d6084d4fd19c0bb03273f257">afw_function_execute_any_of_any</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaf6200480d6084d4fd19c0bb03273f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function any_of_any.  <a href="group__afw__functions__higher__order__list.html#gaf6200480d6084d4fd19c0bb03273f257">More...</a><br /></td></tr>
<tr class="separator:gaf6200480d6084d4fd19c0bb03273f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48ac05979a31031650b0d3218024f46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gab48ac05979a31031650b0d3218024f46">afw_function_execute_filter</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gab48ac05979a31031650b0d3218024f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function filter.  <a href="group__afw__functions__higher__order__list.html#gab48ac05979a31031650b0d3218024f46">More...</a><br /></td></tr>
<tr class="separator:gab48ac05979a31031650b0d3218024f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d874bda8a618b054ced65efedf6794"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga44d874bda8a618b054ced65efedf6794">afw_function_execute_find</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga44d874bda8a618b054ced65efedf6794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function find.  <a href="group__afw__functions__higher__order__list.html#ga44d874bda8a618b054ced65efedf6794">More...</a><br /></td></tr>
<tr class="separator:ga44d874bda8a618b054ced65efedf6794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c206c1e66cfb94ccb1e33db608c95bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga6c206c1e66cfb94ccb1e33db608c95bd">afw_function_execute_map</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga6c206c1e66cfb94ccb1e33db608c95bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function map.  <a href="group__afw__functions__higher__order__list.html#ga6c206c1e66cfb94ccb1e33db608c95bd">More...</a><br /></td></tr>
<tr class="separator:ga6c206c1e66cfb94ccb1e33db608c95bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d7f570272d4e51804685a361a26a63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga25d7f570272d4e51804685a361a26a63">afw_function_execute_reduce</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga25d7f570272d4e51804685a361a26a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function reduce.  <a href="group__afw__functions__higher__order__list.html#ga25d7f570272d4e51804685a361a26a63">More...</a><br /></td></tr>
<tr class="separator:ga25d7f570272d4e51804685a361a26a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef1640be94c2c58044871f42b2b5f08"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga0ef1640be94c2c58044871f42b2b5f08">afw_function_execute_sort</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga0ef1640be94c2c58044871f42b2b5f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function sort.  <a href="group__afw__functions__higher__order__list.html#ga0ef1640be94c2c58044871f42b2b5f08">More...</a><br /></td></tr>
<tr class="separator:ga0ef1640be94c2c58044871f42b2b5f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadb013c1a49c5d2ddd97fb16c1943647b"><td class="memItemLeft" align="right" valign="top"><a id="gadb013c1a49c5d2ddd97fb16c1943647b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gadb013c1a49c5d2ddd97fb16c1943647b">afw_function_definition_all_of</a></td></tr>
<tr class="memdesc:gadb013c1a49c5d2ddd97fb16c1943647b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition all_of. <br /></td></tr>
<tr class="separator:gadb013c1a49c5d2ddd97fb16c1943647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035b9b98c581e45b881aef3be198e5af"><td class="memItemLeft" align="right" valign="top"><a id="ga035b9b98c581e45b881aef3be198e5af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga035b9b98c581e45b881aef3be198e5af">afw_function_definition_all_of_all</a></td></tr>
<tr class="memdesc:ga035b9b98c581e45b881aef3be198e5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition all_of_all. <br /></td></tr>
<tr class="separator:ga035b9b98c581e45b881aef3be198e5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112c115b20ba8a256e70258f1af58833"><td class="memItemLeft" align="right" valign="top"><a id="ga112c115b20ba8a256e70258f1af58833"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga112c115b20ba8a256e70258f1af58833">afw_function_definition_all_of_any</a></td></tr>
<tr class="memdesc:ga112c115b20ba8a256e70258f1af58833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition all_of_any. <br /></td></tr>
<tr class="separator:ga112c115b20ba8a256e70258f1af58833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1894386ea2edea64d1725f8059b7fc"><td class="memItemLeft" align="right" valign="top"><a id="gaec1894386ea2edea64d1725f8059b7fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gaec1894386ea2edea64d1725f8059b7fc">afw_function_definition_any_of</a></td></tr>
<tr class="memdesc:gaec1894386ea2edea64d1725f8059b7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition any_of. <br /></td></tr>
<tr class="separator:gaec1894386ea2edea64d1725f8059b7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403070ecf6dabe1c8ee4c9e6b138d06e"><td class="memItemLeft" align="right" valign="top"><a id="ga403070ecf6dabe1c8ee4c9e6b138d06e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga403070ecf6dabe1c8ee4c9e6b138d06e">afw_function_definition_any_of_all</a></td></tr>
<tr class="memdesc:ga403070ecf6dabe1c8ee4c9e6b138d06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition any_of_all. <br /></td></tr>
<tr class="separator:ga403070ecf6dabe1c8ee4c9e6b138d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1866d935e4952c351fe40e1505a93045"><td class="memItemLeft" align="right" valign="top"><a id="ga1866d935e4952c351fe40e1505a93045"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga1866d935e4952c351fe40e1505a93045">afw_function_definition_any_of_any</a></td></tr>
<tr class="memdesc:ga1866d935e4952c351fe40e1505a93045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition any_of_any. <br /></td></tr>
<tr class="separator:ga1866d935e4952c351fe40e1505a93045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2013ff716171726d9d1da9bb172de07"><td class="memItemLeft" align="right" valign="top"><a id="gad2013ff716171726d9d1da9bb172de07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gad2013ff716171726d9d1da9bb172de07">afw_function_definition_filter</a></td></tr>
<tr class="memdesc:gad2013ff716171726d9d1da9bb172de07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition filter. <br /></td></tr>
<tr class="separator:gad2013ff716171726d9d1da9bb172de07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca50d47ee367075633f79ab1578a53d"><td class="memItemLeft" align="right" valign="top"><a id="ga1ca50d47ee367075633f79ab1578a53d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga1ca50d47ee367075633f79ab1578a53d">afw_function_definition_find</a></td></tr>
<tr class="memdesc:ga1ca50d47ee367075633f79ab1578a53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition find. <br /></td></tr>
<tr class="separator:ga1ca50d47ee367075633f79ab1578a53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8e1c563fb90027cf6a43ab70b796fc"><td class="memItemLeft" align="right" valign="top"><a id="ga3a8e1c563fb90027cf6a43ab70b796fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga3a8e1c563fb90027cf6a43ab70b796fc">afw_function_definition_map</a></td></tr>
<tr class="memdesc:ga3a8e1c563fb90027cf6a43ab70b796fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition map. <br /></td></tr>
<tr class="separator:ga3a8e1c563fb90027cf6a43ab70b796fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2effc7c6ca4388f1d86f2630c91f83fa"><td class="memItemLeft" align="right" valign="top"><a id="ga2effc7c6ca4388f1d86f2630c91f83fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#ga2effc7c6ca4388f1d86f2630c91f83fa">afw_function_definition_reduce</a></td></tr>
<tr class="memdesc:ga2effc7c6ca4388f1d86f2630c91f83fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition reduce. <br /></td></tr>
<tr class="separator:ga2effc7c6ca4388f1d86f2630c91f83fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9266a7b959df6fac8b51467ecce8702"><td class="memItemLeft" align="right" valign="top"><a id="gab9266a7b959df6fac8b51467ecce8702"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__higher__order__list.html#gab9266a7b959df6fac8b51467ecce8702">afw_function_definition_sort</a></td></tr>
<tr class="memdesc:gab9266a7b959df6fac8b51467ecce8702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition sort. <br /></td></tr>
<tr class="separator:gab9266a7b959df6fac8b51467ecce8702"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adaptive Function union&lt;hexBinary&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of hexBinary contains all of the unique values in two or more list of hexBinary values.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function union&lt;hexBinary&gt;( lists_1: (list hexBinary), lists_2: (list hexBinary), ...lists_rest: (list of (list hexBinary)) ): (list hexBinary);</p>
<p>Parameters:</p>
<p>lists - (2 or more list hexBinary) Two or more lists.</p>
<p>Returns:</p>
<p>(list hexBinary)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gac65fd70ccba4536ea9f74c17d5c86cd1" title="Function implementation function afw_function_execute_union.">afw_function_execute_union()</a></p>
<hr  />
<p>higher_order_list adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacc12153b7763382efaba712d95b1699d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc12153b7763382efaba712d95b1699d">&#9670;&nbsp;</a></span>afw_function_execute_all_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_all_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function all_of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true if all values in a list pass the predicate test.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function all_of( predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any) ): boolean;</p>
<p>Parameters:</p>
<p>predicate - (function (... values: any): boolean) This function is called for each value in the first list in values or until false is returned. If no calls return false, the result is true.</p>
<p>values - (1 or more any dataType) These are the parameters passed to predicate with the exception that the first list is passed one value at a time. At least one list is required.</p>
<p>Returns:</p>
<p>(boolean) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00302">302</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="ga45ef2994ac9920e9d6cefa3049ab07a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ef2994ac9920e9d6cefa3049ab07a5">&#9670;&nbsp;</a></span>afw_function_execute_all_of_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_all_of_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function all_of_all. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true if the result of calling predicate with all of the combination of values from list1 and list2 returns true.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function all_of_all( predicate: (function (any value1: any, value2: any): boolean), list1: list, list2: list ): boolean;</p>
<p>Parameters:</p>
<p>predicate - (function (any value1: any, value2: any): boolean) The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2.</p>
<p>list1 - (list)</p>
<p>list2 - (list)</p>
<p>Returns:</p>
<p>(boolean) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00346">346</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="gae337adf36ca73a77a4eb189f8cbb66df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae337adf36ca73a77a4eb189f8cbb66df">&#9670;&nbsp;</a></span>afw_function_execute_all_of_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_all_of_any </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function all_of_any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns true if the result of calling predicate with all of the combination of values from list1 and any of the values of list2 returns true.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function all_of_any( predicate: (function (value1: any, value2: any): boolean), list1: list, list2: list ): boolean;</p>
<p>Parameters:</p>
<p>predicate - (function (value1: any, value2: any): boolean) The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2.</p>
<p>list1 - (list)</p>
<p>list2 - (list)</p>
<p>Returns:</p>
<p>(boolean) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00390">390</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="ga5384b6cafd393e4ff85391ca64b45919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5384b6cafd393e4ff85391ca64b45919">&#9670;&nbsp;</a></span>afw_function_execute_any_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_any_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function any_of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true if any value in a list pass the predicate test.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function any_of( predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any) ): boolean;</p>
<p>Parameters:</p>
<p>predicate - (function (... values: any): boolean) This function is called for each value in the first list in values or until true is returned. If no calls return true, the result is false.</p>
<p>values - (1 or more any dataType) These are the parameters passed to predicate with the exception that the first list is passed one value at a time. At least one list is required.</p>
<p>Returns:</p>
<p>(boolean) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00433">433</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="ga637b205d67b07677e84d23fbc934ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga637b205d67b07677e84d23fbc934ae30">&#9670;&nbsp;</a></span>afw_function_execute_any_of_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_any_of_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function any_of_all. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true if the result of calling predicate with all of the combination of values from list2 and any of the values of list1 returns true.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function any_of_all( predicate: (function (value1: any, value2: any):boolean), list1: list, list2: list ): boolean;</p>
<p>Parameters:</p>
<p>predicate - (function (value1: any, value2: any):boolean) The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2.</p>
<p>list1 - (list)</p>
<p>list2 - (list)</p>
<p>Returns:</p>
<p>(boolean) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00477">477</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="gaf6200480d6084d4fd19c0bb03273f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6200480d6084d4fd19c0bb03273f257">&#9670;&nbsp;</a></span>afw_function_execute_any_of_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_any_of_any </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function any_of_any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns true if the result of calling predicate with any of the combination of values from list1 and list2 returns true.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function any_of_any( predicate: (function (value1: any, value2: any): boolean), list1: list, list2: list ): boolean;</p>
<p>Parameters:</p>
<p>predicate - (function (value1: any, value2: any): boolean) The predicate is passed two parameters, the first is a value from list1 and the second is a value from list2.</p>
<p>list1 - (list)</p>
<p>list2 - (list)</p>
<p>Returns:</p>
<p>(boolean) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00521">521</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="gab48ac05979a31031650b0d3218024f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab48ac05979a31031650b0d3218024f46">&#9670;&nbsp;</a></span>afw_function_execute_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This produces a list containing only values from another list that pass a predicate test.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function filter( predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any) ): list;</p>
<p>Parameters:</p>
<p>predicate - (function (... values: any): boolean) This is a boolean function that is called to determine if a list entry should be included in the returned list.</p>
<p>values - (1 or more any dataType) These are the values passed to the predicate with the exception that the first list is passed as the single current value from the list. At least one list is required.</p>
<p>Returns:</p>
<p>(list) This is the resulting filtered list. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00584">584</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="ga44d874bda8a618b054ced65efedf6794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d874bda8a618b054ced65efedf6794">&#9670;&nbsp;</a></span>afw_function_execute_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function find. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>The predicate is called for each value in the first list in values until true is returned, then that value is returned.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function find( predicate: (function (... values: any): boolean), values_1: any, ...values_rest: (list of any) ): any;</p>
<p>Parameters:</p>
<p>predicate - (function (... values: any): boolean) This is a boolean function that is called to determine if a list entry passes the test.</p>
<p>values - (1 or more any dataType) These are the values passed to the predicate with the exception that the first list is passed as the single current value from the list. At least one list is required.</p>
<p>Returns:</p>
<p>(any dataType) The first value that passes the test is returned. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00652">652</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="ga6c206c1e66cfb94ccb1e33db608c95bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c206c1e66cfb94ccb1e33db608c95bd">&#9670;&nbsp;</a></span>afw_function_execute_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function creates a list of the results of calling functor with each value of the first list in values</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function map( functor: (function (... values: any): any), values_1: any, ...values_rest: (list of any) ): list;</p>
<p>Parameters:</p>
<p>functor - (function (... values: any): any)</p>
<p>values - (1 or more any dataType) These are the parameters passed to functor with the exception that the first list is passed one value at a time. At least one list is required.</p>
<p>Returns:</p>
<p>(list) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00721">721</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="ga25d7f570272d4e51804685a361a26a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d7f570272d4e51804685a361a26a63">&#9670;&nbsp;</a></span>afw_function_execute_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function reduce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Reduce calls functor for each value in list with two parameters, accumulator and value, and must return a value of any dataType. Parameter accumulator is the reduce() accumulator parameter value on first call and the return value of previous functor() call on subsequent calls. The dataType of the return value should normally be the same as accumulator, but this is not required.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function reduce( functor: (function (accumulator: any, value: any): any), accumulator: any, list: list ): any;</p>
<p>Parameters:</p>
<p>functor - (function (accumulator: any, value: any): any) This function is called for each value in a list. The returned value is passed as the accumulator parameter on the next call to functor().</p>
<p>accumulator - (any dataType) This is an initial accumulator value passed to functor(). Normally, the dataType of accumulator will be the dataTape for the reduce() return value, but this is not required.</p>
<p>list - (list) This is a list to be reduced.</p>
<p>Returns:</p>
<p>(any dataType) This is the final return value from functor() or the accumulator parameter value if list is empty. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00789">789</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
<a id="ga0ef1640be94c2c58044871f42b2b5f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ef1640be94c2c58044871f42b2b5f08">&#9670;&nbsp;</a></span>afw_function_execute_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">scope</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This produces a list with values sorted based on result of compareFunction. The compareFunction is passed two values from the list and must return an integer less than 0 if the first value is less than the second value, 0 if they are equal, and a integer greater than 0 if the first value is greater than the second value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function sort( compareFunction: (function (value1: any, value2: any): integer), list: list ): list;</p>
<p>Parameters:</p>
<p>compareFunction - (function (value1: any, value2: any): integer) This function is called with two value from list.</p>
<p>list - (list) This is the list to sort.</p>
<p>Returns:</p>
<p>(list) This the the resulting sorted list. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__higher__order__list_8c_source.html#l00928">928</a> of file <a class="el" href="afw__function__higher__order__list_8c_source.html">afw_function_higher_order_list.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 4 2023 17:55:16 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
