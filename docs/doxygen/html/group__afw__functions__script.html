<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Adaptive Framework: script functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Adaptive Framework
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">script functions<div class="ingroups"><a class="el" href="group__afw__core.html">Core</a> &raquo; <a class="el" href="group__afw__core__functions.html">Adaptive functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adaptive Function union&lt;rfc822Name&gt;  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0cbee54962884e392e5e9b81d4ddc547"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga0cbee54962884e392e5e9b81d4ddc547">afw_function_execute_assign</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga0cbee54962884e392e5e9b81d4ddc547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function assign.  <a href="group__afw__functions__script.html#ga0cbee54962884e392e5e9b81d4ddc547">More...</a><br /></td></tr>
<tr class="separator:ga0cbee54962884e392e5e9b81d4ddc547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f91b63b80c4356758f9bcf8257d270a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga7f91b63b80c4356758f9bcf8257d270a">afw_function_execute_break</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga7f91b63b80c4356758f9bcf8257d270a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function break.  <a href="group__afw__functions__script.html#ga7f91b63b80c4356758f9bcf8257d270a">More...</a><br /></td></tr>
<tr class="separator:ga7f91b63b80c4356758f9bcf8257d270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82ea789d9535c99d63d43711bfbc5a4e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga82ea789d9535c99d63d43711bfbc5a4e">afw_function_execute_compile_script</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga82ea789d9535c99d63d43711bfbc5a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function compile&lt;script&gt;  <a href="group__afw__functions__script.html#ga82ea789d9535c99d63d43711bfbc5a4e">More...</a><br /></td></tr>
<tr class="separator:ga82ea789d9535c99d63d43711bfbc5a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab3baa33c974a58948fe6c3d2f89f22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga6ab3baa33c974a58948fe6c3d2f89f22">afw_function_execute_const</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga6ab3baa33c974a58948fe6c3d2f89f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function const.  <a href="group__afw__functions__script.html#ga6ab3baa33c974a58948fe6c3d2f89f22">More...</a><br /></td></tr>
<tr class="separator:ga6ab3baa33c974a58948fe6c3d2f89f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258a87beada3d0ea7939075190a8e4d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga258a87beada3d0ea7939075190a8e4d9">afw_function_execute_continue</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga258a87beada3d0ea7939075190a8e4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function continue.  <a href="group__afw__functions__script.html#ga258a87beada3d0ea7939075190a8e4d9">More...</a><br /></td></tr>
<tr class="separator:ga258a87beada3d0ea7939075190a8e4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8bc41403349ce49a10d50ecb2295f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga4e8bc41403349ce49a10d50ecb2295f1">afw_function_execute_do_while</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga4e8bc41403349ce49a10d50ecb2295f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function do_while.  <a href="group__afw__functions__script.html#ga4e8bc41403349ce49a10d50ecb2295f1">More...</a><br /></td></tr>
<tr class="separator:ga4e8bc41403349ce49a10d50ecb2295f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4031dba0d558b1badfc92e22011be027"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga4031dba0d558b1badfc92e22011be027">afw_function_execute_evaluate_script</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga4031dba0d558b1badfc92e22011be027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function evaluate&lt;script&gt;  <a href="group__afw__functions__script.html#ga4031dba0d558b1badfc92e22011be027">More...</a><br /></td></tr>
<tr class="separator:ga4031dba0d558b1badfc92e22011be027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa101bea913fea0198cc67c20b66f1ba0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gaa101bea913fea0198cc67c20b66f1ba0">afw_function_execute_for</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaa101bea913fea0198cc67c20b66f1ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function for.  <a href="group__afw__functions__script.html#gaa101bea913fea0198cc67c20b66f1ba0">More...</a><br /></td></tr>
<tr class="separator:gaa101bea913fea0198cc67c20b66f1ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4778d256c2be2dcfa3fe147d73c940c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga4778d256c2be2dcfa3fe147d73c940c3">afw_function_execute_foreach</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga4778d256c2be2dcfa3fe147d73c940c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function foreach.  <a href="group__afw__functions__script.html#ga4778d256c2be2dcfa3fe147d73c940c3">More...</a><br /></td></tr>
<tr class="separator:ga4778d256c2be2dcfa3fe147d73c940c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffd433765d0f467100fcde5f3f8dcd9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gabffd433765d0f467100fcde5f3f8dcd9">afw_function_execute_if</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gabffd433765d0f467100fcde5f3f8dcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function if.  <a href="group__afw__functions__script.html#gabffd433765d0f467100fcde5f3f8dcd9">More...</a><br /></td></tr>
<tr class="separator:gabffd433765d0f467100fcde5f3f8dcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0635816629ffb8423b6e88f262abb4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga1b0635816629ffb8423b6e88f262abb4">afw_function_execute_loc</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:ga1b0635816629ffb8423b6e88f262abb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function loc.  <a href="group__afw__functions__script.html#ga1b0635816629ffb8423b6e88f262abb4">More...</a><br /></td></tr>
<tr class="separator:ga1b0635816629ffb8423b6e88f262abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fe002bbf799693a397b72a024bdb49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gaf9fe002bbf799693a397b72a024bdb49">afw_function_execute_return</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gaf9fe002bbf799693a397b72a024bdb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function return.  <a href="group__afw__functions__script.html#gaf9fe002bbf799693a397b72a024bdb49">More...</a><br /></td></tr>
<tr class="separator:gaf9fe002bbf799693a397b72a024bdb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b860ece33878c6fb235a899e327ac0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structafw__value__s.html">afw_value_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gac4b860ece33878c6fb235a899e327ac0">afw_function_execute_while</a> (<a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *x)</td></tr>
<tr class="memdesc:gac4b860ece33878c6fb235a899e327ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function while.  <a href="group__afw__functions__script.html#gac4b860ece33878c6fb235a899e327ac0">More...</a><br /></td></tr>
<tr class="separator:gac4b860ece33878c6fb235a899e327ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac9d49666e5133988b594a677f633963d"><td class="memItemLeft" align="right" valign="top"><a id="gac9d49666e5133988b594a677f633963d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gac9d49666e5133988b594a677f633963d">afw_function_definition_assign</a></td></tr>
<tr class="memdesc:gac9d49666e5133988b594a677f633963d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition assign. <br /></td></tr>
<tr class="separator:gac9d49666e5133988b594a677f633963d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad647c18864d35f5850dea8bc902bb092"><td class="memItemLeft" align="right" valign="top"><a id="gad647c18864d35f5850dea8bc902bb092"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gad647c18864d35f5850dea8bc902bb092">afw_function_definition_bag_script</a></td></tr>
<tr class="memdesc:gad647c18864d35f5850dea8bc902bb092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition bag&lt;script&gt; <br /></td></tr>
<tr class="separator:gad647c18864d35f5850dea8bc902bb092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8a2c6c8fdfaeaa31af09fd4f509711"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gafd8a2c6c8fdfaeaa31af09fd4f509711">afw_function_definition_bag_size_script</a></td></tr>
<tr class="memdesc:gafd8a2c6c8fdfaeaa31af09fd4f509711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag&lt;script&gt;  <a href="group__afw__functions__script.html#gafd8a2c6c8fdfaeaa31af09fd4f509711">More...</a><br /></td></tr>
<tr class="separator:gafd8a2c6c8fdfaeaa31af09fd4f509711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71b075b9f568b5e13716d1e6f5371e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gad71b075b9f568b5e13716d1e6f5371e8">afw_function_definition_break</a></td></tr>
<tr class="memdesc:gad71b075b9f568b5e13716d1e6f5371e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function bag_size&lt;script&gt;  <a href="group__afw__functions__script.html#gad71b075b9f568b5e13716d1e6f5371e8">More...</a><br /></td></tr>
<tr class="separator:gad71b075b9f568b5e13716d1e6f5371e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1a0faeaff874aa7c58b97412c10913"><td class="memItemLeft" align="right" valign="top"><a id="ga8f1a0faeaff874aa7c58b97412c10913"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga8f1a0faeaff874aa7c58b97412c10913">afw_function_definition_compile_script</a></td></tr>
<tr class="memdesc:ga8f1a0faeaff874aa7c58b97412c10913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition compile&lt;script&gt; <br /></td></tr>
<tr class="separator:ga8f1a0faeaff874aa7c58b97412c10913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63db742d184422511dddd48fada40240"><td class="memItemLeft" align="right" valign="top"><a id="ga63db742d184422511dddd48fada40240"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga63db742d184422511dddd48fada40240">afw_function_definition_const</a></td></tr>
<tr class="memdesc:ga63db742d184422511dddd48fada40240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition const. <br /></td></tr>
<tr class="separator:ga63db742d184422511dddd48fada40240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1dab293cc20cb6723ce300d466d35d"><td class="memItemLeft" align="right" valign="top"><a id="ga8b1dab293cc20cb6723ce300d466d35d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga8b1dab293cc20cb6723ce300d466d35d">afw_function_definition_continue</a></td></tr>
<tr class="memdesc:ga8b1dab293cc20cb6723ce300d466d35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition continue. <br /></td></tr>
<tr class="separator:ga8b1dab293cc20cb6723ce300d466d35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4a2003ec899bbb2d8d03ab27190b71"><td class="memItemLeft" align="right" valign="top"><a id="gacc4a2003ec899bbb2d8d03ab27190b71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gacc4a2003ec899bbb2d8d03ab27190b71">afw_function_definition_do_while</a></td></tr>
<tr class="memdesc:gacc4a2003ec899bbb2d8d03ab27190b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition do_while. <br /></td></tr>
<tr class="separator:gacc4a2003ec899bbb2d8d03ab27190b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88456e4abd65f275b638e5d3f7b1ce20"><td class="memItemLeft" align="right" valign="top"><a id="ga88456e4abd65f275b638e5d3f7b1ce20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga88456e4abd65f275b638e5d3f7b1ce20">afw_function_definition_eq_script</a></td></tr>
<tr class="memdesc:ga88456e4abd65f275b638e5d3f7b1ce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition eq&lt;script&gt; <br /></td></tr>
<tr class="separator:ga88456e4abd65f275b638e5d3f7b1ce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849e677e38929edd9cc92d082d8c6538"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga849e677e38929edd9cc92d082d8c6538">afw_function_definition_eqx_script</a></td></tr>
<tr class="memdesc:ga849e677e38929edd9cc92d082d8c6538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eq&lt;script&gt;  <a href="group__afw__functions__script.html#ga849e677e38929edd9cc92d082d8c6538">More...</a><br /></td></tr>
<tr class="separator:ga849e677e38929edd9cc92d082d8c6538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e69ae410557947d0b126c67fc6aeaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga51e69ae410557947d0b126c67fc6aeaf">afw_function_definition_evaluate_script</a></td></tr>
<tr class="memdesc:ga51e69ae410557947d0b126c67fc6aeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function eqx&lt;script&gt;  <a href="group__afw__functions__script.html#ga51e69ae410557947d0b126c67fc6aeaf">More...</a><br /></td></tr>
<tr class="separator:ga51e69ae410557947d0b126c67fc6aeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab256c3797d05182a85652eb28227ea73"><td class="memItemLeft" align="right" valign="top"><a id="gab256c3797d05182a85652eb28227ea73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gab256c3797d05182a85652eb28227ea73">afw_function_definition_for</a></td></tr>
<tr class="memdesc:gab256c3797d05182a85652eb28227ea73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition for. <br /></td></tr>
<tr class="separator:gab256c3797d05182a85652eb28227ea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2d716b693c6387220cb1e4bc4fc037"><td class="memItemLeft" align="right" valign="top"><a id="ga0e2d716b693c6387220cb1e4bc4fc037"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga0e2d716b693c6387220cb1e4bc4fc037">afw_function_definition_foreach</a></td></tr>
<tr class="memdesc:ga0e2d716b693c6387220cb1e4bc4fc037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition foreach. <br /></td></tr>
<tr class="separator:ga0e2d716b693c6387220cb1e4bc4fc037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae48fef041331b41c0f90584ca188053b"><td class="memItemLeft" align="right" valign="top"><a id="gae48fef041331b41c0f90584ca188053b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gae48fef041331b41c0f90584ca188053b">afw_function_definition_ge_script</a></td></tr>
<tr class="memdesc:gae48fef041331b41c0f90584ca188053b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition ge&lt;script&gt; <br /></td></tr>
<tr class="separator:gae48fef041331b41c0f90584ca188053b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga681fe8a651a2763905a99eae009034b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga681fe8a651a2763905a99eae009034b5">afw_function_definition_gt_script</a></td></tr>
<tr class="memdesc:ga681fe8a651a2763905a99eae009034b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ge&lt;script&gt;  <a href="group__afw__functions__script.html#ga681fe8a651a2763905a99eae009034b5">More...</a><br /></td></tr>
<tr class="separator:ga681fe8a651a2763905a99eae009034b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473da9d43ffaa54e358e54e9fdd4e70c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga473da9d43ffaa54e358e54e9fdd4e70c">afw_function_definition_if</a></td></tr>
<tr class="memdesc:ga473da9d43ffaa54e358e54e9fdd4e70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function gt&lt;script&gt;  <a href="group__afw__functions__script.html#ga473da9d43ffaa54e358e54e9fdd4e70c">More...</a><br /></td></tr>
<tr class="separator:ga473da9d43ffaa54e358e54e9fdd4e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43800777e317fde81350c5f7a12ad8f"><td class="memItemLeft" align="right" valign="top"><a id="gab43800777e317fde81350c5f7a12ad8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gab43800777e317fde81350c5f7a12ad8f">afw_function_definition_is_script</a></td></tr>
<tr class="memdesc:gab43800777e317fde81350c5f7a12ad8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition is&lt;script&gt; <br /></td></tr>
<tr class="separator:gab43800777e317fde81350c5f7a12ad8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd704630ef336feca8e63f18860103c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga7fd704630ef336feca8e63f18860103c">afw_function_definition_le_script</a></td></tr>
<tr class="memdesc:ga7fd704630ef336feca8e63f18860103c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function is&lt;script&gt;  <a href="group__afw__functions__script.html#ga7fd704630ef336feca8e63f18860103c">More...</a><br /></td></tr>
<tr class="separator:ga7fd704630ef336feca8e63f18860103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga614483c3d6544fee2c1415e553bc6f38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga614483c3d6544fee2c1415e553bc6f38">afw_function_definition_loc</a></td></tr>
<tr class="memdesc:ga614483c3d6544fee2c1415e553bc6f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function le&lt;script&gt;  <a href="group__afw__functions__script.html#ga614483c3d6544fee2c1415e553bc6f38">More...</a><br /></td></tr>
<tr class="separator:ga614483c3d6544fee2c1415e553bc6f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3912c670826fd8b5dab2dac42b06a663"><td class="memItemLeft" align="right" valign="top"><a id="ga3912c670826fd8b5dab2dac42b06a663"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga3912c670826fd8b5dab2dac42b06a663">afw_function_definition_lt_script</a></td></tr>
<tr class="memdesc:ga3912c670826fd8b5dab2dac42b06a663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition lt&lt;script&gt; <br /></td></tr>
<tr class="separator:ga3912c670826fd8b5dab2dac42b06a663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5f1dd6ead4809be7f730a1e7587dba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gacf5f1dd6ead4809be7f730a1e7587dba">afw_function_definition_ne_script</a></td></tr>
<tr class="memdesc:gacf5f1dd6ead4809be7f730a1e7587dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function lt&lt;script&gt;  <a href="group__afw__functions__script.html#gacf5f1dd6ead4809be7f730a1e7587dba">More...</a><br /></td></tr>
<tr class="separator:gacf5f1dd6ead4809be7f730a1e7587dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ca7078009f6a9ba00d6dbea50391ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga80ca7078009f6a9ba00d6dbea50391ef">afw_function_definition_nex_script</a></td></tr>
<tr class="memdesc:ga80ca7078009f6a9ba00d6dbea50391ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function ne&lt;script&gt;  <a href="group__afw__functions__script.html#ga80ca7078009f6a9ba00d6dbea50391ef">More...</a><br /></td></tr>
<tr class="separator:ga80ca7078009f6a9ba00d6dbea50391ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5b933a588b5255308763b016e89d02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#gafc5b933a588b5255308763b016e89d02">afw_function_definition_return</a></td></tr>
<tr class="memdesc:gafc5b933a588b5255308763b016e89d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function nex&lt;script&gt;  <a href="group__afw__functions__script.html#gafc5b933a588b5255308763b016e89d02">More...</a><br /></td></tr>
<tr class="separator:gafc5b933a588b5255308763b016e89d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40369467446b37ebfacb996610954c78"><td class="memItemLeft" align="right" valign="top"><a id="ga40369467446b37ebfacb996610954c78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga40369467446b37ebfacb996610954c78">afw_function_definition_script</a></td></tr>
<tr class="memdesc:ga40369467446b37ebfacb996610954c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function definition script. <br /></td></tr>
<tr class="separator:ga40369467446b37ebfacb996610954c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f65020ca7a42aea848630968eb099f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__afw__functions__script.html#ga60f65020ca7a42aea848630968eb099f">afw_function_definition_while</a></td></tr>
<tr class="memdesc:ga60f65020ca7a42aea848630968eb099f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive Function script.  <a href="group__afw__functions__script.html#ga60f65020ca7a42aea848630968eb099f">More...</a><br /></td></tr>
<tr class="separator:ga60f65020ca7a42aea848630968eb099f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Adaptive Function union&lt;rfc822Name&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a list of rfc822Name contains all of the unique values in two or more list of rfc822Name values.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function union&lt;rfc822Name&gt;( lists_1: (list rfc822Name), lists_2: (list rfc822Name), ...lists_rest: (list of (list rfc822Name)) ): (list rfc822Name);</p>
<p>Parameters:</p>
<p>lists - (2 or more list rfc822Name) Two or more lists.</p>
<p>Returns:</p>
<p>(list rfc822Name)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gac65fd70ccba4536ea9f74c17d5c86cd1" title="Function implementation function afw_function_execute_union.">afw_function_execute_union()</a></p>
<hr  />
<p>script adaptive functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0cbee54962884e392e5e9b81d4ddc547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cbee54962884e392e5e9b81d4ddc547">&#9670;&nbsp;</a></span>afw_function_execute_assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function assign. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Assign a value to the innermost structured block definition of a variable. If the variable is not defined, the variable is defined in the innermost structured block. An error is thrown if not called from a list of values in a structured function.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters and has side effects.</p>
<p>Declaration:</p>
<p>function assign( name: string, value: any ): any;</p>
<p>Parameters:</p>
<p>name - (string) Variable name.</p>
<p>value - (any dataType) This is the value to assign to the variable.</p>
<p>Returns:</p>
<p>(any dataType) The value assigned. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00051">51</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga7f91b63b80c4356758f9bcf8257d270a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f91b63b80c4356758f9bcf8257d270a">&#9670;&nbsp;</a></span>afw_function_execute_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_break </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function break. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a special function that can be called to break out of the body of a loop. If called outside of a loop body, an error is thrown.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function break( value?: any ): any;</p>
<p>Parameters:</p>
<p>value - (optional any dataType) The value to evaluate that the enclosing loop will return. If not specified, the last evaluated value or a null value will be returned.</p>
<p>Returns:</p>
<p>(any dataType) This function returns from the body of a loop with the last evaluated value. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00091">91</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga82ea789d9535c99d63d43711bfbc5a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82ea789d9535c99d63d43711bfbc5a4e">&#9670;&nbsp;</a></span>afw_function_execute_compile_script()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_compile_script </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function compile&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile script value and return either an unevaluated adaptive value or a string containing the compiler listing.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function compile&lt;script&gt;( source: script, listing?: any ): unevaluated;</p>
<p>Parameters:</p>
<p>source - (script) script string to compile.</p>
<p>listing - (optional any dataType) If specified, a compiler listing is produced instead of an unevaluated expression value.</p>
<p>This parameter can be an integer between 0 and 10 of a string that is used for indentation. If 0 is specified, no whitespace is added to the resulting string. If 1 through 10 is specified, that number of spaces is used.</p>
<p>Returns:</p>
<p>(unevaluated) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00137">137</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga6ab3baa33c974a58948fe6c3d2f89f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ab3baa33c974a58948fe6c3d2f89f22">&#9670;&nbsp;</a></span>afw_function_execute_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function const. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Define one or more statically scoped constants local to the current script block with a permanent value. These constants can be accessed from the current block and inner blocks, but can not be assigned a different value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function const( name: (list string), value: any, type?: (object <em>AdaptiveValueMeta</em>) ): any;</p>
<p>Parameters:</p>
<p>name - (list string) The name of one or more constants to defined in the current block.</p>
<p>value - (any dataType) This is the value of the constant(s).</p>
<p>type - (optional object <em>AdaptiveValueMeta</em>) The type of the constant(s).</p>
<p>Returns:</p>
<p>(any dataType) The value assigned. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00200">200</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga258a87beada3d0ea7939075190a8e4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258a87beada3d0ea7939075190a8e4d9">&#9670;&nbsp;</a></span>afw_function_execute_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_continue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function continue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a special function that can be called in the body of a loop function to test the condition and, if true, start evaluating the body again. If called outside of a loop body, an error is thrown.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function continue(</p>
<p>): any;</p>
<p>Parameters:</p>
<p>Returns:</p>
<p>(any dataType) This function does not return. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00236">236</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga4e8bc41403349ce49a10d50ecb2295f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e8bc41403349ce49a10d50ecb2295f1">&#9670;&nbsp;</a></span>afw_function_execute_do_while()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_do_while </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function do_while. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This creates a new structured block with a new nested variable scope.</p>
<p>This function will evaluate a list of values at least once while a condition is true. See the related functions "break", "continue", and "return".</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function do_while( condition: boolean, body: list ): any;</p>
<p>Parameters:</p>
<p>condition - (boolean) While this condition is true, the loop will continue. This is evaluated in the loop's scope.</p>
<p>body - (list) This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a "break", "continue" or "return" function is encountered.</p>
<p>Returns:</p>
<p>(any dataType) The last value evaluated in body or null if the body is empty. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00283">283</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga4031dba0d558b1badfc92e22011be027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4031dba0d558b1badfc92e22011be027">&#9670;&nbsp;</a></span>afw_function_execute_evaluate_script()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_evaluate_script </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function evaluate&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Compile and evaluate script value.</p>
<p>This function is not pure, so it may return a different result given exactly the same parameters.</p>
<p>Declaration:</p>
<p>function evaluate&lt;script&gt;( source: script, additionalUntrustedQualifiedVariables?: (object <em>AdaptiveHybridPropertiesObjects</em>) ): unevaluated;</p>
<p>Parameters:</p>
<p>source - (script) script string to compile and evaluate.</p>
<p>additionalUntrustedQualifiedVariables - (optional object <em>AdaptiveHybridPropertiesObjects</em>) This parameter supplies additional qualified variables that can be accessed during evaluation. These variables will not be used by anything that needs to ensure its qualified variables must come from a trusted source, such as authorization. This parameter is intended to be used for testing only and should not be used for anything running in production.</p>
<p>Returns:</p>
<p>(unevaluated) </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00334">334</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="gaa101bea913fea0198cc67c20b66f1ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa101bea913fea0198cc67c20b66f1ba0">&#9670;&nbsp;</a></span>afw_function_execute_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This creates a new structured block with a new nested variable scope.</p>
<p>This function loops while condition is true. If the condition is false for the first iteration, the loop returns a null value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function for( initial?: list, condition?: boolean, increment?: list, body?: list ): any;</p>
<p>Parameters:</p>
<p>initial - (optional list) This is a list of values to evaluate before the loop starts. The values will normally be a call to the "assign" function.</p>
<p>condition - (optional boolean) While this condition is true, the loop will continue.</p>
<p>increment - (optional list) This is a list of values to evaluate after each iteration of the loop. The values will normally be a call to the "assign" function.</p>
<p>body - (optional list) This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a "break", "continue" or "return" function is encountered.</p>
<p>Returns:</p>
<p>(any dataType) The last value evaluated in body or null if condition evaluates to false the first time. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00409">409</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga4778d256c2be2dcfa3fe147d73c940c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4778d256c2be2dcfa3fe147d73c940c3">&#9670;&nbsp;</a></span>afw_function_execute_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function foreach. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This creates a new structured block with a new nested variable scope.</p>
<p>This function will evaluate a list of values while a condition is true with initial and increment values. The condition is tested at the beginning of the loop. If the condition is false for the first iteration, the loop returns a null value.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function foreach( name: (list string), value: any, body?: list ): any;</p>
<p>Parameters:</p>
<p>name - (list string) Variable name(s).</p>
<p>value - (any dataType) Any list, object or single value.</p>
<p>body - (optional list) This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a "break", "continue" or "return" function is encountered.</p>
<p>Returns:</p>
<p>(any dataType) The last value evaluated in body or null if condition evaluates to false the first time. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00466">466</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="gabffd433765d0f467100fcde5f3f8dcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabffd433765d0f467100fcde5f3f8dcd9">&#9670;&nbsp;</a></span>afw_function_execute_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function if. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate one of two different values depending on test condition.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function if( condition: boolean, then: list, else?: list ): any;</p>
<p>Parameters:</p>
<p>condition - (boolean) If true, parameter "then" is evaluated for result. If false, parameter "else" is evaluated.</p>
<p>then - (list) This is the body of a structured block that is evaluated if "condition" is true. See the "body" parameter of the "block" function for information on how the body is processed.</p>
<p>else - (optional list) This is the body of a structured block that is evaluated if "condition" is false. If not specified and condition is false, a null value is returned. See the "body" parameter of the "block" function for information on how the body is processed.</p>
<p>Returns:</p>
<p>(any dataType) The result of evaluating "then" or "else". </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00520">520</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="ga1b0635816629ffb8423b6e88f262abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0635816629ffb8423b6e88f262abb4">&#9670;&nbsp;</a></span>afw_function_execute_loc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_loc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function loc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Declare one or more statically scoped variable locations local to the current script block and optionally assign them an initial value. These variables can be accessed and assigned different values from the current block and inner blocks.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function loc( name: (list string), value?: any, type?: (object <em>AdaptiveValueMeta</em>) ): any;</p>
<p>Parameters:</p>
<p>name - (list string) The name of one or more variables to declared in the current block.</p>
<p>value - (optional any dataType) This is the initial value of the variable(s). If not specified, the variable will have a value of undefined.</p>
<p>type - (optional object <em>AdaptiveValueMeta</em>) The type of the variable(s).</p>
<p>Returns:</p>
<p>(any dataType) The value assigned. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00574">574</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="gaf9fe002bbf799693a397b72a024bdb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9fe002bbf799693a397b72a024bdb49">&#9670;&nbsp;</a></span>afw_function_execute_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Return from the outermost structured block. If the expression of a lambda function is a block function, this will effectively return from the lambda function. If called outside of a structured block, an error is thrown.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function return( value?: any ): any;</p>
<p>Parameters:</p>
<p>value - (optional any dataType) The value to evaluate that the outermost block will return. If not specified, the last evaluated value or a null value will be returned.</p>
<p>Returns:</p>
<p>(any dataType) This function returns from the outermost structured block with the last evaluated value. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00615">615</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<a id="gac4b860ece33878c6fb235a899e327ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4b860ece33878c6fb235a899e327ac0">&#9670;&nbsp;</a></span>afw_function_execute_while()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structafw__value__s.html">afw_value_t</a>* afw_function_execute_while </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__afw__common.html#gadb43fc93a747a00701b8b72205b3e2c9">afw_function_execute_t</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function while. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This creates a new structured block with a new nested variable scope.</p>
<p>This function will evaluate a list of values while a condition is true. The condition is tested at the beginning of the loop. If the condition is false for the first iteration, the loop returns a null value. See the related functions "break", "continue", and "return".</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function while( condition: boolean, body: list ): any;</p>
<p>Parameters:</p>
<p>condition - (boolean) While this condition is true, the loop will continue. This is evaluated in the loop's scope.</p>
<p>body - (list) This is a list of values that are evaluated for each iteration of the loop. Each value in body is evaluated in order until the end of the list or until a "break", "continue" or "return" function is encountered.</p>
<p>Returns:</p>
<p>(any dataType) The last value evaluated in body or null if condition evaluates to false the first time. </p>

<p class="definition">Definition at line <a class="el" href="afw__function__script_8c_source.html#l00664">664</a> of file <a class="el" href="afw__function__script_8c_source.html">afw_function_script.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gafd8a2c6c8fdfaeaa31af09fd4f509711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8a2c6c8fdfaeaa31af09fd4f509711">&#9670;&nbsp;</a></span>afw_function_definition_bag_size_script</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_bag_size_script</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes any number of script values and returns a list of list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function bag&lt;script&gt;( ...values: (list of (list script)) ): (list script);</p>
<p>Parameters:</p>
<p>values - (0 or more list script)</p>
<p>Returns:</p>
<p>(list script)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga39c1a41a0d8363c8d5ceae7a6d65489a" title="Function implementation function afw_function_execute_bag.">afw_function_execute_bag()</a></p>
<hr  />
<p>Function definition bag_size&lt;script&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l26454">26454</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gad71b075b9f568b5e13716d1e6f5371e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad71b075b9f568b5e13716d1e6f5371e8">&#9670;&nbsp;</a></span>afw_function_definition_break</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_break</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function bag_size&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the integer number of values in list.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function bag_size&lt;script&gt;( value: (list script) ): integer;</p>
<p>Parameters:</p>
<p>value - (list script)</p>
<p>Returns:</p>
<p>(integer)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gae78d6ef2506492c58f64e35f7ec84fff" title="Function implementation function afw_function_execute_bag_size.">afw_function_execute_bag_size()</a></p>
<hr  />
<p>Function definition break </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l26490">26490</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga849e677e38929edd9cc92d082d8c6538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga849e677e38929edd9cc92d082d8c6538">&#9670;&nbsp;</a></span>afw_function_definition_eqx_script</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_eqx_script</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eq&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if script arg1 is equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "eqx" ("===") instead if you want false to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function eq&lt;script&gt;( arg1: script, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga4b5f63dcfd77b17d064ce733ffde1b04" title="Function implementation function afw_function_execute_eq.">afw_function_execute_eq()</a></p>
<hr  />
<p>Function definition eqx&lt;script&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l26744">26744</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga51e69ae410557947d0b126c67fc6aeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51e69ae410557947d0b126c67fc6aeaf">&#9670;&nbsp;</a></span>afw_function_definition_evaluate_script</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_evaluate_script</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function eqx&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for script arg1 is equal to the value and data type of arg2 then return the boolean result. Use "eq" ("==") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function eqx&lt;script&gt;( arg1: script, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga8038bd01243984b8b135337e768925f5" title="Function implementation function afw_function_execute_eqx.">afw_function_execute_eqx()</a></p>
<hr  />
<p>Function definition evaluate&lt;script&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l26785">26785</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga681fe8a651a2763905a99eae009034b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga681fe8a651a2763905a99eae009034b5">&#9670;&nbsp;</a></span>afw_function_definition_gt_script</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_gt_script</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ge&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for script arg1 is greater than or equal to script arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ge&lt;script&gt;( arg1: script, arg2: script ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (script)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga2c6ce9c296190c183129fe801999fb85" title="Function implementation function afw_function_execute_ge.">afw_function_execute_ge()</a></p>
<hr  />
<p>Function definition gt&lt;script&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l26975">26975</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga473da9d43ffaa54e358e54e9fdd4e70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga473da9d43ffaa54e358e54e9fdd4e70c">&#9670;&nbsp;</a></span>afw_function_definition_if</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function gt&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for script arg1 is greater than script arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function gt&lt;script&gt;( arg1: script, arg2: script ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (script)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf8fcfd20e0990c533eaf3a75189f28c5" title="Function implementation function afw_function_execute_gt.">afw_function_execute_gt()</a></p>
<hr  />
<p>Function definition if </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l27015">27015</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga7fd704630ef336feca8e63f18860103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fd704630ef336feca8e63f18860103c">&#9670;&nbsp;</a></span>afw_function_definition_le_script</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_le_script</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function is&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks whether value is dataType script and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function is&lt;script&gt;( value: any ): boolean;</p>
<p>Parameters:</p>
<p>value - (any dataType) Value to check.</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga592ff430af3e6f20df8c7c7014da60d6" title="Function implementation function afw_function_execute_is.">afw_function_execute_is()</a></p>
<hr  />
<p>Function definition le&lt;script&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l27098">27098</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga614483c3d6544fee2c1415e553bc6f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga614483c3d6544fee2c1415e553bc6f38">&#9670;&nbsp;</a></span>afw_function_definition_loc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_loc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function le&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for script arg1 is less than or equal to script arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function le&lt;script&gt;( arg1: script, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gab0b76d3bc6ee064c67c3bea1dda7989d" title="Function implementation function afw_function_execute_le.">afw_function_execute_le()</a></p>
<hr  />
<p>Function definition loc </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l27138">27138</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gacf5f1dd6ead4809be7f730a1e7587dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf5f1dd6ead4809be7f730a1e7587dba">&#9670;&nbsp;</a></span>afw_function_definition_ne_script</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_ne_script</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function lt&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks for script arg1 is less that script arg2 and return the boolean result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function lt&lt;script&gt;( arg1: script, arg2: script ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (script)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gafa22bf341d641f266c31a32ceeb256a6" title="Function implementation function afw_function_execute_lt.">afw_function_execute_lt()</a></p>
<hr  />
<p>Function definition ne&lt;script&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l27225">27225</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga80ca7078009f6a9ba00d6dbea50391ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ca7078009f6a9ba00d6dbea50391ef">&#9670;&nbsp;</a></span>afw_function_definition_nex_script</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_nex_script</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function ne&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if script arg1 is not equal to the value of arg2 converted to the data type of arg1 then return the boolean result. Use "nex" ("!==") instead if you want true to be returned if arg1 and arg2's data type don't match.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function ne&lt;script&gt;( arg1: script, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Errors thrown:</p>
<p>conversion - arg2 cannot be converted to the data type of arg1.</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#gaf144f30dc392293fb1eb3058a00f3093" title="Function implementation function afw_function_execute_ne.">afw_function_execute_ne()</a></p>
<hr  />
<p>Function definition nex&lt;script&gt; </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l27270">27270</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="gafc5b933a588b5255308763b016e89d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5b933a588b5255308763b016e89d02">&#9670;&nbsp;</a></span>afw_function_definition_return</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_return</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function nex&lt;script&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if for script arg1 is not equal to the value or data type of arg2 then return the boolean result. Use "ne" ("!=") instead if you want arg2 to be converted to the data type of arg1 before comparison.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function nex&lt;script&gt;( arg1: script, arg2: any ): boolean;</p>
<p>Parameters:</p>
<p>arg1 - (script)</p>
<p>arg2 - (any dataType)</p>
<p>Returns:</p>
<p>(boolean)</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga16fe2f777eb9e0a29ece94637d9c29ec" title="Function implementation function afw_function_execute_nex.">afw_function_execute_nex()</a></p>
<hr  />
<p>Function definition return </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l27311">27311</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
<a id="ga60f65020ca7a42aea848630968eb099f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60f65020ca7a42aea848630968eb099f">&#9670;&nbsp;</a></span>afw_function_definition_while</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">afw_function_definition_while</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptive Function script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>struct for this function. </td></tr>
    <tr><td class="paramname">argc</td><td>number of values in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>list of values. </td></tr>
    <tr><td class="paramname">p</td><td>to use for result. </td></tr>
    <tr><td class="paramname">xctx</td><td>of caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Converts value to data type script returning script result.</p>
<p>This function is pure, so it will always return the same result given exactly the same parameters and has no side effects.</p>
<p>Declaration:</p>
<p>function script( value: any ): script;</p>
<p>Parameters:</p>
<p>value - (any dataType) Value to convert.</p>
<p>Returns:</p>
<p>(script) Converted value.</p>
<p>Errors thrown:</p>
<p>cast_error - value could not be converted</p>
<p>Implemented by <a class="el" href="group__afw__functions__year_month_duration.html#ga54b8da4d037e099a98685689b5986cd0" title="Function implementation function afw_function_execute_convert.">afw_function_execute_convert()</a></p>
<hr  />
<p>Function definition while </p>

<p class="definition">Definition at line <a class="el" href="afw__function__bindings_8h_source.html#l27391">27391</a> of file <a class="el" href="afw__function__bindings_8h_source.html">afw_function_bindings.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 8 2023 19:30:17 for Adaptive Framework by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
